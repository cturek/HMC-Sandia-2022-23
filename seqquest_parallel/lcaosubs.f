c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> EXPUND
c
c
      SUBROUTINE EXPUND( argmax )
c---------------------------------------------------------------
c Purpose: return value x for which exp(-x) underflows
c
c Written: 8Jan91-PAS
c
c Revision history:
c   1May01-PAS/2.47: eliminate machine dependence
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
CCC      DATA  rtpi / 1.772453850 9055160d0 /
CCCc
CCC F1MACH referred to the correct type R1MACH/D1MACH routine
CCC      xunderf= SQRT(- LOG(rtpi*F1MACH(1)))
CCC      xunderf = xunderf - 0.5* LOG(xunderf)/xunderf - 0.01
CCC      argmax = xunderf*xunderf
c
c The standard result gave 704.016; e(-704)~=10**(-306)
c A value of 60 --> 10**(-26.1) is more than adequate in tests
c
      argmax = 60.d0
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKSZERO
c
c
      subroutine MKSZERO( n, a )
c---------------------------------------------------------------
c Purpose: zero out a single precision real array
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  a,zero
c
      DIMENSION  a(n)
      DATA  zero / 0.e0 /
c
      do  i=1,n
        a(i) = zero
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKZERO
c
c
      subroutine MKZERO( n, a )
c---------------------------------------------------------------
c Purpose: zero out a double precision real array
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  a(n)
      DATA  zero / 0.d0 /
c
      do  i=1,n
        a(i) = zero
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SPLINE
c
c
      subroutine SPLINE( n, x, y, ddy0, ddy1, y2,u )
c---------------------------------------------------------------
c Purpose: compute cubic spline fit
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  x(n),y(n), y2(n)
      DIMENSION  u(n)
c
c compute the data for the spline
      if( ddy0 .gt. .99d30 ) then
        y2(1) = 0.d0
        u(1) = 0.d0
      else
        y2(1) = -.5d0
        dx = x(2) - x(1)
        dy = y(2) - y(1)
        u(1) = 3.d0*(dy/dx - ddy0)/dx
      endif
c
      do 11 i=2,n-1
        dx = x(i) - x(i-1)
        dx1 = x(i+1) - x(i)
        d2x = x(i+1) - x(i-1)
        sig = dx/d2x
        p = sig*y2(i-1) + 2.d0
        y2(i) = (sig - 1.d0)/p
        dy = y(i) - y(i-1)
        dy1 = y(i+1) - y(i)
        u(i) = ( 6.d0*(dy1/dx1-dy/dx)/d2x - sig*u(i-1) )/p
   11 continue
c
      if( ddy1 .gt. .99d30 )then
        qn = 0.d0
        un = 0.d0
      else
        qn = .5d0
        dx = x(n) - x(n-1)
        dy = y(n) - y(n-1)
        un = (ddy1 - dy/dx)*3.d0/dx
      endif
c
      y2(n) = (un-qn*u(n-1)) / (qn*y2(n-1)+1.d0)
c
c back substitute
      do 12 i=n-1,1,-1
        y2(i) = y2(i)*y2(i+1) + u(i)
   12 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SPLINT
c
c
      subroutine SPLINT( na, xa,ya,y2,  nb, xb,yb )
c---------------------------------------------------------------
c Purpose: compute function defined by cubic spline
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  xa(na),ya(na), y2(na)
      DIMENSION  xb(*),yb(*)
c
      xmin = xa(1)
      xmax = xa(na)
      do 100 i=1,nb
        x = xb(i)
c
c out of range test
        if( x .ge. xmax )then
          yb(i) = ya(na)
          goto 100
        elseif( x .le. xmin )then
          yb(i) = ya(1)
          goto 100
        endif
c
c in range do binary search
        klo = 1
        khi = na
    1   continue
        if( khi-klo .gt. 1 )then
          k = (khi+klo)/2
          if( xa(k) .gt. x )then
            khi = k
          else
            klo = k
          endif
          goto 1
        endif
c
        dx = xa(khi) - xa(klo)
        a = (xa(khi) - x)/dx
        b = 1.d0 - a
        h2 = (dx**2)/6.d0
        c = (a**3 - a)*h2
        d = (b**3 - b)*h2
        yb(i) = a*ya(klo) + b*ya(khi)
     $        + c*y2(klo) + d*y2(khi)
100   continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SPLIND
c
c
      subroutine SPLIND( na, xa,ya, y2,  nb, xb, dyb )
c---------------------------------------------------------------
c Purpose: compute derivative of cubic spline
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  xa(na),ya(na), y2(na)
      DIMENSION  xb(*),dyb(*)
c
      xmin = xa(1)
      xmax = xa(na)
      do 100 i=1,nb
        x = xb(i)
c
c out of range test
        if( x .ge. xmax )then
          dyb(i) = 0.d0
          goto 100
        elseif( x .lt. xmin )then
          dyb(i) = 0.d0
          goto 100
        endif
c
c in range do binary search
        klo = 1
        khi = na
    1   continue
        if( khi-klo .gt. 1 )then
          k = (khi+klo)/2
          if( xa(k) .gt. x )then
            khi = k
          else
            klo = k
          endif
          goto 1
        endif
c
        dx = xa(khi) - xa(klo)
        a = (xa(khi) - x)/dx
        b = 1.d0 - a
        h2 = (dx**2)/6.d0
        c = (3.d0*a**2 - 1.d0)*h2
        d = (3.d0*b**2 - 1.d0)*h2
        dyb(i) = (  -ya(klo) +   ya(khi)
     $           - c*y2(klo) + d*y2(khi) ) / dx
  100 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SPLIND2
c
c
      subroutine SPLIND2( na, xa,ya, y2,  nb, xb, ddyb )
c---------------------------------------------------------------
c Purpose: compute 2nd derivative of cubic spline
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  xa(na),ya(na), y2(na)
      DIMENSION  xb(*),ddyb(*)
c
      xmin = xa(1)
      xmax = xa(na)
      do 100 i=1,nb
        x = xb(i)
c
c out of range test
        if( x .gt. xmax )then
          ddyb(i) = 0.d0
          goto 100
        elseif( x .lt. xmin )then
          ddyb(i) = 0.d0
          goto 100
        endif
c
c in range do binary search
        klo = 1
        khi = na
    1   continue
        if( khi-klo .gt. 1 )then
          k = (khi+klo)/2
          if( xa(k) .gt. x )then
            khi = k
          else
            klo = k
          endif
          goto 1
        endif
c
        dx = xa(khi) - xa(klo)
        a = (xa(khi) - x)/dx
        b = 1.d0 - a
        ddyb(i) = a*y2(klo) + b*y2(khi)
  100 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TIMSTUFF
c
c
c===============================================================
c Purpose: this module handles timing instrumentation for the code
c
c Written: Peter A. Schultz, 17-July-2003, for version 2.56
c          (expanded from original timing routine)
c
c Revision history:
c  28Oct04-PAS/2.59: to install wall time routine in timer
c  30Apr08-PAS/2.62: to deal with daily reset in wall timer
c===============================================================
c
c Routines contained:
c  TIMINIT( itimer) - initializes timing module
c  TIMFINI( IO_UNIT ) - final timing summary
c  TIMER( msg ) - timing statement
c
c External dependencies:
c  GETTLFT( t ) - returns time-left from system
c  GETTUSE( ttotl, tuser ) - gets time usage from system
c  GETWALLT( twall ) - gets wall time from system
c  FLGETIWR( iwr ) - gets output unit
c
c===============================================================
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TIMINIT
c
c
      subroutine TIMINIT( jtimer )
c---------------------------------------------------------------
c Purpose: initialize timing variables
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /TIMSTUFF/  timetotl,timeuser,timesys,timelim,
     $ timewall,tim0wall,timewoff, itimer
c
c >>>> EXECUTABLE CODE:
c
      timetotl = 0.
      timeuser = 0.
      timesys  = 0.
      timelim  = -1.0
c
      tim0wall = 0.
      timewall = 0.
      timewoff = 0.
c
      if( jtimer .eq. 0 )then
c       Turn timer off entirely
        itimer = 0
      elseif( jtimer .eq. 1 )then
c       System time
        itimer = 1
      elseif( jtimer .eq. 2 )then
c       Wall timer
        itimer = 2
      else
c       Default is system timer
        itimer = 1
      endif
c
c     Initialize the wall timer
      call GETWALLT( twall )
      tim0wall = twall
      timewall = twall
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TIMFINI
c
c
      subroutine TIMFINI( IWRTIM )
c---------------------------------------------------------------
c Purpose: handle closing down of final timing instrumentation
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /TIMSTUFF/  timetotl,timeuser,timesys,timelim,
     $ timewall,tim0wall,timewoff, itimer
c
      if( IWRTIM.gt.0 )then
c
        if( itimer.eq.1 )then
c         Without wall timer:
          write(IWRTIM,901) timetotl,timeuser,timesys
  901     format(1x,'Total TIME used=',f10.1,' seconds (user=',f10.1,
     $     '  sys=',f10.1,')')
c
        elseif( itimer.eq.2 )then
c         With wall timer:
          totlwall = timewall - tim0wall
          timelost = totlwall - timetotl
          write(IWRTIM,902) totlwall,timeuser,timesys,timelost
  902     format(1x,'Total TIME=',f10.1,' seconds (usr=',f10.1,
     $     '  sys=',f10.1,'  lost=',f10.1,')')
c
        endif
c
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TIMER
c
c
      subroutine TIMER( sublabl )
c---------------------------------------------------------------
c Purpose: track running time for code, with labels
c
c Revision history:
c  30Apr08-PAS/2.62: account for day rollover in wall clock
c  17Jul03-PAS/2.56: get IWR from FL module, expand timing info
c  28Aug02-PAS/2.54: increase format for time used
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /TIMSTUFF/  timetotl,timeuser,timesys,timelim,
     $ timewall,tim0wall,timewoff, itimer
c
      CHARACTER*(*)  sublabl
      CHARACTER*(4)  timlbl
c
c >>>> EXECUTABLE CODE:
c
c Retrieve total running time, and user time from system:
      call GETTUSE( ttotl, tuser )
c
c Compute elapsed (tot,usr,sys) times since last record
      oldttotl = timetotl
      timetotl = ttotl
      delttotl = timetotl - oldttotl
c
      oldtuser = timeuser
      timeuser = tuser
      deltuser = timeuser - oldtuser
c
      timesys = timetotl - timeuser
      deltsys = delttotl - deltuser
c
      ioffday = 0
      if( itimer .eq. 2 )then
c       Elapsed wall time since last entry:
        call GETWALLT( twall )
        twall = twall + timewoff
c       Check that we have not had a roll-over of the clock
        if( twall .lt. timewall )then
c         Our wall clock is a day clock, and reset by 86400sec.
c         Adjust our time offset by a day.
cpas: temporary stamp of timer rollover
          write(6,*) 'TIMER rollover, twall,timewoff=',twall,timewoff
          ioffday = ioffday + 1
          delclock = 86400.d0
          timewoff = timewoff + delclock
          twall = twall + delclock
c         In principle, more than one day could have passed between
c         timer calls, and offset error could be more than one day.
c         However, with runs that long, the timer is irrelevant and
c         the time that comes out of that timer unimportant.
        endif
        oldwall = timewall
        timewall = twall
        delwall = timewall - oldwall
        totlwall = timewall - tim0wall
c
        deltime = delwall
        timetot = totlwall
      endif
c
c Retrieve output unit, and write out data:
      call FLGETIWR( IWR )
      if( IWR .gt. 0 )then
c
C       write(IWR,910)  sublabl, delttotl,timetotl
C  910  format(/1x,a,'+',f9.3,' =',f10.1,' seconds used')
c
        if( itimer .eq. 1 )then
          write(IWR,911)  sublabl, delttotl,timetotl
     $                           , deltuser,deltsys
  911     format(/1x,a,'+',f8.2,' =',f10.1,' seconds used'
     $               ,' (',f8.2,' usr',f8.2,' sys)')
c
        elseif( itimer .eq. 2 )then
          write(IWR,912)  sublabl, deltime, timetot
     $                           , deltuser,deltsys
  912     format(/1x,a,'+',f8.2,' =',f10.1,' seconds wall'
     $               ,' (',f8.2,' usr',f8.2,' sys)')
          if( ioffday.ne.0 )then
            write(IWR,9121)
 9121       format(1x,' (after offset of 86400 seconds rollover)' )
          endif
        endif
c
        call MTBUFF
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c***********************************************************************
c 19Dec90-Peter A. Schultz
c The following fast fourier transform routine routines (CFFTI-PASSF5)
c gotten via electronic request to "netlib@ornl.gov" using commands:
c "send cffti from fftpack","send cfftb from fftpack","send cfftf ..."
c
c Revision history:
c   5Dec07-PAS/2.60c: replace obsolete arith if's with modern if's
c   7Mar02-PAS/2.52: explicit constants to d0, and dim(1)->dim(*)
c  Added implicit double precision declarations
c***********************************************************************
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CFFTI
c
      subroutine cffti (n,wsave)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       wsave(*)
      if (n .eq. 1) return
      iw1 = n+n+1
      iw2 = iw1+n+n
      call cffti1 (n,wsave(iw1),wsave(iw2))
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CFFTI1
c
      subroutine cffti1 (n,wa,ifac)
c Revised 5Dec07-PAS/2.60c - replaced obsolete arith-ifs
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       wa(*)      ,ifac(*)    ,ntryh(4)
      data ntryh(1),ntryh(2),ntryh(3),ntryh(4)/3,4,2,5/
      nl = n
      nf = 0
      j = 0
C  101 j = j+1
  101 continue 
      j = j + 1
C      if (j-4) 102,102,103
C  102 ntry = ntryh(j)
C      go to 104
C  103 ntry = ntry+2
C  104 nq = nl/ntry
cpas: replace obsolete arith if with modern construction
      if( j.gt.4 )then
        ntry = ntry + 2
      else
        ntry = ntryh(j)
      endif
  104 continue
      nq = nl/ntry
c
      nr = nl-ntry*nq
C      if (nr) 101,105,101
C  105 nf = nf+1
cpas: replace obsolete arith if with modern construction
      if( nr.ne.0 ) goto 101
      nf = nf + 1
c
      ifac(nf+2) = ntry
      nl = nq
      if (ntry .ne. 2) go to 107
      if (nf .eq. 1) go to 107
      do 106 i=2,nf
         ib = nf-i+2
         ifac(ib+2) = ifac(ib+1)
  106 continue
      ifac(3) = 2
  107 if (nl .ne. 1) go to 104
      ifac(1) = n
      ifac(2) = nf
      tpi = 6.28318530717959d0
cpas      argh = tpi/float(n)
      argh = tpi/ DBLE( n )
      i = 2
      l1 = 1
      do 110 k1=1,nf
         ip = ifac(k1+2)
         ld = 0
         l2 = l1*ip
         ido = n/l2
         idot = ido+ido+2
         ipm = ip-1
         do 109 j=1,ipm
            i1 = i
            wa(i-1) = 1.
            wa(i) = 0.
            ld = ld+l1
            fi = 0.
cpas            argld = float(ld)*argh
            argld = DBLE( ld )*argh
            do 108 ii=4,idot,2
               i = i+2
               fi = fi+1.
               arg = fi*argld
               wa(i-1) = cos(arg)
               wa(i) = sin(arg)
  108       continue
            if (ip .le. 5) go to 109
            wa(i1-1) = wa(i-1)
            wa(i1) = wa(i)
  109    continue
         l1 = l2
  110 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CFFTB
c
      subroutine cfftb (n,c,wsave)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       c(*)       ,wsave(*)
      if (n .eq. 1) return
      iw1 = n+n+1
      iw2 = iw1+n+n
      call cfftb1 (n,c,wsave,wsave(iw1),wsave(iw2))
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CFFTB1
c
      subroutine cfftb1 (n,c,ch,wa,ifac)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       ch(*)      ,c(*)       ,wa(*)      ,ifac(*)
      nf = ifac(2)
      na = 0
      l1 = 1
      iw = 1
      do 116 k1=1,nf
         ip = ifac(k1+2)
         l2 = ip*l1
         ido = n/l2
         idot = ido+ido
         idl1 = idot*l1
         if (ip .ne. 4) go to 103
         ix2 = iw+idot
         ix3 = ix2+idot
         if (na .ne. 0) go to 101
         call passb4 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
         go to 102
  101    call passb4 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
  102    na = 1-na
         go to 115
  103    if (ip .ne. 2) go to 106
         if (na .ne. 0) go to 104
         call passb2 (idot,l1,c,ch,wa(iw))
         go to 105
  104    call passb2 (idot,l1,ch,c,wa(iw))
  105    na = 1-na
         go to 115
  106    if (ip .ne. 3) go to 109
         ix2 = iw+idot
         if (na .ne. 0) go to 107
         call passb3 (idot,l1,c,ch,wa(iw),wa(ix2))
         go to 108
  107    call passb3 (idot,l1,ch,c,wa(iw),wa(ix2))
  108    na = 1-na
         go to 115
  109    if (ip .ne. 5) go to 112
         ix2 = iw+idot
         ix3 = ix2+idot
         ix4 = ix3+idot
         if (na .ne. 0) go to 110
         call passb5 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
         go to 111
  110    call passb5 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
  111    na = 1-na
         go to 115
  112    if (na .ne. 0) go to 113
         call passb (nac,idot,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
         go to 114
  113    call passb (nac,idot,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
  114    if (nac .ne. 0) na = 1-na
  115    l1 = l2
         iw = iw+(ip-1)*idot
  116 continue
      if (na .eq. 0) return
      n2 = n+n
      do 117 i=1,n2
         c(i) = ch(i)
  117 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PASSB
c
      subroutine passb (nac,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       ch(ido,l1,ip)          ,cc(ido,ip,l1)          ,
     1                c1(ido,l1,ip)          ,wa(*)      ,c2(idl1,ip),
     2                ch2(idl1,ip)
      idot = ido/2
      nt = ip*idl1
      ipp2 = ip+2
      ipph = (ip+1)/2
      idp = ip*ido
c
      if (ido .lt. l1) go to 106
      do 103 j=2,ipph
         jc = ipp2-j
         do 102 k=1,l1
            do 101 i=1,ido
               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
  101       continue
  102    continue
  103 continue
      do 105 k=1,l1
         do 104 i=1,ido
            ch(i,k,1) = cc(i,1,k)
  104    continue
  105 continue
      go to 112
  106 do 109 j=2,ipph
         jc = ipp2-j
         do 108 i=1,ido
            do 107 k=1,l1
               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
  107       continue
  108    continue
  109 continue
      do 111 i=1,ido
         do 110 k=1,l1
            ch(i,k,1) = cc(i,1,k)
  110    continue
  111 continue
  112 idl = 2-ido
      inc = 0
      do 116 l=2,ipph
         lc = ipp2-l
         idl = idl+ido
         do 113 ik=1,idl1
            c2(ik,l) = ch2(ik,1)+wa(idl-1)*ch2(ik,2)
            c2(ik,lc) = wa(idl)*ch2(ik,ip)
  113    continue
         idlj = idl
         inc = inc+ido
         do 115 j=3,ipph
            jc = ipp2-j
            idlj = idlj+inc
            if (idlj .gt. idp) idlj = idlj-idp
            war = wa(idlj-1)
            wai = wa(idlj)
            do 114 ik=1,idl1
               c2(ik,l) = c2(ik,l)+war*ch2(ik,j)
               c2(ik,lc) = c2(ik,lc)+wai*ch2(ik,jc)
  114       continue
  115    continue
  116 continue
      do 118 j=2,ipph
         do 117 ik=1,idl1
            ch2(ik,1) = ch2(ik,1)+ch2(ik,j)
  117    continue
  118 continue
      do 120 j=2,ipph
         jc = ipp2-j
         do 119 ik=2,idl1,2
            ch2(ik-1,j) = c2(ik-1,j)-c2(ik,jc)
            ch2(ik-1,jc) = c2(ik-1,j)+c2(ik,jc)
            ch2(ik,j) = c2(ik,j)+c2(ik-1,jc)
            ch2(ik,jc) = c2(ik,j)-c2(ik-1,jc)
  119    continue
  120 continue
      nac = 1
      if (ido .eq. 2) return
      nac = 0
      do 121 ik=1,idl1
         c2(ik,1) = ch2(ik,1)
  121 continue
      do 123 j=2,ip
         do 122 k=1,l1
            c1(1,k,j) = ch(1,k,j)
            c1(2,k,j) = ch(2,k,j)
  122    continue
  123 continue
      if (idot .gt. l1) go to 127
      idij = 0
      do 126 j=2,ip
         idij = idij+2
         do 125 i=4,ido,2
            idij = idij+2
            do 124 k=1,l1
               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
               c1(i,k,j) = wa(idij-1)*ch(i,k,j)+wa(idij)*ch(i-1,k,j)
  124       continue
  125    continue
  126 continue
      return
  127 idj = 2-ido
      do 130 j=2,ip
         idj = idj+ido
         do 129 k=1,l1
            idij = idj
            do 128 i=4,ido,2
               idij = idij+2
               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
               c1(i,k,j) = wa(idij-1)*ch(i,k,j)+wa(idij)*ch(i-1,k,j)
  128       continue
  129    continue
  130 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PASSB2
c
      subroutine passb2 (ido,l1,cc,ch,wa1)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       cc(ido,2,l1)           ,ch(ido,l1,2)           ,
     1                wa1(*)
      if (ido .gt. 2) go to 102
      do 101 k=1,l1
         ch(1,k,1) = cc(1,1,k)+cc(1,2,k)
         ch(1,k,2) = cc(1,1,k)-cc(1,2,k)
         ch(2,k,1) = cc(2,1,k)+cc(2,2,k)
         ch(2,k,2) = cc(2,1,k)-cc(2,2,k)
  101 continue
      return
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ch(i-1,k,1) = cc(i-1,1,k)+cc(i-1,2,k)
            tr2 = cc(i-1,1,k)-cc(i-1,2,k)
            ch(i,k,1) = cc(i,1,k)+cc(i,2,k)
            ti2 = cc(i,1,k)-cc(i,2,k)
            ch(i,k,2) = wa1(i-1)*ti2+wa1(i)*tr2
            ch(i-1,k,2) = wa1(i-1)*tr2-wa1(i)*ti2
  103    continue
  104 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PASSB3
c
      subroutine passb3 (ido,l1,cc,ch,wa1,wa2)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       cc(ido,3,l1)           ,ch(ido,l1,3)           ,
     1                wa1(*)     ,wa2(*)
      data taur,taui /-.5,.866025403784439d0/
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         tr2 = cc(1,2,k)+cc(1,3,k)
         cr2 = cc(1,1,k)+taur*tr2
         ch(1,k,1) = cc(1,1,k)+tr2
         ti2 = cc(2,2,k)+cc(2,3,k)
         ci2 = cc(2,1,k)+taur*ti2
         ch(2,k,1) = cc(2,1,k)+ti2
         cr3 = taui*(cc(1,2,k)-cc(1,3,k))
         ci3 = taui*(cc(2,2,k)-cc(2,3,k))
         ch(1,k,2) = cr2-ci3
         ch(1,k,3) = cr2+ci3
         ch(2,k,2) = ci2+cr3
         ch(2,k,3) = ci2-cr3
  101 continue
      return
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            tr2 = cc(i-1,2,k)+cc(i-1,3,k)
            cr2 = cc(i-1,1,k)+taur*tr2
            ch(i-1,k,1) = cc(i-1,1,k)+tr2
            ti2 = cc(i,2,k)+cc(i,3,k)
            ci2 = cc(i,1,k)+taur*ti2
            ch(i,k,1) = cc(i,1,k)+ti2
            cr3 = taui*(cc(i-1,2,k)-cc(i-1,3,k))
            ci3 = taui*(cc(i,2,k)-cc(i,3,k))
            dr2 = cr2-ci3
            dr3 = cr2+ci3
            di2 = ci2+cr3
            di3 = ci2-cr3
            ch(i,k,2) = wa1(i-1)*di2+wa1(i)*dr2
            ch(i-1,k,2) = wa1(i-1)*dr2-wa1(i)*di2
            ch(i,k,3) = wa2(i-1)*di3+wa2(i)*dr3
            ch(i-1,k,3) = wa2(i-1)*dr3-wa2(i)*di3
  103    continue
  104 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PASSB4
c
      subroutine passb4 (ido,l1,cc,ch,wa1,wa2,wa3)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       cc(ido,4,l1)           ,ch(ido,l1,4)           ,
     1                wa1(*)     ,wa2(*)     ,wa3(*)
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         ti1 = cc(2,1,k)-cc(2,3,k)
         ti2 = cc(2,1,k)+cc(2,3,k)
         tr4 = cc(2,4,k)-cc(2,2,k)
         ti3 = cc(2,2,k)+cc(2,4,k)
         tr1 = cc(1,1,k)-cc(1,3,k)
         tr2 = cc(1,1,k)+cc(1,3,k)
         ti4 = cc(1,2,k)-cc(1,4,k)
         tr3 = cc(1,2,k)+cc(1,4,k)
         ch(1,k,1) = tr2+tr3
         ch(1,k,3) = tr2-tr3
         ch(2,k,1) = ti2+ti3
         ch(2,k,3) = ti2-ti3
         ch(1,k,2) = tr1+tr4
         ch(1,k,4) = tr1-tr4
         ch(2,k,2) = ti1+ti4
         ch(2,k,4) = ti1-ti4
  101 continue
      return
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ti1 = cc(i,1,k)-cc(i,3,k)
            ti2 = cc(i,1,k)+cc(i,3,k)
            ti3 = cc(i,2,k)+cc(i,4,k)
            tr4 = cc(i,4,k)-cc(i,2,k)
            tr1 = cc(i-1,1,k)-cc(i-1,3,k)
            tr2 = cc(i-1,1,k)+cc(i-1,3,k)
            ti4 = cc(i-1,2,k)-cc(i-1,4,k)
            tr3 = cc(i-1,2,k)+cc(i-1,4,k)
            ch(i-1,k,1) = tr2+tr3
            cr3 = tr2-tr3
            ch(i,k,1) = ti2+ti3
            ci3 = ti2-ti3
            cr2 = tr1+tr4
            cr4 = tr1-tr4
            ci2 = ti1+ti4
            ci4 = ti1-ti4
            ch(i-1,k,2) = wa1(i-1)*cr2-wa1(i)*ci2
            ch(i,k,2) = wa1(i-1)*ci2+wa1(i)*cr2
            ch(i-1,k,3) = wa2(i-1)*cr3-wa2(i)*ci3
            ch(i,k,3) = wa2(i-1)*ci3+wa2(i)*cr3
            ch(i-1,k,4) = wa3(i-1)*cr4-wa3(i)*ci4
            ch(i,k,4) = wa3(i-1)*ci4+wa3(i)*cr4
  103    continue
  104 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PASSB5
c
      subroutine passb5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       cc(ido,5,l1)           ,ch(ido,l1,5)           ,
     1                wa1(*)     ,wa2(*)     ,wa3(*)     ,wa4(*)
      data tr11,ti11,tr12,ti12
     $ /.309016994374947d0,.951056516295154d0,
     $ -.809016994374947d0,.587785252292473d0/
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         ti5 = cc(2,2,k)-cc(2,5,k)
         ti2 = cc(2,2,k)+cc(2,5,k)
         ti4 = cc(2,3,k)-cc(2,4,k)
         ti3 = cc(2,3,k)+cc(2,4,k)
         tr5 = cc(1,2,k)-cc(1,5,k)
         tr2 = cc(1,2,k)+cc(1,5,k)
         tr4 = cc(1,3,k)-cc(1,4,k)
         tr3 = cc(1,3,k)+cc(1,4,k)
         ch(1,k,1) = cc(1,1,k)+tr2+tr3
         ch(2,k,1) = cc(2,1,k)+ti2+ti3
         cr2 = cc(1,1,k)+tr11*tr2+tr12*tr3
         ci2 = cc(2,1,k)+tr11*ti2+tr12*ti3
         cr3 = cc(1,1,k)+tr12*tr2+tr11*tr3
         ci3 = cc(2,1,k)+tr12*ti2+tr11*ti3
         cr5 = ti11*tr5+ti12*tr4
         ci5 = ti11*ti5+ti12*ti4
         cr4 = ti12*tr5-ti11*tr4
         ci4 = ti12*ti5-ti11*ti4
         ch(1,k,2) = cr2-ci5
         ch(1,k,5) = cr2+ci5
         ch(2,k,2) = ci2+cr5
         ch(2,k,3) = ci3+cr4
         ch(1,k,3) = cr3-ci4
         ch(1,k,4) = cr3+ci4
         ch(2,k,4) = ci3-cr4
         ch(2,k,5) = ci2-cr5
  101 continue
      return
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ti5 = cc(i,2,k)-cc(i,5,k)
            ti2 = cc(i,2,k)+cc(i,5,k)
            ti4 = cc(i,3,k)-cc(i,4,k)
            ti3 = cc(i,3,k)+cc(i,4,k)
            tr5 = cc(i-1,2,k)-cc(i-1,5,k)
            tr2 = cc(i-1,2,k)+cc(i-1,5,k)
            tr4 = cc(i-1,3,k)-cc(i-1,4,k)
            tr3 = cc(i-1,3,k)+cc(i-1,4,k)
            ch(i-1,k,1) = cc(i-1,1,k)+tr2+tr3
            ch(i,k,1) = cc(i,1,k)+ti2+ti3
            cr2 = cc(i-1,1,k)+tr11*tr2+tr12*tr3
            ci2 = cc(i,1,k)+tr11*ti2+tr12*ti3
            cr3 = cc(i-1,1,k)+tr12*tr2+tr11*tr3
            ci3 = cc(i,1,k)+tr12*ti2+tr11*ti3
            cr5 = ti11*tr5+ti12*tr4
            ci5 = ti11*ti5+ti12*ti4
            cr4 = ti12*tr5-ti11*tr4
            ci4 = ti12*ti5-ti11*ti4
            dr3 = cr3-ci4
            dr4 = cr3+ci4
            di3 = ci3+cr4
            di4 = ci3-cr4
            dr5 = cr2+ci5
            dr2 = cr2-ci5
            di5 = ci2-cr5
            di2 = ci2+cr5
            ch(i-1,k,2) = wa1(i-1)*dr2-wa1(i)*di2
            ch(i,k,2) = wa1(i-1)*di2+wa1(i)*dr2
            ch(i-1,k,3) = wa2(i-1)*dr3-wa2(i)*di3
            ch(i,k,3) = wa2(i-1)*di3+wa2(i)*dr3
            ch(i-1,k,4) = wa3(i-1)*dr4-wa3(i)*di4
            ch(i,k,4) = wa3(i-1)*di4+wa3(i)*dr4
            ch(i-1,k,5) = wa4(i-1)*dr5-wa4(i)*di5
            ch(i,k,5) = wa4(i-1)*di5+wa4(i)*dr5
  103    continue
  104 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CFFTF
c
      subroutine cfftf (n,c,wsave)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       c(*)       ,wsave(*)
      if (n .eq. 1) return
      iw1 = n+n+1
      iw2 = iw1+n+n
      call cfftf1 (n,c,wsave,wsave(iw1),wsave(iw2))
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CFFTF1
c
      subroutine cfftf1 (n,c,ch,wa,ifac)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       ch(*)      ,c(*)       ,wa(*)      ,ifac(*)
      nf = ifac(2)
      na = 0
      l1 = 1
      iw = 1
      do 116 k1=1,nf
         ip = ifac(k1+2)
         l2 = ip*l1
         ido = n/l2
         idot = ido+ido
         idl1 = idot*l1
         if (ip .ne. 4) go to 103
         ix2 = iw+idot
         ix3 = ix2+idot
         if (na .ne. 0) go to 101
         call passf4 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
         go to 102
  101    call passf4 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
  102    na = 1-na
         go to 115
  103    if (ip .ne. 2) go to 106
         if (na .ne. 0) go to 104
         call passf2 (idot,l1,c,ch,wa(iw))
         go to 105
  104    call passf2 (idot,l1,ch,c,wa(iw))
  105    na = 1-na
         go to 115
  106    if (ip .ne. 3) go to 109
         ix2 = iw+idot
         if (na .ne. 0) go to 107
         call passf3 (idot,l1,c,ch,wa(iw),wa(ix2))
         go to 108
  107    call passf3 (idot,l1,ch,c,wa(iw),wa(ix2))
  108    na = 1-na
         go to 115
  109    if (ip .ne. 5) go to 112
         ix2 = iw+idot
         ix3 = ix2+idot
         ix4 = ix3+idot
         if (na .ne. 0) go to 110
         call passf5 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
         go to 111
  110    call passf5 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
  111    na = 1-na
         go to 115
  112    if (na .ne. 0) go to 113
         call passf (nac,idot,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
         go to 114
  113    call passf (nac,idot,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
  114    if (nac .ne. 0) na = 1-na
  115    l1 = l2
         iw = iw+(ip-1)*idot
  116 continue
      if (na .eq. 0) return
      n2 = n+n
      do 117 i=1,n2
         c(i) = ch(i)
  117 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PASSF
c
      subroutine passf (nac,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       ch(ido,l1,ip)          ,cc(ido,ip,l1)          ,
     1                c1(ido,l1,ip)          ,wa(*)      ,c2(idl1,ip),
     2                ch2(idl1,ip)
      idot = ido/2
      nt = ip*idl1
      ipp2 = ip+2
      ipph = (ip+1)/2
      idp = ip*ido
c
      if (ido .lt. l1) go to 106
      do 103 j=2,ipph
         jc = ipp2-j
         do 102 k=1,l1
            do 101 i=1,ido
               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
  101       continue
  102    continue
  103 continue
      do 105 k=1,l1
         do 104 i=1,ido
            ch(i,k,1) = cc(i,1,k)
  104    continue
  105 continue
      go to 112
  106 do 109 j=2,ipph
         jc = ipp2-j
         do 108 i=1,ido
            do 107 k=1,l1
               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
  107       continue
  108    continue
  109 continue
      do 111 i=1,ido
         do 110 k=1,l1
            ch(i,k,1) = cc(i,1,k)
  110    continue
  111 continue
  112 idl = 2-ido
      inc = 0
      do 116 l=2,ipph
         lc = ipp2-l
         idl = idl+ido
         do 113 ik=1,idl1
            c2(ik,l) = ch2(ik,1)+wa(idl-1)*ch2(ik,2)
            c2(ik,lc) = -wa(idl)*ch2(ik,ip)
  113    continue
         idlj = idl
         inc = inc+ido
         do 115 j=3,ipph
            jc = ipp2-j
            idlj = idlj+inc
            if (idlj .gt. idp) idlj = idlj-idp
            war = wa(idlj-1)
            wai = wa(idlj)
            do 114 ik=1,idl1
               c2(ik,l) = c2(ik,l)+war*ch2(ik,j)
               c2(ik,lc) = c2(ik,lc)-wai*ch2(ik,jc)
  114       continue
  115    continue
  116 continue
      do 118 j=2,ipph
         do 117 ik=1,idl1
            ch2(ik,1) = ch2(ik,1)+ch2(ik,j)
  117    continue
  118 continue
      do 120 j=2,ipph
         jc = ipp2-j
         do 119 ik=2,idl1,2
            ch2(ik-1,j) = c2(ik-1,j)-c2(ik,jc)
            ch2(ik-1,jc) = c2(ik-1,j)+c2(ik,jc)
            ch2(ik,j) = c2(ik,j)+c2(ik-1,jc)
            ch2(ik,jc) = c2(ik,j)-c2(ik-1,jc)
  119    continue
  120 continue
      nac = 1
      if (ido .eq. 2) return
      nac = 0
      do 121 ik=1,idl1
         c2(ik,1) = ch2(ik,1)
  121 continue
      do 123 j=2,ip
         do 122 k=1,l1
            c1(1,k,j) = ch(1,k,j)
            c1(2,k,j) = ch(2,k,j)
  122    continue
  123 continue
      if (idot .gt. l1) go to 127
      idij = 0
      do 126 j=2,ip
         idij = idij+2
         do 125 i=4,ido,2
            idij = idij+2
            do 124 k=1,l1
               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)+wa(idij)*ch(i,k,j)
               c1(i,k,j) = wa(idij-1)*ch(i,k,j)-wa(idij)*ch(i-1,k,j)
  124       continue
  125    continue
  126 continue
      return
  127 idj = 2-ido
      do 130 j=2,ip
         idj = idj+ido
         do 129 k=1,l1
            idij = idj
            do 128 i=4,ido,2
               idij = idij+2
               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)+wa(idij)*ch(i,k,j)
               c1(i,k,j) = wa(idij-1)*ch(i,k,j)-wa(idij)*ch(i-1,k,j)
  128       continue
  129    continue
  130 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PASSF2
c
      subroutine passf2 (ido,l1,cc,ch,wa1)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       cc(ido,2,l1)           ,ch(ido,l1,2)           ,
     1                wa1(*)
      if (ido .gt. 2) go to 102
      do 101 k=1,l1
         ch(1,k,1) = cc(1,1,k)+cc(1,2,k)
         ch(1,k,2) = cc(1,1,k)-cc(1,2,k)
         ch(2,k,1) = cc(2,1,k)+cc(2,2,k)
         ch(2,k,2) = cc(2,1,k)-cc(2,2,k)
  101 continue
      return
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ch(i-1,k,1) = cc(i-1,1,k)+cc(i-1,2,k)
            tr2 = cc(i-1,1,k)-cc(i-1,2,k)
            ch(i,k,1) = cc(i,1,k)+cc(i,2,k)
            ti2 = cc(i,1,k)-cc(i,2,k)
            ch(i,k,2) = wa1(i-1)*ti2-wa1(i)*tr2
            ch(i-1,k,2) = wa1(i-1)*tr2+wa1(i)*ti2
  103    continue
  104 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PASSF3
c
      subroutine passf3 (ido,l1,cc,ch,wa1,wa2)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       cc(ido,3,l1)           ,ch(ido,l1,3)           ,
     1                wa1(*)     ,wa2(*)
      data taur,taui /-.5d0,-.866025403784439d0/
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         tr2 = cc(1,2,k)+cc(1,3,k)
         cr2 = cc(1,1,k)+taur*tr2
         ch(1,k,1) = cc(1,1,k)+tr2
         ti2 = cc(2,2,k)+cc(2,3,k)
         ci2 = cc(2,1,k)+taur*ti2
         ch(2,k,1) = cc(2,1,k)+ti2
         cr3 = taui*(cc(1,2,k)-cc(1,3,k))
         ci3 = taui*(cc(2,2,k)-cc(2,3,k))
         ch(1,k,2) = cr2-ci3
         ch(1,k,3) = cr2+ci3
         ch(2,k,2) = ci2+cr3
         ch(2,k,3) = ci2-cr3
  101 continue
      return
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            tr2 = cc(i-1,2,k)+cc(i-1,3,k)
            cr2 = cc(i-1,1,k)+taur*tr2
            ch(i-1,k,1) = cc(i-1,1,k)+tr2
            ti2 = cc(i,2,k)+cc(i,3,k)
            ci2 = cc(i,1,k)+taur*ti2
            ch(i,k,1) = cc(i,1,k)+ti2
            cr3 = taui*(cc(i-1,2,k)-cc(i-1,3,k))
            ci3 = taui*(cc(i,2,k)-cc(i,3,k))
            dr2 = cr2-ci3
            dr3 = cr2+ci3
            di2 = ci2+cr3
            di3 = ci2-cr3
            ch(i,k,2) = wa1(i-1)*di2-wa1(i)*dr2
            ch(i-1,k,2) = wa1(i-1)*dr2+wa1(i)*di2
            ch(i,k,3) = wa2(i-1)*di3-wa2(i)*dr3
            ch(i-1,k,3) = wa2(i-1)*dr3+wa2(i)*di3
  103    continue
  104 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PASSF4
c
      subroutine passf4 (ido,l1,cc,ch,wa1,wa2,wa3)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       cc(ido,4,l1)           ,ch(ido,l1,4)           ,
     1                wa1(*)     ,wa2(*)     ,wa3(*)
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         ti1 = cc(2,1,k)-cc(2,3,k)
         ti2 = cc(2,1,k)+cc(2,3,k)
         tr4 = cc(2,2,k)-cc(2,4,k)
         ti3 = cc(2,2,k)+cc(2,4,k)
         tr1 = cc(1,1,k)-cc(1,3,k)
         tr2 = cc(1,1,k)+cc(1,3,k)
         ti4 = cc(1,4,k)-cc(1,2,k)
         tr3 = cc(1,2,k)+cc(1,4,k)
         ch(1,k,1) = tr2+tr3
         ch(1,k,3) = tr2-tr3
         ch(2,k,1) = ti2+ti3
         ch(2,k,3) = ti2-ti3
         ch(1,k,2) = tr1+tr4
         ch(1,k,4) = tr1-tr4
         ch(2,k,2) = ti1+ti4
         ch(2,k,4) = ti1-ti4
  101 continue
      return
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ti1 = cc(i,1,k)-cc(i,3,k)
            ti2 = cc(i,1,k)+cc(i,3,k)
            ti3 = cc(i,2,k)+cc(i,4,k)
            tr4 = cc(i,2,k)-cc(i,4,k)
            tr1 = cc(i-1,1,k)-cc(i-1,3,k)
            tr2 = cc(i-1,1,k)+cc(i-1,3,k)
            ti4 = cc(i-1,4,k)-cc(i-1,2,k)
            tr3 = cc(i-1,2,k)+cc(i-1,4,k)
            ch(i-1,k,1) = tr2+tr3
            cr3 = tr2-tr3
            ch(i,k,1) = ti2+ti3
            ci3 = ti2-ti3
            cr2 = tr1+tr4
            cr4 = tr1-tr4
            ci2 = ti1+ti4
            ci4 = ti1-ti4
            ch(i-1,k,2) = wa1(i-1)*cr2+wa1(i)*ci2
            ch(i,k,2) = wa1(i-1)*ci2-wa1(i)*cr2
            ch(i-1,k,3) = wa2(i-1)*cr3+wa2(i)*ci3
            ch(i,k,3) = wa2(i-1)*ci3-wa2(i)*cr3
            ch(i-1,k,4) = wa3(i-1)*cr4+wa3(i)*ci4
            ch(i,k,4) = wa3(i-1)*ci4-wa3(i)*cr4
  103    continue
  104 continue
      return
      end
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PASSF5
c
      subroutine passf5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      dimension       cc(ido,5,l1)           ,ch(ido,l1,5)           ,
     1                wa1(*)     ,wa2(*)     ,wa3(*)     ,wa4(*)
      data tr11,ti11,tr12,ti12
     $ /.309016994374947d0,-.951056516295154d0,
     $ -.809016994374947d0,-.587785252292473d0/
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         ti5 = cc(2,2,k)-cc(2,5,k)
         ti2 = cc(2,2,k)+cc(2,5,k)
         ti4 = cc(2,3,k)-cc(2,4,k)
         ti3 = cc(2,3,k)+cc(2,4,k)
         tr5 = cc(1,2,k)-cc(1,5,k)
         tr2 = cc(1,2,k)+cc(1,5,k)
         tr4 = cc(1,3,k)-cc(1,4,k)
         tr3 = cc(1,3,k)+cc(1,4,k)
         ch(1,k,1) = cc(1,1,k)+tr2+tr3
         ch(2,k,1) = cc(2,1,k)+ti2+ti3
         cr2 = cc(1,1,k)+tr11*tr2+tr12*tr3
         ci2 = cc(2,1,k)+tr11*ti2+tr12*ti3
         cr3 = cc(1,1,k)+tr12*tr2+tr11*tr3
         ci3 = cc(2,1,k)+tr12*ti2+tr11*ti3
         cr5 = ti11*tr5+ti12*tr4
         ci5 = ti11*ti5+ti12*ti4
         cr4 = ti12*tr5-ti11*tr4
         ci4 = ti12*ti5-ti11*ti4
         ch(1,k,2) = cr2-ci5
         ch(1,k,5) = cr2+ci5
         ch(2,k,2) = ci2+cr5
         ch(2,k,3) = ci3+cr4
         ch(1,k,3) = cr3-ci4
         ch(1,k,4) = cr3+ci4
         ch(2,k,4) = ci3-cr4
         ch(2,k,5) = ci2-cr5
  101 continue
      return
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ti5 = cc(i,2,k)-cc(i,5,k)
            ti2 = cc(i,2,k)+cc(i,5,k)
            ti4 = cc(i,3,k)-cc(i,4,k)
            ti3 = cc(i,3,k)+cc(i,4,k)
            tr5 = cc(i-1,2,k)-cc(i-1,5,k)
            tr2 = cc(i-1,2,k)+cc(i-1,5,k)
            tr4 = cc(i-1,3,k)-cc(i-1,4,k)
            tr3 = cc(i-1,3,k)+cc(i-1,4,k)
            ch(i-1,k,1) = cc(i-1,1,k)+tr2+tr3
            ch(i,k,1) = cc(i,1,k)+ti2+ti3
            cr2 = cc(i-1,1,k)+tr11*tr2+tr12*tr3
            ci2 = cc(i,1,k)+tr11*ti2+tr12*ti3
            cr3 = cc(i-1,1,k)+tr12*tr2+tr11*tr3
            ci3 = cc(i,1,k)+tr12*ti2+tr11*ti3
            cr5 = ti11*tr5+ti12*tr4
            ci5 = ti11*ti5+ti12*ti4
            cr4 = ti12*tr5-ti11*tr4
            ci4 = ti12*ti5-ti11*ti4
            dr3 = cr3-ci4
            dr4 = cr3+ci4
            di3 = ci3+cr4
            di4 = ci3-cr4
            dr5 = cr2+ci5
            dr2 = cr2-ci5
            di5 = ci2-cr5
            di2 = ci2+cr5
            ch(i-1,k,2) = wa1(i-1)*dr2+wa1(i)*di2
            ch(i,k,2) = wa1(i-1)*di2-wa1(i)*dr2
            ch(i-1,k,3) = wa2(i-1)*dr3+wa2(i)*di3
            ch(i,k,3) = wa2(i-1)*di3-wa2(i)*dr3
            ch(i-1,k,4) = wa3(i-1)*dr4+wa3(i)*di4
            ch(i,k,4) = wa3(i-1)*di4-wa3(i)*dr4
            ch(i-1,k,5) = wa4(i-1)*dr5+wa4(i)*di5
            ch(i,k,5) = wa4(i-1)*di5-wa4(i)*dr5
  103    continue
  104 continue
      return
c
c    That's all Folks!
c
      END
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c STRTOOLS
c
c Purpose: Tools for manipulating strings
c Written: Peter A. Schultz, Decemeber-2014, for 2.65
c
c Routines:
c  STRPARS    - extracts the first (bland-delimited) character string
c  LNENDS     - finds index in string of last non-blank character
c  LNWRIT     - writes a character line, out to last non-blank character
c  LNREADTYP  - reads an atom type out of a character strong line
c  LNREADR8   - reads a REAL*8 value out of character string line
c
c Revision history:
c   5Jun15-PAS/2.67: special cases for atom type reads
c   9Apr15-PAS/2.66: LN line routines added into this module (from vdwload)
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> STRPARS
c
c
      subroutine STRPARS( line, nl1,nl2, n1,n2 )
c---------------------------------------------------------------
c Purpose: parse bounds of first character string within line
c
c Written: Peter A. Schultz, 26-November-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      CHARACTER*(*)  line
c
c local declarations:
      CHARACTER*(1)  blank
      DATA           blank / ' ' /
c
c >>>> EXECUTABLE CODE:
c
      n1 = 0
      n2 = nl2
      do  il=nl1,nl2
        if( line(il:il) .ne. blank )then
c         Found the first non-blank character ...
          n1 = il
          n2 = n1
c          ... and find the last character in string:
          do  jl=n1+1,nl2
            if( line(jl:jl) .eq. blank ) goto 999
            n2 = jl
          enddo
          goto 999
        endif
      enddo
c
  999 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LNENDS
c
c
      subroutine LNENDS( line, nline, n1line, ndline )
c
      IMPLICIT NONE
c
      INTEGER    nline, n1line, ndline
      CHARACTER*(*)  line
c Local declarations:
      INTEGER    ic
c
c Find last non-blank character in line:
      ndline = nline
      do 10 ic=nline,1,-1
        if( line(ic:ic) .ne. ' ' )then
          ndline = ic - 1
          goto 11
        endif
   10 continue
c     Line is blank
      ndline = 0
      n1line = 0
      goto 99
   11 continue
c
c Find first non-blank character in line:
      n1line = 1
      do 20 ic=1,ndline
        if( line(ic:ic) .ne. ' ' )then
          n1line = ic
          goto 21
        endif
   20 continue
   21 continue
c
   99 continue
c     
c    That's all, Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LNWRIT
c
c
      subroutine LNWRIT( IWRLN, line, nline )
c---------------------------------------------------------------
c Purpose: write out line, only out to last non-blank char
c Written: Peter A. Schultz, February-2013, for v2.65 (vdw)
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c input
      INTEGER        IWRLN
      CHARACTER*(*)  line
      INTEGER        nline
c Local
      INTEGER        ic, lenlin
      LOGICAL        printon
c
      printon = ( IWRLN .ge. 0 )
c
      if( .not. printon ) RETURN
c
      lenlin = 0
c Determine length of line to write
      do  ic=nline,1,-1
        if( line(ic:ic) .ne. ' ' )then
          lenlin = ic
          goto 120
        endif
      enddo
c
  120 continue
      if( lenlin .gt. 0 )then
c       Write the line out
        write(IWRLN,'(a)')  line(1:lenlin)
      else
c       Write a blank line
        write(IWRLN,*)
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LNREADTYP
c
c
      subroutine LNREADTYP( line,n1,nline, ityp, ntyp,typnm,natmnm )
c---------------------------------------------------------------
c Purpose: determine typ # from input
c Written: Peter A. Schultz, February-2013, for v2.65 (vdw)
c Revised:
c  29Apr16-PAS/2.67b - removed length-limimit on integer read
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c input/Output
      CHARACTER*(*)  line
      INTEGER        n1,nline
      CHARACTER*(*)  typnm
      DIMENSION  typnm(*)
      INTEGER        ityp, ntyp,natmnm
c Local:
c     atmnm needs to be at least as long as typnm (I.e. natmnm)
      CHARACTER*(12)  atmnm
      INTEGER         is1,isn,islast, nmlen, jtyp
c
c >>>> EXECUTABLE CODE:
c
      ityp = -2
      if( n1 .gt. nline ) RETURN
      call STRPARS( line, n1,nline, is1,isn )
c
c     CHeck if this line is blank
      ityp = -1
      if( is1 .le. 0 ) RETURN
      n1 = isn + 1
c
      atmnm = ' '
      islast = isn
      nmlen = islast - is1 + 1
      if( nmlen .gt. natmnm ) nmlen = natmnm
      islast = is1 + nmlen - 1
      atmnm(1:natmnm) = line(is1:islast)
c
C      if( nmlen.lt.3 )then
c       Attempt to read an atom type number out of this:
        read( atmnm, * , err=100 ) jtyp
        if( jtyp.gt.0 .and. jtyp.le.ntyp )then
          ityp = jtyp
          RETURN
        endif
C      endif
c
  100 continue
      do  jtyp=1,ntyp
        if( atmnm(1:natmnm) .eq. typnm(jtyp) )then
          ityp = jtyp
          RETURN
        endif
      enddo
c
c  Did not find the type, check some special cases:
      if( atmnm(1:5) .eq. 'FIRST' )then
        ityp = 1
      elseif( atmnm(1:4) .eq. 'LAST' )then
        ityp = ntyp
      else 
c       We could not identify the atom
        ityp = 0
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LNREADR8
c
c
      subroutine LNREADR8( line,n1,nline, value, ierr )
c---------------------------------------------------------------
c Purpose: determine real*8 from input
c Written: Peter A. Schultz, February-2013, for v2.65 (vdw)
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c input/Output
      CHARACTER*(*)  line
      INTEGER        n1,nline,ierr
      REAL*8         value
c Local
      INTEGER        is1,isn
c
c >>>> EXECUTABLE CODE:
c
      ierr = -2
      if( n1 .gt. nline ) RETURN
      call STRPARS( line, n1,nline, is1,isn )
c
c     CHeck if this line is blank
      ierr = -1
      if( is1 .le. 0 ) RETURN
c
c Read the value from the line, and update the char counter
      read( line(is1:isn), * , err=130 )  value
      n1 = isn + 1
      ierr = 0
c
      RETURN
c
c Error encountered
  130 continue
      value = 0.d0
      ierr = -1
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLSTUFF
c
c
c#######################################################################
c Module FLSTUFF
c
c Purpose: take care of file/unit/name handling for fortran code
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  29Dec19-PAS/2.68a: reconcile FLNSTUFF/FLSPECS commons
c   6Jul06-APT/    : merged task parallel and image parallel
c   7Aug03-PAS/2.55a: cosmetics, and Cplant file synch workaround.
c  29Oct02-PAS/2.54: cleanup, document, and debug flag
c---------------------------------------------------------------
c
c The machinery in this package constructs fully qualified path names:
c     <filesp> = <path>/<filenm> = <path>/<jobnm>.<filetag>
c  The variable name in the calling arguments denotes what pieces of
c  this are assembled in the routine to give the ultimate <filesp>.
c
c The user does not specify unit numbers (except for standard in/out/err
c  in the initialization).  This package tracks available unit numbers,
c  allocates a unit number as an *output* when it opens a file, and
c  makes that unit number available again when the file is closed.  The
c  code then identifies all open units when the module is terminated
c  and closes all outstanding open files.
c
c External dependencies:
c  STOPXERR( msg ) which outputs <msg> and STOPs code when fatal error
c  MPNODE_G( node ) which returns global rank of node for debugging output
c  STRPARS( string,n1,n2,i1,i2 ) - first field (i1:i2) in string(n1:n2)
c
c >>>>> Module initialization (invoked before first file access):
c     subroutine FLINIT( IRD, IWR, IERRFL )
c        IRD,IWR,IERRFL(input) = set unit #'s for standard in/out/err
c        Initializes all unit numbers as unused.
c
c >>>>> Module termination (invoked when code completed):
c     subroutine FLFINI()
c        Closes all outstanding open file units.
c
c >>>>> File manipulation:
c  (NB: input character variables flstat and flform are shorthand for
c  fortran status and format keywords, and are translated in FL_CHKEYS)
c  Check for existence of file with name "filenm"
c     subroutine FLEXIST( iexist, filenm, flform )
c  Open ASCII file with tag "filetag" (input), and unit# ifl (output)
c     subroutine FLOPENA( ifl, filetag )
c  Open binary file with tag "filetag" (input), and unit# ifl (output)
c     subroutine FLOPENB( ifl, filetag )
c  Open file with name "filenm" (input), and unit# ifl (output)
c     subroutine FLOPENF( ifl, filenm, flstat, flform )
c  Open file with name "filenm", using specified unit# ifl (**input**)
c     entry FLOPENU( ifl, filenm, flstat, flform )
c  Open file with full spec "filesp" (input), and unit# ifl (output)
c     subroutine FLOPEN( ifl, filesp, flstat, flform, ierror )
c  Translation of fortran open keyword (flform/flstat):
c     subroutine FL_CHKEYS( flkey, flkeyword, ierror )
c  Close file with unit# ifl (input)
c     subroutine FLCLOSE( ifl )
c  Close and delete file with unit# ifl (input)
c     subroutine FLDELETE( ifl )
c
c >>>>> File name/path building routines
c  Extend a path name with nadd-length string "addpath", i.e.
c  <path> = <path> // <addpath> // '/' (i.e. note closing slash)
c     subroutine FLADDPATH( nadd, addpath )
c  Set job name "jobnm" (i.e. file names made as <jobnm>.<filetag> )
c     subroutine FLSETJOB( jobnm )
c  Take input string "filetag", output full file spec "filesp"
c     subroutine FLNAMESP( filetag, filesp )
c  Take input string "filetag", output filename "filenm"
c     subroutine FLNAME( filetag, filenm )
c  Take input filename "filenm", output file spec "filesp"
c     subroutine FLSPEC( filenm, filesp )
c
c >>>>> Unit number manipulation routines
c   subroutine FLGETU( ifl ) - return unused unit# ifl (input), taken
c   entry FLFINDU( ifl ) - returns unused unit# ifl (output), reserved
c   entry FLGETIRD( ifl ) - returns standard in unit# ifl (output)
c   entry FLGETIWR( ifl ) - returns standard out unit# ifl (output)
c   entry FLGETIERR( ifl ) - returns standard error unit# ifl (output)
c
c >>>>> Internal routines:
c   FLN_SUBS - primitives for path/filename manipulations
c   FLU_SUBS - primitives for unit number manipulation
c#######################################################################
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLINIT
c
c
      subroutine FLINIT( IRD, IWR, IERRFL )
c---------------------------------------------------------------
c Purpose: initialize file handling module
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  29Dec19-PAS/2.68a: get rid of unneeded&misnamed FLSPECS common
c---------------------------------------------------------------
c
c  IRD    = standard input unit number
c  IWR    = standard output unit number
c  IERRFL = standard error output unit number
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
c Set up units as all unused:
      call FLU_INIT
c Set up null directory structure:
      call FLN_INIT
c
c Set the standard i/o units, and reserve the unit numbers:
      call FLU_IRDSET( IRD )
      call FLU_RSV( IRD, ierror )
      call FLU_IWRSET( IWR )
      call FLU_RSV( IWR, ierror )
      call FLU_IERRSET( IERRFL )
      if( IERRFL .ne. IWR ) call FLU_RSV( IERRFL, ierror )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLFINI
c
c
      subroutine FLFINI
c---------------------------------------------------------------
c Purpose: close all open files
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( nfld = 100 )
      COMMON  /FLUSTUFF/ IRDU,IWRU,IERRU,IFLU1,IFLU2,iflstat(nfld)
c
c >>>> EXECUTABLE CODE:
c
c Check all unit numbers for open files, and close them:
      do  jfl=1,nfld
        if( iflstat(jfl) .eq. 2 )then
          call FLCLOSE( jfl )
          iflstat(jfl) = 0
        endif
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLEXIST
c
c
      subroutine FLEXIST( iexist, filenm, flform )
c---------------------------------------------------------------
c Purpose: check whether a file exists
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Returns iexist=0 if file does not exist
c         iexist=1 if file does exist
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input: full file spec;  Output: format of file to be tested
      CHARACTER*(*)  filenm, flform
c Local: format of file to be tested
      CHARACTER*(12) form
      CHARACTER  filesp*128
c
c >>>> EXECUTABLE CODE:
c
      call FLU_NUM( ifl, ierror )
      if( ierror.ne.0 ) call STOPXERR( 'FLEXIST1: no unit# avail' )
c
      call FL_CHKEYS( flform, form, ierror )
      if( ierror.ne.0 ) call STOPXERR( 'FLEXIST2: bad format key' )
c
      call FLSPEC( filenm, filesp )
      OPEN( unit=ifl,file=filesp,status='OLD',form=form,err=1301 )
      CLOSE( unit=ifl )
c
      iexist = 1
      RETURN
 1301 iexist = 0
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLOPENA
c
c
      subroutine FLOPENA( ifl, filetag )
c---------------------------------------------------------------
c Purpose: open a standard ascii file
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input: tag for file
      CHARACTER*(*) filetag
c Local: full file spec for file
      CHARACTER  filenm*128
c
c >>>> EXECUTABLE CODE:
c
      call FLNAME( filetag, filenm )
      call FLOPENF( ifl, filenm, 'UNK', 'FOR' )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLOPENB
c
c
      subroutine FLOPENB( ifl, filetag )
c---------------------------------------------------------------
c Purpose: open a standard binary file
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input: tag for file to be opened
      CHARACTER*(*) filetag
c Local: full file spec for file
      CHARACTER  filenm*128
c
c >>>> EXECUTABLE CODE:
c
      call FLNAME( filetag, filenm )
      call FLOPENF( ifl, filenm, 'UNK', 'UNF' )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLOPENF
c
c
      subroutine FLOPENF( ifl, filenm, flstat, flform )
c---------------------------------------------------------------
c Purpose: open a file (in need of a path)
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c   6Feb02-PAS/2.51c: move some stuff around within FL.
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input: full file spec, status of file, format of file
      CHARACTER*(*)  filenm, flstat,flform
c Local: (fortran) status of file, format of file
      CHARACTER*(12) stat,form
      CHARACTER      filesp*128
      DATA  idebug_fl / 0 /
c
c >>>> EXECUTABLE CODE:
c
c Find a free unit number:
      call FLU_NUM( ifl, ierror )
      if( ierror.ne.0 ) call STOPXERR( 'FLOPENF1: no unit# avail' )
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLOPENU
c
      entry FLOPENU( ifl, filenm, flstat, flform )
c
c Check that unit number is actually available:
      call FLU_CHK( ifl, ierror )
      if( ierror.ne.0 ) call STOPXERR( 'FLOPENF2: unit# already open' )
c
c Set up the keywords for the fortran open statement:
      call FL_CHKEYS( flstat, stat, ierror )
      if( ierror.ne.0 ) call STOPXERR( 'FLOPENF3: bad status key' )
      call FL_CHKEYS( flform, form, ierror )
      if( ierror.ne.0 ) call STOPXERR( 'FLOPENF4: bad format key' )
c
c Open the file ...
      call FLSPEC( filenm, filesp )
      if( idebug_fl .gt. 0 )then
        call MPNODE_G( node )
        call STRPARS( filesp, 1,80, i1,i2 )
        write(*, '(a,i4, a,i2, a,a)' )  'FLOPENF/node=',node,
     $   ', attempt unit=',ifl,   ', filesp=',filesp(i1:i2)
        write(*, '(a,i4, a,i2, a,a,a)' )  'FLOPENF/node=',node,
     $   ', attempt unit=',ifl,   ',         stat,form=',stat,form
      endif
c
cxxxcplant:start * * * * * * * * * * * * * * * * * * * * * * * * *
      if( flstat.eq.'OLD' )then
c       This section of code prompted by file system synch problem
c       on Cplant: code may not recognize existence of input file
c       on *first* attempt to open file.  Preliminary touch with
c       an INQUIRE (that might lie and say not-exist) is enough to
c       cause synch and have the open work. - 07Aug03-PAS
c        The ACCESS was Cplant suggestion - but fails on new OS.
c        if( flstat.eq.'OLD') call ACCESS( filesp, 0 )
        if( flstat.eq.'OLD' ) call FLEXIST( iexist, filenm, flform )
        if( iexist .eq. 0 )then
          call MPNODE_G( node )
          call STRPARS( filesp, 1,128, i1,i2 )
          write(*,'(a,i4,2x,a)') '***** OLD file missing on node',
     $     node,filesp(i1:i2)
        endif
      endif
cxxxcplant:end * * * * * * * * * * * * * * * * * * * * * * * * * *
      OPEN( unit=ifl,file=filesp,status=stat,form=form,err=1301 )
c  ... and record the unit number as being with an open file:
      call FLU_OPN( ifl, ierror )
c
      if( idebug_fl .gt. 0 )then
        write(*, '(a,i4, a,i2, a,a)' )  'FLOPENF/node=',node,
     $   ', open ok unit=',ifl,   ', filesp=',filesp(i1:i2)
      endif
c
      RETURN
c
 1301 continue
      if( idebug_fl .gt. 0 )then
        write(*, '(a,i4, a,i2, a,a)' )  'FLOPENF/node=',node,
     $   ', open FAILED unit=',ifl,   ', filesp=',filesp(i1:i2)
      endif
      call FLU_IERR( IWR )
      write(IWR,*) '***** ERROR *****'
      write(IWR,*) 'File open failed: unit number=',ifl
      write(IWR,*) '  file=',filesp
      call STOPXERR( 'FLOPENF: file open failed' )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLOPEN
c
c
      subroutine FLOPEN( ifl, filesp, flstat, flform, ierror )
c---------------------------------------------------------------
c Purpose: open a file with full file specification
c
c Written: Peter A. Schultz, 6-February-2002, for v2.51(c)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c ifl = output:  unit number for the opened file
c filesp = input: fully qualified path name for a file
c flstat = input: shorthand for fortran open "status"
c flform = input: shorthand for fortran open "format"
c ierror = output: 0 if successful open, otherwise non-zero
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input: full file spec, status of file, format of file
      CHARACTER*(*)  filesp, flstat,flform
c Local: (fortran) status of file, format of file
      CHARACTER*(12) stat,form
      DATA  idebug_fl / 0 /
c
c >>>> EXECUTABLE CODE:
c
      ierror = 0
c Find a free unit number:
      call FLU_NUM( ifl, ierror )
      if( ierror.ne.0 ) call STOPXERR( 'FLOPEN1: no unit number avail' )
c
c Set up the keywords for the fortran open statement:
      call FL_CHKEYS( flstat, stat, ierror )
      if( ierror.ne.0 ) call STOPXERR( 'FLOPEN3: bad status key' )
      call FL_CHKEYS( flform, form, ierror )
      if( ierror.ne.0 ) call STOPXERR( 'FLOPEN4: bad format key' )
c
c Open the file ...
      if( idebug_fl .gt. 0 )then
        call MPNODE_G( node )
        call STRPARS( filesp, 1,80, i1,i2 )
        write(*, '(a,i4, a,i2, a,a)' )  'FLOPEN/node=',node,
     $   ', attempt unit=',ifl,   ', filesp=',filesp(i1:i2)
        write(*, '(a,i4, a,i2, a,a,a)' )  'FLOPEN/node=',node,
     $   ', attempt unit=',ifl,   ',         stat,form=',stat,form
      endif
cxxxcplant: could prep OLD open with touch, but not enfs here.
      OPEN( unit=ifl,file=filesp,status=stat,form=form,err=1301 )
c  ... and record the unit number as being with an open file:
      call FLU_OPN( ifl, ierror )
c
      if( idebug_fl .gt. 0 )then
        write(*, '(a,i4, a,i2, a,a)' )  'FLOPEN/node=',node,
     $   ', open ok unit=',ifl,   ', filesp=',filesp(i1:i2)
      endif
c
      RETURN
c
 1301 ierror = 1
      if( idebug_fl .gt. 0 )then
        write(*, '(a,i4, a,i2, a,a)' )  'FLOPEN/node=',node,
     $   ', open FAILED unit=',ifl,   ', filesp=',filesp(i1:i2)
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FL_CHKEYS
c
c
      subroutine FL_CHKEYS( flkey, flkeyword, ierror )
c---------------------------------------------------------------
c Purpose: find full correct keyword for fortran open statement
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Input: internal key for file open
      CHARACTER*(*)   flkey
c Output: full fortran keyword for open statement
      CHARACTER*(12)  flkeyword
c Local:
      CHARACTER*(3)   keyfl
c
c >>>> EXECUTABLE CODE:
c
      ierror = 0
      keyfl = flkey(1:3)
c
      if( keyfl .eq. 'UNK' )then
        flkeyword = 'unknown'
      elseif( keyfl .eq. 'NEW' )then
        flkeyword = 'new'
      elseif( keyfl .eq. 'OLD' )then
        flkeyword = 'old'
c
      elseif( keyfl .eq. 'UNF' )then
        flkeyword = 'unformatted'
      elseif( keyfl .eq. 'FOR' )then
        flkeyword = 'formatted'
c
      elseif( keyfl .eq. 'KEE' )then
        flkeyword = 'keep'
      elseif( keyfl .eq. 'DEL' )then
        flkeyword = 'delete'
c
      else
        flkeyword = ' '
        ierror = 1
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLCLOSE
c
c
      subroutine FLCLOSE( ifl )
c---------------------------------------------------------------
c Purpose: close (and keep) a file with unit number "ifl"
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Local:
      DATA  idebug_fl / 0 /
c
c >>>> EXECUTABLE CODE:
c
c Close the file ...
      if( idebug_fl .gt.0 )then
        call MPNODE_G( node )
        write(*, '(a,i4, a,i2)' )  'FLCLOSE/node=',node,
     $   ', closed unit=',ifl
      endif
      CLOSE( unit=ifl, status ='KEEP' )
c  ... and record the unit number as being available again:
      call FLU_CLS( ifl, ierror )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLDELETE
c
c
      subroutine FLDELETE( ifl )
c---------------------------------------------------------------
c Purpose: close (and delete) a file with unit number "ifl"
c
c Written: Peter A. Schultz, 9-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Local:
      DATA  idebug_fl / 0 /
c
c >>>> EXECUTABLE CODE:
c
c Close the file ...
      if( idebug_fl .gt. 0 )then
        call MPNODE_G( node )
          write(*, '(a,i4, a,i2)' )  'FLDELETE/node=',node,
     $     ', closed unit=',ifl
      endif
      CLOSE( unit=ifl, status ='DELETE' )
c  ... and record the unit number as being available again:
      call FLU_CLS( ifl, ierror )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLSETJOB
c
c
      subroutine FLSETJOB( jobnm )
c---------------------------------------------------------------
c Purpose: set a job name for the code
c
c Written: Peter A. Schultz, 7-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input: job name
      CHARACTER*(*)  jobnm
c Local:
      DATA  idebug_fl / 0 /
c
c >>>> EXECUTABLE CODE:
c
      call FLN_SETJ( jobnm )
c
      if( idebug_fl .gt. 0 )then
        call MPNODE_G( node )
        call STRPARS( jobnm, 1,80, i1,i2 )
        write(*, '(a,i4, a,a)' )  'FLSETJOB/node=', node,
     $   ', jobname=',jobnm(i1:i2)
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLADDPATH
c
c
      subroutine FLADDPATH( nadd, addpath )
c---------------------------------------------------------------
c Purpose: add to path name
c
c Written: Peter A. Schultz, 7-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input: addition to directory path for files
      CHARACTER*(*)  addpath
c Local:
      DATA  idebug_fl / 0 /
c
c >>>> EXECUTABLE CODE:
c
      call FLN_ADDP( nadd, addpath )
c
      if( idebug_fl .gt. 0 )then
        call MPNODE_G( node )
        write(*, '(a,i4, a,a)' )  'FLADDPATH/node=',node,
     $   ', addpath=',addpath(1:nadd)
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLNAMESP
c
c
      subroutine FLNAMESP( filetag, filesp )
c---------------------------------------------------------------
c Purpose: construct full path name from file tag (add dir/job)
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input: file tag;  Output: full file spec
      CHARACTER*(*)  filetag, filesp
c Local:
      CHARACTER*128  filenm
c
c >>>> EXECUTABLE CODE:
c
      call FLNAME( filetag, filenm )
      call FLSPEC( filenm, filesp )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLNAME
c
c
      subroutine FLNAME( filetag, filenm )
c---------------------------------------------------------------
c Purpose: connect job name to file tag to get file name
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revi  sion history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON /FLNSTUFF/ ndirspec, njobspec, dirspec, jobspec
      CHARACTER  dirspec*128, jobspec*128
c
c Input: file tag;  Output: file name
      CHARACTER*(*)  filetag, filenm
c Local:
      CHARACTER*(1)  chdot
      DATA           chdot / '.' /
c
c >>>> EXECUTABLE CODE:
c
      filenm = jobspec(1:njobspec) // chdot // filetag
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLSPEC
c
c
      subroutine FLSPEC( filenm, filesp )
c---------------------------------------------------------------
c Purpose: connect file name to directory to get full file spec
c
c Written: Peter A. Schultz, 6-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON /FLNSTUFF/ ndirspec, njobspec, dirspec, jobspec
      CHARACTER  dirspec*128, jobspec*128
c
c Input: file name;  Output: full file spec
      CHARACTER*(*)  filenm, filesp
c
c Local:
      CHARACTER*(128)  chtmp
c
c >>>> EXECUTABLE CODE:
c
      chtmp = filenm
      call STRPARS( chtmp, 1,128, n1,nd )
c
      if( n1 .gt. 0 )then
        filesp = dirspec(1:ndirspec) // filenm(n1:nd)
      else
        filesp = dirspec(1:ndirspec)
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLGETU
c
c
      subroutine FLGETU( ifl )
c---------------------------------------------------------------
c Purpose: find a free i/o unit number "ifl"
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
c Get a free unit number ...
      call FLU_NUM( jfl, ierror )
c  ... and mark it as opened:
      call FLU_OPN( jfl, ierror )
      ifl = jfl
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLFINDU
c
      entry FLFINDU( ifl )
c
c Get a free unit number ...
      call FLU_NUM( jfl, ierror )
c  ... and reserve it:
      call FLU_RSV( jfl, ierror )
      ifl = jfl
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLGETIRD
c
      entry FLGETIRD( ifl )
c
c Get the standard input unit number:
      call FLU_IRD( jfl )
      ifl = jfl
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLGETIWR
c
      entry FLGETIWR( ifl )
c
c Get the standard output unit number:
      call FLU_IWR( jfl )
      ifl = jfl
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLGETIERR
c
      entry FLGETIERR( ifl )
c
c Get the standard output error unit number:
      call FLU_IERR( jfl )
      ifl = jfl
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLN_SUBS
c
c
c---------------------------------------------------------------
c Purpose: internal primitive routines to handle file/path names
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLN_INIT
c
c
      subroutine FLN_INIT
c---------------------------------------------------------------
c Purpose: initialized directory info to null
c
c Written: Peter A. Schultz, 6-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON /FLNSTUFF/ ndirspec, njobspec, dirspec, jobspec
      CHARACTER  dirspec*128, jobspec*128
c
c >>>> EXECUTABLE CODE:
c
c Blank directory name ...
      dirspec = ' '
c  ... with zero length:
      ndirspec = 0
c Standard job name ...
      call FLN_SETJ( 'job' )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLN_ADDP
c
c
      subroutine FLN_ADDP( nch, chfl )
c---------------------------------------------------------------
c Purpose: extend a path name
c
c Written: Peter A. Schultz, 6-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON /FLNSTUFF/ ndirspec, njobspec, dirspec, jobspec
      CHARACTER  dirspec*128, jobspec*128
c
      CHARACTER*(*)  chfl
c Local:
      CHARACTER*128  chtmp
      CHARACTER*1    slash
      DATA           slash / '/' /
c
c >>>> EXECUTABLE CODE:
c
      chtmp = chfl
      call STRPARS( chtmp, 1,nch, n1,n2 )
      if( n1 .eq. 0 ) RETURN
c
      len2 = n2 - n1 + 1
      len1 = ndirspec
      nd1 = len1 + 1
      nd2 = len1 + len2 + 1
      if( nd2.gt.128 ) call STOPXERR( 'dir spec too long >128' )
c
c Augment directory specification:
      ndirspec = nd2
      dirspec(nd1:nd2) = chfl(n1:n2) // slash
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLN_SETJ
c
c
      subroutine FLN_SETJ( chfl )
c---------------------------------------------------------------
c Purpose: overwrite a job name
c
c Written: Peter A. Schultz, 6-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON /FLNSTUFF/ ndirspec, njobspec, dirspec, jobspec
      CHARACTER  dirspec*128, jobspec*128
c
      CHARACTER*(*)  chfl
c Local:
      CHARACTER*(128)  chtmp
c
c >>>> EXECUTABLE CODE:
c
      chtmp = chfl
      call STRPARS( chtmp, 1,128, n1,n2 )
      if( n1 .eq. 0 ) RETURN
c
      len2 = n2 - n1 + 1
      len1 = 0
      nd1 = len1 + 1
      nd2 = len1 + len2
c
      njobspec = nd2
      jobspec(nd1:nd2) = chfl(n1:n2)
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_SUBS
c
c
c---------------------------------------------------------------
c Purpose: internal primitive routines to handle files/units
c
c Written: Peter A. Schultz, 5-Decemeber-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c In the common block FLUSTUFF:
c   IRDU,IWRU,IERRU = standard in/out/err unit numbers
c   IFLU1,IFLU2 (not used) = two other standard units
c   ifstat(ifl) - status of unit number: 0=free,1=reserved,2=opened
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_INIT
c Initialize all unit numbers as free:
      subroutine FLU_INIT
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( nfld = 100 )
      COMMON  /FLUSTUFF/ IRDU,IWRU,IERRU,IFLU1,IFLU2,iflstat(nfld)
c
      do  jfl=1,nfld
        iflstat(jfl) = 0
      enddo
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_IRDSET
c Set standard input unit
      entry FLU_IRDSET( ifl )
      IRDU = ifl
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_IWRSET
c Set standard output unit number
      entry FLU_IWRSET( ifl )
      IWRU = ifl
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_IERRSET
c Set standard error output unit number
      entry FLU_IERRSET( ifl )
      IERRU = ifl
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_IRD
c Return standard input unit number
      entry FLU_IRD( ifl )
      ifl = IRDU
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_IWR
c Return standard output unit number
      entry FLU_IWR( ifl )
      ifl = IWRU
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_IERR
c Return standard error output unit number
      entry FLU_IERR( ifl )
      ifl = IERRU
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_NUM
c Return available unit number
      entry FLU_NUM( ifl, ierror )
      ierror = 0
c I intentionally leave the single digit units untouched
      do  jfl=10,nfld
        if( iflstat(jfl) .eq. 0 )then
c         This unit number is available
          ifl = jfl
          RETURN
        endif
      enddo
c     We did not find a free unit number, very bad:
      ifl = -1
      ierror = 5
      call STOPXERR( 'FLU_NUM: no free unit numbers for file' )
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_CHK
c Check if file is already open
      entry FLU_CHK( ifl, ierror )
      ierror = 0
c     Check if unit number attached to opened file:
      if( iflstat(ifl) .eq. 2 ) ierror = 1
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_RSV
c Set unit number as reserved
      entry FLU_RSV( ifl, ierror )
      if( iflstat(ifl) .eq. 0 )then
        iflstat(ifl) = 1
        ierror = 0
      else
        ierror = 1
      endif
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_OPN
c Set unit number as in-use and opened, and unavailable
      entry FLU_OPN( ifl, ierror )
      if( iflstat(ifl) .ne. 2 )then
        ierror = 0
      else
        ierror = 1
      endif
      iflstat(ifl) = 2
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FLU_CLS
c Set unit number as closed file, making it available
      entry FLU_CLS( ifl, ierror )
      if( iflstat(ifl) .eq. 2 )then
        ierror = 0
      else
        ierror = 1
      endif
      iflstat(ifl) = 0
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPSTUFF
c
c
c###############################################################
c Purpose: manage MPI handling in the code
c
c Written: Peter A. Schultz, 7-December-2001, for 2.51
c
c Revision history:
c  19Nov08-PAS/2.62: to accommodate k-parallel communicator layer
c   6Jul06-APT/2.60: to merge task and image parallel
c###############################################################
c
c External dependencies:
c  none
c
c Public routines:
c  Initialize communicator for communicator level icommlvl:
c    MPLOADCOMM( node,node0,nodes,icomm, icommlvl )
c  Global communicator, icommlvl=1:
c    MPNODES_G( nodes ) - returns number of nodes in global communicator
c    MPNODE_G( node )   - returns rank of this node in global communicator
c    MPNODE0_G( node0 ) - returns rank of master in global communicator
c    MPCOMM_G( icomm )  - returns communicator id for global communicator
c  Local communicator (image layer), icommlvl=2:
c    MPSTAMP( IWR )  - print out communicator info for local communicator
c    MPNODES( nodes )   - returns number of nodes in local communicator
c    MPNODE( node )     - returns rank of this node in local communicator
c    MPNODE0( node0 )   - returns rank of master in local communicator
c    MPCOMM( icomm )    - returns communicator id for local communicator
c  "k-local" communicator (sub-image "k-parallel" layer), icommlvl=3:
c    MPNODES_K( nodes ) - returns number of nodes in k-local communicator
c    MPNODE_K( node )   - returns rank of this node in k-local communicator
c    MPNODE0_K( node0 ) - returns rank of master in k-local communicator
c    MPCOMM_K( icomm )  - returns communicator id k-local communicator
c  Note: MPSTUFF data structure is set 4-deep, allowing for another level
c
c Private routines:
c    MPSET{N,I,0,C}( arg, icommlvl ) - sets arg for icommlvl
c    MPGET{N,I,0,C}( arg, icommlvl ) - returns arg for icommlvl
c     ... where arg = nodes, rank of node, master rank, communicator
c         for {N,I,0,C} routines respectively
c
c###############################################################
c Notes on the MPSTUFF module:
c
c  This is not a particularly clean, general implementation,
c   but a minimalist module just to make wrapping the mpi possible.
c  We will refine this module as the parallelism in the code matures,
c   and the specific needs for better parallelism mgmt become clearer.
c  The "parallel" global/local/k-local accessors are notably clunky.
c  The code itself must keep track of a lot of information
c   about processor organization, very awkward. E.g., ...
c  An ad hoc machinery is necessary to keep track of node-id's
c   between levels of communicators, e.g., to collect in upper
c   communicator results from masters of lower communicators.
c  However, this does hide direct mpi from most of the core code.
c
c###############################################################
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPSTAMP
c
c
      subroutine MPSTAMP( IWR )
c---------------------------------------------------------------
c Purpose: print out local processor allocation
c
c Written: Aidan P. Thompson, 6-July-2006, for v2.60
c
c Revision history:
c  21Jun07-PAS/2.60: pushed into subroutine
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
      INTEGER  IWR
      INTEGER  nodes,node,node0,icomm
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nodes )
      call MPNODE( node )
      call MPNODE0( node0 )
      call MPCOMM( icomm )
c
      if( IWR .ge. 0 )then
        write(IWR,'(1x,a)')
     $       'MPINFO::: Local Communicator         :::'
        write(IWR,'(1x,a,i4,a)')
     $       'MPINFO::: Local Context = ',icomm  ,'       :::'
        write(IWR,'(1x,a,i4,a)')
     $       'MPINFO::: Local Size =    ',nodes  ,'       :::'
        write(IWR,'(1x,a,i4,a)')
     $       'MPINFO::: Local Root =    ',node0  ,'       :::'
        write(IWR,'(1x,a,i4,a)')
     $       'MPINFO::: Local Rank =    ',node   ,'       :::'
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPLOADCOMM
c
c
      subroutine MPLOADCOMM( nprocs, node, node0, icomm, icommlvl )
c---------------------------------------------------------------
c Purpose: initialize wrapper layers
c
c Written: Peter A. Schultz, 19_November-2008, for 2.62
c
c Revision history:
c   none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
c  Currently max out at 4 levels in MPSTUFF:
      ncommlvl = 4
c  Initialize this and all subordinate communicators:
      do  icommset=icommlvl,ncommlvl
        call MP_SETN( nprocs, icommset )
        call MP_SETI( node  , icommset )
        call MP_SET0( node0 , icommset )
        call MP_SETC( icomm , icommset )
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPNODES
c
c
      subroutine MPNODES( nprocs )
c---------------------------------------------------------------
c Purpose: return the local number of processors/nodes
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 2
      call MP_GETN( nprocs, icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPNODE
c
c
      subroutine MPNODE( node )
c---------------------------------------------------------------
c Purpose: return the local node number of this processor
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 2
      call MP_GETI( node, icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPNODE0
c
c
      subroutine MPNODE0( node0 )
c---------------------------------------------------------------
c Purpose: return the local root node "node0"
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 2
      call MP_GET0( node0, icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPCOMM
c
c
      subroutine MPCOMM( icomm )
c---------------------------------------------------------------
c Purpose: return the local communicator/context
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 2
      call MP_GETC( icomm,icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPNODES_K
c
c
      subroutine MPNODES_K( nprocs )
c---------------------------------------------------------------
c Purpose: return the local number of processors/nodes
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 3
      call MP_GETN( nprocs, icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPNODE_K
c
c
      subroutine MPNODE_K( node )
c---------------------------------------------------------------
c Purpose: return the local node number of this processor
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 3
      call MP_GETI( node, icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPNODE0_K
c
c
      subroutine MPNODE0_K( node0 )
c---------------------------------------------------------------
c Purpose: return the k-local root node rank "node0"
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 3
      call MP_GET0( node0, icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPCOMM_K
c
c
      subroutine MPCOMM_K( icomm )
c---------------------------------------------------------------
c Purpose: return the k-local communicator/context
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 3
      call MP_GETC( icomm,icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPNODES_G
c
c
      subroutine MPNODES_G( nprocs )
c---------------------------------------------------------------
c Purpose: return the global number of processors/nodes
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 1
      call MP_GETN( nprocs, icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPNODE_G
c
c
      subroutine MPNODE_G( node )
c---------------------------------------------------------------
c Purpose: return the global node number of this processor
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 1
      call MP_GETI( node, icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPNODE0_G
c
c
      subroutine MPNODE0_G( node0 )
c---------------------------------------------------------------
c Purpose: return the global root node "node0"
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 1
      call MP_GET0( node0, icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPCOMM_G
c
c
      subroutine MPCOMM_G( icomm )
c---------------------------------------------------------------
c Purpose: return the global communicator/context
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      icommlvl = 1
      call MP_GETC( icomm, icommlvl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MP_SUBS
c
c
c#######################################################################
c     Internal routines that manipulate MPSTUFF module data
c---------------------------------------------------------------
c Purpose: internal primitive routines to manipulate MPSTUFF data
c
c Written: Peter A. Schultz, 7-December-2001, for v2.51
c
c Revision history:
c  19Nov08-PAS/2.62: unify MPSTUFF data, expand
c   6Jul06-APT/2.60: merged task parallel and image parallel
c#######################################################################
c
      subroutine MP_SUBS( icommlvl )
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MP_SUBS
c Clear to a non-parallel default
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /MPSTUFF/ nodetot(4),nodeid(4),node0id(4),icommid(4)
c
      nodetot(icommlvl) = 1
      nodeid(icommlvl)  = 0
      node0id(icommlvl) = 0
      icommid(icommlvl) = 0
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MP_SETN
c Set the number of nodes
      entry MP_SETN( nprocs, icommlvl )
      nodetot(icommlvl) = nprocs
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MP_SETI
c Set id of current node
      entry MP_SETI( node, icommlvl )
      nodeid(icommlvl) = node
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MP_SET0
c Set node0
      entry MP_SET0( node0, icommlvl )
      node0id(icommlvl) = node0
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MP_SETC
c Set communicator/context
      entry MP_SETC( icomm, icommlvl )
      icommid(icommlvl) = icomm
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MP_GETN
c Get the number of nodes
      entry MP_GETN( nprocs, icommlvl )
      nprocs = nodetot(icommlvl)
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MP_GETI
c Get id of current node
      entry MP_GETI( node, icommlvl )
      node = nodeid(icommlvl)
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MP_GET0
c Get node0
      entry MP_GET0( node0, icommlvl )
      node0 = node0id(icommlvl)
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MP_GETC
c Get communicator/context
      entry MP_GETC( icomm, icommlvl )
      icomm = icommid(icommlvl)
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> STRNUM
c
c
      subroutine STRNUM( nstr, str, num, maxnum )
c---------------------------------------------------------------
c Purpose: put integer into string of appropriate length
c
c Written: Peter A. Schultz, 11-July-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Integer "num" to be written must be greater than or equal to zero.
c Integer "num" is written to character string of minimum length
c     needed to write largest possible input integer "maxnum"
c     with leading zeroes as needed.
c If error (num<0.or.maxnum<num), return null, i.e. 0-len, string
c If num=maxnum=0, return null string
c
c E.g. STRNUM( nstr, str, 13, 1000 ) returns str='0013' (nstr=4)
c      STRNUM( nstr, str,  0,   13 ) returns str='00'   (nstr=2)
c      STRNUM( nstr, str,  0,    0 ) returns nstr=0 (zero-len str)
c      STRNUM( nstr, str,113,  113 ) returns str='113'  (nstr=3)
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Output: character string with number
      CHARACTER*(*)  str
c
c Local declarations
      CHARACTER*(1)  chzero
      DATA           chzero / '0' /
c
c >>>> EXECUTABLE CODE:
c
      nstr = 0
c
c Check that number is within its allowed bounds:
      if( num.lt.0 .or. num.gt.maxnum .or. maxnum.eq.0 ) RETURN
c
c Determine length of full string:
      istr = 0
      mx = 1
   10 if( mx.gt.maxnum ) goto 19
      istr = istr + 1
      str(istr:istr) = chzero
      mx = mx*10
      goto 10
   19 nstr = istr
c
c Write in characters for this number:
      n0 = num
      istr = nstr
   20 nx = n0 / 10
      id = n0 - 10*nx
      write( str(istr:istr), '(i1)' ) id
      n0 = nx
      istr = istr - 1
      if( n0.gt.0 ) goto 20
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ICOPYOFF
c
c
      subroutine ICOPYOFF( n, i1vec,n1off, i2vec,n2off )
c---------------------------------------------------------------
c Purpose: copy integer vector, with offsets
c
c Written: Peter A. Schultz, 20-February-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  i1vec(*), i2vec(*)
c
c >>>> EXECUTABLE CODE:
c
      do  i=1,n
        i2vec(n2off+i) = i1vec(n1off+i)
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BIGIO
c
c
c===============================================================
c Purpose: these routines manage big i/o to files
c
c Written: Peter A. Schultz, 22-July-2003, for 2.56
c          (expanded from original big i/o routines)
c
c Revision history:
c  26Mar20-PAS/2.68e add READB1 to read partial vector (ivecfl)
c   9Apr15-PAS/2.66: install MPBC routine (master-only i/o + bcasts)
c===============================================================
c
c Notes:
c  These routines prompted by problem encountered on some dec
c  alphas where the OS limited the length of the a single record
c  in a read (but, apparently, not in a write - go figure).
c
c External dependencies:
c  none
c
c Public routines:
c  (administrative)
c    BIGIOINIT( maxreclen ) - Initializes module
c    IOSETRECL( maxreclen ) - Sets max record length
c    IOGETRECL( maxreclen ) - Gets max record length
c  (functional)
c    WRITBIG( ifile, lenvec, vec ) - write vector to unit
c    READBIG( ifile, lenvec, vec ) - read vector from unit
c    READB1 ( ifile, lendim, lenvec, vec ) - read part of vector from unit
c    BACKBIG( ifile, lenvec )      - backspace over vector on unit
c    READSKP( ifile, lenvec )      - skip over vector on unit
c  (master-parallel - i.e. master reads and broadcasts)
c    MPBCREWIND( ifile )               - rewind unit
c    MPBCREADBIG( ifile, lenvec, vec ) - read vector from unit
c    MPBCREADSKP( ifile, lenvec, vec ) - skip over vector on unit
c
c Variables:
c  ifile  - file unit number being written to (read from)
c  vec()  - the vector to be written (read)
c  lenvec - length of the vector
c  maxreclen = >0 maximum length of a single write/read record (r8)
c            =  0 uses default for max length of record
c            = <0 unlimited record length
c
c===============================================================
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BIGIOINIT
c
c
      subroutine BIGIOINIT( maxrecl )
c---------------------------------------------------------------
c Purpose: initialize big i/o stuff
c
c Written: Peter A. Schultz, 22-July-2003
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      maxlen = maxrecl
      call IOSETRECL( maxlen )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> IOSETRECL
c
c
      subroutine IOSETRECL( maxrecl )
c---------------------------------------------------------------
c Purpose: Set/get max record length
c
c Written: Peter A. Schultz, 22-July-2003
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /BIGIO/ maxreclen
c
      maxreclen = maxrecl
c
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> IOGETRECL
c
      entry IOGETRECL( maxrecl )
c
      maxrecl = maxreclen
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WRITBIG
c
c
      subroutine WRITBIG( ifile, lenvec, vec )
c---------------------------------------------------------------
c Purpose: write/read big line within max size records
c          ***** MACHINE DEPENDENT *****
c
c Written: Peter A. Schultz, 15-February-1999, for v2.31
c
c Revision history:
c  22Jul03-PAS/2.56: modularized, and removed from 'utl'
c  21Jun01-PAS/2.47a: moved to utl, enddo
c---------------------------------------------------------------
c
c Variables:
c  ifile  - file unit number being written to (read from)
c  vec()  - the vector to be written (read)
c  lenvec - length of the vector
c  maxlen - maximum length of a single write/read record
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  (maxrecdef= 1 000 000)
c
      COMMON  /BIGIO/ maxreclen
c
      DIMENSION  vec(lenvec)
c
c >>>> EXECUTABLE CODE:
c
      maxlen = maxreclen
      if( maxlen.eq.0 )then
c       If undefined, use internal default
        maxlen = maxrecdef
      elseif( maxlen.lt.0 )then
c       If turned OFF (maxlen<0), write full vectors
        maxlen = lenvec
      endif
c
      nvrec = lenvec/maxlen
      if( nvrec.eq.0 )then
c       The vector will fit in a single record:
        write(ifile)  vec
      else
c       The vector needs to be broken up:
        iv0 = 0
        do  ivrec=1,nvrec
          write(ifile)  (vec(iv),iv=iv0+1,iv0+maxlen)
          iv0 = iv0 + maxlen
        enddo
        if( iv0.lt.lenvec )  write(ifile) (vec(iv),iv=iv0+1,lenvec)
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> READBIG
c
c
      entry READBIG( ifile, lenvec, vec )
c
      maxlen = maxreclen
      if( maxlen.eq.0 )then
        maxlen = maxrecdef
      elseif( maxlen.lt.0 )then
        maxlen = lenvec
      endif
c
      nvrec = lenvec/maxlen
      if( nvrec.eq.0 )then
c       The vector will fit in a single record:
        read(ifile)  vec
      else
c       The vector needs to be broken up:
        iv0 = 0
        do  ivrec=1,nvrec
          read(ifile)  (vec(iv),iv=iv0+1,iv0+maxlen)
          iv0 = iv0 + maxlen
        enddo
        if( iv0.lt.lenvec ) read(ifile)  (vec(iv),iv=iv0+1,lenvec)
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> READB1
c
c
      entry READB1 ( ifile, lendim,lenvec, vec )
c
      maxlen = maxreclen
      if( maxlen.eq.0 )then
        maxlen = maxrecdef
      elseif( maxlen.lt.0 )then
        maxlen = lenvec
      endif
c
      nvrec = lenvec / maxlen
      ndrec = lendim / maxlen
      if( ndrec*maxlen .lt. lendim ) ndrec = ndrec + 1
c
      if( nvrec.eq.0 )then
c       The vector will fit in a single record:
        ndrec = ndrec - 1
        read(ifile)  vec
      else
c       The vector needs to be broken up:
        iv0 = 0
        do  ivrec=1,nvrec
          ndrec = ndrec - 1
          read(ifile)  (vec(iv),iv=iv0+1,iv0+maxlen)
          iv0 = iv0 + maxlen
        enddo
        if( iv0.lt.lenvec )then
          ndrec = ndrec - 1
          read(ifile)  (vec(iv),iv=iv0+1,lenvec)
        endif
      endif
c
      if( ndrec.gt.0 )then
c       Skip through (unread) rest of the whole vector
        do  idrec=1,ndrec
          read(ifile)
        enddo
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BACKBIG
c
c
      entry BACKBIG( ifile, lenvec )
c
      maxlen = maxreclen
      if( maxlen.eq.0 )then
        maxlen = maxrecdef
      elseif( maxlen.lt.0 )then
        maxlen = lenvec
      endif
c
      nvrec = lenvec/maxlen
      if( nvrec.eq.0 )then
c       The vector will fit in a single record:
        BACKSPACE( ifile )
      else
c       The vector needs to be broken up:
        iv0 = 0
        do  ivrec=1,nvrec
          BACKSPACE( ifile )
          iv0 = iv0 + maxlen
        enddo
        if( iv0.lt.lenvec ) BACKSPACE( ifile )
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> READSKP
c
c
      entry READSKP( ifile, lenvec )
c
      maxlen = maxreclen
      if( maxlen.eq.0 )then
        maxlen = maxrecdef
      elseif( maxlen.lt.0 )then
        maxlen = lenvec
      endif
c
      nvrec = lenvec/maxlen
      if( nvrec.eq.0 )then
c       The vector will fit in a single record:
        read(ifile)
      else
c       The vector needs to be broken up:
        iv0 = 0
        do  ivrec=1,nvrec
          read(ifile)
          iv0 = iv0 + maxlen
        enddo
        if( iv0.lt.lenvec ) read(ifile)
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPBCREWIND
c
c
      subroutine MPBCREWIND( ifile )
c---------------------------------------------------------------
c Purpose: master rewind file
c
c Written: Peter A. Schultz, 28-January-2008, for 2.61
c
c Revision history:
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nprocs )
      call MPNODE0( master )
      call MPNODE( iproc )
      call MPCOMM( icomm )
c
      if( iproc .eq. master )then
        REWIND( ifile )
      endif
c
      RETURN
      END
c
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPBCREADBIG
c
c
      subroutine MPBCREADBIG( ifile, nvec, vec )
c---------------------------------------------------------------
c Purpose: master read vector and broadcast to all
c
c Written: Peter A. Schultz, 27-July-2007, for 2.60
c
c Revision history:
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  vec(*)
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nprocs )
      call MPNODE0( master )
      call MPNODE( iproc )
      call MPCOMM( icomm )
c
      if( iproc .eq. master )then
        call READBIG( ifile, nvec, vec )
      endif
c
      if( nprocs .gt. 1 )then
        lenmsg = nvec
        call MPBCAST8( master, lenmsg, vec, icomm )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MPBCREADSKP
c
c
      subroutine MPBCREADSKP( ifile, nvec, vec )
c---------------------------------------------------------------
c Purpose: master read vector and broadcast to all
c
c Written: Peter A. Schultz, 27-July-2007, for 2.60
c
c Revision history:
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  vec(*)
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nprocs )
      call MPNODE0( master )
      call MPNODE( iproc )
      call MPCOMM( icomm )
c
      if( iproc .eq. master )then
        call READSKP( ifile, nvec )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> AINIT
c
c
      subroutine AINIT( a )
c---------------------------------------------------------------
c Purpose: initialize a-matrix for non-local matrix element
c
c Revision history:
c   7Mar02-PAS/2.52: ang constants extracted
c  18Nov99-PAS/2.42: cosmetic cleanup
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  a(9,9)
c
c local declarations:
      DIMENSION  vnorm(5)
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Get angular normalizations:
      call VNORMS( vnorm )
c
      do  j=1,9
        do  i=1,9
          a(i,j) = zero
        enddo
      enddo
c
      a(1,1) =  vnorm(1)
      a(2,2) = -vnorm(2)
      a(3,3) = -vnorm(2)
      a(4,4) =  vnorm(2)
      a(5,5) =  vnorm(3)
      a(6,6) = -vnorm(3)
      a(7,7) = -vnorm(3)
      a(8,8) =  vnorm(4)
      a(9,9) =  vnorm(5)
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> AINITF
c
c
      subroutine AINITF( a,grada )
c---------------------------------------------------------------
c Purpose: initialize a() for non-local force matrix element
c
c Revision history:
c   7Mar02-PAS/2.52: ang constants extracted
c  18Nov99-PAS/2.42: cosmetic cleanup
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  a(9,9),grada(3,9,9)
c
c local declarations:
      DIMENSION  vnorm(5)
      DATA  zero,two,four / 0.d0,2.d0,4.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Get angular normalizations:
      call VNORMS( vnorm )
c
      do  j=1,9
        do  i=1,9
          a(i,j) = zero
          grada(1,i,j) = zero
          grada(2,i,j) = zero
          grada(3,i,j) = zero
        enddo
      enddo
c
      a(1,1) =  vnorm(1)
      a(2,2) = -vnorm(2)
      a(3,3) = -vnorm(2)
      a(4,4) =  vnorm(2)
      a(5,5) =  vnorm(3)
      a(6,6) = -vnorm(3)
      a(7,7) = -vnorm(3)
      a(8,8) =  vnorm(4)
      a(9,9) =  vnorm(5)
c
      grada(1,1,2) = -vnorm(1)
      grada(2,1,3) = -vnorm(1)
      grada(3,1,4) = -vnorm(1)
      grada(2,2,5) =  vnorm(2)
      grada(1,3,5) =  vnorm(2)
      grada(3,3,6) =  vnorm(2)
      grada(2,4,6) = -vnorm(2)
      grada(3,2,7) =  vnorm(2)
      grada(1,4,7) = -vnorm(2)
      grada(1,2,8) =  two*vnorm(2)
      grada(2,3,8) = -two*vnorm(2)
      grada(1,2,9) = -two*vnorm(2)
      grada(2,3,9) = -two*vnorm(2)
      grada(3,4,9) = -four*vnorm(2)
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> AOFR
c
c
      subroutine AOFR( a, r )
c---------------------------------------------------------------
c Purpose: calculate r-dependent part of coefficient matrix
c          for evaluation of non-local matrix elements
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c assume a() initialized elsewhere to include all r-dependence
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  r(3), a(9,9)
c local declarations:
      DATA  rt4pi   / 3.544907701811d0 /
      DATA  rt4pid3 / 2.046653415893d0 /
      DATA  two,four / 2.d0,4.d0 /
c
      x = r(1)
      y = r(2)
      z = r(3)
c
      a(1,2) = -x * rt4pi
      a(1,3) = -y * rt4pi
      a(1,4) = -z * rt4pi
      a(1,5) = x*y * rt4pi
      a(1,6) = y*z * rt4pi
      a(1,7) = z*x * rt4pi
      a(1,8) = (x**2 - y**2) * rt4pi
      a(1,9) = (two*z**2 - x**2 - y**2) * rt4pi
c
      a(2,5) =  y * rt4pid3
      a(3,5) =  x * rt4pid3
      a(3,6) =  z * rt4pid3
      a(4,6) = -y * rt4pid3
      a(2,7) =  z * rt4pid3
      a(4,7) = -x * rt4pid3
      a(2,8) =  two*x * rt4pid3
      a(3,8) = -two*y * rt4pid3
      a(2,9) = -two*x * rt4pid3
      a(3,9) = -two*y * rt4pid3
      a(4,9) = -four*z * rt4pid3
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> AOFRF
c
c
      subroutine AOFRF( a,grada, r )
c---------------------------------------------------------------
c Purpose: calculate r-dependent part of coefficient matrix
c          for evaluation of non-local force matrix elements
c
c Revision history:
c   7Mar02-PAS/2.52: explicitly promote constants to dp
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c assume a() initialized elsewhere to include all r-dependence
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  r(3), a(9,9),grada(3,9,9)
c
      DATA  rt4pi   / 3.544907701811d0 /
      DATA  rt4pid3 / 2.046653415893d0 /
      DATA  two,four / 2.d0,4.d0 /
c
c >>>> EXECUTABLE CODE:
c
      x = r(1)
      y = r(2)
      z = r(3)
c
      a(1,2) = -x * rt4pi
      a(1,3) = -y * rt4pi
      a(1,4) = -z * rt4pi
      a(1,5) = x*y * rt4pi
      a(1,6) = y*z * rt4pi
      a(1,7) = z*x * rt4pi
      a(1,8) = (x**2-y**2) * rt4pi
      a(1,9) = (two*z**2-x**2-y**2) * rt4pi
c
      a(2,5) =  y * rt4pid3
      a(3,5) =  x * rt4pid3
      a(3,6) =  z * rt4pid3
      a(4,6) = -y * rt4pid3
      a(2,7) =  z * rt4pid3
      a(4,7) = -x * rt4pid3
      a(2,8) =  two*x * rt4pid3
      a(3,8) = -two*y * rt4pid3
      a(2,9) = -two*x * rt4pid3
      a(3,9) = -two*y * rt4pid3
      a(4,9) = -four*z * rt4pid3
c
      grada(1,1,5) =  y * rt4pi
      grada(2,1,5) =  x * rt4pi
      grada(2,1,6) =  z * rt4pi
      grada(3,1,6) =  y * rt4pi
      grada(1,1,7) =  z * rt4pi
      grada(3,1,7) =  x * rt4pi
      grada(1,1,8) =  two*x * rt4pi
      grada(2,1,8) = -two*y * rt4pi
      grada(1,1,9) = -two*x * rt4pi
      grada(2,1,9) = -two*y * rt4pi
      grada(3,1,9) =  four*z * rt4pi
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ASSGNPUT
c
c
      subroutine ASSGNPUT( node, node_img, neb_master, image,imgstep,
     $ ndata, data_img, ntmp, tmp, icomm )
c---------------------------------------------------------------
c Purpose: Send out assignment of image data to work on
c
c Written: Peter A. Schultz, 21-January-2002, for v2.54
c
c Revision history:
c   6Jul06-APT/    : merged task parallel and image parallel
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input/Output (data for image)
      DIMENSION  data_img(*)
c Scratch space (buffer space for send/receive)
      DIMENSION  tmp(*)
c Local:
      DATA       zero / 0.d0 /
c converting int to real, add a little so back-conversion is clean:
      DATA       xtra / 0.1d0 /
c
c >>>> EXECUTABLE CODE:
c
      if( image.gt.0 )then
c       Pack up the image id, step, number, and data that goes along
c
        rimage = DBLE( image ) + xtra
        tmp(1) = rimage
        rstep  = DBLE( imgstep ) + xtra
        tmp(2) = rstep
        i_data = 3
        call DCOPY( ndata, data_img,1, tmp(i_data),1 )
        lenmsg = 2 + ndata
c
      else
c       No image is assigned, construct null assignment
c
        rimage = xtra
        tmp(1) = rimage
        lenmsg = 1
c
      endif
c
      call MPSENDR8( node_img, lenmsg, tmp, icomm )
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ASSGNGET
c
c
      entry      ASSGNGET( node, node_img, neb_master, image,imgstep,
     $ ndata, data_img, ntmp, tmp, icomm )
c---------------------------------------------------------------
c Purpose: Get assignment of data to work on
c
c Written: Peter A. Schultz, 21-January-2002, for v2.54
c
c Revision history:
c   6Jul06-APT/    : merged task parallel and image parallel
c---------------------------------------------------------------
c
      lenmsg = ndata + 2
c
      call MPRECVR8( neb_master, lenmsg, tmp, icomm )
c
      rimage = tmp(1)
      image = rimage
c
      if( image.gt.0 )then
c       Unpack data received for assigned image
c
        if( ndata.ne. (lenmsg-2) ) call STOPXERR( 'ASSGNGET: lenmsg' )
        imgstep = tmp(2)
        i_data = 3
        call DCOPY( ndata, tmp(i_data),1, data_img,1 )
c
      else
c       Null assignment ... this node is done - stop
c
        if( node.ne.neb_master ) call STOPX
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ATDEFCT
c
c
      subroutine ATDEFCT( IWR, idmatfl,
     $ ncplx, znuc,rhoatom,defatom,
     $ norb,nk, natm,ntyp, noad, itypa, norba,
     $ near2c, s1atom, orbint,orbofk, wksm,
     $ dmat,    dmatloc )
c      R8(mat)  R8(nkloc*mat)
c---------------------------------------------------------------
c Purpose: compute nearby-construction local atom charge defects
c
c Written: Peter A. Schultz, June-1993, for v2.10
c
c Revision history:
c  24Jan09-PAS/2.63: k-parallel
c  20Jun07-PAS/2.60: merge serial and tp
c   6Jul06-APT/    : merged task parallel and image parallel
c  30Jul05-PAS/2.59: master-only matrix files
c  23Jul01-PAS/2.49: compact dmat; spin-polarized dft
c   3May99-PAS/2.35: use flag to set use of two-center terms
c  15Feb99-PAS/2.31: routine to intercept perhaps too-big i/o
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Apr97-PAS/2.17: naming conventions
c---------------------------------------------------------------
c
c Notes:
c  TP: the only tp effect in here is a master-only I/O
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 ,one = 1.d0, two = 2.d0 )
c
c Input arrays:
      DIMENSION  znuc(ntyp), rhoatom(natm), defatom(natm,*)
      DIMENSION  itypa(natm), norba(ntyp)
      DIMENSION  s1atom(noad,noad,nk,natm)
      DIMENSION  orbint(2,norb,nk),orbofk(2,natm,norb,nk)
c Scratch array:
      DIMENSION  wksm(natm,*)
      DIMENSION  dmat(norb,norb)
      DIMENSION  dmatloc(norb,norb,*)
c
c Local declarations:
      DATA  lstout / 1 /
c
c >>>> EXECUTABLE CODE:
c
      matsiz = norb*norb
c  Get Local MP info
      call MPNODES( nprocl )
      call MPNODE( iprocl )
      call MPNODE0( masterl )
      call MPCOMM( icomml )
c
      call MPNODES_K( nprocs )
      call MPNODE_K( iproc )
      call MPNODE0_K( master )
      call MPCOMM_K( icomm )
c
c  Set up k-parallel
      call KPMINE( nk,nkloc,nk0 )
      if( nkloc .eq. 0 ) goto 1001
c
c  Obtain and distribute dmat
      call KPDMATRD( idmatfl, norb, ncplx, nk,nk0,nkloc,
     $ dmat,         dmatloc )
c      r8(norb^2)-s  r8(norb^2*nkloc)-o
c
      do 1000 ikloc=1,nkloc
        k = nk0 + ikloc
c
c       Only k-master does this calculation
        call KPMASTER( nk, nprocl, k, kmasterpr )
        if( iprocl .ne. kmasterpr ) goto 1000
c
c       Load in density matrix for this k-vector
        if( nk.gt.1 )then
          call DCOPY( matsiz, dmatloc(1,1,ikloc),1, dmat,1 )
c         Otherwise, matrix already in dmat
        endif
c
        i = 0
        do 200 iatm=1,natm
c
          do 190 iorbat=1,norba(itypa(iatm))
            i = i + 1
c
            j = 0
            do 100 jatm=1,iatm
              norbatj = norba(itypa(jatm))
              if( jatm.eq.iatm ) norbatj = iorbat
c
              do 90 jorbat=1,norbatj
                j = j + 1
c
                if( iatm.eq.jatm )then
c
                  si1r = s1atom(iorbat,jorbat,k,iatm)
                  if( iorbat.ne.jorbat )then
                    si1i = s1atom(jorbat,iorbat,k,iatm)
                    defatom(iatm,1) = defatom(iatm,1)
     $               + two*( si1r*dmat(i,j) + si1i*dmat(j,i) )
                  else
                    defatom(iatm,1) = defatom(iatm,1) + dmat(i,i)*si1r
                  endif
c
                elseif( near2c.eq.2 )then
c
C                  si2r = REAL(orbint(i,k)*CONJG(orbofk(iatm,j,k)))
C                  si2i = IMAG(orbint(i,k)*CONJG(orbofk(iatm,j,k)))
C                  sj2r = REAL(orbofk(jatm,i,k)*CONJG(orbint(j,k)))
C                  sj2i = IMAG(orbofk(jatm,i,k)*CONJG(orbint(j,k)))
                  si2r = orbint(1,i,k)*orbofk(1,iatm,j,k)
     $                 + orbint(2,i,k)*orbofk(2,iatm,j,k)
                  si2i = orbint(2,i,k)*orbofk(1,iatm,j,k)
     $                 - orbint(1,i,k)*orbofk(2,iatm,j,k)
                  sj2r = orbofk(1,jatm,i,k)*orbint(1,j,k)
     $                 + orbofk(2,jatm,i,k)*orbint(2,j,k)
                  sj2i = orbofk(2,jatm,i,k)*orbint(1,j,k)
     $                 - orbofk(1,jatm,i,k)*orbint(2,j,k)
                  defatom(iatm,2) = defatom(iatm,2)
     $             + two*( si2r*dmat(i,j) + si2i*dmat(j,i) )
                  defatom(jatm,2) = defatom(jatm,2)
     $             + two*( sj2r*dmat(i,j) + sj2i*dmat(j,i) )
c
                endif
c
   90         continue
c
  100       continue
c
  190     continue
c
  200   continue
c
 1000 continue
c     Bypass for nkloc=0:
 1001 continue
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     Done with calculation, accumulate final result ...
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      ndefatm = 2*natm
c
      call KPFLAG_GET( kparopt )
      if( kparopt .eq. 2 )then
c
c       k-parallel, merge results from k-masters to image master
c
        if( iprocl .eq. masterl )then
c         Image master, collect results from k-masters
c         Results on k-masters are summed over their local nkloc.
c         We need strictly one copy of defatom from each k-master.
          do  ik=1,nk
            call KPMASTER( nk,nprocl, ik,kmasterpr )
            if( kmasterpr .ne. masterl )then
              call MPSENDTICKET( kmasterpr, icomml )
              lenmsg = 1
              call MPRECVI( kmasterpr, lenmsg, inewdef, icomml )
c             For inewdef==1 - first time, get the defatom for this set
              if( inewdef .eq. 1 )then
                lenmsg = ndefatm
                call MPRECVR8( kmasterpr, lenmsg, wksm, icomml )
                call DAXPY( ndefatm, one, wksm,1, defatom,1 )
              endif
            endif
          enddo
        elseif( iproc .eq. master .and. nkloc .gt. 0 )then
c         Master of this k-point, send defatom to image/local master
c         We will use inewdef to track if this k-master been reaped already
c         This should likely be done via ik/nkloc arithmetic, but this works.
          inewdef = 1
          do  ikloc=1,nkloc
            call MPRECVTICKET( masterl, icomml )
            lenmsg = 1
            call MPSENDI( masterl, lenmsg, inewdef, icomml)
            if( inewdef .eq. 1 )then
              lenmsg = ndefatm
              call MPSENDR8( masterl, lenmsg, defatom, icomml )
              call MKZERO( ndefatm, defatom )
c             Record that this master has done his duty
              inewdef = 0
            endif
          enddo
        endif
      endif
c
      if( nprocl .gt. 1 )then
c       Send the full combined result out to everyone
        lenmsg = ndefatm
        call MPBCAST8( masterl, lenmsg, defatom, icomml )
      endif
c     
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c           Document the result in output
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if( lstout.gt.0 )then
        write(IWR,*)
        if( lstout.gt.1 )then
          write(IWR,*)'ATDEFCT: nearby-construction atom charge defects'
          write(IWR,900)
        endif
  900   format(2x,'atom',9x,'z-rho',9x,'total',9x,'1-ctr',9x,'2-ctr')
  901   format(2x,i3,3x   ,4f14.8)
        defatm = zero
        def1atm = zero
        do 300 iatm=1,natm
          defgr = znuc(itypa(iatm)) - rhoatom(iatm)
          defnr = defatom(iatm,1) + defatom(iatm,2)
          def1atm = def1atm + defatom(iatm,1)
          defatm = defatm + defnr
          if( lstout.gt.1 )
     $    write(IWR,901)iatm,defgr,defnr,defatom(iatm,1),defatom(iatm,2)
  300   continue
        if( near2c.lt.2 )then
          write(IWR,'(1x,a,2f18.8)')
     $     'one-center local charge defect = ',def1atm
        else
          write(IWR,'(1x,a,2f18.8)')
     $     '1ctr/total local charge defect = ',def1atm,defatm
        endif
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ATMDAT1
c
c
      subroutine ATMDAT1( IWR, IPOT,IBAS,
     $ ityp, ntyp,nshld,nald, noad,
     $ numshl,lshel,nala,ala,cala, occsh,  norba, znuc,
     $ atmass,atengy,
     $ lmx1ctr,almnv1c,lmxnlp1,almnnl,
     $ nrd,nrad,nrps,radmsh,radwt,vpsrad, nrcor,corden,cordrv,
     $ itypxc,nfityp,alxcmin,nalfxc,nrxcfit,nalfxcd,alfxc,alsq,ipvt,
     $ wkrd )
c---------------------------------------------------------------
c Purpose: read atom file (potential and basis)
c
c Written: Peter A. Schultz,  9-May-2000, for v2.45
c          Extracted from "indata"
c
c Revision history:
c   9Apr15-PAS/2.66: lnwrit lines
c  21Jun07-PAS/2.60: removed dsifa call to clean dependencies
c  25Jun02-PAS/2.53e: FLOPEN bugfix on dormant path
c   5Mar02-PAS/2.51d: fix bug with null rfitmax/nrxc
c   6Dec01-PAS/2.51: file mgmt
c   2Oct01-PAS/2.50: input atom masses and reference energies
c  21Jun01-PAS/2.48: replace STOPs
c   5May01-PAS/2.47: clean echo; purge old format
c  28Dec00-PAS/2.46: gga code; add notes
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c basis information ...
c  ... number of shells on atom type, L(shell)
      DIMENSION  numshl(ntyp),lshel(nshld,ntyp),
c  ... gaussians/shell, gaussian exponents, contraction coefficients
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
c  ... shell occupancies for reference atom
      DIMENSION  occsh(nshld,ntyp)
c  ... total number of basis on a given atom type
      DIMENSION  norba(ntyp)
c potential information ...
c  ... effective nuclear charge
      DIMENSION  znuc(ntyp)
c  ... atomic masses (for md), and atomic reference energies
      DIMENSION  atmass(ntyp), atengy(ntyp)
c  ... Lmax+1 of pseudopotential, effective range of pot as gaussian exp.
      DIMENSION  lmxnlp1(ntyp),almnnl(ntyp)
c  ... number of points in radial mesh, number used in pseudopotential
      DIMENSION  nrad(ntyp),nrps(ntyp)
c  ... radial mesh, mesh weights, and pseudopotential on mesh (by L)
      DIMENSION  radmsh(nrd,ntyp),radwt(nrd,ntyp),vpsrad(nrd,4,ntyp)
c  ... number of radial pts. for core density, core density, and deriv.
      DIMENSION  nrcor(ntyp), corden(nrd,ntyp),cordrv(nrd,ntyp)
c dynamic 1-center params (non-standard) ...
c  ... Lmax for dynamic fast local density, effective gaussian range
      DIMENSION  lmx1ctr(ntyp),almnv1c(ntyp)
c xc-fit variables (NOT production code - development only)
      DIMENSION  nfityp(ntyp),alxcmin(ntyp)
      DIMENSION  nalfxc(ntyp),nrxcfit(ntyp),alfxc(nalfxcd,ntyp),
     $ alsq(nalfxcd,nalfxcd,3,ntyp),ipvt(nalfxcd,3,ntyp)
c scratch array:
      DIMENSION  wkrd(noad)
c
c local declarations:
      PARAMETER  ( nline = 128 )
      CHARACTER    label*(nline)
      CHARACTER*6  wantlbl,readlbl
      EQUIVALENCE  (label,readlbl)
      CHARACTER*1  ndist
c
      DATA  zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Set up some defaults ...
c  ... no pseudopotential
      lmxp1 = -1
      almnps = one
c  ... no core density
      nrcor(ityp) = 0
c  ... no dynamic 1-center terms
      lmx1c = -1
      almn1c = 9.d9
c  ... no dynamic 1-center xc terms
      nalfxi = 0
      almnxc = 9.d9
      nfityp(ityp) = 0
c
C      wantlbl = 'type n'
C      read(IPOT,8000)  label
C      call LNWRIT( IWR, label, nline )
C  100 continue
C      if( readlbl.ne.wantlbl ) goto 1300
C      read(IPOT,8040)  jtyp, (label(il), il=1,4)
C      write(IWR,9040)  ityp, (label(il), il=1,4)
C      if( jtyp.ne.ityp .and. IPOT.eq.IDAT )then
C        write(IWR,*) '***** ERROR: atom type out of sequence',jtyp
C        call STOPXERR( 'typ ordr/atom type out of sequence' )
C      endif
c
c >>>>>> START READING FILE
c
      read(IPOT,8000)  label
c
c >>>>>> NOTES
c (optional)
      if( readlbl(1:5).eq.'notes' )then
        call LNWRIT( IWR, label, nline )
        read( readlbl(6:6), '(i1)' )  ntitl
        if( ntitl.eq.0 ) ntitl = 1
        write(IWR,*) 'notes for this atom file:'
        if( ntitl.gt.0 )then
          do  ititl=1,ntitl
            read(IPOT,8000)  label
            call LNWRIT( IWR, label, nline )
          enddo
        endif
c
        read(IPOT,8000)  label
c
      endif
c
c >>>>>> ATOMIC MASS
c (optional)
      wantlbl = 'mass  '
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
        read(IPOT,8030)  atmass(ityp)
        write(IWR,9030)  atmass(ityp)
c
        read(IPOT,8000)  label
      else
        atmass(ityp) = one
      endif
c
c >>>>>> ATOMIC REFERENCE ENERGY
c (optional)
      wantlbl = 'energy'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
        read(IPOT,8030)  atengy(ityp)
        write(IWR,9030)  atengy(ityp)
c
        read(IPOT,8000)  label
      else
        atengy(ityp) = zero
      endif
c
c >>>>>> EFFECTIVE NUCLEAR CHARGE
c
      wantlbl = 'effect'
      call LNWRIT( IWR, label, nline )
      if( readlbl.ne.wantlbl ) goto 1300
      read(IPOT,8030)  znuc(ityp)
      write(IWR,9030)  znuc(ityp)
c
c If no nuclear charge/potential, skip directly to basis:
      if( znuc(ityp).eq.zero ) goto 1000
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c             have a nuclear charge, hence read potential
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      read(IPOT,8000)  label
c
c >>>>>> PSEUDOPOTENTIALS: Lmax, and effective gaussian range
c (optional)
      wantlbl = 'pseudo'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
        read(IPOT,*   )  lmxp1, almnps
        write(IWR,9025)  lmxp1, almnps
c
        read(IPOT,8000)  label
      endif
c
c >>>>>> DYNAMIC 1-CENTER PARAMS: Lmax, and maximum gaussian
c (optional)
      wantlbl = '1-cent'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
        read(IPOT,*   )  lmx1c, almn1c
        write(IWR,9025)  lmx1c, almn1c
c
        read(IPOT,8000)  label
      else
c       Must have 1-ctr stuff ON to use xc-fit stuff
        goto 200
      endif
c
c >>>>>> XC-FIT PARAMS (development code only - non-functional):
c (optional)
      wantlbl = 'xc-fit'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
        read(IPOT,8130)  nalfxi, ndist, rfitmax, almnxc
        write(IWR,9130)  nalfxi, ndist, rfitmax, almnxc
        if( nalfxi.gt.nalfxcd )then
C         write(IWR,*) '***** NOTE: setting nalfxc to max=',nalfxcd
C         write(IWR,*) '>>>>> too many fit alphas:',nalfxi,'/',nalfxcd
C         write(IWR,*) '>>>>> this option currently inactive in code'
          nalfxi = nalfxcd
        endif
c
        read(IPOT,8000)  label
      endif
c
  200 continue
c
c >>>>>> FUNCTIONAL TYPE USED TO GENERATE POTENTIAL
c (optional for now)
      wantlbl = 'functi'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
        read(IPOT,8000)  readlbl
        write(IWR,*   )  readlbl, ' = dft fcnal used to generate pot'
c
        read(IPOT,8000)  label
      endif
c
c >>>>>> NUMBER OF RADIAL POINTS FOR CENTER/NON-LOCAL
c
      wantlbl = 'radial'
      call LNWRIT( IWR, label, nline )
      if( readlbl.ne.wantlbl ) goto 1300
      read(IPOT,*   )  nrl, nrnl
      write(IWR,9120)  nrl, nrnl
      if( 0.gt.nrl .or. nrnl.gt.nrl .or. nrl.gt.nrd )then
         write(IWR,*)
     $       '>>>>> Need nrnl=',nrnl,'.LE.nrl=',nrl,'.LE.nrd=',nrd
         call STOPXERR( 'nrlatom /Too many radial points for atom' )
      endif
      nrad(ityp) = nrl
      nrps(ityp) = nrnl
c
c >>>>>> RADIAL MESH POINT POSITIONS
c
      wantlbl = 'mesh p'
      read(IPOT,8000)  label
      call LNWRIT( IWR, label, nline )
      if( readlbl.ne.wantlbl ) goto 1300
      read(IPOT,8065)  (radmsh(nr,ityp), nr=1,nrl)
      write(IWR,9065)  (radmsh(nr,ityp), nr=1,nrl)
c
c >>>>>> RADIAL MESH POINT WEIGHTS
c
      wantlbl = 'weight'
      read(IPOT,8000)  label
      call LNWRIT( IWR, label, nline )
      if( readlbl.ne.wantlbl .and. readlbl.ne.'radwts' ) goto 1300
      read(IPOT,8065)  (radwt(nr,ityp), nr=1,nrl)
      write(IWR,9065)  (radwt(nr,ityp), nr=1,nrl)
      if( readlbl .eq. 'radwts' )then
        do  nr=1,nrl
          radwt(nr,ityp) = radwt(nr,ityp)*radmsh(nr,ityp)**2
        enddo
      endif
c
      locp = lmxp1 + 1
      if( locp.gt.0 )then
c
c >>>>>> READ NON-LOCAL POTENTIALS:
c
        do 230 lp=1,locp
c
          wantlbl = 'non-lo'
          read(IPOT,8000)  label
          call LNWRIT( IWR, label, nline )
          if( readlbl.ne.wantlbl ) goto 1300
          read(IPOT,8070)  lpot, (vpsrad(nr,lp,ityp), nr=1,MIN(6,nrl))
          if( nrl.gt.6 ) read(IPOT,8065)  (vpsrad(nr,lp,ityp), nr=7,nrl)
          write(IWR,9070)  lpot, (vpsrad(nr,lp,ityp), nr=1,nrl)
          if( lpot.ne.lp-1 ) call STOPXERR( 'lpotordr' )
  230   continue
c
c Highest non-local potential is local potential; process here.
c
        write(IWR,9240) ityp, lmxp1
 9240   format(/1x,'For atom type', i3, ', l=', i2,
     $   ' potential used as local nuclear potential' )
c
        if( locp.gt.1 )then
c         Extract local potential from non-local potentials:
          do 240 lp=1,locp-1
            do  nr=1,nrl
              vpsrad(nr,lp,ityp) = vpsrad(nr,lp,ityp)
     $                           - vpsrad(nr,locp,ityp)
            enddo
  240     continue
        endif
c
c  Remove weighting so can add locol pot directly to "vatrad()" in vlocpot
        rlogfac = LOG( radmsh(nrl,ityp) / radmsh(nrl-1,ityp) )
        do  nr=1,nrl
          vpsrad(nr,locp,ityp) = vpsrad(nr,locp,ityp) /
     $                        ( radmsh(nr,ityp)*rlogfac )
        enddo
      endif
c
c >>>>>> CORE DENSITY
c (optional)
      wantlbl = 'partia'
      read(IPOT,8000,err=1000,end=1000)  label
      if( readlbl.ne.wantlbl ) goto 1010
      call LNWRIT( IWR, label, nline )
      read(IPOT,8070)  lp, (corden(nr,ityp), nr=1,MIN(6,nrl))
      if( nrl.gt.6 ) read(IPOT,8065)  (corden(nr,ityp), nr=7,nrl)
      write(IWR,9070)  lp, (corden(nr,ityp), nr=1,nrl)
      if( lp.ne.-2 ) call STOPXERR( 'lpotord2' )
c
      if( nrl.gt.nrnl )then
        do  nr=nrnl+1,nrl
          corden(nr,ityp) = zero
          cordrv(nr,ityp) = zero
        enddo
      endif
      do 270 nr=nrnl,1,-1
        nrsc = nr
        if( corden(nr,ityp) .ne. zero ) goto 271
  270 continue
  271 nrcor(ityp) = nrsc
c
c >>>>>> CORE DENSITY DERIVATIVE
c (optional, and not used)
      wantlbl = 'deriva'
      read(IPOT,8000)  label
      if( readlbl.ne.wantlbl ) goto 1010
      call LNWRIT( IWR, label, nline )
      read(IPOT,8070)  lp, (cordrv(nr,ityp), nr=1,MIN(6,nrl))
      if( nrl.gt.6 ) read(IPOT,8065)  (cordrv(nr,ityp), nr=7,nrl)
      write(IWR,9070)  lp, (cordrv(nr,ityp), nr=1,nrl)
      if( lp.ne.-3 ) call STOPXERR( 'lpotord3' )
c
 1000 continue
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                        get basis data from file
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c >>>>>> READ BASIS FOR THIS ATOM, FIRST GET NUMBER OF SHELLS
c
      read(IBAS,8000)  label
c
 1010 wantlbl = 'number'
      call LNWRIT( IWR, label, nline )
      if( readlbl.ne.wantlbl ) goto 1300
      read(IBAS,8020)  nshl
      write(IWR,9020)  nshl
      if( nshl.gt.nshld )then
        write(IWR,*) '>>>>> input=',nshl,',   max=',nshld
        call STOPXERR( 'nshl2big/ too many shells for atom basis' )
      endif
      numshl(ityp) = nshl
c
      norbat = 0
      do 1070 ishl=1,nshl
c
c >>>>>> ANGULAR MOMENTUM, NUMBER OF GAUSSIANS FOR THIS SHELL
c
        wantlbl = 'angula'
        read(IBAS,8000)  label
        call LNWRIT( IWR, label, nline )
        if( readlbl.ne.wantlbl ) goto 1300
        read(IBAS,8020)  lshl, nal
        write(IWR,9020)  lshl, nal
        if( lshl.gt.2 .or. nal.gt.nald )then
          write(IWR,*) '>>>>> l,ng=',lshl,nal,',   max=',2,nald
          call STOPXERR( 'nala2big/atom basis out of dimensioning' )
        endif
        lshel(ishl,ityp) = lshl
        nala(ishl,ityp) = nal
        norbat = norbat + 2*lshl + 1
c
c >>>>>> ALPHAS OF GAUSSIANS FOR THIS SHELL
c
        wantlbl = 'alphas'
        read(IBAS,8000)  label
        call LNWRIT( IWR, label, nline )
        if( readlbl.ne.wantlbl ) goto 1300
        read(IBAS,8030)  (ala(ial,ishl,ityp), ial=1,nal)
        write(IWR,9030)  (ala(ial,ishl,ityp), ial=1,nal)
c
c >>>>>> COEFICIENTS FOR CONTRACTED GAUSSIAN SHELLS
c
        wantlbl = 'wave f'
        read(IBAS,8000)  label
        call LNWRIT( IWR, label, nline )
        if( readlbl.ne.wantlbl ) goto 1300
        read(IBAS,8030)  (cala(ial,ishl,ityp), ial=1,nal)
        write(IWR,9030)  (cala(ial,ishl,ityp), ial=1,nal)
c
c         Close loop over shells:
c
 1070 continue
c
      if( norbat.gt.noad )then
        write(IWR,*) '>>>>> typ=',ityp,', bf/atm=',norbat,',noad=',noad
        call STOPXERR( 'noad2big/too many orbitals per atom (noad)' )
      endif
      norba(ityp) = norbat
c
c >>>>>> OCCUPATION NUMBERS FOR REFERENCE ATOM OF THIS TYPE
c
      read(IBAS,8000)  label
      call LNWRIT( IWR, label, nline )
c
c EITHER: old by-orbital occupancies
      wantlbl = 'occupa'
      if( readlbl.eq.wantlbl )then
c       Read in occupancies by orbital
        read(IBAS,8065)  (wkrd(iorb), iorb=1,norbat)
        write(IWR,9065)  (wkrd(iorb), iorb=1,norbat)
c       Convert to shell occupancies:
        iorbat0 = 0
        do  ishl=1,nshl
          norbsh = 2*lshel(ishl,ityp) + 1
          occshl = zero
          do  iorbat=iorbat0+1,iorbat0+norbsh
            occshl = occshl + wkrd(iorbat)
          enddo
          occsh(ishl,ityp) = occshl
          iorbat0 = iorbat0 + norbsh
        enddo
        goto 1100
      endif
c
c OR: new by-shell occupancies
      wantlbl = 'shell '
      if( readlbl.ne.wantlbl ) goto 1300
c     Read in occupancies by shell
      read(IBAS,8065)  (occsh(ishl,ityp), ishl=1,nshl)
      write(IWR,9065)  (occsh(ishl,ityp), ishl=1,nshl)
c
c >>>>>> END OF ATOM DATA:
c
      read(IBAS,8000,end=1100,err=1100)  label
      call LNWRIT( IWR, label, nline )
c
      wantlbl = 'end at'
      if( readlbl.ne.wantlbl ) goto 1300
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                End input of atom data files
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
 1100 continue
c
      lmxnlp1(ityp) = lmxp1
      almnnl(ityp) = almnps
      if( almnnl(ityp).eq.zero )  almnnl(ityp) = one
c
      lmx1ctr(ityp) = lmx1c
      almnv1c(ityp) = almn1c
      if( almnv1c(ityp).eq.zero ) almnv1c(ityp) = 9.d9
c
      nalfxc(ityp) = nalfxi
      alxcmin(ityp) = almnxc
      if( alxcmin(ityp).eq.zero ) alxcmin(ityp) = 9.d9
c
      almina = ala(1,1,ityp)
      almaxa = ala(1,1,ityp)
      do  ishl=1,nshl
        lshl = lshel(ishl,ityp)
        nal = nala(ishl,ityp)
        call GNORM( lshl, nal, ala(1,ishl,ityp),cala(1,ishl,ityp) )
        do  ial=1,nal
          almina = MIN( almina, ala(ial,ishl,ityp) )
          almaxa = MAX( almaxa, ala(ial,ishl,ityp) )
        enddo
      enddo
      alamin = almina
      alamax = almaxa
c
c Determine whether this atom type will have a 1-center potential
      if( znuc(ityp).eq.zero .or. alamax.le.almnv1c(ityp) )
     $ lmx1ctr(ityp) = -1
c
cxcf:###############################################################
cxcf:start
cxcf: development code for testing schemes for fitting scf xc-pots
cxcf: rest of this code, until "cxcf:end", can be ignored.
cxcf:
        if( lmx1ctr(ityp).ge.0 .and. nalfxc(ityp).gt.0
     $   .and. alamax.gt.alxcmin(ityp) )then
          itypxc = itypxc + 1
          nfityp(ityp) = itypxc
          do 1210 nr=1,nrl
            nrxc = nr
            if( radmsh(nr,ityp).gt.rfitmax ) goto 1211
 1210     continue
 1211     nrxcfit(ityp) = nrxc
        else
          nrxcfit(ityp) = 0
        endif
c
c Determine alphas for xc-fit if this atom gives a 1-ctr potential
C        if( lmx1ctr(ityp).ge.0 .and. alamax.gt.alxcmin(ityp) )then
        if( nfityp(ityp).gt.0 )then
c         nalfxc(ityp) alphas geom. from alamin/3 to 2*alamax/3
          if( ndist.eq.'g' )then
            alfxc(1,ityp) = alamin/3.
            if( nalfxi.gt.1 )
     $       alrat = (2.*alamax/alamin)**(1./( DBLE(nalfxi)-1.))
            do  nal=2,nalfxi
              alfxc(nal,ityp) = alfxc(nal-1,ityp)*alrat
            enddo
CPAS: TEMP TO GET ALPHAS I WANT IN
          ELSEIF( NDIST.EQ.'r' )THEN
            CALL FLOPENF( IDTXC, 'ALF.XC' ,'OLD', 'FOR' )
            READ(IDTXC,8272)  NALFXI
            NALFXC(ITYP) = NALFXI
 8272       FORMAT(I2)
            READ(IDTXC,*) (ALFXC(IALF,ITYP),IALF=1,NALFXI)
            CALL FLCLOSE( IDTXC )
          else
c           space fit alphas arith. between alamin/3 and 2*alamax/3
            alfxc(1,ityp) = alamin/3.
            if( nalfxi.gt.1 )
     $       aldif = (2.*alamax-alamin)/(3.*( DBLE(nalfxi)-1.))
            do  nal=2,nalfxi
              alfxc(nal,ityp) = alfxc(nal-1,ityp) + aldif
            enddo
          endif
c         Also compute matrix for least squares fit
          do 1276 ial=1,nalfxi
            do 1275 jal=1,nalfxi
              alsq(ial,jal,1,ityp) = zero
              alsq(ial,jal,2,ityp) = zero
              alsq(ial,jal,3,ityp) = zero
              als = alfxc(ial,ityp) + alfxc(jal,ityp)
              do 1274 nr=1,nrxcfit(ityp)
                r = radmsh(nr,ityp)
                r2 = r*r
                r4 = r2*r2
                expfac = radwt(nr,ityp)*EXP( -als*r2 )
                alsq(ial,jal,1,ityp) = alsq(ial,jal,1,ityp) + expfac
                alsq(ial,jal,2,ityp) = alsq(ial,jal,2,ityp) + expfac*r2
                alsq(ial,jal,3,ityp) = alsq(ial,jal,3,ityp) + expfac*r4
 1274         continue
 1275       continue
 1276     continue
clib: disable calls to linpack/dsifa -
          call STOPXERR( 'DISABLED - removed linpack/dsifa calls' )
clib          call DSIFA(alsq(1,1,1,ityp),nalfxcd,nalfxi,ipvt(1,1,ityp),if)
          if( if.ne.0 )then
            write(IWR,*)'xcfit:',nalfxi,(alfxc(ial,ityp),ial=1,nalfxi)
            call STOPXERR( 'vfiterr1/dsifa-1 error' )
          endif
clib          call DSIFA(alsq(1,1,2,ityp),nalfxcd,nalfxi,ipvt(1,2,ityp),if)
          if( if.ne.0 ) call STOPXERR( 'vfiterr2/dsifa-2 error' )
clib          call DSIFA(alsq(1,1,3,ityp),nalfxcd,nalfxi,ipvt(1,3,ityp),if)
          if( if.ne.0 ) call STOPXERR( 'vfiterr3/dsifa-3 error' )
        endif
cxcf:
cxcf:end
cxcf:###############################################################
c
      RETURN
c
c >>>>>> ERROR HANDLING:
c
 1300 continue
      write(IWR,*) '>>>>> Want label >',wantlbl,'<, found >',readlbl,'<'
      call STOPXERR( 'atmdat1- format error in atom file' )
c
c  Data input formats
c
 8000 format(a)
 8020 format(4(i2,1x))
C9025 format(i2,1x,2f12.8)
 8030 format(4d16.8)
 8040 format(i2,4a6)
 8065 format(3x,6f12.8)
 8070 format(i2,1x,6f12.8)
C8120 format(i2,1x,i2,i3)
 8130 format(i2,a1,3x,2f12.8)
c
c  Data output formats
c
 9000 format(1x,a)
 9020 format(1x,4(i2,1x))
 9025 format(1x,i2,1x,2f12.8)
 9030 format(1x,1p4d16.8)
 9040 format(1x,i2,4a6)
 9065 format(4x,6f12.8)
 9070 format(1x,i2,1x,6f12.8 / (4x,6f12.8) )
 9120 format(1x,i3,1x,i3,1x,i3)
 9130 format(1x,i2,a1,3x,2f12.8)
c
c    That's all Folks!
c
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ATMRHO
c
c
      subroutine ATMRHO( ilocrho,
     $ natm,ntyp, nshld,nald, noad, nrd, nlat, nang,
     $ itypa, numshl,lshel,nala,ala,cala, occ,nfityp, nrad,radmsh,
     $ ratm,rlat, angpts,
     $ rhorad,rsph,rpt,rsq,rsqtol )
c---------------------------------------------------------------
c Purpose: to compute local radial charge about atoms due to all
c          OTHER atoms for the purpose of getting 0th order
c          correction for the local density used to generate the
c          local xc-potential/energy density for 1-center fit.
c
c Written: Peter A. Schultz, 19-February-1993
c
c Revision history:
c  11Mar02-PAS/2.52: literal reals to d0
c   1Mar00-PAS/2.43: bugfix for non-xcfit
c  21Dec99-PAS/2,42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Apr97-PAS/2.17: naming conventions
c---------------------------------------------------------------
c
c  Note: could use orbital occupations to give directionality
c        to the density.  I am guessing using spherical atoms
c        with shell occupations is good enough. 19Feb93-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c data arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  occ(noad,*), nfityp(*),nrad(*),radmsh(nrd,*)
      DIMENSION  ratm(3,natm),rlat(3,nlat)
      DIMENSION  angpts(3,*)
c scratch arrays:
      DIMENSION  rhorad(*)
      DIMENSION  rsph(3,*),rpt(3,*),rsq(*),rsqtol(*)
c local declarations:
      DIMENSION  rnuc(3),ratom(3)
      DATA  zero,half / 0.d0,0.5d0 /
c
c >>>> EXECUTABLE CODE:
c
      fourpi = pi + pi + pi + pi
      argmx = half*cutexp
c
c      Loop over sites, include only those with potentials:
c
      do 2000 nuc=1,natm
        ktyp = itypa(nuc)
        if( nfityp(ktyp).eq.0 ) goto 2000
c
        do  j=1,3
          rnuc(j) = ratm(j,nuc)
        enddo
        nrxc = nrad(ktyp)
c  Blank density array, compute positions of site's cluster of points
        ir = 0
        do  iang=1,nang
          do  nr=1,nrxc
            r = radmsh(nr,ktyp)
            ir = ir + 1
            rhorad(ir) = zero
            rsph(1,ir) = angpts(1,iang)*r
            rsph(2,ir) = angpts(2,iang)*r
            rsph(3,ir) = angpts(3,iang)*r
          enddo
        enddo
        nrsph = ir
c
c      Loop over atoms, find those with occupied shells
c
        do 1000 iatm=1,natm
          ityp = itypa(iatm)
c         Make sure the site's own density is excluded
          ilat1 = 1
          if( iatm.eq.nuc ) ilat1 = 2
c
          iorbat = 0
          do 900 ishl=1,numshl(ityp)
            lshl = lshel(ishl,ityp)
c
            occshl = zero
            do  ll=1,2*lshl+1
              iorbat = iorbat + 1
              occshl = occshl + occ(iorbat,ityp)
            enddo
c           Check if shell is occupied
            if( ABS( occshl ).lt.1.d-10 ) goto 900
c
            nal = nala(ishl,ityp)
            almini = ala(1,ishl,ityp)
            do  ial=1,nal
              if(ala(ial,ishl,ityp).lt.almini)almini=ala(ial,ishl,ityp)
            enddo
            alsmin = almini + almini
c
c      Loop over this atom in all unit cells:
c
            do 500 ilat=ilat1,nlat
c
c             Get nuclear position wrt this atom
              do  j=1,3
                ratom(j) =  rnuc(j) - ratm(j,iatm) - rlat(j,ilat)
              enddo
              rsqat = ratom(1)**2 + ratom(2)**2 + ratom(3)**2
c
c             Check if atom shell density overlaps site
              if( alsmin*rsqat.gt.argmx ) goto 500
c
c             Compute positions of site cluster of points wrt atom
              do  ir=1,nrsph
                rpt(1,ir) = ratom(1) + rsph(1,ir)
                rpt(2,ir) = ratom(2) + rsph(2,ir)
                rpt(3,ir) = ratom(3) + rsph(3,ir)
                rsq(ir) = rpt(1,ir)**2 + rpt(2,ir)**2 + rpt(3,ir)**2
              enddo
c
              if( lshl.gt.0 )then
                do  ir=1,nrsph
                  rsqtol(ir) = rsq(ir)**lshl
                enddo
              endif
c
              do 420 ial=1,nal
                ali = ala(ial,ishl,ityp)
                cali = occshl*cala(ial,ishl,ityp)
                cali0 = cali
c
                do 410 jal=ial,1,-1
                  alsum = ali + ala(jal,ishl,ityp)
                  if( alsum*rsqat.gt.argmx ) goto 410
c
                  prod = cali*cala(jal,ishl,ityp)
                  cali = cali0 + cali0
                  rhoprod = prod/fourpi
c
                  ir0 = 0
                  do 300 iang=1,nang
                    rendsq = rsq(ir0+nrxc)
                    nrxcn = nrxc
c
                    if( alsum*rendsq.gt.argmx )then
c                     Outer end of points too large, cut em off
                      rsqcut = argmx/alsum
                      do 200 ir=ir0+nrxc,ir0+1,-1
                        if( rsq(ir).lt.rsqcut ) goto 201
                        nrxcn = nrxcn - 1
  200                 continue
  201                 continue
                    endif
c
c      Compute contribution of density into this angular slice of points
c
                    if( lshl.eq.0 )then
c
                      do  ir=ir0+1,ir0+nrxcn
                        rhorad(ir) = rhorad(ir) + rhoprod*
     $                                EXP(-alsum*rsq(ir))
                      enddo
c
                    else
c
                      do  ir=ir0+1,ir0+nrxcn
                        rhorad(ir) = rhorad(ir) + rhoprod*rsqtol(ir)*
     $                                EXP(-alsum*rsq(ir))
                      enddo
c
                    endif
c
                    ir0 = ir0 + nrxc
  300             continue
c
c    Close alpha loops:
c
  410           continue
  420         continue
c
c    Close lattice loop:
c
  500       continue
c
c    Close shell loop:
c
  900     continue
c
c    Close atom loop:
c
 1000   continue
c
c    Write local density about this site to disk:
c
      write(ilocrho) nrxc,nang
      write(ilocrho) (rhorad(ir),ir=1,nrsph)
c
c    Close nuclear loop:
c
 2000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ATOMNM
c
c
      subroutine ATOMNM( atmfil,nflnm, filenm, atmnm,natnm )
c---------------------------------------------------------------
c Purpose: parse atom file input to get atom name AND file name
c
c Written: Peter A. Schultz, 31-May-2001 for v2.47
c          Based on an idea by Art Edwards
c
c Revision history:
c  R21Jun01-PAS/2.48: replace STOPs
c---------------------------------------------------------------
c
c Looking to parse an atom name and a file name out of an input
c file type name.  Two types of input:
c  (1) <atmnm> = <filenm>
c     - where aliasing is explicit, and the presence of '='
c       uniquely signifies use of an alias.  We allow no spaces
c       within <atmnm> or <filenm>, but will allow spaces on
c       either side of the '='
c  (2) <filenm>
c     - where we will attempt to parse out a default atom name
c       from the atom file name, the atom name being XXXX, where
c       the atom file is XXXX.atm.  Must ignore directory name.
c I take care to be sure that the length of the character string
c for the atom name does not exceed that alloted in 'atmnm'
c
c input:
      CHARACTER*(*)  atmfil
c output:
      CHARACTER*(*)  filenm
      CHARACTER*(*)  atmnm
c
c local declarations:
      LOGICAL      got_name
      CHARACTER*4  atmtag
      DATA         atmtag /'.atm'/
      CHARACTER*1  blank,       equals,       slash
      DATA         blank /' '/, equals /'='/, slash /'/'/
c
c >>>> EXECUTABLE CODE:
c
      got_name = .false.
c Set default atom name to no-name:
      atmnm = blank
      filenm = blank
c
      ic1 = 1
c
   10 continue
c
c first step: find first non-blank character
c
      do 20 ic=ic1,nflnm
        i1 = ic
        if( atmfil(ic:ic) .ne. blank ) goto 21
   20 continue
      call STOPXERR( 'blankatm/atom name or file parsed blank' )
   21 continue
c
c next step: find end of string (blank), and look for '=' which
c            would signify an alias.
c
      i2 = nflnm
      do 50 ic=i1+1,nflnm
c
        if( atmfil(ic:ic) .eq. blank )then
          i2 = ic - 1
c         If already have an atom name, this string is file name:
          if( got_name ) goto 100
c
c         Look for first non-blank character and check for '='
c         that would signify an alias:
          do 40 jc=ic+1,nflnm
c           End string, we either have atom name or file name:
            if( atmfil(jc:jc) .ne. blank ) then
              if( atmfil(jc:jc) .eq. equals )then
c               Found an alias
                got_name = .true.
                inm1 = i1
                inm2 = i2
                ic1 = jc + 1
c               Got atom name, now go get file name:
                goto 10
              else
c               Not an alias, end of file name instead:
                goto 100
              endif
            endif
   40     continue
c         Have nothing but blanks left, must be file name:
          goto 100
        elseif( atmfil(ic:ic) .eq. equals )then
c         Make sure not *two* equals around:
          if( got_name ) call STOPXERR( 'at=file=/two equals in atom' )
          i2 = ic - 1
c         Found an alias
          got_name = .true.
          inm1 = i1
          inm2 = i2
          ic1 = ic + 1
          goto 10
        endif
c
   50 continue
c
  100 continue
c  We have parsed an atom file name, load it:
      lenfl = i2 - i1 + 1
      filenm(1:lenfl) = atmfil(i1:i2)
c
      if( .not. got_name .and. lenfl.gt.4 )then
c       Try to get atom name out of atom file name:
        it1 = i2 - 3
        it2 = i2
        inm2 = it1 - 1
        if( atmfil(it1:it2) .eq. atmtag .and.
     $      atmfil(inm2:inm2) .ne. slash )then
          got_name = .true.
c         Go looking backwards for directory slash:
          inm1 = i1
          do 140 ic=inm2-1,i1,-1
            if( atmfil(ic:ic) .eq. slash )then
              inm1 = ic + 1
              goto 150
            endif
  140     continue
        endif
      endif
c
  150 continue
      if( got_name )then
c       Guarantee that atom name fits in space alloted:
        if( inm2 .gt. (inm1+natnm-1 ) ) inm2 = inm1+natnm-1
        lennm = inm2 - inm1 + 1
        atmnm(1:lennm) = atmfil(inm1:inm2)
      endif
c      print*, "Debug printing in atomnm (delete):"
c      print*, atmtag,blank,equals,slash
c      print*, nflnm,natnm
c      print*, lennm,inm1,inm2
c      print*, atmnm
c      print*, filenm
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BFSETUP
c
c
      subroutine BFSETUP( IWR, natm,ntyp,nshld,nald,
     $ norb,norbd,
     $ numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ znuc,occsh,occij,alamin )
c---------------------------------------------------------------
c Purpose: process some atom information
c
c Written: Peter A. Schultz,  9-May-2000, for v2.45
c
c Revision history:
c  10Jan08-PAS/2.61: eliminate unused passed arguments
c  21Jun01-PAS/2.48: replace STOPs
c   7Jun01-PAS/2.47: eliminate nstd
c---------------------------------------------------------------
c Note: this routine copies the basis info onto the shell info,
c       getting ready for a possible split basis tranformation
c       It also sets up the occupation arrays and finds min
c       alphas for each type to be used later in the code.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input/output arrays:
c  ... basis description
      DIMENSION  numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
c  ... reference shell description
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $ nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  znuc(ntyp), occsh(nshld,ntyp), occij(nshld,nshld,ntyp)
      DIMENSION  alamin(ntyp)
c
c local declarations:
      DATA  zero / 0.d0 /
      DATA  cutocc / 0.9d-8 /
      LOGICAL  booboo
c
c >>>> EXECUTABLE CODE:
c
      booboo = .false.
c
      do 1000 ityp=1,ntyp
        nshl = numshl(ityp)
c
c  Copy basis into shell info:
        nocc(ityp) = numshl(ityp)
        do  ishl=1,nshl
          locc(ishl,ityp) = lshel(ishl,ityp)
          nalsh(ishl,ityp) = nala(ishl,ityp)
          do  ial=1,nalsh(ishl,ityp)
            alsh(ial,ishl,ityp) = ala(ial,ishl,ityp)
            calsh(ial,ishl,ityp) = cala(ial,ishl,ityp)
          enddo
        enddo
c
c  Take care of occupation information:
        occatm = zero
        call MKZERO( nshld*nshld, occij(1,1,ityp) )
        do  ishl=1,nshl
          occshl = occsh(ishl,ityp)
          if( ABS( occshl ).lt.cutocc ) occshl = zero
          occatm = occatm + occshl
          occsh(ishl,ityp) = occshl
          norbsh = 2*lshel(ishl,ityp) + 1
          occij(ishl,ishl,ityp) = occshl / DBLE( norbsh )
        enddo
c
        if( ABS( znuc(ityp)-occatm ) .gt. cutocc )then
          write(IWR,*) '***** ERROR: occups .ne. z on atom type',ityp
          write(IWR,*) '>>>>> z,occatm=',znuc(ityp), occatm
          booboo = .true.
        endif
c
c  Find and store minimum alpha:
        almina = ala(1,1,ityp)
        do  ishl=1,nshl
          lshl = lshel(ishl,ityp)
          nal = nala(ishl,ityp)
          call GNORM( lshl, nal, ala(1,ishl,ityp),cala(1,ishl,ityp) )
          do  ial=1,nal
            almina = MIN( almina, ala(ial,ishl,ityp) )
          enddo
        enddo
        alamin(ityp) = almina
c
 1000 continue
c
      if( booboo ) call STOPXERR( 'bfsetup-errors' )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BFSPLIT
c
c
      subroutine BFSPLIT( ntyp,nshld,nald, cbfsh,occsh,occij,
     $ numshl,lshel,nala,ala,cala )
c---------------------------------------------------------------
c Purpose: construct split valence basis from full shell basis
c
c Written: Peter A. Schultz, 27-July-1998, for v2.23 (split basis)
c
c Revision history:
c  21Jun01-PAS/2.48: replace STOPs
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c  On input, the bf and occ shells are copies of each other
c  On output:
c    1) The bf shells (numshl-cala) are in split basis form.
c    2) cbfsh gives orig shells from split basis shells:
c                sh(j) = SUM[i]( cbfsh(i,j)*bf(i) )
c    3) occij(i,j) = matrix coefs for i.gt.j (shell-wise)
c                  = effective z for i.le.j
c
c  I assume that bf coefficients are all non-zero on input.
c  Otherwise the splitting algorithm *might* have a problem.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  (lmax=4)
c output/input arrays:
      DIMENSION  cbfsh(nshld,nshld,ntyp)
      DIMENSION  occsh(nshld,ntyp), occij(nshld,nshld,ntyp)
      DIMENSION  numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
c local declarations:
      DIMENSION  numl(0:lmax)
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /, vsmall / 1.d-6 /
c
c >>>> EXECUTABLE CODE
c
      call MKZERO( nshld*nshld*ntyp, cbfsh )
      call MKZERO( nshld*nshld*ntyp, occij )
c
c  Cycle over all atom types:
c
      do 1000 ityp=1,ntyp
        nshl = numshl(ityp)
c
c  Start with identity, i.e. bf=occ shells:
        do  ishl=1,nshl
          cbfsh(ishl,ishl,ityp) = one
        enddo
c
c  Count up number of shells in each angular momentum:
        do  l=0,lmax
          numl(l) = 0
        enddo
        do  ishl=1,nshl
          lshl = lshel(ishl,ityp)
          if( lshl.gt.lmax .or. lshl.lt.0 ) call STOPXERR( 'split-l' )
          numl(lshl) = numl(lshl) + 1
        enddo
c
c Loop over shells of a given angular momentum
        do 500 l=0,lmax
c
          alnext = zero
          numspl = numl(l)
c
c  Return here to split out next shell:
c
  100     numspl = numspl - 1
c
c  Setting this cutoff at 1 would restrict kind of splitting allowed
          if( numspl.lt.0 ) goto 500
c
c  Find next shell/alpha to be split off
          ishspl = 0
          aldone = alnext
          do 200 ishl=1,nshl
            if( lshel(ishl,ityp).ne.l ) goto 200
c
c  This shell has right l, find its range of alphas:
            ispl = 1
            almins = ala(1,ishl,ityp)
            almaxs = ala(1,ishl,ityp)
            do 110 ial=2,nala(ishl,ityp)
              ali = ala(ial,ishl,ityp)
              if( ali.lt.almins )then
                ispl = ial
                almins = ali
              endif
              if( ali.gt.almaxs ) almaxs = ali
  110       continue
c
            if( ishspl.eq.0 )then
              if( almins.gt.aldone )then
c  First shell with l, load up
                ishspl = ishl
                ialspl = ispl
                alnext = almins
                almax = almaxs
              endif
            elseif( almins.gt.aldone .and. almins.lt.alnext )then
c  Has smaller unsplit alpha than previous, load it
              ishspl = ishl
              ialspl = ispl
              alnext = almins
              almax = almaxs
            elseif( almins.eq.alnext .and. almaxs.lt.almax )then
c  Has same splitting alpha, but smaller range, load it instead
              ishspl = ishl
              ialspl = ispl
              almax = almaxs
            endif
c
  200     continue
          if( ishspl.eq.0 ) call STOPXERR( 'split-n' )
c
c  Project out this splitting shell from other shells:
c
          do 300 ishl=1,nshl
            if( lshel(ishl,ityp).ne.l ) goto 300
            if( ishl.eq.ishspl ) goto 300
c
c  Right, at this point I have some choices:
c   A0) project out of *every* shell having this alpha
c   A1) project only those where projected number of non-zero
c       alphas does not increase (i.e., at most one new alpha)
c   A2) project only those where all splitting shell gaussians
c       are also present in target shell
c      (Hence *strictly* reducing in number of gaussians)
c   B0) restrict to those where target has same min alpha
c       (with or without conditions 1 and 2)
c
c  I am going to choose A2.  The bookkeeping is simpler, and
c  gives best set of min alphas for all but pathological cases
c  (internal alphas could be better optimized), and easier
c  formulas for getting bf:occ shell projections.
c
c  This shell has right l, check the projecting alphas:
            jalspl = 0
            nalj = nala(ishl,ityp)
            do 220 ial=1,nala(ishspl,ityp)
              ali = ala(ial,ishspl,ityp)
              do 210 jal=1,nalj
                alj = ala(jal,ishl,ityp)
                if( alj.eq.ali )then
                  if( ial.eq.ialspl ) jalspl = jal
                  goto 220
                endif
  210         continue
c  We did not find a match for a splitting shell gaussian:
              goto 300
  220       continue
c
c  I have assumed a non-zero coefficient.  Idiot-check this here:
            if( ABS(cala(ialspl,ishspl,ityp)).lt.vsmall )
     $       call STOPXERR( 'split-c' )
c
c  Do the arithmetic:
            coef = cala(jalspl,ishl,ityp)/cala(ialspl,ishspl,ityp)
c
c  Keep track of how to back-transform:
            do 240 jshl=1,nshl
              cbfsh(ishspl,jshl,ityp) = cbfsh(ishspl,jshl,ityp) +
     $                             coef*cbfsh(ishl,jshl,ityp)
  240       continue
c
c  And do the work on the coefficients:
            do 260 ial=1,nala(ishspl,ityp)
              ali = ala(ial,ishspl,ityp)
              cali = coef*cala(ial,ishspl,ityp)
              do 250 jal=1,nalj
                alj = ala(jal,ishl,ityp)
                if( alj.eq.ali )then
                  cala(jal,ishl,ityp) = cala(jal,ishl,ityp) - cali
                  goto 260
                endif
  250         continue
  260       continue
            cala(jalspl,ishl,ityp) = zero
c
c  And compact the result (i.e. clean out alphas with zero weight):
            do 280 jal=nalj,1,-1
              if( ABS(cala(jal,ishl,ityp)) .lt. vsmall )then
                nala(ishl,ityp) = nala(ishl,ityp) - 1
                do 270 jj=jal+1,nalj
                  ala(jj-1,ishl,ityp) = ala(jj,ishl,ityp)
                  cala(jj-1,ishl,ityp) = cala(jj,ishl,ityp)
  270           continue
              endif
  280       continue
            if( nala(ishl,ityp).eq.0 ) call STOPXERR( 'split-x' )
c
c  Close shell loop:
c
  300      continue
c
c  This splitting shell/alpha now taken out of all relevant orbs.
c  Go find the next splitting shell/alpha for this angular momentum:
c
           goto 100
c
c  Close angular momentum loop:
c
  500   continue
c
c  Normalize the split basis functions:
c
        do 550 ishl=1,nshl
          lshl = lshel(ishl,ityp)
          nal  = nala(ishl,ityp)
c
          call GOVLP( s,lshl, nal,ala(1,ishl,ityp),cala(1,ishl,ityp),
     $                        nal,ala(1,ishl,ityp),cala(1,ishl,ityp) )
c
c  Both normalize the basis functions *and* scale transformation matrix:
          scale = SQRT(s)
          do  jshl=1,nshl
            cbfsh(ishl,jshl,ityp) = scale*cbfsh(ishl,jshl,ityp)
          enddo
          snorm = one/scale
          do  ial=1,nal
            cala(ial,ishl,ityp) = snorm*cala(ial,ishl,ityp)
          enddo
  550   continue
c
c  Now construct reference occupation numbers for split basis:
        do 650 kshl=1,nshl
          lshl = lshel(kshl,ityp)
          norbsh = 2*lshl + 1
          occfac = occsh(kshl,ityp)/DBLE(norbsh)
          if( occfac.ne.zero )then
            do  jshl=1,nshl
              do  ishl=1,nshl
                occij(ishl,jshl,ityp) = occij(ishl,jshl,ityp) +
     $           occfac*cbfsh(ishl,kshl,ityp)*cbfsh(jshl,kshl,ityp)
              enddo
            enddo
          endif
  650   continue
c
c  Now get z numbers of cross terms, double, and put into
c  ishl<jshl triangle (for use in "vlocmii")
        do 700 jshl=2,nshl
          l = lshel(jshl,ityp)
          nalj = nala(jshl,ityp)
          do 690 ishl=1,jshl-1
            if( occij(ishl,jshl,ityp).ne.zero )then
              nali = nala(ishl,ityp)
              call GOVLP(s,l,nali,ala(1,ishl,ityp),cala(1,ishl,ityp),
     $                       nalj,ala(1,jshl,ityp),cala(1,jshl,ityp) )
              occij(ishl,jshl,ityp) = two*s*occij(ishl,jshl,ityp)
            endif
  690     continue
  700   continue
c
c  Close loop over types:
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BLKVOFN
c
c
      subroutine BLKVOFN( ilocrho, nuc,ktyp, lmx1ctr,almnv1c,
     $ norb,nk, natm,ntyp,nshld,nald, noad, nlat,
     $ itypa, numshl,lshel,nala,ala,cala,  norba,ioffa, occij,
     $ nrs,nrd,radmsh,radwt,
     $ ratm,rlat,vk, nsyms,dsym,naofsym,
     $ dmatrd,
     $ dcountr,rh1coef, cv,ce,  ves1c, pot1c,xen1c,
     $ alxcmin,nalfxc,nalfxcd,alfxc,  alsq,ipvt,
     $ nrxc, vxcrad,excrad,
     $ itypxc, nang, angylm,angpts,angwts, radwf,
     $ nrho, rholoc,vxcloc,excloc, vlm,elm,rfac, vg,eg,
     $ orb,grorb,grgrorb, wf1cwk1,wf1cwk2,wf1cwk3,wf1cwk4,wf1cwk5,
     $ orbj,grorbj,grgrorj,gofac,ggofac,
     $ erfwork, dmatwk, cphi )
c---------------------------------------------------------------
c Purpose: construct local 1-center potentials for nuc given dmat
c
c Revision history:
c  21Jun07-PAS/2.60: removed dsisl calls to clean dependencies
c  11Jun05-PAS/2.59: File units
c   7Mar02-PAS/2.52: ang constants extracted
c   2Jul01-PAS/2.48: replace undirected writes, xcfcn->dftlda
c   1Mar00-PAS/2.43: non-xcfit bugfix
c  21Dec99-PAS/2.42: cosmetic clean-up
c   9Dec98-PAS/2.29: promote source to explicit double precision
c  29Jul98-PAS/2.23: split basis occs
c  28Apr97-PAS/2.17: naming conventions
c  16Oct94-PAS:  reorged for speed,clarity/all-but-real-space-opts
c---------------------------------------------------------------
c
c  There are two contributions to local 1-ctr potentials at nuc from
c  change in density matrix dmat(i,j):
c  First, i and j are both centered on nuc. this term is:
c          sum(   dmat(i,j)* phi(i,r) *phi(j,r)  )
c  and the other term is a two-center contribution (j not on "nuc"):
c          sum( 2.*dmat(i,j) * phi(i,r)* phi(j,r(nuc)) )
c  To avoid divergences in performing the required lattice sums, we
c  make sure that the zeroth, first and second moments of the "1-ctr"
c  charge density vanish exactly.  Thus potential we calculate here
c  falls off rapidly as a function of distance from nucleus "nuc."
c
c  On output, array "ves1c" = short-range es potential for nuc
c  Also computes the quantities "rh1coef" used in "rho1ctr" to
c  subtract the density corresponding to potentials computed here
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c data arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  norba(ntyp),ioffa(natm), occij(nshld,nshld,ntyp)
      DIMENSION  almnv1c(ntyp)
      DIMENSION  radmsh(nrs),radwt(nrs)
      DIMENSION  ratm(3,natm),rlat(3,nlat),vk(3,nk)
      DIMENSION  dsym(5,5,3,*),naofsym(natm,*)
      DIMENSION  dmatrd(2,norb,norb,nk)
complex dmatrd
c xc-fit data
      DIMENSION  alfxc(nalfxc),alsq(nalfxcd,nalfxcd,3),ipvt(nalfxcd,3)
      DIMENSION  vxcrad(nrxc),excrad(nrxc)
      DIMENSION  angylm(nang,9),angpts(3,nang),angwts(nang)
      DIMENSION  radwf(nang,nrd,noad)
c output arrays:
      DIMENSION  dcountr(10),rh1coef(10,noad)
      DIMENSION  cv(10,nalfxc),ce(10,nalfxc)
      DIMENSION  ves1c(nrd,10), pot1c(nrd,10),xen1c(nrd,10)
c scratch arrays:
      DIMENSION  rholoc(nrho,nang),vxcloc(nrxc,nang),excloc(nrxc,nang)
      DIMENSION  vlm(nrxc),elm(nrxc),rfac(nrs,nalfxc)
      DIMENSION  vg(nalfxcd,9),eg(nalfxcd,9)
      DIMENSION  orb(nlat),grorb(3,nlat),grgrorb(3,3,nlat)
      DIMENSION  wf1cwk1(3,nlat),wf1cwk2(3,3,nlat),
     $           wf1cwk3(3,nlat),wf1cwk4(nlat),wf1cwk5(nlat)
      DIMENSION  orbj(noad),grorbj(3,noad),grgrorj(3,3,noad)
      DIMENSION  gofac(nang),ggofac(nang)
      DIMENSION  erfwork(nrs), dmatwk(noad,noad,nlat)
c scratch array used complex only in ROTGRP, declare real here:
      DIMENSION  cphi(*)
c---------------------------------------------------------------
c
c  LOCAL DECLARATIONS:
c
c scratch arrays:
      DIMENSION  eslongr(10),eslfac(10)
      DIMENSION  rij(3)
      DIMENSION  erfiwk(64),eswk(64,2)
c data constant arrays:
      DIMENSION  number(5)
      DATA  number / 1,4,10,20,35 /
c npots has no. of pots in 0<L<3 from i*j orb products
      DIMENSION  npots(9,9)
      DATA  npots
     s/ 1, 1,1,1, 1,1,1, 2,3,
     x  1, 1,1,1, 0,0,0, 0,0,
     y  1, 1,1,1, 0,0,0, 0,0,
     z  1, 1,1,1, 0,0,0, 0,0,
     d  1, 0,0,0, 0,0,0, 0,0,
     d  1, 0,0,0, 0,0,0, 0,0,
     d  1, 0,0,0, 0,0,0, 0,0,
     D  2, 0,0,0, 0,0,0, 0,0,
     D  3, 0,0,0, 0,0,0, 0,0 /
c
c lpots has L<3 pot. no. of off-diag orb prods of ip<8
      DIMENSION  lpots(7,7),lpt(4)
      DATA  lpots
     s/ 1, 2,3,4,  5,6,7,
     x  2, 8,5,7,  0,0,0,
     y  3, 5,9,6,  0,0,0,
     z  4, 7,6,10, 0,0,0,
     d  5, 0,0,0,  0,0,0,
     d  6, 0,0,0,  0,0,0,
     d  7, 0,0,0,  0,0,0/
      DATA  lpt / 8,9,10,8 /
      DIMENSION  lpotgr(3,4),lpgrgr(3,3)
      DATA  lpotgr/2,3,4,
     $             8,5,7,
     $             5,9,6,
     $             7,6,10/
      DATA  lpgrgr/8,5,7,
     $             5,9,6,
     $             7,6,10/
c
      DIMENSION  wght(3,3)
      DATA  wght / 1.,0.,0.,  1.,-1.,0.,  -1.,-1.,2. /
c
      DIMENSION  vnorm(9)
c
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c >>>> EXECUTABLE CODE:
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c Get angular normalizations:
      call VNORMS9( vnorm )
      lp1 = lmx1ctr + 1
      lp1sq = lp1*lp1
      lpotmax = number(lp1)
c
c    Zero potentials of nucleus "nuc"
c
      do  lpot=1,lpotmax
        eslongr(lpot) = zero
        call MKZERO( nrs, pot1c(1,lpot) )
        call MKZERO( nrs, xen1c(1,lpot) )
        call MKZERO( nrs, ves1c(1,lpot) )
      enddo
c
c    Initialize accumulators for Taylor series coefficients.
c
      do  iorbat=1,norba(ktyp)
        orbj(iorbat) = zero
        do  ir=1,3
          grorbj(ir,iorbat) = zero
          do  jr=1,3
            grgrorj(ir,jr,iorbat) = zero
          enddo
        enddo
      enddo
c
c    Initialize density of atom "nuc" on spherical mesh:
c
      if( ilocrho.gt.0 )then
c       Initialize density with tails from other atoms
        read(ilocrho)  rholoc
      else
c       Start with a blank slate
        do  nr=1,nrxc
          do  iang=1,nang
            rholoc(nr,iang) = zero
          enddo
        enddo
      endif
c
c    Set error function for alpha minimum
c
      alvmin = almnv1c(ktyp)
      alxmin =  MAX( alxcmin, almnv1c(ktyp) )
      rtalvmn = SQRT( alvmin )
      do  nr=1,nrs
        erfwork(nr) = DERF( rtalvmn*radmsh(nr) ) / radmsh(nr)
      enddo
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                      Begin Atom j loop
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      do 1000 jatm=1,natm
        jtyp = itypa(jatm)
c
c    Sum density matrix over surface brillouin zone
c
        call MKZERO( nlat*noad**2, dmatwk )
        do 20 klat=1,nlat
c
          do  jr=1,3
            rij(jr) = ratm(jr,nuc) - ratm(jr,jatm) - rlat(jr,klat)
          enddo
c
          call ROTGRP( dmatwk(1,1,klat), nuc,jatm,rij,
     $     norb,nk, natm,ntyp,nshld, noad,
     $     itypa,numshl,lshel, ioffa, vk,rlat(1,klat),
     $     nsyms,dsym,naofsym,
     $     dmatrd,cphi )
c
   20   continue
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c              begin rh1coef calculation
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
        jorbat = 0
        do 75 jshl=1,numshl(jtyp)
          nalj = nala(jshl,jtyp)
          lorbj = lshel(jshl,jtyp)
          lj = lorbj**2
          norbshj = 2*lorbj + 1
          do 65 jorbsh=1,norbshj
            jorbat = jorbat + 1
            lj = lj + 1
c
c    Obtain orb, grorb, and grgrorb for all nlat:
c
            call WF1COFR( orb,grorb,grgrorb,
     $       nuc,jatm, lj,jtyp,jshl,nalj,
     $       natm,ntyp,nshld,nald, nlat, ala,cala, ratm,rlat,
     $       wf1cwk1,wf1cwk2,wf1cwk3,wf1cwk4,wf1cwk5 )
c
            iorbat = 0
            do 70 ishl=1,numshl(ktyp)
              nali = nala(ishl,ktyp)
              lorbi = lshel(ishl,ktyp)
              norbshi = 2*lorbi + 1
              do 60 iorbsh=1,norbshi
                iorbat = iorbat + 1
c
                do 50 klat=1,nlat
c
                  if( jatm.eq.nuc .and. klat.eq.1 )then
c
c    Accumulate 1-atom part of density to "rholoc"
c
                    if( itypxc.ne.0 )then
                      dm = dmatwk(iorbat,jorbat,1)
                      do  iang=1,nang
                        do  nr=1,nrxc
                          rholoc(nr,iang) = rholoc(nr,iang) + dm*
     $                     radwf(iang,nr,iorbat)*radwf(iang,nr,jorbat)
                        enddo
                      enddo
                    endif
c                   Skip rest as jatm and nuc are same atom
                    goto 50
c
                  endif
c
c    Add approximate contributions to "rholoc" for 2-atom case
c
c  Accumulate coefficients for Taylor series expansions about site iatm
c  of orbitals j, multplied by 2*dmat(i,j).  Note 2nd derivative in
c  in Taylor series includes factor of 1/2, cancelling this factor of 2
c  This information is used to complete "rholoc" calculation after
c  completion of the "do 1000" loop, below
c
                  dm = dmatwk(iorbat,jorbat,klat)
                  dmm = dm + dm
                  orbj(iorbat) = orbj(iorbat) + dmm*orb(klat)
                  do  ir=1,3
                    grorbj(ir,iorbat) = grorbj(ir,iorbat)
     $               + dmm*grorb(ir,klat)
                    do  jr=1,3
                      grgrorj(ir,jr,iorbat) = grgrorj(ir,jr,iorbat)
     $                  + dm*grgrorb(ir,jr,klat)
                    enddo
                  enddo
c
c Accumulate 2-atom contributions to "rh1coef" ...
c
                  if( lorbi .gt. lmx1ctr ) goto 60
c
c  ... from orbital j at site
c
                  rh1coef(1,iorbat) = rh1coef(1,iorbat) +
     $             dmatwk(iorbat,jorbat,klat)*orb(klat)
c
                  if( lorbi+1 .gt. lmx1ctr ) goto 50
c
c  ... from gradient of orbital j
c
                  do  lgrad=1,3
                    rh1coef(1+lgrad,iorbat) = rh1coef(1+lgrad,iorbat)
     $               + dmatwk(iorbat,jorbat,klat)*grorb(lgrad,klat)
                  enddo
c
                  if( lorbi+2 .gt. lmx1ctr ) goto 50
c
c  ... from grad(grad(orbital j).
c      (since lmx1ctr restricted to .le.2, lorbi must=0 to use)
c
                  lcoef = 4
                  do  lgr=1,3
                    do  llgr=1,lgr
                      if( llgr.eq.lgr )then
                        offd = half
                      else
                        offd = one
                      endif
                      lcoef = lcoef + 1
                      rh1coef(lcoef,iorbat) =rh1coef(lcoef,iorbat)+offd*
     $                 dmatwk(iorbat,jorbat,klat)*grgrorb(llgr,lgr,klat)
                    enddo
                  enddo
c
c    Close lattice vector loop:
c
   50           continue
c
c    Close i-orbital loops:
c
   60         continue
   70       continue
c
c    Close j-orbital loops:
c
   65     continue
   75   continue
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c               end rh1coef calculation
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                begin vofn calculation
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if( jatm.eq.nuc )then
c
c **********************  1 atom case  **********************
c
      iorbat0 = 0
      do 182 ishl=1,numshl(ktyp)
        nali = nala(ishl,ktyp)
        lorbi = lshel(ishl,ktyp)
        norbshi = 2*lorbi + 1
        li0 = lorbi*lorbi
c
        jorbat0 = 0
        do 181 jshl=1,numshl(ktyp)
          nalj = nala(jshl,ktyp)
          lorbj = lshel(jshl,ktyp)
          norbshj = 2*lorbj + 1
          lj0 = lorbj*lorbj
c
          lorbsum = lorbi + lorbj
c
          if( lorbsum .gt. lmx1ctr ) goto 181
c
          esll = zero
          esl0 = zero
          do  nr=1,nrs
            eswk(nr,1) = zero
            eswk(nr,2) = zero
          enddo
c
          if( ishl.gt.jshl )then
            occ = occij(ishl,jshl,ktyp)
          else
            occ = occij(jshl,ishl,ktyp)
          endif
c
c    Alpha loops:
c
          do 162 ial=1,nali
            ali = ala(ial,ishl,ktyp)
            cali = cala(ial,ishl,ktyp)
c
            do 161 jal=1,nalj
              alj = ala(jal,jshl,ktyp)
              calj = cala(jal,jshl,ktyp)
c
              als = ali + alj
              if( als.lt.alvmin ) goto 161
c
              twoals = als + als
              rtals = SQRT( als )
              rtpial = rtpi/rtals
              expfac = two/rtpial
              alfac = cali*calj*(rtpial**3)/(twoals**lorbsum)
c
              esll = esll + alfac
              esl0 = esl0 + twoals*alfac
c
c  Last statements account for fact that x**2 potential (y**2 and
c  z**2 too) equivalent to a (d/dx)**2 plus an s-like potential
c
              alfac = two*alfac
              alfm2 = twoals*alfac
c generate and save unvectorizeable functions of r:
              do  nr=1,nrs
                r = radmsh(nr)
                erfiwk(nr) = DERF(rtals*r)/r
              enddo
c
c  Calculate the radial parts of the potentials:
c
              if( lorbsum.eq.0 )then
                do  nr=1,nrs
                  esfac = erfiwk(nr) - erfwork(nr)
                  eswk(nr,1) = eswk(nr,1) + alfac*esfac
                enddo
              elseif( lorbsum.eq.1 )then
                do  nr=1,nrs
                  esfac = erfiwk(nr) - erfwork(nr)
                  eswk(nr,1) = eswk(nr,1) + alfac*esfac
                enddo
              elseif( lorbsum.eq.2 )then
                do  nr=1,nrs
                  r = radmsh(nr)
                  esfac = erfiwk(nr) - erfwork(nr)
                  eswk(nr,1) = eswk(nr,1) + alfac*esfac
                  eswk(nr,2) = eswk(nr,2) + alfm2*esfac
                enddo
              endif
c
c    Close alpha loops:
c
  161       continue
  162     continue
c
c    Orbital loops:
c
          iorbat = iorbat0
          li = li0
          do 172 iorbsh=1,norbshi
            iorbat = iorbat + 1
            li = li + 1
c
            jorbat = jorbat0
            lj = lj0
            do 171 jorbsh=1,norbshj
              jorbat = jorbat + 1
              lj = lj + 1
c
c  Determine how many potentials this pair of orbitals contributes
c  to, what l-values, and with what weight
c
              numpot = npots(li,lj)
              if( numpot.eq.0 ) goto 171
c
              dmatr = dmatwk(iorbat,jorbat,1)
              if( li.eq.lj ) dmatr = dmatr - occ
              dmfac = dmatr/(vnorm(li)*vnorm(lj))
c
              efacl = dmfac*esll
              efac0 = dmfac*esl0
c
              if( numpot.eq.1 )then
                lpot = lpots(li,lj)
                if( lpot.gt.lpotmax ) goto 171
                vfac = dmfac
                eslongr(lpot) = eslongr(lpot) + efacl
                if( lpot.lt.8 )then
                  do  nr=1,nrs
                    ves1c(nr,lpot) = ves1c(nr,lpot) + vfac*eswk(nr,1)
                  enddo
                else
                  eslongr(1) = eslongr(1) + efac0
                  do  nr=1,nrs
                    ves1c(nr,lpot) = ves1c(nr,lpot) + vfac*eswk(nr,1)
                    ves1c(nr,1) = ves1c(nr,1) + vfac*eswk(nr,2)
                  enddo
                endif
              else
                do 155 npt=1,numpot
                  wt = wght(npt,numpot)
                  lpot = lpt(npt)
                  if( lpot.gt.lpotmax ) goto 171
                  if( wt.eq.zero ) goto 155
                  vfac = wt*dmfac
                  eslongr(lpot) = eslongr(lpot) + wt*efacl
                  if( lpot.lt.8 )then
                    do  nr=1,nrs
                      ves1c(nr,lpot) = ves1c(nr,lpot) + vfac*eswk(nr,1)
                    enddo
                  else
                    eslongr(1) = eslongr(1) + wt*efac0
                    do  nr=1,nrs
                      ves1c(nr,lpot) = ves1c(nr,lpot) + vfac*eswk(nr,1)
                      ves1c(nr,1) = ves1c(nr,1) + vfac*eswk(nr,2)
                    enddo
                  endif
  155           continue
              endif
c
c    Close orbital loops:
c
  171       continue
  172     continue
c
c    Close radial function loops:
c
  181   jorbat0 = jorbat0 + norbshj
  182 iorbat0 = iorbat0 + norbshi
c
      endif
c
c **********************  2 atom case  **********************
c
      iorbat0 = 0
      do 282 ishl=1,numshl(ktyp)
        nali = nala(ishl,ktyp)
        lorbi = lshel(ishl,ktyp)
        norbshi = 2*lorbi + 1
        li0 = lorbi*lorbi
c
c    Alpha i loop:
c
      do 262 ial=1,nali
        ali = ala(ial,ishl,ktyp)
        cali = cala(ial,ishl,ktyp)
        if( ali.lt.alvmin ) goto 262
c
        do  lpot=1,10
          eslfac(lpot) = zero
        enddo
c
c    Get value of jorbat-th orbital at nucleus "nuc"
c
        twoali = ali + ali
        jorbat = 0
        do 281 jshl=1,numshl(jtyp)
          nalj = nala(jshl,jtyp)
          lorbj = lshel(jshl,jtyp)
          lj = lorbj*lorbj
          norbshj = 2*lorbj + 1
          do 272 jorbsh=1,norbshj
            jorbat = jorbat + 1
            lj = lj + 1
c
c    Obtain orb, grorb, and grgrorb for all nlat
c
            call WF1COFR( orb,grorb,grgrorb,
     $       nuc,jatm, lj,jtyp,jshl,nalj,
     $       natm,ntyp,nshld,nald, nlat, ala,cala, ratm,rlat,
     $       wf1cwk1,wf1cwk2,wf1cwk3,wf1cwk4,wf1cwk5 )
c
c    Orbital i loop:
c
            iorbat = iorbat0
            li = li0
            do 271 iorbsh=1,norbshi
              iorbat = iorbat + 1
              li = li + 1
c
c    Loop for lattice vector j
c
              do 290 klat=1,nlat
c
c    Skip if jatm and nuc are same atom
c
                if( klat.eq.1 .and. jatm.eq.nuc ) goto 290
c
                dmfac = two*dmatwk(iorbat,jorbat,klat)/vnorm(li)
                rtali = SQRT( ali )
                rtpial = rtpi/rtali
                cofac = dmfac*two*cali*(rtpial**3)/(twoali**lorbi)
                coeff = cofac*orb(klat)
c
c    Accumulate counter-charge:
c
                numpot = npots(li,1)
                if( numpot.eq.1 )then
                  lpot = lpots(li,1)
                  if( lpot.gt.lpotmax ) goto 272
                  eslfac(lpot) = eslfac(lpot) + coeff
                else
                  do  npt=1,numpot
                    wt = wght(npt,numpot)
                    lpot = lpt(npt)
                    if( lpot.gt.lpotmax ) goto 272
                    eslfac(lpot) = eslfac(lpot) + coeff*wt
                  enddo
                endif
c
                if( lorbi+1 .le. lmx1ctr )then
c
c      ... from gradient of orbital j at nucleus i
c
                  do  lgrad=1,3
                    coeff = cofac*grorb(lgrad,klat)/twoali
                    lpot = lpotgr(lgrad,li)
                    eslfac(lpot) = eslfac(lpot) + coeff
                  enddo
                endif
c
                if( lorbi+2 .le. lmx1ctr )then
c
c      ... from grad(grad(orbital j).
c
                  do  lgr=1,3
                    do  llgr=1,lgr
                      if( llgr.eq.lgr )then
                        offd = half
                      else
                        offd = one
                      endif
                      coeff =cofac*offd*grgrorb(llgr,lgr,klat)/twoali**2
                      lpot = lpgrgr(llgr,lgr)
                      eslfac(lpot) = eslfac(lpot) + coeff
                    enddo
                  enddo
                endif
c
c    Close lattice vector loop:
c
  290         continue
c
c    Close orbital i loop:
c
  271       continue
c
c    Close orbital j loop:
c
  272     continue
c
c    Close jshl loop:
c
  281   continue
c
        do  lpot=1,10
          if( eslfac(lpot).ne.zero ) goto 420
        enddo
        goto 262
c
c    Add potential to ves1c:
c
  420   sesl = zero
        do  lpot=8,10
          sesl = sesl + twoali*eslfac(lpot)
        enddo
c
        do  nr=1,nrs
          erfiwk(nr) = DERF(rtali*radmsh(nr))/radmsh(nr) - erfwork(nr)
        enddo
c
        eslfac(1) = eslfac(1) + sesl
        do 440 lpot=1,10
          eslp = eslfac(lpot)
          if( eslp.ne.zero )then
            eslongr(lpot) = eslongr(lpot) + half*eslp
            do  nr=1,nrs
              ves1c(nr,lpot) = ves1c(nr,lpot) + eslp*erfiwk(nr)
            enddo
          endif
  440   continue
c
c    Close alpha i loop:
c
  262 continue
c
c    Close ishl loop:
c
  282 iorbat0 = iorbat0 + norbshi
c
c  Calculate coefficients of counter charges to cancel
c  long-ranged portions of the 1-center potential.
c
        do 950 lpot=1,lpotmax
          dcountr(lpot) = eslongr(lpot)
          if( lpot.lt.8 ) goto 950
          dcountr(1) = dcountr(1) - two*alvmin*eslongr(lpot)
  950   continue
c
c    Close atom j loop:
c
 1000 continue
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c           Finished with electrostatic potentials
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Check if we have an xc-fit potential to build:
      if( itypxc.eq.0 ) RETURN
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c        Complete accumulation of rholoc, the density
c        associated with atom "nuc" on a spherical mesh.
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Initialize xc-fit Gaussian coefficients:
      do  ialfxc=1,nalfxc
        do  ilxc=1,10
          cv(ilxc,ialfxc) = zero
          ce(ilxc,ialfxc) = zero
        enddo
      enddo
c
c  To compute contribution of terms where one atom is not "nuc,"
c  multiply Taylor series coefficients by angular factors.
c
      do 1070 iorbat=1,norba(ktyp)
        do  iang=1,nang
          x = angpts(1,iang)
          y = angpts(2,iang)
          z = angpts(3,iang)
          twoy = y + y
          twoz = z + z
          gofac(iang) = grorbj(1,iorbat)*x + grorbj(2,iorbat)*y +
     $     grorbj(3,iorbat)*z
          ggofac(iang) = x*( x*grgrorj(1,1,iorbat) +
     $     twoy*grgrorj(2,1,iorbat) + twoz*grgrorj(3,1,iorbat) ) +
     $     y*( y*grgrorj(2,2,iorbat) + twoz*grgrorj(3,2,iorbat) ) +
     $     z*z*grgrorj(3,3,iorbat)
        enddo
c
c  Multiply by orbital i and radial factors then accumulate density
c
        do  nr=1,nrxc
          r = radmsh(nr)
          rsq = r*r
          do  iang=1,nang
            orbi = radwf(iang,nr,iorbat)
            orbfac = orbj(iorbat) + r*gofac(iang) + rsq*ggofac(iang)
            rholoc(nr,iang) = rholoc(nr,iang) + orbi*orbfac
          enddo
        enddo
c
 1070 continue
c
c  (1/4/90)-PJF: In this attempt, I deliberately do not add to rholoc
c  the contributions from the tails of the neighboring atoms.
c  This contribution would require computing additional dmatwk matrix
c  elements, and the resulting contribution to the density is small.
c  20Feb93-PAS: tails of nearby atoms approximated by adding
c  density from initial occupations (computed by ATMRHO in setup)
c
c  At this point, the density on the spherical mesh around atom "iatm"
c  has been accumulated in "rholoc".  Now evaluate the exchange
c  correlation potential and energy density.
c
      rhat0 = rholoc(1,1)
      rhat = zero
      rnorm = zero
      do  nr=1,nrxc
        do  iang=1,nang
          rhat = rhat + radwt(nr)*rholoc(nr,iang)*angwts(iang)
          rnorm = rnorm + radwt(nr)*angwts(iang)*angylm(iang,1)
          call DFTLDA( rholoc(nr,iang), vxcloc(nr,iang),excloc(nr,iang))
        enddo
      enddo
c
c  Now project out l,m components of vxcloc and excloc using values
c  of real ylm's on unit sphere in array angylm.
c
      lval = 1
      do 1200 lm=1,lp1sq
c
        if( lm.eq.1 )then
          do  ialfxc=1,nalfxc
            do  nr=1,nrxc
              r = radmsh(nr)
              rfac(nr,ialfxc) = radwt(nr)*EXP( -alfxc(ialfxc)*r*r )
            enddo
          enddo
          vn1 = vnorm(1)
c  Subtract isolated atom spherical parts
          do  nr=1,nrxc
            vlm(nr) = -vn1*vxcrad(nr)
            elm(nr) = -vn1*excrad(nr)
          enddo
        else
          do  nr=1,nrxc
            vlm(nr) = zero
            elm(nr) = zero
          enddo
        endif
c
        do  iang=1,nang
          angfac = angwts(iang)*angylm(iang,lm)
          do  nr=1,nrxc
            vlm(nr) = vlm(nr) + angfac*vxcloc(nr,iang)
            elm(nr) = elm(nr) + angfac*excloc(nr,iang)
          enddo
        enddo
cpas:start
        if( lm.eq.1 )then
          vreq0 = vxcloc(1,1)
          ereq0 = excloc(1,1)
          vleq0 = vlm(1) / vnorm(1)
          eleq0 = elm(1) / vnorm(1)
C         write(IWR,1313)  nuc,rhat,rhat0,vreq0,ereq0,vleq0,eleq0
 1313 format(1x,'NUC',i2,' elns=',2f12.8/1x,'vxc(0),exc(0)=',4f12.8)
        endif
cpas:end
c
c  Now least squares fit vlm and elm to linear combinations of
c  gaussians times r**l, by solving AX=B.  Compute B vectors:
c
        do  ialfxc=1,nalfxc
          vg(ialfxc,lm) = zero
          eg(ialfxc,lm) = zero
          do  nr=1,nrxc
            vg(ialfxc,lm) = vg(ialfxc,lm) + vlm(nr)*rfac(nr,ialfxc)
            eg(ialfxc,lm) = eg(ialfxc,lm) + elm(nr)*rfac(nr,ialfxc)
          enddo
        enddo
c
c   Using saved matrices for this atom type, solve AX=B problem to
c   determine best fit coefficients for vxc and exc.
c
clib: disable calls to linpack/dsisl
        call STOPXERR( 'DSIABLED - removed linpack/dsisl calls' )
clib        call DSISL(alsq(1,1,lval),nalfxcd,nalfxc,ipvt(1,lval),vg(1,lm))
clib        call DSISL(alsq(1,1,lval),nalfxcd,nalfxc,ipvt(1,lval),eg(1,lm))
c
        if( lm.eq.1 .or. lm.eq.4 )then
          lval = lval + 1
          do  ialfxc=1,nalfxc
            do  nr=1,nrxc
              rfac(nr,ialfxc) = rfac(nr,ialfxc)*radmsh(nr)
            enddo
          enddo
        endif
c
 1200 continue
c
c  This ends lm loop.  Output is set of coefficients "vg" and "eg" for
c  the xc potential and energy density about atom "nuc."
c
c  Assemble rapidly varying components of Vxc and Exc on radial mesh,
c  using fit coefficients corresponding to the Gaussians that vary
c  rapidly.  That is, only use the coefficients in the just completed
c  fit corresponding to alphas greater than alv1cmn.
c
      do 1500 ialfxc=1,nalfxc
        alfi = alfxc(ialfxc)
        twoalfi = alfi + alfi
        if( alfi.lt.alxmin ) goto 1500
c
c      First reorganize coeffs so that potentials are proportional to:
c      1,x,y,z,xy,yz,zx,x**2,y**2,z**2
c
        cv( 1,ialfxc) = vg(ialfxc,1)/vnorm(1)
        ce( 1,ialfxc) = eg(ialfxc,1)/vnorm(1)
c
        if( lpotmax.gt.1 )then
          cv( 2,ialfxc) = -vg(ialfxc,2)/vnorm(2)
          cv( 3,ialfxc) = -vg(ialfxc,3)/vnorm(2)
          cv( 4,ialfxc) =  vg(ialfxc,4)/vnorm(2)
          ce( 2,ialfxc) = -eg(ialfxc,2)/vnorm(2)
          ce( 3,ialfxc) = -eg(ialfxc,3)/vnorm(2)
          ce( 4,ialfxc) =  eg(ialfxc,4)/vnorm(2)
        endif
c
        if( lpotmax.gt.4 )then
          cv( 5,ialfxc) =  vg(ialfxc,5)/vnorm(5)
          cv( 6,ialfxc) = -vg(ialfxc,6)/vnorm(5)
          cv( 7,ialfxc) = -vg(ialfxc,7)/vnorm(5)
          vg1334 = vg(ialfxc,8)/vnorm(8)
          vg1135 = vg(ialfxc,9)/vnorm(9)
          cv( 8,ialfxc) =   vg1334 - vg1135
          cv( 9,ialfxc) = - vg1334 - vg1135
          cv(10,ialfxc) =   vg1135 + vg1135
          ce( 5,ialfxc) =  eg(ialfxc,5)/vnorm(5)
          ce( 6,ialfxc) = -eg(ialfxc,6)/vnorm(5)
          ce( 7,ialfxc) = -eg(ialfxc,7)/vnorm(5)
          eg1334 = eg(ialfxc,8)/vnorm(8)
          eg1135 = eg(ialfxc,9)/vnorm(9)
          ce( 8,ialfxc) =   eg1334 - eg1135
          ce( 9,ialfxc) = - eg1334 - eg1135
          ce(10,ialfxc) =   eg1135 + eg1135
        endif
c
        do  nr=1,nrs
          r = radmsh(nr)
          rfac(nr,ialfxc) = EXP( -alfxc(ialfxc)*r*r )
        enddo
c
        do 1450 lpot=1,lpotmax
          do  nr=1,nrs
            ves1c(nr,lpot) = ves1c(nr,lpot)
     $       + cv(lpot,ialfxc)*rfac(nr,ialfxc)
            pot1c(nr,lpot) = pot1c(nr,lpot)
     $       + cv(lpot,ialfxc)*rfac(nr,ialfxc)
            xen1c(nr,lpot) = xen1c(nr,lpot)
     $       + ce(lpot,ialfxc)*rfac(nr,ialfxc)
          enddo
c
          if( lpot.eq.1 .or. lpot.eq.4 )then
            do  nr=1,nrs
c might need a minus here:
              rfac(nr,ialfxc) = rfac(nr,ialfxc)/twoalfi
            enddo
          endif
c
 1450   continue
c
c    Close loop over fit alphas:
c
 1500 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BOXR
c
c
      subroutine BOXR( hh, ira0,irb0,irc0, idra,idrb,idrc, r0, rmid )
c---------------------------------------------------------------
c Purpose: give cartesian coord of box corner, and midpoint
c
c Written:  Peter A. Schultz, 1-May-1997, for v2.20 (boxes)
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input array: (mesh definition vectors)
      DIMENSION  hh(3,3)
c output array: (r-offset, r-midpoint)
      DIMENSION  r0(3),rmid(3)
c local:
      DATA  half / 0.5d0 /
c
c >>>> EXECUTABLE CODE:
c
      do  i=1,3
        r0(i) = ira0*hh(i,1) + irb0*hh(i,2) + irc0*hh(i,3)
        rmid(i) = (idra-1)*hh(i,1) + (idrb-1)*hh(i,2) + (idrc-1)*hh(i,3)
      enddo
c
      do  i=1,3
        rmid(i) = r0(i) + half*rmid(i)
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BOXRNG
c
c
      subroutine BOXRNG( IWR,lvlout, maxrec,    mngr3,mxgr3,ngr,
     $ ndim, n1r,n2r,n3r, natm,ntyp, nshld,nald,
     $ itypa,numshl,lshel,nala,norba,ala, alamin, ratm,rprim,
     $ hh, ndbox,nbox,nrec,inrec,noboxs,inboxs, boxrad0,
     $ wkbox )
c---------------------------------------------------------------
c Purpose: to determine extent of orbitals on grid, and record
c   which shells are in which boxes, radius of boxes.
c
c Written: Peter A. Schultz,  3-June-1997, for 2.20 (boxes)
c
c Revision history:
c  27Feb07-PAS/2.60: adjust output flags
c   2Dec03-PAS/2.58: add atm/shl record when atom not in cell
c   8Mar02-PAS/2.52: clean unused variables & literal const d0
c  21Jun01-PAS/2.48: replace STOPs
c  24May01-PAS/2.47: transfer out wf storage requirements code
c   2May01-PAS/2.47: remove disk storage of grid orbitals
c  11Apr00-PAS/2.43: pass out length of grid wf storage
c  21Dec99-PAS/2.42: cosmetic clean-up
c  22Jul99-PAS/2.37: filter parallelpiped of boxes, chg diagnostic
c   1May99-PAS/2.35: pass max single box mem.
c   9Jan99-PAS/2.30: redo symmetry scheme
c   9Nov98-PAS/2.28: single precision grid orbitals/wf4
c  10Sep98-PAS/2.26: cosmetic - documentation
c  14May98-PAS/2.22: redid
c---------------------------------------------------------------
c
c Notes:
c  The filter of box occupancy within parallelpiped is done via
c  a crude box-center to atom distance scheme.  This should be
c  good enough.  You'll miss a couple of boxes you should keep
c  where a few points at a corner will be within range of an
c  atom, and you will include some boxes where all the points
c  will be out of range, but not all that many of either.
c  You could do a finer point-wise check for the suspect boxes,
c  but it is not worth the effort and cost.  26Jul99-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp)
      DIMENSION  ratm(3,natm), rprim(3,3), hh(3,3)
      DIMENSION  ndbox(2,2,3),noboxs(nbox),inboxs(*)
cpas:1 these are for non-standard usage
      DIMENSION  mngr3(*),mxgr3(*),ngr(*)
c scratch arrays:
      DIMENSION  wkbox(4,nbox)
c local declarations:
      DIMENSION  rlnn(3,27), r0box(3)
      DIMENSION  g(3,3),rg(3),nrv(3),rnv(3), v(3),irngs(2,3)
      DIMENSION  ibox1(3),iboxn(3)
      LOGICAL    booboo
c
      DATA  zero,half,one / 0.d0,0.5d0,1.d0 /
      DATA  lstout / 1 /
c
c >>>> EXECUTABLE CODE:
c
      booboo = .false.
      lstout = lvlout
      if( lstout.gt.0 ) write(IWR,*)
c
c  Find minimum radius of a sphere that contains largest box:
      do  idim=1,3
        g(1,idim) = (ndbox(1,2,idim)-1)*hh(1,idim)
        g(2,idim) = (ndbox(1,2,idim)-1)*hh(2,idim)
        g(3,idim) = (ndbox(1,2,idim)-1)*hh(3,idim)
      enddo
      rg(1) = half*( g(1,1) + g(1,2) + g(1,3) )
      rg(2) = half*( g(2,1) + g(2,2) + g(2,3) )
      rg(3) = half*( g(3,1) + g(3,2) + g(3,3) )
      sqpp = zero
      sqpm = zero
      sqmp = zero
      sqmm = zero
      do  j=1,3
        sqpp = sqpp +   rg(j)**2
        sqpm = sqpm + ( rg(j) - g(j,3) )**2
        sqmp = sqmp + ( rg(j) - g(j,2) )**2
        sqmm = sqmm + ( rg(j) - g(j,2) - g(j,3) )**2
      enddo
      boxrad0 = MAX( sqpp, sqpm, sqmp, sqmm )
      boxrad0 = SQRT( boxrad0 )
      if( lstout.gt.4 ) write(IWR,*) 'BOXRNG: boxrad=',boxrad0
c
c  Actually, using this true extreme radius without point-wise
c  filter will catch boxes that have very few, even zero, points
c  within range of the atom, unless you do a point-wise check.
c  I sacrifice boxes with a few in-range corner points to kick
c  out boxes with zero in-range points.  I do this by using a
c  box radius that is smaller that the extreme.  Assuming a cube
c  and box radius, the radius is the 111-diag, and the smallest
c  radius is a 100-face, with ratio rt3:1.  Try an intermediate
c  ratio such as .75*rt3:1 (~1.3:1).
      boxrad = 0.75*boxrad0
c
c Collect coordinates of box centers
c
      irpot = 0
      do 30 ibox=1,nbox
c
c  Get basic box info
        call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $   ira0,irb0,irc0, idra,idrb,idrc )
        nrbox = idra*idrb*idrc
c
        iv0 = irpot
        irpot = irpot + nrbox
c
c  Generate coordinates
        call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,v )
c  Load coordinates of center of this box:
        wkbox(1,ibox) = v(1)
        wkbox(2,ibox) = v(2)
        wkbox(3,ibox) = v(3)
c        call MKRBOX( hh,r0box, idra,idrb,idrc, r(1,iv0+1) )
c
   30 continue
c
c Set up nearby lattice vectors
c
      nla = 0
      nlb = 0
      nlc = 0
      if( ndim.gt.0 ) nla = 1
      if( ndim.gt.1 ) nlb = 1
      if( ndim.gt.2 ) nlc = 1
c  Put origin first
      il = 1
      rlnn(1,1) = zero
      rlnn(2,1) = zero
      rlnn(3,1) = zero
      do  kc=-nlc,nlc
        do  kb=-nlb,nlb
          do  ka=-nla,nla
            if( ka.ne.0 .or. kb.ne.0 .or. kc.ne.0 )then
              il = il + 1
              rlnn(1,il) = ka*rprim(1,1) + kb*rprim(1,2) + kc*rprim(1,3)
              rlnn(2,il) = ka*rprim(2,1) + kb*rprim(2,2) + kc*rprim(2,3)
              rlnn(3,il) = ka*rprim(3,1) + kb*rprim(3,2) + kc*rprim(3,3)
            endif
          enddo
        enddo
      enddo
      nlnn = il
c
      nrv(1) = n1r
      nrv(2) = n2r
      nrv(3) = n3r
c generate orthogonal projection of grid vectors:
      call CROSS( hh(1,2),hh(1,3), g(1,1) )
      call CROSS( hh(1,3),hh(1,1), g(1,2) )
      call CROSS( hh(1,1),hh(1,2), g(1,3) )
      do  id=1,3
        gmag = SQRT( g(1,id)**2+g(2,id)**2+g(3,id)**2 )
        g(1,id) = g(1,id)/gmag
        g(2,id) = g(2,id)/gmag
        g(3,id) = g(3,id)/gmag
        rnv(id) = DBLE( nrv(id) )
        rg(id) = hh(1,id)*g(1,id) + hh(2,id)*g(2,id) + hh(3,id)*g(3,id)
        if( rg(id).lt.zero )then
          rg(id) = -rg(id)
          g(1,id) = -g(1,id)
          g(2,id) = -g(2,id)
          g(3,id) = -g(3,id)
        endif
      enddo
c
c  Make sure have enough box records
      natshl = 0
      do  iatm=1,natm
        ityp = itypa(iatm)
        natshl = natshl + numshl(ityp)
      enddo
      nrec = (natshl+inrec-1)/inrec
      if( nrec.gt.(maxrec-1) )then
        write(IWR,*) '>>>>> nrec,nbox=',nrec,nbox
        write(IWR,*) '>>>>> need nrecd =',(nrec+1)*nbox
        call STOPXERR( 'box-recs/not enough box records (nrecd)' )
      else
c       Clear out box records
        do  ibox=1,nbox
          noboxs(ibox) = 0
        enddo
        do  ibr=1,nrec*nbox
          inboxs(ibr) = 0
        enddo
      endif
c
 9000 format(/1x,'ATOMIC ORBITAL RANGES:', /1x,
     $   ' Atom Shell  Min-alf     range',14x,'grid range')
 9001 format( 1x,i4,3x,2x,1x,f10.6,f11.6 )
 9002 format( 1x,4x,3x,i2,1x,f10.6,f11.6,3x,
     $ 2('(',i3,'-',i3,')x'),'(',i3,'-',i3,')' )
 9012 format( 2x,4x,3x,i2,1x,f10.6,f11.6)
 9003 format( 1x,4x,3x,2x,1x, 10x ,'nbox = ',i4,' = ',
     $ 2('(',i3,'-',i3,')x'),'(',i3,'-',i3,')' )
c
      if( lstout.gt.0 )then
        write(IWR,*) ' Atom'
        write(IWR,*) ' Type  Shell  Min-alf     range'
        do  ityp=1,ntyp
          almina = alamin(ityp)
          range = SQRT( cutgrid / (almina+almina) )
          write(IWR,9001)  ityp,almina,range
          if( lstout.gt.2 )then
            do  ishl=1,numshl(ityp)
              almins = ala(1,ishl,ityp)
              do  ial=1,nala(ishl,ityp)
                ali = ala(ial,ishl,ityp)
                if( ali.lt.almins ) almins = ali
              enddo
              almin = almina
              range = SQRT( cutgrid / (almin +almins) )
              write(IWR,9012)  ishl,almins,range
            enddo
          endif
        enddo
      endif
c
      if( lstout.gt.3 ) write(IWR,9000)
cpas:1 for non-standard code
      iorb = 0
      nobchk = 0
      nobocc = 0
      nsbchk = 0
      nsbocc = 0
      irec = 0
      iatshl = 0
      inbox = 0
      do 300 iatm=1,natm
        ityp = itypa(iatm)
c
        do  idim=1,3
          v(idim) = ratm(1,iatm)*g(1,idim)
     $            + ratm(2,iatm)*g(2,idim)
     $            + ratm(3,iatm)*g(3,idim)
        enddo
c
        almina = alamin(ityp)
        range = SQRT( cutgrid / (almina+almina) )
c
        if( lstout.gt.3 ) write(IWR,9001)  iatm,almina,range
c
c  Do grid orbitals ranges, shell-by-shell:
c  On the first pass through, create cutoff alpha using longest
c  alpha on atom.  This is a bad hack, but other choices are bad, too.
        do 280 ishl=0,numshl(ityp)
c
          if( ishl.eq.0 )then
c
c  Pass 0: Compute cutoff alphas by box, use longest atom alpha
c
            almins = almina
c
          else
c
c  Otherwise, go ahead and compute ranges
c
            norbsh = 2*lshel(ishl,ityp) + 1
            inbox = inbox*2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = 1
            endif
            iatshl = iatshl + 1
c
            almins = ala(1,ishl,ityp)
            do  ial=2,nala(ishl,ityp)
              ali = ala(ial,ishl,ityp)
              if( ali.lt.almins ) almins = ali
            enddo
c
          endif
          almin = almina
          range = SQRT( cutgrid / (almin +almins) )
c
          do 150 idim=1,3
            irdim = nrv(idim)
            rdim = rg(idim)
c  Get orbital range ...
            rmn = (v(idim) - range)/rdim
            rmx = (v(idim) + range)/rdim
            if( rmn.gt.-half )then
              irmn = ( rmn + half + one )
            else
              irmn = -ABS( rmn - half - one )
            endif
            if( rmx.gt.-half )then
              irmx = ( rmx + half + one )
            else
              irmx = -ABS( rmx - half - one )
            endif
c
            if( idim.gt.ndim .and. (irmn.lt.1 .or. irmx.gt.irdim) )then
c             See how bad it is
              ioutdn = MAX( 0, 1 - irmn )
              ioutup = MAX( 0, irmx - irdim )
              routdn = ioutdn*rg(idim)
              routup = ioutup*rg(idim)
  913         format(1x,a,4i6)
  914         format(1x,a,2f12.3)
              write(IWR,913)
     $         '***** WARNING: orbitals extend outside unit cell'
              write(IWR,913)
     $         '>>>>> atom,shell,direction=',iatm,ishl,idim
              write(IWR,913)
     $         '>>>>> Grid: irmn,irmx, limits=',irmn,irmx, 1,irdim
              write(IWR,914)
     $         '>>>>> outside cell (dn/up) by:', routdn,routup
              rngerr = MAX( routup, routdn )
              if( rngerr/range .gt. 0.25d0 )then
                booboo = .true.
              endif
              irmn = MAX( irmn, 1 )
              irmx = MIN( irmx, irdim )
            endif
c
c  ... and convert to range over boxes
            nbox1 = ndbox(1,1,idim)
            nbox2 = ndbox(2,1,idim)
            nboxs = nbox1 + nbox2
            idr1 = ndbox(1,2,idim)
            idr2 = ndbox(2,2,idim)
            if( (irmx-irmn+idr1) .gt. irdim ) then
              ibox1(idim) = 1
              iboxn(idim) = nboxs
              jrmn = 1
              jrmx = irdim
            else
              jrmn = irmn
              if( irmn.lt.1 ) jrmn = irmn + irdim
              if( jrmn.gt.(nbox1*idr1) )then
                ibox1(idim) = nbox1 + (jrmn-nbox1*idr1+idr2-1) / idr2
              else
                ibox1(idim) = (jrmn+idr1-1) / idr1
              endif
              jrmx = irmx
              if( irmx.gt.irdim ) jrmx =  irmx - irdim
              if( jrmx.gt.(nbox1*idr1) )then
                iboxn(idim) = nbox1 + (jrmx-nbox1*idr1+idr2-1) / idr2
              else
                iboxn(idim) = (jrmx+idr1-1) / idr1
              endif
              if( irmn.lt.  1   ) ibox1(idim) = ibox1(idim) - nboxs
              if( irmx.gt.irdim ) iboxn(idim) = iboxn(idim) + nboxs
c    ... check if have all boxes
              if( (iboxn(idim)-ibox1(idim)+1) .ge. nboxs ) then
                ibox1(idim) = 1
                iboxn(idim) = nboxs
              elseif( ibox1(idim).lt.1 )then
                ibox1(idim) = ibox1(idim) + nboxs
                iboxn(idim) = iboxn(idim) + nboxs
              endif
            endif
            irngs(1,idim) = jrmn
            irngs(2,idim) = jrmx
  150     continue
c
c At this point, use range to box to determine cutoff alpha,
c and use this cutoff alpha to determine if shell overlaps box.
c Only want to compute cutoffs once, hence need to branch here
c according to: first pass, compute cutoff alphas; second
c passes for shells all cutoff alphas already computed, load
c box occupancies.
c
          nboxa = ndbox(1,1,1) + ndbox(2,1,1)
          nboxb = ndbox(1,1,2) + ndbox(2,1,2)
          nboxc = ndbox(1,1,3) + ndbox(2,1,3)
          jboxa1 = ibox1(1)
          jboxb1 = ibox1(2)
          jboxc1 = ibox1(3)
          jboxan = iboxn(1)
          jboxbn = iboxn(2)
          jboxcn = iboxn(3)
          nboxat = (jboxan-jboxa1+1)*(jboxbn-jboxb1+1)*(jboxcn-jboxc1+1)
c
          if( ishl.eq.0 )then
c
c  Cycle over boxes potentially within range of any shell of this atom:
            do 173 jboxc=jboxc1,jboxcn
              iboxc = jboxc
              if( jboxc.gt.nboxc ) iboxc = jboxc - nboxc
              do 172 jboxb=jboxb1,jboxbn
                iboxb = jboxb
                if( jboxb.gt.nboxb ) iboxb = jboxb - nboxb
                do 171 jboxa=jboxa1,jboxan
                  iboxa = jboxa
                  if( jboxa.gt.nboxa ) iboxa = jboxa - nboxa
                  ibox = iboxa + nboxa*( iboxb - 1 + nboxb*(iboxc-1) )
c  Compute cutoff alphas for all boxes w/in range of longest atom shell
                  ilmn = 1
                  rsqmn = (ratm(1,iatm)-wkbox(1,ibox))**2
     $                  + (ratm(2,iatm)-wkbox(2,ibox))**2
     $                  + (ratm(3,iatm)-wkbox(3,ibox))**2
                  do 170 il=2,nlnn
                    rsq = (ratm(1,iatm)-wkbox(1,ibox)-rlnn(1,il))**2
     $                  + (ratm(2,iatm)-wkbox(2,ibox)-rlnn(2,il))**2
     $                  + (ratm(3,iatm)-wkbox(3,ibox)-rlnn(3,il))**2
                    if( rsq.lt.rsqmn )then
                      ilmn = il
                      rsqmn = rsq
                    endif
  170             continue
c  We have a range**2 of box, convert to max alpha that overlaps it:
                  rngbox = SQRT( rsqmn ) - boxrad
                  if( rngbox.lt. 1.d-8 ) rngbox = 1.d-8
                  cutalf = cutgrid/(rngbox**2) - almin
                  wkbox(4,ibox) = cutalf
  171           continue
  172         continue
  173       continue
c
          else
c
c  Cycle over boxes potentially within range of this shell ...
            do 183 jboxc=jboxc1,jboxcn
              iboxc = jboxc
              if( jboxc.gt.nboxc ) iboxc = jboxc - nboxc
              do 182 jboxb=jboxb1,jboxbn
                iboxb = jboxb
                if( jboxb.gt.nboxb ) iboxb = jboxb - nboxb
                do 181 jboxa=jboxa1,jboxan
                  iboxa = jboxa
                  if( jboxa.gt.nboxa ) iboxa = jboxa - nboxa
                  ibox = iboxa + nboxa*( iboxb - 1 + nboxb*(iboxc-1) )
c   ... and check shell alpha against cutoff alpha to overlap box:
                  if( almins.lt.wkbox(4,ibox) )then
                    nirec = nrec*(ibox-1) + irec
                    noboxs(ibox) = noboxs(ibox) + norbsh
                    inboxs(nirec) = inboxs(nirec) + inbox
c
                    nsbocc = nsbocc + 1
                    nobocc = nobocc + norbsh
                  endif
c
                    nsbchk = nsbchk + 1
                    nobchk = nobchk + norbsh
  181           continue
  182         continue
  183       continue
c
cpas:start/oldstuff
            imin3 = irngs(1,3)
            imax3 = irngs(2,3)
            nr = n1r*n2r*(imax3-imin3+1)
            do  iorbsh=1,norbsh
              iorb = iorb + 1
              ngr(iorb) = nr
              mngr3(iorb) = imin3
              mxgr3(iorb) = imax3
            enddo
cpas:end/oldstuff
            if( lstout.gt.4 )then
              write(IWR,9002) ishl,almins,range,irngs
              if( lstout.gt.5 )
     $          write(IWR,9003)   nboxat,
     $           jboxa1,jboxan,jboxb1,jboxbn,jboxc1,jboxcn
            endif
c
          endif
c
  280   continue
c
  300 continue
c
      if( lstout.gt.3 )then
        write(IWR,'(a,2i10)')'BOXRNG: shell/orb box chks=',nsbchk,nobchk
        write(IWR,'(a,2i10)')'BOXRNG: shell/orb box occs=',nsbocc,nobocc
      endif
c
      if( booboo )then
        call STOPXERR( 'orb-rng /orbitals range too far outside cell' )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BOXWFN
c
c
      subroutine BOXWFN( ibox, ncplx,
     $ nk,nk0,nkloc, natm,ntyp, nshld,nald, nlat,
     $ itypa,numshl,lshel,nala,ala,cala, alamin,ratm,rlat,coskr,sinkr,
     $ nobox,nrbox,nrec,inrec,inboxs, boxrad,boxctr,
     $ wvfcns, wf,
     $ r, sumg,rsq, rv1,rv2,rv3,rv4,rv5 )
c---------------------------------------------------------------
c Purpose: generate orbitals on regular space grid for a box
c
c Written: Peter A. Schultz, 28-May-1997, for v2.20 (boxes)
c
c Revision history:
c  18Jan09-PAS/2.63: k-parallel
c   7Mar02-PAS/2.52: ang constants extracted
c  21Jun01-PAS/2.48: replace STOPs
c  21Dec99-PAS/2.42: cosmetic clean-up
c   9Nov98-PAS/2.28: single precision grid orbitals/wf4
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns,wf
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), ratm(3,natm), rlat(3,nlat)
      DIMENSION  coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  inboxs(nrec,ibox), boxctr(3)
      DIMENSION  r(3,*)
c output arrays:
      DIMENSION  wvfcns(2,*),wf(*)
c scratch arrays:
      DIMENSION  sumg(*),rsq(*)
      DIMENSION  rv1(*),rv2(*),rv3(*),rv4(*),rv5(*)
c local declarations:
      DIMENSION  ratom(3)
c
      DIMENSION  vnorm(5)
      DATA  zero, three / 0.d0, 3.d0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
c Get angular normalizations:
      call VNORMS( vnorm )
      ang4 = vnorm(3) / vnorm(4)
      ang5 = vnorm(3) / vnorm(5)
c
      nrkbox = nkloc*nrbox
c
      ir00 = 0
      inbox = 0
c
c    Clear out wave function array:
c
      nwf = ncplx*nkloc*nobox*nrbox
      if( ncplx.eq.1 )then
        call MKSZERO( nwf, wf(ir00+1) )
      else
        call MKSZERO( nwf, wvfcns(1,ir00+1) )
      endif
c
c    Center loop:
c
      irec = 0
      iatshl = 0
      irshl = ir00
      do 1000 iatm=1,natm
        ityp = itypa(iatm)
        almina = alamin(ityp)
c
        do 800 ishl=1,numshl(ityp)
          norbshi = 2*lshel(ishl,ityp) + 1
          inbox = inbox/2
          if( inrec*(iatshl/inrec).eq.iatshl )then
            irec = irec + 1
            inbox = inboxs(irec,ibox)
          endif
          iatshl = iatshl + 1
          if( EVEN(inbox) ) goto 800
c
          lshl = lshel(ishl,ityp)
          nali = nala(ishl,ityp)
c
          almins = ala(1,ishl,ityp)
          do  ial=2,nali
            ali = ala(ial,ishl,ityp)
            if( ali.lt.almins ) almins = ali
          enddo
          almin = almina
          rngmax = SQRT( cutgrid / (almin +almins) )
c
c  Cycle through lattice vectors:
c
          do 900 ilat=1,nlat
c
            rngbox = zero
            do  jr=1,3
              ratom(jr) = ratm(jr,iatm) + rlat(jr,ilat)
              rngbox = rngbox + (ratom(jr)-boxctr(jr))**2
            enddo
            rngbox = SQRT( rngbox ) - boxrad
            if( rngbox.gt.rngmax ) goto 900
c
            rsqbox = rngbox**2
            if( rngbox.lt.zero ) rsqbox = zero
c
            do  nr=1,nrbox
              rv1(nr) = r(1,nr) - ratom(1)
              rv2(nr) = r(2,nr) - ratom(2)
              rv3(nr) = r(3,nr) - ratom(3)
              rsq(nr) = rv1(nr)**2 + rv2(nr)**2 + rv3(nr)**2
              sumg(nr) = zero
            enddo
c
            ndo = 0
            do 70 ial=1,nali
              alf = ala(ial,ishl,ityp)
              twoalc = alf + almin
              rsqcut = cutgrid/twoalc
              if( rsqbox.gt.rsqcut ) goto 70
c
              coef = cala(ial,ishl,ityp) / vnorm(lshl+1)
              ndo = ndo + 1
              do  nr=1,nrbox
                sumg(nr) = sumg(nr) + coef*EXP( -alf*rsq(nr) )
              enddo
   70       continue
            if( ndo.eq.0 ) goto 900
c
            if( ncplx.eq.1 )then
c
c >>>>> Real orbitals/molecular systems
c
              ir0 = irshl
              if( lshl.eq.0 )then
c
                do  nr=1,nrbox
                  wf(ir0+nr) = wf(ir0+nr) + sumg(nr)
                enddo
c
              elseif( lshl.eq.1 )then
c
                nr1 = ir0
                nr2 = nr1 + nrkbox
                nr3 = nr2 + nrkbox
                do  nr=1,nrbox
                  wf(nr1+nr) = wf(nr1+nr) + sumg(nr)*rv1(nr)
                  wf(nr2+nr) = wf(nr2+nr) + sumg(nr)*rv2(nr)
                  wf(nr3+nr) = wf(nr3+nr) + sumg(nr)*rv3(nr)
                enddo
c
              elseif( lshl.eq.2 )then
c
                nr1 = ir0
                nr2 = nr1 + nrkbox
                nr3 = nr2 + nrkbox
                nr4 = nr3 + nrkbox
                nr5 = nr4 + nrkbox
                do  nr=1,nrbox
                  wf(nr1+nr) = wf(nr1+nr) + sumg(nr) * rv1(nr)*rv2(nr)
                  wf(nr2+nr) = wf(nr2+nr) + sumg(nr) * rv2(nr)*rv3(nr)
                  wf(nr3+nr) = wf(nr3+nr) + sumg(nr) * rv3(nr)*rv1(nr)
                  wf(nr4+nr) = wf(nr4+nr) + sumg(nr) *
     $             (rv1(nr)**2-rv2(nr)**2)*ang4
                  wf(nr5+nr) = wf(nr5+nr) + sumg(nr) *
     $             (three*rv3(nr)**2-rsq(nr))*ang5
                enddo
c
              else
c
                call STOPXERR( 'boxwfn-l/lshl is too high' )
c
              endif
c
            else
c
c >>>>> Complex orbitals/periodic systems
c
c start out with some arithmetic to accelerate things
              if( lshl.eq.1 )then
                do  nr=1,nrbox
                  rv1(nr) = sumg(nr)*rv1(nr)
                  rv2(nr) = sumg(nr)*rv2(nr)
                  rv3(nr) = sumg(nr)*rv3(nr)
                enddo
              elseif( lshl.eq.2 )then
c the order in which I do this critical for memory mgmt
                do  nr=1,nrbox
                  rsq(nr) = sumg(nr)*(three*rv3(nr)**2-rsq(nr))*ang5
                  rv4(nr) = sumg(nr)*(rv1(nr)**2-rv2(nr)**2)*ang4
                  rv5(nr) = sumg(nr)*rv1(nr)*rv2(nr)
                  rv2(nr) = sumg(nr)*rv2(nr)*rv3(nr)
                  rv3(nr) = sumg(nr)*rv3(nr)*rv1(nr)
                enddo
              endif
c
              ir0 = irshl
              do 400 ikloc=1,nkloc
                ik = nk0 + ikloc
                facr = coskr(ik,ilat)
                faci = sinkr(ik,ilat)
c
                if( lshl.eq.0 )then
c
                  do  nr=1,nrbox
                    wvfcns(1,ir0+nr) = wvfcns(1,ir0+nr) + facr*sumg(nr)
                    wvfcns(2,ir0+nr) = wvfcns(2,ir0+nr) + faci*sumg(nr)
                  enddo
c
                elseif( lshl.eq.1 )then
c
                  nr1 = ir0
                  nr2 = nr1 + nrkbox
                  nr3 = nr2 + nrkbox
                  do  nr=1,nrbox
                    wvfcns(1,nr1+nr) = wvfcns(1,nr1+nr) + facr*rv1(nr)
                    wvfcns(2,nr1+nr) = wvfcns(2,nr1+nr) + faci*rv1(nr)
                    wvfcns(1,nr2+nr) = wvfcns(1,nr2+nr) + facr*rv2(nr)
                    wvfcns(2,nr2+nr) = wvfcns(2,nr2+nr) + faci*rv2(nr)
                    wvfcns(1,nr3+nr) = wvfcns(1,nr3+nr) + facr*rv3(nr)
                    wvfcns(2,nr3+nr) = wvfcns(2,nr3+nr) + faci*rv3(nr)
                  enddo
c
                elseif( lshl.eq.2 )then
c
                  nr1 = ir0
                  nr2 = nr1 + nrkbox
                  nr3 = nr2 + nrkbox
                  nr4 = nr3 + nrkbox
                  nr5 = nr4 + nrkbox
                  do  nr=1,nrbox
                    wvfcns(1,nr1+nr) = wvfcns(1,nr1+nr) + facr*rv5(nr)
                    wvfcns(2,nr1+nr) = wvfcns(2,nr1+nr) + faci*rv5(nr)
                    wvfcns(1,nr2+nr) = wvfcns(1,nr2+nr) + facr*rv2(nr)
                    wvfcns(2,nr2+nr) = wvfcns(2,nr2+nr) + faci*rv2(nr)
                    wvfcns(1,nr3+nr) = wvfcns(1,nr3+nr) + facr*rv3(nr)
                    wvfcns(2,nr3+nr) = wvfcns(2,nr3+nr) + faci*rv3(nr)
                    wvfcns(1,nr4+nr) = wvfcns(1,nr4+nr) + facr*rv4(nr)
                    wvfcns(2,nr4+nr) = wvfcns(2,nr4+nr) + faci*rv4(nr)
                    wvfcns(1,nr5+nr) = wvfcns(1,nr5+nr) + facr*rsq(nr)
                    wvfcns(2,nr5+nr) = wvfcns(2,nr5+nr) + faci*rsq(nr)
                  enddo
c
                else
c
                  call STOPXERR( 'boxwfn-l/lshl is too high' )
c
                endif
c
c  Close bloch vector loop:
c
                ir0 = ir0 + nrbox
  400         continue
c
            endif
c
c  Close lattice vector loop:
c
  900     continue
c
c  Close shell/atom loops:
c
          irshl = irshl + norbshi*nrkbox
  800   continue
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROYDDJ
c
c
      subroutine BROYDDJ( IWR, sufx, iter,nhist, blendfac,
     $ chg, nvec,
     $ vv1,vv2,vv3,vv4 )
c---------------------------------------------------------------
c Purpose: blend guess vectors using Johnson modified Broyden
c          [D.D. Johnson, PRB 38,12807 (1988)]
c
c Written: Peter A. Schultz
c          Based on original code by D.D. Johnson
c          Via code modified by P.J. Feibelman
c
c Revision history:
c  13Feb07-PAS/2.60: make more consistent w/pbroyddj;
c                    extract file-handling to separate file
c   5Feb03-PAS/2.57a: fix bug in diagnostic output (prune),
c     and fix bug that sets number of Broyden files.
c  11Sep03-PAS/2.57: push itmaxd into broyden
c   8Jan03-PAS/2.55: file size limits, limited history added
c   8Mar02-PAS/2.52: literal constants to d0
c   6Dec01-PAS/2.51: file mgmt
c  11Oct01-PAS/2.50: purge 'inquire' usage
c  21Dec99-PAS/2.42: cosmetic clean-up
c  15Feb99-PAS/2.31: routine to intercept perhaps too-big i/o
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  22Sep97-PAS/2.21: pass dv in vv1, take out convrg tests,
c                    use for geo opt, and rename.
c   9May95-PAS/2.12: shrink memory usage 2X
c---------------------------------------------------------------
c
c Notes:
c  This routine protects itself like a module.
c  It is initialized with input of iter.le.1, but afterwards
c  maintains its state internally.  It should be able to
c  protect itself from all eventualities short of malicious
c  tampering with its files.
c
c Variables:
c  sufx  = character string/tag identifying optimized quantity
c  iter  = .le.1 - restart broyden; else - *ignored*
c          (broyden step numbers are maintained internally)
c  nhist = if>0, max number of steps used in Broyden history
c  blendfac = mixing parameter for first step
c          (recommend: electronic: ~.1->.3; geometric: ~0.5->6.0)
c  chg   = for weighting set, measure of goodnees of this set
c          (e.g. max force/change, or rms, etc)
c
c  nvec  = length of vector to be optimized
c  vv2() = v(in) [input] -> new guess v() [output]
c  vv1() = dv()  [input]
c  vv3,vv4 = scratch space of dimensioned length
c
c  itmaxd = maximum number of active Broyden steps
c
c Notes:
c  u() and dft() = johnson's u() and df(transpose)
c    These are continually updated and all iterations stored on
c    unit ibroyfl to avoid memory cost of holding entire jacobian
c  dv()  = v(out) - v(in) OR d(F)/d(v())
c  ddv() = dv(m+1) - dv(m)
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.0d0, one=1.0d0 )
c
c Input/Output:
      CHARACTER  sufx*(*)
      DIMENSION  vv1(nvec),vv2(nvec)
c Scratch:
      DIMENSION  vv3(*),vv4(*)
c
c Local declarations:
c    itmaxd = max steps in history for blend (30 is likely overkill)
      PARAMETER  ( itmaxd = 30 )
      DIMENSION  a(itmaxd,itmaxd),b(itmaxd,itmaxd),cm(itmaxd)
      DIMENSION  d(itmaxd,itmaxd),w(itmaxd)
      DIMENSION  td(itmaxd),ad(itmaxd),bd(itmaxd)
c    maxfl_broy = maximum files to divide Broyden data into
      PARAMETER  ( maxfl_broy = 20 )
      DIMENSION  ibrfls(maxfl_broy)
      CHARACTER  broyfl*80
c
      DATA  lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
      nprocl = 1
      nveclocl = nvec
c
c Open binary file for broyden:
      broyfl = 'broy0_' // sufx
      call FLOPENB( ibrfl0, broyfl )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c        Broyden blend: first iteration is simple blend
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if( iter .le. 1 )then
c
        blendbr = blendfac
        write(IWR,'(a,a,a,f9.6)') '>>>>> Broyden: first step (',sufx,
     $      ') simple blend ratio=',blendbr
        iters = 1
        iterbm1 = 0
        REWIND( unit=ibrfl0 )
        write(ibrfl0)  blendbr, iters,iterbm1, nprocl
        call WRITBIG( ibrfl0, nveclocl, vv2 )
        call WRITBIG( ibrfl0, nveclocl, vv1 )
c
c       On first iteration, simple blend to get new vector.
        do  n=1,nveclocl
          vv2(n) = vv2(n) + blendbr*vv1(n)
        enddo
c
        goto 900
c
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c        Broyden blending method for later iterations
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      write(IWR,'(a,a)') '>>>>> Broyden blend to get next step - ',sufx
c
c  w0 = weighting factor for the zeroth iteration
      w0 = 0.01d0
      REWIND( unit=ibrfl0 )
      read(ibrfl0,end=1301,err=1301)  blendbr, itersm1,iterbm2, nprocbr
      if( nprocbr .ne. nprocl ) call STOPXERR( 'BROY = #procs changed' )
c  vv3<=previous vin ; vv4<=previous dv
      call READBIG( ibrfl0, nveclocl, vv3 )
      call READBIG( ibrfl0, nveclocl, vv4 )
      if( iterbm2.gt.0 .and. iterbm2.lt.itmaxd )then
        read(ibrfl0)  ( ( a(jt,it),jt=1,iterbm2 ), it=1,iterbm2 )
        read(ibrfl0)  ( w(it), it=1,iterbm2 )
      endif
c
c Check limits on blend counts:
      itmaxbr = itmaxd
      if( nhist.gt.0 .and. nhist.lt.itmaxd ) itmaxbr = nhist
      if( iterbm2.eq.itmaxbr )then
c       Drop old iterations in limited-history blend
        write(IWR,'(a)') ' Broyden: limit-history, dropping oldest'
        do  jt=2,iterbm2
          w(jt-1) = w(jt)
          do it=2,iterbm2
            a(it-1,jt-1) = a(it,jt)
          enddo
        enddo
        iterbm2 = iterbm2 - 1
      elseif( iterbm2.gt.itmaxbr )then
        write(IWR,*) 'BROYDEN: more iterations than dimensioned for'
        write(IWR,*) 'This event indicates a coding error, sys failure'
        call STOPXERR( 'BROY dimensions' )
      endif
c Set up blend step counts: iters=total steps, iterb=steps in blend
      iters   = itersm1 + 1
      iterbm1 = iterbm2 + 1
      iterb   = iterbm1 + 1
      itprune = iters - iterb
c
c Have vin and dv of current iteration, write to ibrfl0 for use later
      REWIND( unit=ibrfl0 )
      write(ibrfl0)  blendbr, iters,iterbm1, nprocl
c  vv2=vin ; vv1=dv
      call WRITBIG( ibrfl0, nveclocl, vv2 )
      call WRITBIG( ibrfl0, nveclocl, vv1 )
c
c  vv1=current dv ; vv2=current vin ; vv3=previous vin ; vv4=previous dv
c  vv3=>delta-vin ; vv4=>ddv
      do  n=1,nveclocl
        vv3(n) = vv2(n) - vv3(n)
        vv4(n) = vv1(n) - vv4(n)
      enddo
c
c For i-th iter, dfnorm = | dv[i] - dv[i-1] |, for normalization
      dfnorm = zero
      do  n=1,nveclocl
        dfnorm = dfnorm + vv4(n)*vv4(n)
      enddo
      dfnorm = SQRT( dfnorm )
      if( lstout.gt.0 ) write(IWR,'(a,f16.8)')  ' dfnorm=',dfnorm
c
      fac2 = one / dfnorm
      fac1 = blendbr*fac2
c  vv3=>u ; vv4=>dft
      do  n=1,nveclocl
        vv3(n) = fac1*vv4(n) + fac2*vv3(n)
        vv4(n) = fac2*vv4(n)
      enddo
c
c*********** calculation of coefficient matrices *************
c***********    and the sum for corrections      *************
c
c recall: a(i,j) is a symmetric matrix
c       : b(i,j) is the inverse of [ w0**2 I + a ]
c
c Compute nfl_broy=number of files necessary to hold broyden data:
c  msize_it = how big array needed to save per iteration
c  itersav=itersm1 - saves *all* past iters in more and more files
c  itersav=iterb   - uses (and reuses) minimum possible files
      msize_it = 2*nveclocl
      itertot = itersm1
      itersav = iterb
      call BROYF( IWR, itertot,itersav, itmaxbr, msize_it,
     $ nit_file,maxfl_broy, nfl_broy )
c
c Open the Broyden file(s):
C      broyfl  = 'broy_' // sufx
C      call FLOPENB( ibroyfl , broyfl  )
      call BROYFOPEN( sufx, nfl_broy, ibrfls )
c
      call BROYF0( ibroyfl, ifl_broy,it_file, ibrfls )
c
      REWIND( unit=ibroyfl )
      if( iterb.gt.2 )then
c
        if( itprune.gt.0 )then
c         Skip to beginning of active Broyden history:
          it_skip = itprune
          call BROYFSKIP( itprune,it_skip, ibroyfl,
     $     ifl_broy,it_file, nit_file,nfl_broy,ibrfls )
c
          REWIND( ibroyfl )
          do  it=1,it_skip
            call READSKP( ibroyfl, nveclocl )
            call READSKP( ibroyfl, nveclocl )
          enddo
        endif
c
        do  it=1,iterbm2
c         Get dft[it] in vv2(), skipping u[it]
          call BROYFIT( ibroyfl,
     $     ifl_broy,it_file, nit_file,nfl_broy,ibrfls )
          call READSKP( ibroyfl, nveclocl )
          call READBIG( ibroyfl, nveclocl, vv2 )
c
          aij = zero
          cmj = zero
          do  n=1,nveclocl
            aij = aij + vv2(n)*vv4(n)
            cmj = cmj + vv2(n)*vv1(n)
          enddo
          a(iterbm1,it) = aij
          a(it,iterbm1) = aij
          cm(it)       = cmj
        enddo
      endif
c
      cmj = zero
      aij = zero
      do  n=1,nveclocl
        cmj = cmj + vv4(n)*vv1(n)
        aij = aij + vv4(n)*vv4(n)
      enddo
      cm(iterbm1)        = cmj
      a(iterbm1,iterbm1) = aij
c
c  vv3=u ; vv4=dft
      call BROYFIT( ibroyfl,
     $ ifl_broy,it_file, nit_file,nfl_broy,ibrfls )
      call WRITBIG( ibroyfl, nveclocl, vv3 )
      call WRITBIG( ibroyfl, nveclocl, vv4 )
c
c Weighting factors for each iteration set to one over sqrt of max error
c This need not be the case, e.g., could be one over rms instead.
      wtmp = zero
      if( chg.gt. 1.0d-09 ) wtmp = 2.0d0*SQRT( 0.010d0/chg )
      if( wtmp.lt.one ) wtmp = one
      w(iterbm1) = wtmp
      if( lstout.gt.0 ) write(IWR,'(a,f20.6)') 'weighting set=',wtmp
c
      write(ibrfl0)  ( ( a(jt,it), jt=1,iterbm1 ), it=1,iterbm1 )
      write(ibrfl0)  ( w(it), it=1,iterbm1 )
c
c Set up and calculate beta matrix
      do  it=1,iterbm1
        do  jt=1,iterbm1
          d(jt,it) = a(jt,it)*w(jt)*w(it)
          b(jt,it) = zero
        enddo
        b(it,it) = one
        d(it,it) = w0**2 + d(it,it)
      enddo
c
      call INVERT( d,b,iterbm1, td,ad,bd, itmaxd )
c
c Compute input vector for new iteration
c
      REWIND( unit=ibrfl0 )
      read(ibrfl0)  blendbr, itm1_t,itm2_t, nprocbr
      if( nprocbr .ne. nprocl ) call STOPXERR( 'BROY - #procs changed' )
c  recover vv2=vin, have vv1=dv; start vv2=>vnew with simple blend
      call READBIG( ibrfl0, nveclocl, vv2 )
      do  n=1,nveclocl
        vv2(n) = vv2(n) + blendbr*vv1(n)
      enddo
c
      call BROYF0( ibroyfl, ifl_broy,it_file, ibrfls )
      REWIND( unit=ibroyfl )
c
      if( itprune.gt.0 )then
c       Skip to beginning of active Broyden history:
        it_skip = itprune
        call BROYFSKIP( itprune,it_skip, ibroyfl,
     $   ifl_broy,it_file, nit_file,nfl_broy,ibrfls )
c
        REWIND( ibroyfl )
        do  it=1,it_skip
          call READSKP( ibroyfl, nveclocl )
          call READSKP( ibroyfl, nveclocl )
        enddo
      endif
c
      do  it=1,iterbm1
c       Get u[it] in vv3(), and skip dft[it]
        call BROYFIT( ibroyfl,
     $   ifl_broy,it_file, nit_file,nfl_broy,ibrfls )
c
        call READBIG( ibroyfl, nveclocl, vv3 )
        call READSKP( ibroyfl, nveclocl )
        gmi = zero
        do  jt=1,iterbm1
          gmi = gmi + cm(jt)*b(jt,it)*w(jt)
        enddo
        do  n=1,nveclocl
          vv2(n) = vv2(n) - gmi*vv3(n)*w(it)
        enddo
      enddo
c
c Close the Broyden file(s):
C      call FLCLOSE( ibroyfl )
      call BROYFCLOSE( nfl_broy,ibrfls )
c
      goto 900
c
 1301 continue
      call STOPXERR( 'BROYDDJ - broyden files missing/mangled' )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c        Clean up and get out:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  900 continue
c
      call FLCLOSE( ibrfl0 )
c
      write(IWR,'(a,i6)') '<<<<< Broyden step complete, iter=',iter
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BSIALL
c
c
      subroutine BSIALL( nrs, llmxi, barg, bess, radmsh,
     $  x,w1,w2,w3,w4, xx )
c---------------------------------------------------------------
c Purpose: to compute half odd order bessel functions
c          bess(nr,k)=i(k-0.5,x(nr)), k=1,8 for x>1.d-40
c
c Written: Peter A. Schultz, 26-April-1989,  based on PJF's
c          adaptation of Don Amos' original bessel routines
c
c Revision history:
c  11Mar02-PAS/2.52: last literal reals to d0
c   8Aug00-PAS/2.45: renamed "chbsv" to "bsicbsv"
c  22Oct99-PAS/2.40: simple optimizations with chbsv
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Aug98-PAS/2.25: promote constants
c  22May98-PAS/2.22: cleanup
c---------------------------------------------------------------
c
c Arrays:
c    bess()    - output bessel functions on mesh
c    radmsh()  - input points on radial mesh
c    w1()-w4() - scratch arrays for chbsv routine
c    x()       - bessel argument on mesh=barg*radmsh()
c    xx()      - input parameters for chbsv routine
c
c Caution: w1(),w2(); w3,w4 need to be consecutive in mem, w1() and
c          w3() are used double sized in chbsv and bsixgt4 routines
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
      DIMENSION  bess(nrs,*),radmsh(nrs)
c scratch arrays:
      DIMENSION  x(nrs),xx(nrs)
      DIMENSION  w1(*),w2(nrs),w3(*),w4(nrs)
c
c local declarations:
      DATA  zero,two / 0.d0,2.d0 /
      DATA  four,five,fivp5 / 4.d0,5.d0,5.5d0 /
c
c >>>> EXECUTABLE CODE:
c
      rthafpi = SQRT( pi/two )
      nra = 0
      do  nr=1,nrs
        x(nr) = barg*radmsh(nr)
      enddo
c
c    Determine which range x's belong in:
c
      if( x(nrs).le.four )then
        nra = nrs
        goto 100
      elseif( x(1).gt.four )then
        goto 200
      endif
      nra = 1
      do  nr=2,nrs-1
        if( x(nr).gt.four ) goto 100
        nra = nra + 1
      enddo
c
c  * * * * *  x le 4  * * * * *
c
  100 continue
      do  nr=1,nra
        xx(nr) = x(nr) - two
      enddo
c
      call BSICBSV( nrs,nra, bess(1,6), xx, w1,w3 )
c
c pulling the next two loops separately out of the third
c loop was just a touch faster than combined loop(s)
c The cost here appears to be taken up in the EXP and LOG.
      do  nr=1,nra
        w2(nr) = five* LOG( x(nr) ) - x(nr)
      enddo
      do  nr=1,nra
        w3(nr) = rthafpi*EXP( w2(nr) )
      enddo
      do  nr=1,nra
        bess(nr,6) = bess(nr,6)*w3(nr)
        bess(nr,7) = bess(nr,7)*w3(nr)*x(nr)
        w1(nr) = two/x(nr)
        w2(nr) = fivp5*w1(nr)
      enddo
c get the rest by recursion:
c (note: unrolling the k-loop yields no performance gain).
      do  k=5,1,-1
        do  nr=1,nra
          bess(nr,k) = w2(nr)*bess(nr,k+1) + bess(nr,k+2)
          w2(nr) = w2(nr) - w1(nr)
        enddo
      enddo
c fwd recursion to get extra bessel fcn (if needed)
      if( llmxi.eq.8 )then
        do  nr=1,nra
          bess(nr,8) = bess(nr,6) - 13.d0*bess(nr,7)/x(nr)
        enddo
      endif
c
      if( nra.eq.nrs ) RETURN
c
c  * * * * *  x > 4  * * * * *
c
  200 continue
c
c Caution: w1() used double sized inside bsixgt4
c     This routine dependent on w1,w2 being consecutive
c     in memory (or at least that w1 can be safely double-sized).
c Note: array x() is destroyed in bsixgt4
c
      call BSIXGT4( nra+1,nrs, llmxi, bess, x,xx,w1,w3,w4 )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BSICBSV
c
c
      subroutine BSICBSV( nrs,nra, b, xx, s1,s2 )
c---------------------------------------------------------------
c Revision history:
c   8Aug00-PAS/2.45: renamed from "chbsv" to "bsicbsv"
c  22Oct99-PAS/2.40: local 2X opt/2-unroll k-loop and (nra<->2)
c  14Jun99-PAS/2.40: a simple optimization
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c  ai65(),ai55() - coefs. for 6.5 and 5.5 order bessel fcns.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  (n=14)
c
      DIMENSION  b(nrs,2), xx(nra),  s1(nra,2),s2(nra,2)
c local declarations:
      DIMENSION  ai55(14),ai65(14)
      DATA  (ai55(i),i=1,14) /
     2     9.84033426637529d-05,     2.99702005100095d-05,
     3     9.19213342363118d-06,     1.02971223258331d-06,
     4     1.74888326874802d-07,     1.56403099137419d-08,
     5     1.88861632972884d-09,     1.41056070635215d-10,
     6     1.33792649824125d-11,     8.59457809289520d-13,
     7     6.75553647465783d-14,     3.81127987453573d-15,
     8     2.56705246725694d-16,     1.29201110336002d-17/
      DATA  (ai65(i),i=1,14) /
     2     7.31335376759418d-06,     1.94255942832937d-06,
     3     5.83433173657527d-07,     5.89076413815039d-08,
     4     9.74426182172852d-09,     8.00554251040564d-10,
     5     9.40404192453049d-11,     6.53461776118609d-12,
     6     6.03109914162418d-13,     3.63752560527624d-14,
     7     2.78439618029305d-15,     1.48513584937351d-16,
     8     9.75140047077775d-18,     4.66539056854547d-19/
c
      DATA  zero,half / 0.0d0,0.5d0 /
c
c >>>> EXECUTABLE CODE:
c
      a1k = ai55(n)
      a2k = ai65(n)
      do  nr=1,nra
        s1(nr,1) = zero
        s1(nr,2) = a1k
        s2(nr,1) = zero
        s2(nr,2) = a2k
      enddo
c
      do 150 k=n-1,3,-2
c
        a1k = ai55(k)
        a2k = ai65(k)
        do  nr=1,nra
          s1(nr,1) = xx(nr)*s1(nr,2) - s1(nr,1) + a1k
          s2(nr,1) = xx(nr)*s2(nr,2) - s2(nr,1) + a2k
        enddo
c
        a1k = ai55(k-1)
        a2k = ai65(k-1)
        do  nr=1,nra
          s1(nr,2) = xx(nr)*s1(nr,1) - s1(nr,2) + a1k
          s2(nr,2) = xx(nr)*s2(nr,1) - s2(nr,2) + a2k
        enddo
c
  150 continue
c
      a1k = ai55(1)
      a2k = ai65(1)
      do  nr=1,nra
        b(nr,1) = half*xx(nr)*s1(nr,2) - s1(nr,1) + a1k
        b(nr,2) = half*xx(nr)*s2(nr,2) - s2(nr,1) + a2k
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BSIXGT4
c
c
      subroutine BSIXGT4( nrsmin,nrs, ltop, bessi,x,
     $ xinv,sum1,xtok,expm2r )
c---------------------------------------------------------------
c Revision history:
c   7Mar02-PAS/2.52: explicitly promote constants to r** (d0)
c  16Nov99-PAS/2.42: cleanup and commentary
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c Notes: there is no easy optimization available here.  Tried
c        several ideas, but none were helpful. PAS/16Nov99
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
      DIMENSION  bessi(nrs,ltop),x(nrs)
      DIMENSION  xinv(nrs),sum1(nrs,2),xtok(nrs),expm2r(nrs)
c
c the following data array has form ( (j-1)+(i-1) )! / ( (j-1)!*(i-1)! )
      DIMENSION  a(8,8)
      DATA  (a(i,1),i=1,8) / 8*1.d0 /
      DATA  (a(i,2),i=2,8)
     $ /  2.d0,  6.d0,  12.d0,  20.d0,  30.d0,  42.d0,  56.d0/
      DATA  (a(i,3),i=3,8)
     $ /  12.d0,  60.d0,  180.d0,  420.d0,  840.d0, 1512.d0/
      DATA  (a(i,4),i=4,8)
     $ /  120.d0,  840.d0,  3360.d0,  10080.d0, 25200.d0/
      DATA  (a(i,5),i=5,8)
     $ /  1680.d0,  15120.d0, 75600.d0,  277200.d0/
      DATA  (a(i,6),i=6,8)
     $ /  30240.d0,  332640.d0, 1995840.d0/
      DATA  (a(i,7),i=7,8)
     $ /  665280.d0,  8648640.d0/
      DATA   a(8,8)
     $ / 17297280.d0/
c
      DATA  zero,half,one / 0.d0,0.5d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
c  cutexp=largest neg. argument before exp underflow
      argmx  = half*cutexp
      argtst = half*argmx
      nrsmax = nrs
      do  nr=nrs,nrsmin,-1
        if( x(nr).lt.argtst ) goto 6
        nrsmax = nr - 1
        xinv(nr) = half/x(nr)
        expm2r(nr) = zero
      enddo
    6 continue
c
      do  nr=nrsmin,nrsmax
        xinv(nr) = half/x(nr)
        arg = x(nr) + x(nr)
        expm2r(nr) = EXP( -arg )
      enddo
c
      do  nr=nrsmin,nrs
        bessi(nr,1) = xinv(nr)*a(1,1)*(one-expm2r(nr))
      enddo
      if( ltop.ge.2 )then
        do  nr=nrsmin,nrs
          bessi(nr,2) = xinv(nr)*( a(2,1)*(one+expm2r(nr))
     $                  - xinv(nr)*a(2,2)*(one-expm2r(nr)) )
        enddo
      endif
c
      do 100 l=3,ltop
c
        do  nr=nrsmin,nrs
          expm2r(nr) = -expm2r(nr)
          xtok(nr) = xinv(nr)*xinv(nr)
          sum1(nr,1) = a(l,1)*xinv(nr)
          sum1(nr,2) = a(l,2)*xtok(nr)
        enddo
c
c  You'd think pulling this loop apart would help, but
c  it does not seem to.
        do 40 k=3,l
          is = 2 - MOD(k,2)
          alk = a(l,k)
          do  nr=nrsmin,nrs
            xtok(nr) = xtok(nr)*xinv(nr)
            sum1(nr,is) = sum1(nr,is) + alk*xtok(nr)
          enddo
   40   continue
c
        do  nr=nrsmin,nrs
          bessi(nr,l) = (sum1(nr,1)-sum1(nr,2))
     $                + (sum1(nr,1)+sum1(nr,2))*expm2r(nr)
        enddo
c
  100 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BULKPOL
c
c
      subroutine BULKPOL( IWR, ndim, elchrg,dielec, rprim, engypol )
c---------------------------------------------------------------
c Purpose: generate bulk polarization energy in response to charge
c          in cell.
c
c Written: Peter A. Schultz, 2-October-2003, for v2.57
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Thanks to Art Edwards (AFRL) for finding the method used here.
c
c Notes:
c  The model used here for the bulk polarization in response to
c  a local charged defect is the Jost model:
c     W. Jost, J. Chem. Phys 1, 466 (1933).
c  where the polarization energy is approximated by the polarization
c  response of an infinite bulk dielectric material outside a
c  spherical hollow of the same volume as the simulation supercell.
c  The formula for the bulk polarization response (in Hartree):
c    E(Jost) = ( 1 - 1/dielec ) * ( Q^2 / 2*R(Jost) )
c  where:
c    E = output bulk polarization energy (Hartree).
c    dielec = the static dielectric constant of the material
c    Q = net charge in the simulation cell (au)
c    R = is the radius of a sphere that gives the same volume as
c        the parallelpiped supercell (bohr)
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, three=3.d0 )
c
c Input:
c   rprim - supercell vectors Ry/bohr)
      DIMENSION  rprim(3,*)
c
c Local:
      DIMENSION  vtmp(3)
      DATA  toev / 13.605805d0 /
      DATA  pi / 3.14159265358979d0 /
      DATA  fourthrd / 1.333333333333333d0 /
c
c >>>> EXECUTABLE CODE:
c
      engypol = zero
c If not bulk, with a net charge, and with a dielectric, skip ...
      if( ndim.ne.3 .or. ABS( elchrg ).eq.zero .or.
     $    dielec.le.zero ) RETURN
c
c Obtain the volume of the supercell
      call CROSS( rprim(1,2),rprim(1,3), vtmp )
      volum = ABS( rprim(1,1)*vtmp(1) + rprim(2,1)*vtmp(2)
     $           + rprim(3,1)*vtmp(3) )
c
c Compute the radius of a sphere with the same volume
      r3 = volum / ( fourthrd*pi )
      rln = LOG( r3 ) / three
      rjost = EXP( rln )
c
c The Jost model bulk polarization energy around spherical cavity
      ejost = ( one - one/dielec ) * elchrg**2 / (two*rjost)
c
c Convert to Rydberg
      engypol = two*ejost
c
c Tell the user about it
 9020 format(1x,a,3f16.6)
      if( IWR .gt. 0 )then
        write(IWR,9020) 'BULKPOL: bulk polarization response'
        write(IWR,9020) ' Jost model: Epol = (1-1/e)*q^2 / (2*Rjost)'
        write(IWR,9020) ' Dielectric constant, e=', dielec
        write(IWR,9020) ' cell volume(bohr^3), Rjost(bohr)=',
     $                    volum,  rjost
        engyev = engypol*toev
        write(IWR,9020) ' Bulk polarization ENERGY (Ry)=',engypol
        write(IWR,9020) ' Bulk polarization ENERGY (eV)=',engyev
      endif
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> C16LOW
c
c
      subroutine C16LOW( n, rm, cm )
c--------------------------------------------------------------
c Purpose: take complex matrix loaded in r*8 packed array
c          and load into lower triangle of c*8 array
c          Also initialize other triangle to zero.
c
c Written: Peter A. Schultz,  8-April-1999, for v2.34
c
c Revision history:
c   3Oct04-PAS/2.59: zero the upper triangle, to fix parallel
c--------------------------------------------------------------
c
c Note: need to conjugate the existing matrix to get right phase
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0 )
      DIMENSION  rm(n,n), cm(2,n,n)
c
c >>>> EXECUTABLE CODE:
c
      do  j=1,n
        do  i=1,j-1
          cm(1,i,j) = zero
          cm(2,i,j) = zero
        enddo
        cm(1,j,j) = rm(j,j)
        cm(2,j,j) = zero
        do  i=j+1,n
          cm(1,i,j) =  rm(i,j)
          cm(2,i,j) = -rm(j,i)
        enddo
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CEE1
c
c
      FUNCTION CEE1( a,b,c, d,e,f )
c---------------------------------------------------------------
c Revision history:
c  24Sep08-PAS/2.62: cosmetic to removed compiler warning
c   7Mar02-PAS/2.52: explicitly promote constants to dp (d0)
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      INTEGER  a,b,c, d,e,f
c local declarations:
      DIMENSION  fact(21)
      DATA  fact /
     $  1.d0,1.d0,2.d0,6.d0,24.d0,120.d0,720.d0,5040.d0,40320.d0,
     $  362880.d0,3628800.d0,39916800.d0,479001600.d0,6227020800.d0,
     $  87178291200.d0,1307674368000.d0,20922789888000.d0,
     $  3.55687428096d+14,6.402373705728d+15,
     $  1.216451004088d+17,2.432902008177d+18 /
      DATA  zero,one / 0.d0,1.d0 /
      LOGICAL  ODD
c statement function:
      ODD(int) = (AND(int,1).eq.1)
c
c >>>> EXECUTABLE CODE:
c
      p = fact(a+b-c+1)
      q = fact(a-b+c+1)
      r = fact(b+c-a+1)
      s = fact(a+b+c+2)
      t = fact(a+d+1)
      u = fact(a-d+1)
      v = fact(b+e+1)
      w = fact(b-e+1)
      x = fact(c+f+1)
      y = fact(c-f+1)
      p = SQRT( p*q*r/s ) * SQRT( t*u*v*w*x*y )
      if( ODD(c-f) ) p = -p
      ceesum = zero
      is = -1
      q = -one
c
  100 continue
      is = is + 1
      q = -q
      r = fact(is+1)
      i = a + b - c - is
      if( i.lt.0 ) goto 990
      s = fact(i+1)
      i = a - d - is
      if( i.lt.0 ) goto 990
      t = fact(i+1)
      i = b + e - is
      if( i.lt.0 ) goto 990
      u = fact(i+1)
      i = -b + c + d + is
      if( i.lt.0 ) goto 100
      v = fact(i+1)
      i = -a + c - e + is
      if( i.lt.0 ) goto 100
      w = fact(i+1)
      ceesum = ceesum + p*q/(r*s*t*u*v*w)
      cee1 = ceesum
      goto 100
c
  990 continue
      cee1 = ceesum
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CEE
c
c
      FUNCTION CEE( l1,m1,l2,m2,k )
c---------------------------------------------------------------
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      LOGICAL  ODD
c statement function:
      ODD(int) = (AND(int,1).eq.1)
c
      pf = SQRT(  DBLE( (2*l1+1)*(2*l2+1) ) )
      if( ODD(m1) ) pf = -pf
c
      cee = CEE1( l1,l2,k, -m1,m2,m1-m2 )*CEE1( l1,l2,k, 0,0,0 )*pf
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CELLDAT
c
c
      subroutine CELLDAT( IWR,IDAT,
     $ do_cell, do_pvcalc, ndim, iuctype, icellscheme,strsbroy,
     $ iucstep,iuciter,maxucstep,nhistuc, cellconv,strxtrnl,
     $ strnmax, ucstepfac,cellstepdecr,cellstepincr, ucblend,
     $ strlast )
c---------------------------------------------------------------
c Purpose: input options affecting cell relaxation
c
c Written: Peter A. Schultz, 3-May-2002, for v2.53 (cell opt)
c
c Revision history:
c   9Apr15-PAS/2.66: lnwrite lines
c  24Sep13-PAS/2.65a: install flag for enthalpy(E+PV) calc
c   6Apr130PAS/2.65: axial-based constrained cell options
c  23Sep08-PAS/2.62: isotropic cell opt
c  11Jul07-PAS/2.60: cosmetic
c  11Sep03-PAS/2.57: remove itmaxd-dependence
c  10Jan03-PAS/2.55: limited-history option
c  15May02-PAS/2.53: patch new changes
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      LOGICAL    do_cell, do_pvcalc
      DIMENSION  strxtrnl(3,3)
      DIMENSION  strlast(3*3), ucstepfac(3*3)
c
c Local:
      PARAMETER  ( nline = 128 )
      CHARACTER    label*(nline), readlbl*6, wantlbl*6, glabel*8
      EQUIVALENCE  (label,readlbl)
      DIMENSION    v(3)
c
      DATA  zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
 8000 format(a128)
 9000 format(1x,a)
c
  100 continue
      read(IDAT,8000,err=1300,end=1300)  label
      call LNWRIT( IWR, label, nline )
c
c      ***** Standard options *****
c
      if    ( readlbl.eq. 'end ce' .or.
     $        readlbl.eq. 'end_ce' )then
c       End of cell parameter input
        goto 990
c
      elseif( readlbl.eq. 'ucstep' )then
c       Maximum number of steps in cell relaxation
        read(IDAT,*)  maxucstep
        write(IWR,'(1x,i4)')  maxucstep
        if( maxucstep.le.0 ) call STOPXERR( 'uc steps max bad' )
c
      elseif( readlbl.eq. 'uc_con' )then
c       Converged stress (GPa) for cell relaxation
        read(IDAT,*)  fac
        write(IWR,'(1x, f15.8, a, f15.8, a )')
     $   fac, ' GPa (default=', cellconv, ' GPa)'
        if( fac.le.zero ) call STOPXERR( 'uc_conv < 0' )
        cellconv = fac
c
      elseif( readlbl.eq. 'isotro' )then
c       Just do an isotropic (fixed-shape) cell volume optimization
        iuctype = 1
c
      elseif( readlbl.eq. 'constr' )then
c       Choose some limiting constraints for cell shape optimization
        read(IDAT,8000)  label
        call LNWRIT( IWR, label, nline )
        call STRPARS( label, 1,60, il1,il2 )
        wantlbl = label(il1:il1+5)
        if(     wantlbl.eq.'isotro' )then
          iuctype = 1
        elseif( wantlbl.eq.'vfixed' )then
          iuctype = 2
c
c       NB: Urelax/Ufixed iuctype parsed via bitmap in cellopt
        elseif( wantlbl.eq.'xrelax' )then
          iuctype = 3
        elseif( wantlbl.eq.'xfixed' )then
          iuctype = 8
        elseif( wantlbl.eq.'yrelax' )then
          iuctype = 4
        elseif( wantlbl.eq.'yfixed' )then
          iuctype = 7
        elseif( wantlbl.eq.'zrelax' )then
          iuctype = 6
        elseif( wantlbl.eq.'zfixed' )then
          iuctype = 5
        elseif( wantlbl.eq.'arelax' )then
          iuctype = 9
        endif
c
      elseif( readlbl.eq. 'pressu' )then
c       Input external pressure (in GPa)
        call MKZERO( 9, strxtrnl )
        read(IDAT,*)  pressure
        write(IWR,'(1x,f15.8,a)')  pressure, ' GPa'
c       Hydrostatic pressure, on diagonal of stress tensor
        do  id=1,ndim
          strxtrnl(id,id) = pressure
        enddo
c       If doing pressure, will want enthalpy
        do_pvcalc = .true.
c
      elseif( readlbl.eq. 'uniaxi' )then
c       Input external uniaxial pressures (in GPa)
        call MKZERO( 9, strxtrnl )
        read(IDAT,*)  (v(id),id=1,ndim)
        write(IWR,'(1x,3f15.8,a)')  (v(id),id=1,ndim), ' GPa'
        do  id=1,ndim
          strxtrnl(id,id) = v(id)
        enddo
c
      elseif( readlbl.eq. 'stress' )then
c       Input external stress (in GPa)
        call MKZERO( 9, strxtrnl )
        read(IDAT,*)  pressure
        write(IWR,'(1x,f15.8,a)')  pressure, ' GPa'
        do  jd=1,ndim
          read(IDAT,*,err=1301)    (strxtrnl(id,jd),id=1,ndim)
          write(IWR,'(1x,3f15.8)') (strxtrnl(id,jd),id=1,ndim)
        enddo
c       Check that this stress tensor is symmetric:
        do  jd=1,ndim
          do id=jd+1,ndim
            if( strxtrnl(id,jd) .ne. strxtrnl(jd,id) )
     $       call STOPXERR( 'tsk,tsk - external stress not symmetric!' )
          enddo
        enddo
c
c      ***** Slightly non-standard options *****
c
      elseif( readlbl.eq. 'uchist' )then
c       Specify history to be used in blend opt methods
        read(IDAT,*)  nhistuc
c
      elseif( readlbl.eq. 'ucmeth' )then
c       Specify cell optimization method
        read(IDAT,8000,err=1300,end=1300)  label
        call LNWRIT( IWR, label, nline )
        call STRPARS( label, 1,60, ig1,ig2 )
c       We assume here that glabel is an 8-char string
        glabel = label(ig1:ig1+7)
        if( glabel.eq. 'BEST    ' )then
c         Choose steepest-to-broyden switch
          icellscheme = 0
        elseif( glabel.eq. 'STEEPEST' )then
c         Force steepest descent method
          icellscheme = 1
        elseif( glabel.eq. 'BROYDEN ' )then
c         Force broyden
          icellscheme = 2
        else
c         Unknown - stick with "best" default
          write(IWR,*) '***** Unknown cell opt method'
          write(IWR,*) 'Choices are: BEST,STEEPEST,BROYDEN'
          write(IWR,*) 'Default to BEST=steep-to-broy scheme'
          icellscheme = 0
        endif
c
      elseif( readlbl.eq. 'str_br' )then
c       Stress criterion to convert to broyden from steepest
        read(IDAT,*) fac
        write(IWR,'(1x,f15.8,a)')  fac, ' GPa'
        strsbroy = fac
c
c      ***** Non-standard options *****
c
      elseif( readlbl.eq. 'max_st' )then
c       Size limit on strain in initial cell step (unitless)
        read(IDAT,*)  fac
        write(IWR,'(1x,f15.8)')  fac
        if( fac.le.zero .or. fac.gt.0.5 )
     $   call STOPXERR( 'cell strain input is out-of-bounds' )
        strnmax = fac
c
      elseif( readlbl.eq. 'cell_f' )then
c       Stress (GPa) to strain factor for initial cell update (1/GPa)
        read(IDAT,*)  fac
        write(IWR,'(1x, f15.8, a, f15.8, a )')
     $   fac, ' GPa^-1 (default=', ucstepfac, ')'
        if( fac .ge. zero )
     $   call STOPXERR( 'cell_factor must be strictly negative')
        do  ij=1,3*3
          ucstepfac(ij) = fac
        enddo
c
      elseif( readlbl.eq. 'bulk_m' )then
c       Bulk_modulus guess for setting step factor (GPa)
        read(IDAT,*)  bmod
        write(IWR,'(1x,f15.8,a)')  bmod, ' GPa'
        if( bmod.le.zero ) call STOPXERR( 'bulk_modulus < 0' )
        fac = - ( one / (3.d0*bmod) )
        do  ij=1,3*3
          ucstepfac(ij) = fac
        enddo
c
      elseif( readlbl.eq. 'uc_ble' )then
c       Blend factor for initial broyden step (should be 1.0)
        read(IDAT,*)  fac
        write(IWR,'(1x,f15.8)')  fac
        if( fac.le.zero ) call STOPXERR( 'uc_blend < 0' )
        ucblend = fac
c
      else
c
        call STOPXERR( 'celldat - unknown keyword' )
c
      endif
c
      goto 100
c
  990 continue
      write(IWR,9991) cellconv
 9991 format(1x,'>>>> uc_conv (cell convergence)=',f15.8,' GPa' )
c
       RETURN
c
 1300 continue
      write(IWR,*) '***** ERROR: reading cell relax params'
      write(IWR,*) '>>>>> >end cell opt< to end cell input'
      call STOPXERR( 'celldat - error processing cell data' )
 1301 continue
      call STOPXERR( 'cellstr - error reading xtrnl stress' )
      do_cell = .false.
c
      RETURN
c
c    That's all Folks!
c
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CELLOPT
c
c
      subroutine CELLOPT( iucstat, ihistfl,
     $ do_cell, ndim, iuctype, icellscheme,strsbroy,
     $ iucstep,iuciter,maxucstep,nhistuc, cellconv,strxtrnl,
     $ strnmax, ucstepfac,cellstepdecr,cellstepincr, ucblend,
     $ strlast, engytotl,
     $ rprim, orig,rscale, strtot, nsym,rmatsym,
     $ nk,veck, dolvatm, natm,ratm,ratm0 )
c---------------------------------------------------------------
c Purpose: initialize user-adjustable parameters for cell opt
c
c Written: Rick P. Muller and Peter A. Schultz, 1-May-2002, v2.53
c
c Revision history:
c   1Oct13-PAS/2.65a: patch dscal args, (b)5Feb14-ACP patch another dscal arg
c   5Apr13-PAS/2.65: axial constraints; independent cell factors
c  28Jun12-PAS?2.63: fix steepest (had damped when hole accelerates)
c  23Sep08-PAS/2.62: output cell volume
c  11Sep03-PAS/2.57: remove itmaxd-dependence
c   8Aug03-PAS/2.56: modify k-vector handling
c  20May03-PAS/2.55: history file added
c  10Jan03-PAS/2.55: limited-history Broyden
c  23Jun02-PAS/2.53e: oops - forgot to symmetrize stress tensor!
c  19May02-PAS/2.53b: 1D and 2D cell opt code made to work
c   1May02-PAS: Rick Muller code pushed down from main program
c---------------------------------------------------------------
c
c The input scf stress "strtot" is assumed to be in Rydberg.
c
c The user-specified convergence criterion "cellconv" and the
c external stress "strxtrnl" - and the various quantities
c determining the blend - use units of GPa (for bulk, and the
c appropriate units generated in "str2gpa" and shown in the
c string "strlbl" for other dimensions).
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, half=0.5d0, one=1.d0, two=2.d0 )
      PARAMETER  ( three=3.d0 )
c
c Input:
      LOGICAL    do_cell
c      ... scf stress (in Ry), and external stress (in GPa)
      DIMENSION  strtot(3,3), strxtrnl(3,3)
      DIMENSION  strlast(3,3), ucstepfac(3,3)
      DIMENSION  rmatsym(*)
c Output:
      DIMENSION  rprim(3,3)
      DIMENSION  orig(3),rscale(3)
c Input/Output coordinate arrays modified with lattice vectors:
      DIMENSION  veck(3,*)
      LOGICAL    dolvatm
      DIMENSION  ratm(3,*),ratm0(3,*)
c
c Local:
      DIMENSION  strgpa(3,3), oldprim(3,3), epsilon(3,3)
      DIMENSION  vtmp(3)
      DIMENSION  ipiv(3)
      DIMENSION  delprim(9),optprim(9),wt3(9),wt4(3,3)
      CHARACTER*8  strlbl
      LOGICAL    debug_cell
      DIMENSION  ioptaxis(3)
c
c >>>> EXECUTABLE CODE:
c
      iucstat = 0
      if( ndim.eq.0 .or. .not. do_cell ) RETURN
c
c Set flag for debug output messages:
      debug_cell = .false.
 9020 format(1x,a,3f20.10)
 9030 format(1x,5x,3f12.6)
c
      call FLGETIWR( IWR )
c
      write(IWR,9010)
 9010 format(/1x,79('='),
     $ /5x,'Cell optimization driver v1.0 ',
     $ /5x,'Written by R.P. Muller - April 2002',
     $ /5x,'Revised by P.A. Schultz - May 2002',
     $ /5x,'Last update:  6Apr13-PAS (independent components)',
     $ /1x,49('-') )
 9090 format(1x,'End cell optimization step' / 79('=') / )
c
c Convert stress into the appropriate units for dimension ...
      call MKZERO( 9, strgpa )
      call STR2GPA( ndim, rprim, strtot, strgpa, strlbl )
c
c And symmetrize matrix:
      do  jd=2,ndim
        do  id=1,jd-1
          strij = ( strgpa(id,jd) + strgpa(jd,id) ) / two
          strgpa(id,jd) = strij
          strgpa(jd,id) = strij
        enddo
      enddo
c
      if( debug_cell )then
c      ... and output the stress, both raw, and converted:
        write(IWR,*) 'Total stress tensor (scf) in Ry and ',strlbl
        do  jd=1,ndim
          if( ndim.eq.1 )then
            write(IWR,'(2(2x, f13.6))') (strtot(id,jd),id=1,ndim),
     $                                  (strgpa(id,jd),id=1,ndim)
          elseif( ndim.eq.2 )then
            write(IWR,'(2(2x,2f13.6))') (strtot(id,jd),id=1,ndim),
     $                                  (strgpa(id,jd),id=1,ndim)
          elseif( ndim.eq.3 )then
            write(IWR,'(2(2x,3f13.6))') (strtot(id,jd),id=1,ndim),
     $                                  (strgpa(id,jd),id=1,ndim)
          endif
        enddo
      endif
      call QHIST( ihistfl, 'STRE' , ndim , rdata, strgpa )
c
c Rework stress to apply constraints to cell optimization:
c
      if( iuctype .eq. 1 )then
        write(IWR,*) 'Isotropic volume expansion only'
        press = ( strgpa(1,1) + strgpa(2,2) + strgpa(3,3) ) / three
        call MKZERO( 9, strgpa )
        strgpa(1,1) = press
        strgpa(2,2) = press
        strgpa(3,3) = press
c
      elseif( iuctype .eq. 2 )then
        write(IWR,*) 'Fixed-volume cell optimization'
c       Here, we remove the net pressure from the stress tensor
        press = ( strgpa(1,1) + strgpa(2,2) + strgpa(3,3) ) / three
        do  idim=1,3
          strgpa(idim,idim) = strgpa(idim,idim) - press
        enddo
c
      elseif( iuctype .ge. 3 .and. iuctype .le. 9 )then
        write(IWR,*) 'Enforce axial constraints'
c       Off-diagonal terms are zeroed ...
        do  idim=1,ndim-1
          do  jdim=idim+1,ndim
            strgpa(idim,jdim) = zero
            strgpa(jdim,idim) = zero
          enddo
        enddo
c        ... and axial constraints were binary-encoded into the option
        iucopt = iuctype - 2
        ioptaxis(1) = 1
        if( AND(iucopt,1) .eq. 0 )then
c         Freeze out x-optimization
          ioptaxis(1) = 0
          strgpa(1,1) = zero
        endif
        iucopt = iucopt/2
        ioptaxis(2) = 1
        if( AND(iucopt,1) .eq. 0 )then
c         Freeze out y-optimization
          ioptaxis(2) = 0
          strgpa(2,2) = zero
        endif
        iucopt = iucopt/2
        ioptaxis(3) = 1
        if( AND(iucopt,1) .eq. 0 )then
c         Freeze out z-optimization
          ioptaxis(3) = 0
          strgpa(3,3) = zero
        endif
        call STOPXERR('uc axial constraints not ready')
      endif
c
c Add external desired stress to scf stress to get stress to
c be eliminated in cell optimization
c
      strxsum = zero
      do  jd=1,ndim
        do  id=1,ndim
          strgpa(id,jd) = strgpa(id,jd) + strxtrnl(id,jd)
          strxsum = strxsum + ABS( strxtrnl(id,jd) )
        enddo
      enddo
      if( strxsum.gt. 1.d-6 )then
c       Write out stress (different from scf) being eliminated:
        write(IWR,*) 'Net stress tensor, external stress, in ',strlbl
        do  jd=1,ndim
          if( ndim.eq.1 )then
            write(IWR,'(2(2x, f13.6))') (strgpa(id,jd),id=1,ndim),
     $                                  (strxtrnl(id,jd),id=1,ndim)
          elseif( ndim.eq.2 )then
            write(IWR,'(2(2x,2f13.6))') (strgpa(id,jd),id=1,ndim),
     $                                  (strxtrnl(id,jd),id=1,ndim)
          elseif( ndim.eq.3 )then
            write(IWR,'(2(2x,3f13.6))') (strgpa(id,jd),id=1,ndim),
     $                                  (strxtrnl(id,jd),id=1,ndim)
          endif
        enddo
      endif
c
c Test for cell stress convergence:
c
      ijd = 0
      strs_this = zero
      do  jd=1,ndim
        do  id=1,ndim
          ijd = ijd + 1
          wt3(ijd) = strgpa(id,jd)
          if( ABS( strgpa(id,jd) ) .gt. ABS( strs_this ) )
     $     strs_this = strgpa(id,jd)
        enddo
      enddo
      nrlxdim = ijd
c
      call CONVCHK( IWR, 'stress', iucstat,iucstep,maxucstep,cellconv,
     $ strsmax,strsrms,  1, nrlxdim, wt3 )
c
c     We have the absolute value of largest stress in strsmax
c     and its signed value in strs_this, which we will use for different purposes
c
      call QHIST( ihistfl, 'MAXS' , ndata, strsmax, wt3 )
      call QHIST( ihistfl, 'RMSS' , ndata, strsrms, wt3 )
c
c     iucstat = 0(cont); 1(steps); 2(conv)
c
      if( debug_cell ) write(IWR,'(a,3i6)') 'iucstat,step,iter=',
     $                                    iucstat,iucstep,iuciter
c
      if( iucstat .ne. 2 )then
c
c       Not converged - generate new cell
c
c       Save the old lattice vectors in oldprim
        do  jd=1,3
          do  id=1,3
            oldprim(id,jd) = rprim(id,jd)
          enddo
        enddo
c
        if( iucstep.eq.1 )then
          ucstepf = ucstepfac(1,1)
c         On initial step, limit strain to less than strnmax
          epsmax = ABS( ucstepf*strsmax )
          if( epsmax .gt. strnmax )then
c           Shrink step size
            ascal = (strnmax/epsmax)
            call DSCAL( 9, ascal, ucstepfac,1 )
C            ucstepfac = ucstepf*( strnmax / epsmax )
            write(IWR,9020) 'ucstepfac reduced to (1/GPa):',
     $                       ucstepf*ascal
          endif
        endif
c
c       icellscheme==0: Start with steepest descent, and switch
c                       to broyden when strsmax < strsbroy
c       icellscheme==1: Do steepest descent
c       icellscheme==2: Do broyden
c
        if( (icellscheme.eq.0) .and. (strsmax.lt.strsbroy) )
     $   icellscheme = 2
c
        if( (icellscheme.eq.0) .or. (icellscheme.eq.1) )then
c
c         ***** STEEPEST DESCENT *****
c
          if( iucstep.gt.1 )then
c           Past first step: adjust the step size (compare stress)
c           (sorry, the energy is the wrong criterion here)
c           (but, oops, so is the absolute value of the stress!)
            do  id=1,ndim
              do  jd=id,ndim
                strs_this = strgpa(id,jd)
                strs_last = strlast(id,jd)
                ucstepf = ucstepfac(id,jd)
                if( strs_this*strs_last .lt. zero )then
c                 Step overshot (stress reversed):
                  if( ABS(strs_this) .gt. 0.400*ABS(strs_last)
     $             .and. ABS(strs_this) .gt. 0.400*cellconv )then
c                   Step overshot by more than ~50%, decrease step fac
                    ucstepf = ucstepf*cellstepdecr
                  endif
                elseif( ABS(strs_this) .gt. 0.400*ABS(strs_last)
     $            .and. ABS(strs_this) .gt. 0.400*cellconv )then
c                 Step undershot, and by a lot, increase step increment
                  ucstepf = ucstepf*cellstepincr
                endif
                ucstepfac(id,jd) = ucstepf
                if( id.ne.jd) ucstepfac(jd,id) = ucstepf
              enddo
            enddo
          endif
c         Record the current stress for use in next step update
          call DCOPY( 9, strgpa,1, strlast,1 )
c
          write(IWR,'(a,6f10.6)') 'steepest descent ucstepf (1/GPa)=',
     $                  ((ucstepfac(id,jd),jd=id,ndim),id=1,ndim)
c
c         Form the strain matrix epsilon = (I+h\sigma) and
c         then multiply by the lattice vectors
c
          call MKZERO( 9, epsilon )
          do  jd=1,ndim
            epsilon(jd,jd) = one
            do  id=1,ndim
              epsilon(id,jd) = epsilon(id,jd)
     $                       + ucstepfac(id,jd)*strgpa(id,jd)
            enddo
          enddo
          if( debug_cell )then
            write(IWR,*) 'Strain matrix (steep d.) before symmetrize'
            do  id=1,ndim
              write(IWR,'(3f11.6)') (epsilon(id,jd),jd=1,ndim)
            enddo
          endif
c         Generate candidate new lattice vectors L' in rprim
          do  id=1,ndim
            do  jd=1,ndim
              rprim(id,jd) = zero
              do  kd=1,ndim
                rprim(id,jd) = rprim(id,jd)
     $                       + epsilon(id,kd)*oldprim(kd,jd)
               enddo
            enddo
          enddo
c
c         Reset iterative method step counter:
          iuciter = 1
c
c         End steepest descent update
        else
c
c         ***** BROYDEN *****
c
          write(IWR,*) 'cell opt: broyden iteration#',iuciter
c
c         Generate candidate strain matrix
          call MKZERO( 9, epsilon )
          do  jd=1,ndim
            epsilon(jd,jd) = one
            do  id=1,ndim
              epsilon(id,jd) = epsilon(id,jd)
     $                       + ucstepfac(id,jd)*strgpa(id,jd)
            enddo
          enddo
          if( debug_cell )then
            write(IWR,*) 'Strain matrix (broyden) before symmetrize'
            do  id=1,ndim
              write(IWR,'(3f11.6)') (epsilon(id,jd),jd=1,ndim)
            enddo
          endif
c         Generate candidate new lattice vectors L' in rprim
          do  id=1,ndim
            do  jd=1,ndim
              rprim(id,jd) = zero
              do  kd=1,ndim
                rprim(id,jd) = rprim(id,jd)
     $                       + epsilon(id,kd)*oldprim(kd,jd)
              enddo
            enddo
          enddo
c
c         Pack rprim, and cell change matrix (L'-L) for blend
          chgmax = zero
          ijd = 0
          do  jd=1,ndim
            do  id=1,ndim
              ijd = ijd + 1
              optprim(ijd) = oldprim(id,jd)
              delprim(ijd) = rprim(id,jd) - oldprim(id,jd)
              chg = ABS( delprim(ijd) )
              if( chg.gt.chgmax ) chgmax = chg
            enddo
          enddo
          nblend = ijd
c
          call BROYDDJ( IWR, 'cell', iuciter,nhistuc,
     $     ucblend,chgmax,nblend,
     $     delprim, optprim,  wt3,  wt4 )
c -->      vv1-i    vv2-io    vv3-s vv4-s
c
          iuciter = iuciter + 1
c
c         Unpack new primitive vectors:
          ijd = 0
          do  jd=1,ndim
            do  id=1,ndim
              ijd = ijd + 1
              rprim(id,jd) = optprim(ijd)
            enddo
          enddo
c
c         End broyden update
        endif
c
        if( iuctype .eq. 2 )then
          write(IWR,*) 'Fixed volume update enforced'
c         This is the iffy one, as update will not be clean.
          call CROSS( rprim(1,2),rprim(1,3), vtmp )
          volold = ABS( oldprim(1,1)*vtmp(1) + oldprim(2,1)*vtmp(2)
     $                + oldprim(3,1)*vtmp(3) )
          call CROSS( rprim(1,2),rprim(1,3), vtmp )
          volnew = ABS( rprim(1,1)*vtmp(1) + rprim(2,1)*vtmp(2)
     $                + rprim(3,1)*vtmp(3) )
          volchange = volold/volnew
          write(IWR,*) 'Volume change factor=',volchange
          afactor = volchange**(0.3333333333333333d0)
          call DSCAL( 9, afactor, rprim,1 )
        endif
c
c       Purify the move based on any symmetry; reuse the epsilon matrix
c       for the strain matrix
c
        if( nsym.ge.1 )then
c         Copy matrices into temp space and take transpose
c         We want to solve e*L = L'. If we take the transpose of both
c         sides, we get (e*L)T = (L)T*(e)T = (L')T. Thus, we can solve
c         (L)T*e=(L')T for e, since e is symmetric.
c
          if( debug_cell )then
            write(IWR,*) 'Old and (raw) new lattice vectors:'
            do  jd=1,ndim
              write(IWR,'(6f13.6)') (oldprim(id,jd),id=1,ndim),
     $                                (rprim(id,jd),id=1,ndim)
            enddo
          endif
c
c         Load full 3x3 matrix for use in dgesv:
          do  id=1,3
            do  jd=1,3
              epsilon(id,jd) = rprim(jd,id)
              wt4(id,jd) = oldprim(jd,id)
            enddo
          enddo
c
c          Solve L*epsilon = L' for the strain matrix "epsilon"
           info = 0
           call DGESV( 3,3, wt4,3,ipiv,epsilon,3,info )
c
c          Purify the strain matrix (in "epsilon")
           if( debug_cell .and. nsym.gt.1 )then
             write(IWR,*) 'Strain matrix before symmetrize (again)'
             do  id=1,ndim
               write(IWR,'(3f11.6)') (epsilon(id,jd),jd=1,ndim)
             enddo
           endif
           call SYMSTR( ndim, epsilon, nsym, rmatsym )
c
c          Apply constraints to get squeeze what we want into this:
           if( iuctype .eq. 1 )then
             write(IWR,*) 'Isotropic cell expansion enforced'
             ascale = ( epsilon(1,1) + epsilon(2,2) + epsilon(3,3) )
     $                                / three
             dif = ABS( ascale-epsilon(1,1) )
     $           + ABS( ascale-epsilon(2,2) )
     $           + ABS( ascale-epsilon(3,3) )
             if( dif .gt. 1.d-4 )then
c              Something went wrong, tell everyone:
               write(IWR,*) 'Strain matrix for isotropic update:'
               do  id=1,ndim
                 write(IWR,'(3f11.6)') (epsilon(id,jd),jd=1,ndim)
               enddo
               call STOPXERR( 'isotropic cell update not isotropic' )
             endif
             call MKZERO( 9, epsilon )
             epsilon(1,1) = ascale
             epsilon(2,2) = ascale
             epsilon(3,3) = ascale
           elseif( iuctype .eq. 2 )then
             write(IWR,*) 'Fixed volume update not checked'
c            This is the iffy one, as update will not be clean.
C             call CROSS( rprim(1,2),rprim(1,3), vtmp )
C             volold = ABS( oldprim(1,1)*vtmp(1) + oldprim(2,1)*vtmp(2)
C     $                   + oldprim(3,1)*vtmp(3) )
C             call CROSS( rprim(1,2),rprim(1,3), vtmp )
C             volnew = ABS( rprim(1,1)*vtmp(1) + rprim(2,1)*vtmp(2)
C     $                   + rprim(3,1)*vtmp(3) )
C             volchange = volold/volnew
C             write(IWR,*) 'Volume change factor=',volchange
C             afactor = volchange**(0.3333333333333333d0)
C             call DSCAL( 9, afactor, epsilon,1 )
           elseif( iuctype .ge. 3 .and. iuctype .le. 9 )then
             write(IWR,*) 'Axial constraints enforced'
             do  id=1,nd
               if( ioptaxis(id).eq.0 ) epsilon(id,id) = zero
               do  jd=1,nd
                 if( id.ne.jd ) epsilon(id,jd) = zero
               enddo
             enddo
           endif
c
           if( debug_cell )then
             write(IWR,*) 'Strain matrix after symmetrization'
             do  id=1,ndim
               write(IWR,'(3f11.6)') (epsilon(id,jd),jd=1,ndim)
             enddo
           endif
c
c          Reapply epsilon to L (rprim): L' = L*epsilon
           do  id=1,ndim
             do  jd=1,ndim
               rprim(id,jd) = zero
               do  kd=1,ndim
                 rprim(id,jd) = rprim(id,jd) +
     $            epsilon(id,kd)*oldprim(kd,jd)
              enddo
            enddo
          enddo
c
c         End symmetry purification
        endif
c
        if( debug_cell )then
          write(IWR,*) 'Old and (purified) new lattice vectors'
          do  jd=1,ndim
            write(IWR,'(6f13.6)') (oldprim(id,jd),id=1,ndim),
     $                              (rprim(id,jd),id=1,ndim)
          enddo
c         Leave a record of the cell volume for new cell:
          call CROSS( rprim(1,2),rprim(1,3), vtmp )
          volum = ABS( rprim(1,1)*vtmp(1) + rprim(2,1)*vtmp(2)
     $               + rprim(3,1)*vtmp(3) )
          write(IWR,'(1x,a,f16.6)') 'New Cell volume(bohr^3)=',volum
        endif
c
c       Update the atomic coords, k-points, etc.:
        call CELLRUPD( do_cell, iucstat, dolvatm,
     $   ndim, rprim, oldprim, orig,rscale,
     $   natm,ratm,ratm0 )
c
c       Print output and iterate
c
        iucstep = iucstep + 1
c
        if( debug_cell ) write(IWR,'(a8,i3,6f13.6)')
     $   'CellOpt',iucstep,engytotl,strsmax,
     $    strs_this,strs_last,oldprim(1,1),rprim(1,1)
c
c       Save this max stress for next step descent criterion
        strs_last = strs_this
c
      else
c       Converged!
c
        if( iucstat .eq. 2 )then
          write(IWR,*) 'CellOpt: Converged'
        elseif( iucstat .eq. 1 )then
          write(IWR,*) 'CellOpt: Not converged - out of iterations'
        endif
c
        if( debug_cell ) write(IWR,'(a8,i3,5f13.6/)')
     $   'CellOpt', iucstep,engytotl,zero,
     $           strsmax,zero,rprim(1,1)
c
        if( debug_cell )then
          write(IWR,*)
          write(IWR,*) 'Final Cell Parameters'
          do  jd=1,ndim
            write(IWR,'(5x,3f20.10)') (rprim(id,jd),id=1,ndim)
          enddo
c         Leave a record of the cell volume for new cell:
          call CROSS( rprim(1,2),rprim(1,3), vtmp )
          volum = ABS( rprim(1,1)*vtmp(1) + rprim(2,1)*vtmp(2)
     $               + rprim(3,1)*vtmp(3) )
          write(IWR,'(1x,a,f16.6)') 'Final Cell volume(bohr^3)=',volum
          write(IWR,*)
          write(IWR,*) 'Final Stress Tensor'
          do  jd=1,ndim
            write(IWR,'(5x,3f20.10)') (strgpa(id,jd),id=1,ndim)
          enddo
        endif
c
      endif
c
      write(IWR,9090)
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> UCSTAMP
c
c
      subroutine UCSTAMP( IWR, iucstat, iucstep,iuciter, rprim )
c---------------------------------------------------------------
c Purpose: write the new cell vector to the output file
c
c Written: Peter A. Schultz, 23-Septemeber-2002, v2.62
c
c Revision history:
c  23Sep08-PAS/2.62: extracted from main routine; 23Jan11-add LAT out
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
      DIMENSION  rprim(3,3)
c Local:
      DIMENSION  vtmp(3)
c
c >>>> EXECUTABLE CODE:
c
      if( IWR.lt. 0 ) goto 999
c
      write(IWR,9430) 
 9430 format(1x,79('#') )
c
      if( iucstat.lt.2 )then
        write(IWR,9531) 'NEW',iucstep,iuciter
      else
        write(IWR,9531) 'FINAL',iucstep, iuciter
      endif
 9531 format(1x,a,' UNIT CELL for step',i4,', (blend step',i4,')')
c
      write(IWR,*) 'primitive lattice vectors'
      write(IWR,9532)  ((rprim(id,jd),id=1,3),jd=1,3)
 9532 format(5x,3f20.10)
c
      write(IWR,9430)
c
c     Leave a record of the cell volume for new cell:
      call CROSS( rprim(1,2),rprim(1,3), vtmp )
      volum = ABS( rprim(1,1)*vtmp(1) + rprim(2,1)*vtmp(2)
     $           + rprim(3,1)*vtmp(3) )
      if( iucstat .lt. 2 )then
c       Not converged
        write(IWR,'(1x,a,f16.6)') 'New Cell volume(bohr^3)=',volum
      else
c       Final converged volume
        write(IWR,'(1x,a,f16.6)') 'FINAL Cell volume(bohr^3)=',volum
      endif
c
c     Put out lattice vectors in condensed form:
      write(IWR,'(1x,a,        3(1x,3f9.4)                )')
     $              'NEWCELL', ((rprim(i,j),i=1,3),j=1,3)
c
  999 continue
c
c    That's all, Folks!
c
      RETURN
      END
c
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CELLRUPD
c
c
      subroutine CELLRUPD( do_cell, iucstat, dolvatm,
     $ ndim, rprim, oldprim, orig,rscale,
     $ natm,ratm,ratm0 )
c---------------------------------------------------------------
c Purpose: update atoms, k-points, etc. to new unit cell
c
c Written: Peter A. Schultz, 2-May-2002, v2p53 ( cell opt)
c
c Revision history:
c   8Aug03-PAS/2.56: fix k-vector handling, remove gprim stuff
c  27Aug02-PAS/2.53g: sign error in rt-hand cell to gprim
c   1May02-RPM: adapted from Rick Muller cell code in main program
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, one=1.d0 )
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
      LOGICAL    do_cell, dolvatm
      DIMENSION  rprim(3,3), oldprim(3,3)
      DIMENSION  orig(3),rscale(3)
      DIMENSION  ratm(3,natm), ratm0(3,natm)
c Local:
      DIMENSION  ratmlv(3)
      DATA       lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
      if( iucstat.gt.0 ) RETURN
c
      do  id=1,ndim
        if( ABS( rscale(id) - one ) .gt. 1.d-8 )
     $   call STOPXERR( 'scale+cell - incompatible with cell opt' )
      enddo
c
      if( .not. dolvatm )then
C        call STOPXERR( 'cell opt with lattice coords only' )
c
c       Update the atom positions based on the new lattice vectors
c ****  Only necessary if we do not have lattice units, which we
c ****  currently require.  However, the trial code below had
c ****  crashed, and it is blocked for now.
c
        if( lstout.gt.3 )then
          call FLGETIWR( IWR )
          write(IWR,*) 'CELLRUPD: old rprim'
          do  jd=1,3
             write(IWR,'(3f12.6)')  (oldprim(id,jd),id=1,3)
          enddo
          write(IWR,*) 'CELLRUPD: new rprim'
          do  jd=1,3
             write(IWR,'(3f12.6)')  (rprim(id,jd),id=1,3)
          enddo
          write(IWR,*) 'CELLRUPD: ratm positions before update'
          do  iatm=1,natm
            write(IWR,'(3f12.6)')  (ratm(i,iatm),i=1,3)
          enddo
        endif
c
c       Convert atomic coordinates to internal (Cartesian bohr)
        call RINTRNL( ndim,natm, dolvatm, oldprim,orig,rscale,
     $   ratm,ratm0 )
c
c       The following really should be limited by problem dimension,
c       and should also include transform of orig(), and origws().
        do  iatm=1,natm
c         Project on old lattice vectors to get lattice units:
          call LVPROJ( oldprim, ratm0(1,iatm),ratmlv )
c         Expand in new lattice vectors to get get new positions
          call LVXPND( rprim, ratm0(1,iatm),ratmlv )
        enddo
c
c       Convert atomic positions back to user external frame
        call REXTRNL( ndim,natm, dolvatm, rprim,orig,rscale,
     $   ratm,ratm0 )
c
        if( lstout.gt.3 )then
          write(IWR,*) 'CELLRUPD: Atom positions after update'
          do  iatm=1,natm
            write(IWR,'(3f12.6)')  (ratm(i,iatm),i=1,3)
          enddo
          write(IWR,*) 'CELLRUPD: ratm0 after update'
          do  iatm=1,natm
            write(IWR,'(3f12.6)')  (ratm0(i,iatm),i=1,3)
          enddo
          write(IWR,*) 'CELLRUPD: new rprim'
          do  jd=1,3
            write(IWR,'(3f12.6)')  (rprim(id,jd),id=1,3)
          enddo
        endif
c
      endif
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CFFT3DB
c
c
      subroutine CFFT3DB( array, n1r,n2r,n3r, ws1,ws2,ws3, ftarray )
c---------------------------------------------------------------
c Purpose: compute normalized complex backward fourier transform
c          of the 3-dimensionally periodic "array."
c
c Revision history:
c   5Dec07-PAS/2.60c: replace cmplx<->2dble with more generic
c  21Dec99-PAS/2.42: comsetic clean-up
c   9Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c  For case n1r, n2r, or n3r odd, phase factor multiplication
c  translates in k-space by -(n1r-1)/2, -(n2r-1)/2, etc
c  For case n1r, n2r, or n3r even, phase factor multiplication
c  translates in k-space by -(n1r/2-1), -(n2r/2-1), etc
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,expamx
c
c input/output arrays:
      DOUBLE COMPLEX    array(n1r,n2r,n3r)
      DIMENSION  ws1(*),ws2(*),ws3(*), ftarray(*)
c
c local declarations:
      DIMENSION  phx(2),phy(2),phz(2)
C      EQUIVALENCE  (phx,ph1),(phy,ph2),(phz,ph3)
      DOUBLE COMPLEX    ph1,ph2,ph3, ph3j,ph32j,ph321j
      LOGICAL    EVEN
      DATA  zero,one / 0.d0,1.d0 /
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      do  j2=1,n2r
        do  j3=1,n3r
          call CFFTB( n1r, array(1,j2,j3),ws1 )
        enddo
      enddo
c
      do  j1=1,n1r
        do  j3=1,n3r
          call ZCOPY( n2r, array(j1,1,j3),n1r, ftarray,1 )
          call CFFTB( n2r, ftarray,ws2 )
          call ZCOPY( n2r, ftarray,1, array(j1,1,j3),n1r )
        enddo
      enddo
c
      do  j1=1,n1r
        do  j2=1,n2r
          call ZCOPY( n3r, array(j1,j2,1),n1r*n2r, ftarray,1 )
          call CFFTB( n3r, ftarray,ws3 )
          call ZCOPY( n3r, ftarray,1, array(j1,j2,1),n1r*n2r )
        enddo
      enddo
c
c      restore phase coming from translation in k-space (see cfft3d)
c      in reciprocal space
c
c 18Dec92-PAS: cexp()-> generics; 5Dec07-PAS: even more generic
      if( EVEN(n1r) )then
        ph1 = -one
      else
c       ph1  =-cexp(cmplx(0.,pi/float(n1r)))
        f1r = DBLE(n1r)
        phx(1) = -COS( pi/f1r )
        phx(2) = -SIN( pi/f1r )
        ph1 = DCMPLX( phx(1), phx(2) )
      endif
c
      if( EVEN(n2r) )then
        ph2 = -one
      else
c       ph2 = -cexp(cmplx(0.,pi/float(n2r)))
        f2r = DBLE(n2r)
        phy(1) = -COS( pi/f2r )
        phy(2) = -SIN( pi/f2r )
        ph2 = DCMPLX( phy(1), phy(2) )
      endif
c
      if( EVEN(n3r) )then
        ph3 = -one
      else
c       ph3 = -cexp(cmplx(0.,pi/float(n3r)))
        f3r = DBLE(n3r)
        phz(1) = -COS( pi/f3r )
        phz(2) = -SIN( pi/f3r )
        ph3 = DCMPLX( phz(1), phz(2) )
      endif
c
      ph3j = one
      do  j3=1,n3r
        ph32j = ph3j
        do  j2=1,n2r
          ph321j = ph32j
          do  j1=1,n1r
            array(j1,j2,j3) = array(j1,j2,j3)*ph321j
            ph321j = ph1*ph321j
          enddo
          ph32j = ph2*ph32j
        enddo
        ph3j = ph3*ph3j
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CFFT3D
c
c
      subroutine CFFT3D( array, n1r,n2r,n3r, ws1,ws2,ws3, ftarray )
c---------------------------------------------------------------
c Purpose: compute normalized complex forward fourier transform
c          of the 3-dimensionally periodic "array."
c
c Revision history:
c  23Jun15-PAS/2.67: fix ph2 bug (inserted 2.60c) using phx
c   5Dec07-PAS/2.60c: replace cmplx<->2dble with more generic
c  21Dec99-PAS/2.42: cosmetic clean-up
c   9Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c  For case n1r, n2r, or n3r odd, phase factor multiplication
c  translates in k-space by -(n1r-1)/2, -(n2r-1)/2, etc
c  For case n1r, n2r, or n3r even, phase factor multiplication
c  translates in k-space by -(n1r/2-1), -(n2r/2-1), etc
c  We assume ws1,ws2,ws3 arrays already initialized upon entry
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,expamx
c
c input/output arrays:
      DOUBLE COMPLEX    array(n1r,n2r,n3r)
      DIMENSION  ws1(*),ws2(*),ws3(*), ftarray(*)
c
c local declarations:
      DIMENSION  phx(2),phy(2),phz(2)
C      EQUIVALENCE  (phx,ph1),(phy,ph2),(phz,ph3)
      DOUBLE COMPLEX    ph1,ph2,ph3, ph3j,ph32j,ph321j
      LOGICAL    EVEN
      DATA  zero,one / 0.d0,1.d0 /
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
c 18Dec92-PAS: cexp()-> generics; 5Dec07-PAS: even more generic
      if( EVEN(n1r) )then
        ph1 = -one
      else
c       ph1  =-cexp(cmplx(0.,-pi/float(n1r)))
        f1r = DBLE(n1r)
        phx(1) = -COS( pi/f1r )
        phx(2) =  SIN( pi/f1r )
        ph1 = DCMPLX( phx(1), phx(2) )
      endif
c
      if( EVEN(n2r) )then
        ph2 = -one
      else
c       ph2 = -cexp(cmplx(0.,-pi/float(n2r)))
        f2r = DBLE(n2r)
        phy(1) = -COS( pi/f2r )
        phy(2) =  SIN( pi/f2r )
        ph2 = DCMPLX( phy(1), phy(2) )
      endif
c
      if( EVEN(n3r) )then
        ph3 = -one
      else
c       ph3 = -cexp(cmplx(0.,-pi/float(n3r)))
        f3r = DBLE(n3r)
        phz(1) = -COS( pi/f3r )
        phz(2) =  SIN( pi/f3r )
        ph3 = DCMPLX( phz(1), phz(2) )
      endif
c
      ph3j = one
      do  j3=1,n3r
        ph32j = ph3j
        do  j2=1,n2r
          ph321j = ph32j
          do  j1=1,n1r
            array(j1,j2,j3) = array(j1,j2,j3)*ph321j
            ph321j = ph1*ph321j
          enddo
          ph32j = ph2*ph32j
        enddo
        ph3j = ph3*ph3j
      enddo
c
c  Transform 1st coordinate:
c
      do  j2=1,n2r
        do  j3=1,n3r
          call CFFTF( n1r, array(1,j2,j3),ws1 )
        enddo
      enddo
c
c  Transform 2nd coordinate
c
      do  j3=1,n3r
        do  j1=1,n1r
          call ZCOPY( n2r, array(j1,1,j3),n1r, ftarray,1 )
          call CFFTF( n2r, ftarray,ws2 )
          call ZCOPY( n2r, ftarray,1, array(j1,1,j3),n1r )
        enddo
      enddo
c
c  Transform 3rd coordinate
c
      do  j2=1,n2r
        do  j1=1,n1r
          call ZCOPY( n3r, array(j1,j2,1),n1r*n2r, ftarray,1 )
          call CFFTF( n3r, ftarray,ws3 )
          call ZCOPY( n3r, ftarray,1, array(j1,j2,1),n1r*n2r )
        enddo
      enddo
c
c  Normalize result
c
      wnorm = one/ DBLE(n1r*n2r*n3r)
      call DSCAL( 2*n1r*n2r*n3r, wnorm, array,1 )
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CINIT
c
c
      subroutine CINIT( c )
c---------------------------------------------------------------
c Purpose: initialize c() for electron-nucleus matrix element
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  c(10,9)
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /
c
      do  j=1,9
        do  i=1,10
          c(i,j) = zero
        enddo
      enddo
c
      do  i=1,8
        c(i,i) = one
      enddo
      c(9,8)  = -one
      c(8,9)  = -one
      c(9,9)  = -one
      c(10,9) =  two
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CINITF
c
c
      subroutine CINITF( c,gradc )
c---------------------------------------------------------------
c Purpose: initialize c() for electron-nucleus force element
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  c(10,9),gradc(3,10,9)
      DATA  zero,one,two,four / 0.d0,1.d0,2.d0,4.d0 /
c
      do  j=1,9
        do  i=1,10
          c(i,j) = zero
          gradc(1,i,j) = zero
          gradc(2,i,j) = zero
          gradc(3,i,j) = zero
        enddo
      enddo
c
      do  i=1,8
        c(i,i) = one
      enddo
      c(9,8)  = -one
      c(8,9)  = -one
      c(9,9)  = -one
      c(10,9) =  two
c
      gradc(1,1,2) = -one
      gradc(2,1,3) = -one
      gradc(3,1,4) = -one
      gradc(2,2,5) = -one
      gradc(1,3,5) = -one
      gradc(3,3,6) = -one
      gradc(2,4,6) = -one
      gradc(3,2,7) = -one
      gradc(1,4,7) = -one
      gradc(1,2,8) = -two
      gradc(2,3,8) =  two
      gradc(1,2,9) =  two
      gradc(2,3,9) =  two
      gradc(3,4,9) = -four
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CMPTORB
c
c
      subroutine CMPTORB( icpctfl,
     $ natm,ntyp,nshld,nald, n1r,n2r,n3r,nptr,nlat,maxwf,
     $ itypa, numshl,lshel,nala,ala,cala, ratm,hh,rlat,
     $ lmx1ctr,almnv1c,  mngr3,mxgr3,ngr,
     $ r, rv,rsq,gsum, wf )
c---------------------------------------------------------------
c Purpose: compute compact orbitals on mesh for two-atom terms
c          in RHO1CTR.
c
c Written: Peter A. Schultz, based on PJFs original routine
c
c Revision history:
c   7Mar02-PAS/2.52: ang constants extracted
c  21Jun01-PAS/2.48: replace STOPs
c  19Dec99-PAS/2.42: clean-up; read/write big grid records
c  10Dec98-PAS/2.29: promote source to explicit double precision
c   1May97-PAS/2.17: naming conventions, on-off criterion
c  15Dec95-PAS/2.14: shell-by-shell ranges, cleanup
c  17Sep93-PAS: more stringent cutoffs installed
c   5Apr90-PAS: to speed up and bring in line with ORBBULK
c---------------------------------------------------------------
c
c  In order to give a "1-center density" that has the symmetry
c  of the crystal, these bloch orbitals all need to correspond
c  to k(parallel)=0.
c
c  On input, coordinate mesh assumed to be stored in r()
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  ratm(3,natm),hh(3,3),rlat(3,nlat)
      DIMENSION  lmx1ctr(ntyp),almnv1c(ntyp)
      DIMENSION  mngr3(*),mxgr3(*),ngr(*)
c input/output array:
      DIMENSION  r(3,nptr)
c scratch arrays:
      DIMENSION  rv(3,nptr),rsq(nptr),gsum(nptr)
      DIMENSION  wf(*)
c local declarations:
      DIMENSION  ratom(3)
c
      DIMENSION  vnorm(5)
      DIMENSION  lwrite(3)
      DATA  lwrite / 10,12,5 /
      DATA  zero,half,three / 0.d0,0.5d0,3.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Get angular normalizations:
      call VNORMS( vnorm )
      argmx = half*cutgaus
c
c    Center loop:
c
      i1next = 1
      do 1000 iatm=1,natm
        ityp = itypa(iatm)
        nshl = numshl(ityp)
        iorb1 = i1next
        do  ishl=1,nshl
          i1next = i1next + 2*lshel(ishl,ityp) + 1
        enddo
        if( lmx1ctr(ityp).lt.0 ) goto 1000
c
        almin = ala(1,1,ityp)
        almax = ala(1,1,ityp)
        do  ishl=1,nshl
          do  ial=1,nala(ishl,ityp)
            if( ala(ial,ishl,ityp).lt.almin ) almin = ala(ial,ishl,ityp)
            if( ala(ial,ishl,ityp).gt.almax ) almax = ala(ial,ishl,ityp)
          enddo
        enddo
c
        al1c = almax
        do  ishl=1,nshl
          do  ial=1,nala(ishl,ityp)
            ali = ala(ial,ishl,ityp)
            if( ali.ge.almnv1c(ityp) .and. ali.lt.al1c ) al1c = ali
          enddo
        enddo
        twoalc = al1c + almin
        rsqtop = cutgrid/twoalc
c
        nlatm = nlat
        iorbat0 = 0
        do 800 ishl=1,nshl
          lshl = lshel(ishl,ityp)
          nali = nala(ishl,ityp)
          norbsh = 2*lshl + 1
c
          nrs = ngr(iorb1+iorbat0)
          imin3 = mngr3(iorb1+iorbat0)
          nr0 = n1r*n2r*(imin3-1)
c
          iorbat0 = iorbat0 + norbsh
c
          alimax = ala(nali,ishl,ityp)
          do  ial=1,nali
            ali = ala(ial,ishl,ityp)
            if( ali.gt.alimax )  alimax = ali
          enddo
          if( lshl.gt.lmx1ctr(ityp).or.alimax.lt.almnv1c(ityp) )goto 800
c
          al1c = almax
          do  ial=1,nali
            ali = ala(ial,ishl,ityp)
            if( ali.ge.almnv1c(ityp) .and. ali.lt.al1c ) al1c = ali
          enddo
          twoalc = al1c + almin
          r2cutsh = cutgrid/twoalc
c
          nrset = lwrite(lshl+1)*nrs
          if( nrset.gt.2*maxwf )  call STOPXERR( 'cmptorb1' )
c
          do  nr=1,nrset
            wf(nr) = zero
          enddo
c
          nwrite = 0
          nlatmx = 1
          do 900 ilat=1,nlatm
c
            do  jr=1,3
              ratom(jr) = ratm(jr,iatm) + rlat(jr,ilat)
            enddo
c
            do  nr=1,nrs
              rv(1,nr) = r(1,nr0+nr) - ratom(1)
              rv(2,nr) = r(2,nr0+nr) - ratom(2)
              rv(3,nr) = r(3,nr0+nr) - ratom(3)
              rsq(nr) = rv(1,nr)**2 + rv(2,nr)**2 + rv(3,nr)**2
              gsum(nr) = zero
            enddo
            rsqmin = rsq(1)
            rsqmax = rsq(1)
            do  nr=1,nrs
              if( rsq(nr).lt.rsqmin ) rsqmin = rsq(nr)
              if( rsq(nr).gt.rsqmax ) rsqmax = rsq(nr)
            enddo
            if( rsqmin.lt.rsqtop .and. ilat.gt.nlatmx ) nlatmx = ilat
            if( rsqmin.gt.r2cutsh ) goto 900
c
            do 290 ial=1,nali
              alf = ala(ial,ishl,ityp)
              if( alf.lt.almnv1c(ityp) ) goto 290
c
              twoalf = alf + alf
              twoalc = alf + almin
              rsqcut = cutgrid/twoalc
              if( rsqmin.gt.rsqcut ) goto 290
c
              coef = cala(ial,ishl,ityp)/vnorm(lshl+1)
              if( twoalf*rsqmax.lt.argmx )then
                do  nr=1,nrs
                  gsum(nr) = gsum(nr) + coef*EXP( -alf*rsq(nr) )
                enddo
              else
                do  nr=1,nrs
                  if( rsq(nr).lt.rsqcut )
     $            gsum(nr) = gsum(nr) + coef*EXP( -alf*rsq(nr) )
                enddo
              endif
  290       continue
c
            if( lshl.eq.0 )then
c
              if( lmx1ctr(ityp).eq.0 )then
c
                nwrite = 1
                do  nr=1,nrs
                  wf(      nr) = wf(      nr) + gsum(nr)
                enddo
c
              elseif( lmx1ctr(ityp).eq.1 )then
c
                nwrite = 4
                do  nr=1,nrs
                  wf(      nr) = wf(      nr) + gsum(nr)
                  wf(  nrs+nr) = wf(  nrs+nr) + gsum(nr)*rv(1,nr)
                  wf(2*nrs+nr) = wf(2*nrs+nr) + gsum(nr)*rv(2,nr)
                  wf(3*nrs+nr) = wf(3*nrs+nr) + gsum(nr)*rv(3,nr)
                enddo
c
              else
c
                nwrite = 10
                do  nr=1,nrs
                  wf(      nr) = wf(      nr) + gsum(nr)
                  wf(  nrs+nr) = wf(  nrs+nr) + gsum(nr)*rv(1,nr)
                  wf(2*nrs+nr) = wf(2*nrs+nr) + gsum(nr)*rv(2,nr)
                  wf(3*nrs+nr) = wf(3*nrs+nr) + gsum(nr)*rv(3,nr)
                  wf(4*nrs+nr) = wf(4*nrs+nr) + gsum(nr)*
     $             rv(1,nr)*rv(1,nr)
                  wf(5*nrs+nr) = wf(5*nrs+nr) + gsum(nr)*
     $             rv(2,nr)*rv(1,nr)
                  wf(6*nrs+nr) = wf(6*nrs+nr) + gsum(nr)*
     $             rv(2,nr)*rv(2,nr)
                  wf(7*nrs+nr) = wf(7*nrs+nr) + gsum(nr)*
     $             rv(3,nr)*rv(1,nr)
                  wf(8*nrs+nr) = wf(8*nrs+nr) + gsum(nr)*
     $             rv(3,nr)*rv(2,nr)
                  wf(9*nrs+nr) = wf(9*nrs+nr) + gsum(nr)*
     $             rv(3,nr)*rv(3,nr)
                enddo
              endif
c
            elseif( lshl.eq.1 .and. lshl.lt.lmx1ctr(ityp) )then
c
              nwrite = 12
              do  nr=1,nrs
                wf(       nr) = wf(       nr) + gsum(nr)*rv(1,nr)
                wf(   nrs+nr) = wf(   nrs+nr) + gsum(nr)*rv(1,nr)*
     $           rv(1,nr)
                wf( 2*nrs+nr) = wf( 2*nrs+nr) + gsum(nr)*rv(1,nr)*
     $           rv(2,nr)
                wf( 3*nrs+nr) = wf( 3*nrs+nr) + gsum(nr)*rv(1,nr)*
     $           rv(3,nr)
                wf( 4*nrs+nr) = wf( 4*nrs+nr) + gsum(nr)*rv(2,nr)
                wf( 5*nrs+nr) = wf( 5*nrs+nr) + gsum(nr)*rv(2,nr)*
     $           rv(1,nr)
                wf( 6*nrs+nr) = wf( 6*nrs+nr) + gsum(nr)*rv(2,nr)*
     $           rv(2,nr)
                wf( 7*nrs+nr) = wf( 7*nrs+nr) + gsum(nr)*rv(2,nr)*
     $           rv(3,nr)
                wf( 8*nrs+nr) = wf( 8*nrs+nr) + gsum(nr)*rv(3,nr)
                wf( 9*nrs+nr) = wf( 9*nrs+nr) + gsum(nr)*rv(3,nr)*
     $           rv(1,nr)
                wf(10*nrs+nr) = wf(10*nrs+nr) + gsum(nr)*rv(3,nr)*
     $           rv(2,nr)
                wf(11*nrs+nr) = wf(11*nrs+nr) + gsum(nr)*rv(3,nr)*
     $           rv(3,nr)
              enddo
c
            elseif( lshl.eq.1 .and. lshl.ge.lmx1ctr(ityp) )then
c
              nwrite = 3
              do  nr=1,nrs
                wf(      nr) = wf(      nr) + gsum(nr)*rv(1,nr)
                wf(  nrs+nr) = wf(  nrs+nr) + gsum(nr)*rv(2,nr)
                wf(2*nrs+nr) = wf(2*nrs+nr) + gsum(nr)*rv(3,nr)
              enddo
c
            elseif( lshl.eq.2 )then
c
              if( lshl.lt.lmx1ctr(ityp) ) call STOPXERR( 'cmptorb2' )
              ang4 = vnorm(3)/vnorm(4)
              ang5 = vnorm(3)/vnorm(5)
c
              nwrite = 5
              do  nr=1,nrs
                wf(      nr) = wf(      nr) + gsum(nr)*
     $           rv(1,nr)*rv(2,nr)
                wf(  nrs+nr) = wf(  nrs+nr) + gsum(nr)*
     $           rv(2,nr)*rv(3,nr)
                wf(2*nrs+nr) = wf(2*nrs+nr) + gsum(nr)*
     $           rv(3,nr)*rv(1,nr)
                wf(3*nrs+nr) = wf(3*nrs+nr) + gsum(nr)*
     $           (rv(1,nr)**2 - rv(2,nr)**2)*ang4
                wf(4*nrs+nr) = wf(4*nrs+nr) + gsum(nr)*
     $           (three*rv(3,nr)**2 - rsq(nr))*ang5
              enddo
c
            else
              call STOPXERR( 'cmptorb3' )
            endif
c
c    Close lattice vector loop:
c
  900     continue
          nlatm = nlatmx
c
c    Save short-range orbitals to disk:
c
          if( nwrite.gt.0 )then
            nrset0 = 0
            do  nwr=1,nwrite
C             write(icpctfl)  (wf(nr),nr=nrset0+1,nrset0+nrs)
              call WRITBIG( icpctfl, nrs, wf(nrset0+1) )
              nrset0 = nrset0 + nrs
            enddo
          endif
c
c    Close radial function, then center loop:
c
  800   continue
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CNTRRHO
c
c
      subroutine CNTRRHO( icountr,
     $ natm,ntyp,nshld, n1r,n2r,n3r,nptr,nlat,maxwf,
     $ itypa, numshl,lshel, ratm,hh,rlat,
     $ lmx1ctr,almnv1c,  mngr3,mxgr3,ngr,
     $ r, rv, rho )
c---------------------------------------------------------------
c Purpose: compute charge densities of the required angular
c          symmetries used to cancel the lowest multipole
c          moments of the 1-center charges in the solution
c          of Poisson's equation for strong pseudopot atoms
c
c Written: Peter A. Schultz, based on PJFs original routine.
c
c Revision history:
c   8Mar02-PAS/2.52: clean unused variables/literal constants d0
c  21Jun01-PAS/2.48: replace STOPs
c  19Dec99-PAS/2.42: clean-up; read/write big grid records
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  24Apr97-PAS/2.17: naming conventions + on/off criterion
c  15Dec95-PAS/2.14: shell-by-shell range + cleanup
c  12Oct93-PAS: loosen a bit for rough consistency with rho calc
c  17Sep93-PAS: more stringent cutoffs installed
c   6Apr90-PAS: made more efficent and to need less disk
c---------------------------------------------------------------
c
c  On input, mesh coordinates  assumed carried in r()
c  Should install z-cutoffs of shorter range as well
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c input arrays:
      DIMENSION  itypa(ntyp), numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  ratm(3,natm),hh(3,3),rlat(3,nlat)
      DIMENSION  lmx1ctr(ntyp),almnv1c(ntyp)
      DIMENSION  mngr3(*),mxgr3(*),ngr(*)
c input/output:
      DIMENSION  r(3,nptr)
c scratch:
      DIMENSION  rv(3,nptr)
      DIMENSION  rho(*)
c local declarations:
      DIMENSION  number(3),ratom(3)
      DATA  number / 1,4,10 /
      DATA  zero,half  / 0.d0,0.5d0 /
c
c >>>> EXECUTABLE CODE:
c
      argmx = half*cutgaus
c
c    Loop over centers:
c
      iorb = 1
      do 1000 iatm=1,natm
        ityp = itypa(iatm)
        nrat = ngr(iorb)
        imin3 = mngr3(iorb)
        do  ishl=1,numshl(ityp)
          if( ngr(iorb).gt.nrat )then
            nrat = ngr(iorb)
            imin3 = mngr3(iorb)
          endif
          iorb = iorb + 2*lshel(ishl,ityp) + 1
        enddo
        if( lmx1ctr(ityp).lt.0 ) goto 1000
c
        al1c = almnv1c(ityp)
        twoal1c = al1c + al1c
c this cutoff ill-defined with current wvfcn cutoff implementation
        rsqcut = cutgrid / (0.75d0*al1c)
c       rsqcut = cutgrid / (0.5d0*(al1c+almin))
c
        aldpi = al1c/pi
        scoef = SQRT( aldpi )*aldpi
        pcoef = twoal1c*scoef
        dcoef = twoal1c*pcoef
        numlmx = number(lmx1ctr(ityp)+1)
c
        nr0 = n1r*n2r*(imin3-1)
        nrset = numlmx*nrat
        if( (nrset+5*nrat).gt.2*maxwf ) call STOPXERR( 'cntrrho1' )
c
        do  nr=1,nrset
          rho(nr) = zero
        enddo
        ng = nrset
        nrsq = ng + nrat
        nx = nrsq + nrat
        ny = nx + nrat
        nz = ny + nrat
c
        do 900 ilat=1,nlat
c
          do  jr=1,3
            ratom(jr) = ratm(jr,iatm) + rlat(jr,ilat)
          enddo
c
          do  nr=1,nrat
            rho(ng+nr) = zero
            rho(nx+nr) = r(1,nr0+nr) - ratom(1)
            rho(ny+nr) = r(2,nr0+nr) - ratom(2)
            rho(nz+nr) = r(3,nr0+nr) - ratom(3)
            rho(nrsq+nr) = rho(nx+nr)**2 + rho(ny+nr)**2 + rho(nz+nr)**2
          enddo
          rsqmin = rho(nrsq+1)
          rsqmax = rho(nrsq+1)
          do  nr=1,nrat
            if( rho(nrsq+nr).lt.rsqmin ) rsqmin = rho(nrsq+nr)
            if( rho(nrsq+nr).gt.rsqmax ) rsqmax = rho(nrsq+nr)
          enddo
          if( rsqmin.gt.rsqcut ) goto 900
c
          if( al1c*rsqmax.lt.argmx )then
            do  nr=1,nrat
              rho(ng+nr) = EXP( -al1c*rho(nrsq+nr) )
            enddo
          else
            do  nr=1,nrat
              if( rho(nrsq+nr).lt.rsqcut )
     $        rho(ng+nr) = EXP( -al1c*rho(nrsq+nr) )
            enddo
          endif
c
          if( numlmx.eq.1 )then
c
            do  nr=1,nrat
              rho(nr) = rho(nr) + scoef*rho(ng+nr)
            enddo
c
          elseif( numlmx.eq.4 )then
c
            do  nr=1,nrat
              gauss = pcoef*rho(ng+nr)
              rho(       nr) = rho(       nr) + gauss*(scoef/pcoef)
              rho(  nrat+nr) = rho(  nrat+nr) + gauss*rho(nx+nr)
              rho(2*nrat+nr) = rho(2*nrat+nr) + gauss*rho(ny+nr)
              rho(3*nrat+nr) = rho(3*nrat+nr) + gauss*rho(nz+nr)
            enddo
c
          elseif( numlmx.eq.10 )then
c
            do  nr=1,nrat
              x = rho(nx+nr)
              y = rho(ny+nr)
              z = rho(nz+nr)
              gauss = rho(ng+nr)
              rho(       nr) = rho(       nr) + scoef*gauss
              rho(  nrat+nr) = rho(  nrat+nr) + pcoef*gauss* x
              rho(2*nrat+nr) = rho(2*nrat+nr) + pcoef*gauss* y
              rho(3*nrat+nr) = rho(3*nrat+nr) + pcoef*gauss* z
              rho(4*nrat+nr) = rho(4*nrat+nr) + dcoef*gauss* x*y
              rho(5*nrat+nr) = rho(5*nrat+nr) + dcoef*gauss* y*z
              rho(6*nrat+nr) = rho(6*nrat+nr) + dcoef*gauss* z*x
              rho(7*nrat+nr) = rho(7*nrat+nr) + dcoef*gauss* x*x
              rho(8*nrat+nr) = rho(8*nrat+nr) + dcoef*gauss* y*y
              rho(9*nrat+nr) = rho(9*nrat+nr) + dcoef*gauss* z*z
            enddo
c
          endif
c
c    Close lattice vector loop:
c
  900   continue
c
c    Write out counter-charges:
c
        nrset0 = 0
        do  lmx=1,numlmx
C         write(icountr)  (rho(nr),nr=nrset0+1,nrset0+nrat)
          call WRITBIG( icountr, nrat, rho(nrset0+1) )
          nrset0 = nrset0 + nrat
        enddo
c
c    Close center loop:
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> COFR
c
c
      subroutine COFR( c, r )
c---------------------------------------------------------------
c Purpose: calculate r-dependent part of coefficient matrix
c          for evaluation of electron-nucleus matrix elements
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c assume c() initialized elsewhere to include all r-dependence
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  r(3), c(10,9)
      DATA  two,four / 2.d0,4.d0 /
c
      x = r(1)
      y = r(2)
      z = r(3)
c
      c(1,2) = -x
      c(1,3) = -y
      c(1,4) = -z
      c(1,5) = x*y
      c(1,6) = y*z
      c(1,7) = z*x
      c(1,8) = x**2 - y**2
      c(1,9) = two*z**2 - x**2 - y**2
c
      c(2,5) = -y
      c(3,5) = -x
      c(3,6) = -z
      c(4,6) = -y
      c(2,7) = -z
      c(4,7) = -x
      c(2,8) = -two*x
      c(3,8) =  two*y
      c(2,9) =  two*x
      c(3,9) =  two*y
      c(4,9) = -four*z
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> COFRF
c
c
      subroutine COFRF( c,gradc, r )
c---------------------------------------------------------------
c Purpose: calculate r-dependent part of coefficient matrix
c          for evaluation of electron-nucleus force elements
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c assume c() initialized elsewhere to include all r-dependence
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  r(3), c(10,9),gradc(3,10,9)
      DATA  two,four / 2.d0,4.d0 /
c
      x = r(1)
      y = r(2)
      z = r(3)
c
      c(1,2) = -x
      c(1,3) = -y
      c(1,4) = -z
      c(1,5) = x*y
      c(1,6) = y*z
      c(1,7) = z*x
      c(1,8) = x**2-y**2
      c(1,9) = two*z**2-x**2-y**2
c
      c(2,5) = -y
      c(3,5) = -x
      c(3,6) = -z
      c(4,6) = -y
      c(2,7) = -z
      c(4,7) = -x
      c(2,8) = -two*x
      c(3,8) =  two*y
      c(2,9) =  two*x
      c(3,9) =  two*y
      c(4,9) = -four*z
c
      gradc(1,1,5) =  y
      gradc(2,1,5) =  x
      gradc(2,1,6) =  z
      gradc(3,1,6) =  y
      gradc(1,1,7) =  z
      gradc(3,1,7) =  x
      gradc(1,1,8) =  two*x
      gradc(2,1,8) = -two*y
      gradc(1,1,9) = -two*x
      gradc(2,1,9) = -two*y
      gradc(3,1,9) =  four*z
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ATFMT
c
c
      subroutine ATFMTIN( iatmfmt, line )
c---------------------------------------------------------------
c Purpose: connect type of atom-line format to atom-line label
c
c Written: Peter A. Schultz, 11-January-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c iatmfmt = format of atom description
c         = 0  "coordinates"
c         = 1  "atom, type, positions"
c
c Warning: routine assumes (does not check) that input "line"
c is at least six characters long, and that the output "line"
c has enough space to load the identifying label.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      CHARACTER*(*)  line
      CHARACTER*(*)  readlbl*6
c
c >>>> EXECUTABLE CODE:
c
      iatmfmt = -1
c
      readlbl = line(1:6)
      if( readlbl.eq. 'coordi' )then
c       This will be position-only input (x,y,z)
        iatmfmt = 0
      elseif( readlbl.eq. 'atom, ' )then
c       This denotes atom,type,position (at,ty,x,y,z) input
        iatmfmt = 2
      endif
      RETURN
c
      entry ATFMTOUT( iatmfmt, line )
c
      if( iatmfmt.eq.0 )then
        line = 'coordinates (x y z) for atoms'
      elseif( iatmfmt.eq.1 .or. iatmfmt.eq.2 )then
        line = 'atom, type, position (at,ty,x,y,z) for atoms'
      else
        call STOPXERR( 'ATFMTOUT: unknown atom output format' )
      endif
      RETURN
c
c >>>> That's all, Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CONFIGRD
c
c
      subroutine CONFIGRD( IDT,IWR, iatmfmt, natmnm, ntyp,typnm,
     $ natm, atmnm, itypa, ratm )
c---------------------------------------------------------------
c Purpose: input atomic configuration
c
c Written: Peter A. Schultz, 26-November-2001, for v2.51
c
c Revision history:
c  10Jan02-PAS/2.54: bare coord read enabled
c---------------------------------------------------------------
c
c iatmfmt = format of atom description
c         = 0  just x,y,z
c         = 1  atom, type(as number), coords
c         = 2  atom name, type(as name), coords
c
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input: (type names)
      CHARACTER*(*)  typnm
      DIMENSION  typnm(*)
c output: atom names, atom types, atom coordinates
      CHARACTER*(*)  atmnm
      DIMENSION  atmnm(*)
      DIMENSION  itypa(*)
      DIMENSION  ratm(3,natm)
c
c >>>> EXECUTABLE CODE:
c
      do  iatm=1,natm
        call ATOMRD( IDT,IWR, iatmfmt, natmnm, ntyp, typnm,
     $   atmnm(iatm), iatm,itypa, ratm(1,iatm) )
      enddo
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CONFIGWR
c
c
      entry CONFIGWR( IDT, iatmfmt, natmnm, ntyp,typnm,
     $ natm, atmnm, itypa, ratm )
c---------------------------------------------------------------
c Purpose: output atomic configuration
c
c Written: Peter A. Schultz, 26-November-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      do  iatm=1,natm
        call ATOMWR( IDT, iatmfmt, natmnm, ntyp, typnm,
     $   atmnm(iatm), iatm,itypa, ratm(1,iatm) )
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> COORDRD
c
c
      subroutine COORDRD( IDT, iatmfmt, natm,ratm )
c---------------------------------------------------------------
c Purpose: extract atomic coordinates from geometry file
c
c Written: Peter A. Schultz, 10-January-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c atomic coordinates:
      DIMENSION  ratm(3,natm)
c Local
      DIMENSION  ratmi(3)
c
c >>>> EXECUTABLE CODE:
c
      jatmfmt = iatmfmt
      do  iatm=1,natm
        call RATMRD( IDT, jatmfmt, ratmi )
        ratm(1,iatm) = ratmi(1)
        ratm(2,iatm) = ratmi(2)
        ratm(3,iatm) = ratmi(3)
      enddo
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> COORDWR
c
c
      entry COORDWR( IDT,  natm,ratm )
c---------------------------------------------------------------
c Purpose: dump raw atomic coordinates to geometry file
c
c Written: Peter A. Schultz, 10-January-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      do  iatm=1,natm
        ratmi(1) = ratm(1,iatm)
        ratmi(2) = ratm(2,iatm)
        ratmi(3) = ratm(3,iatm)
        call RATMWR( IDT, ratmi )
      enddo
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ATOMRD
c
c
      subroutine ATOMRD( IDT,IWR, iatmfmt, natmnm, ntyp,typnm,
     $ atmnm, iatm,itypa, ratm )
c---------------------------------------------------------------
c Purpose: input atom coordinates
c
c Written: Peter A. Schultz, 26-November-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Oh, the ineffable joys of character manipulation in fortran ...
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input: (type names)
      CHARACTER*(*)  typnm
      DIMENSION  typnm(*)
c output: atom names, atom types, atom coordinates
      CHARACTER*(*)  atmnm
      DIMENSION  itypa(*)
      DIMENSION  ratm(3)
c
c local declarations:
      PARAMETER  ( nline=80 )
      CHARACTER  line*(nline), strtmp*(nline)
      LOGICAL    printon
c
c >>>> EXECUTABLE CODE:
c
      printon = ( IWR .ge. 0 )
c Global format for output of atomic coordinates:
 9100 format(1x,3f16.10)
c
      if( iatmfmt .eq. 0 )then
c       Read the raw coordinates
        read(IDT,*)  ratm
        if( printon ) write(IWR,9100)  ratm
c
      elseif( iatmfmt .eq. 1 .or. iatmfmt .eq. 2 )then
c
c       Read the line with the atomic information:
c
        read(IDT,'(a80)',end=1301,err=1301 )  line
        if( printon ) write(IWR,'(a)' )   line
        nl1 = 1
        nl2 = nline
c
c       Parse the atom number/name (first string on line):
c
        call STRPARS( line, nl1,nl2, n1,n2 )
        if( n1 .eq. 0 ) call STOPXERR( 'no atom name found' )
        nmlen = n2 - n1 + 1
        if( nmlen .gt. natmnm ) call STOPXERR( 'atom name too long' )
        strtmp = ' '
        strtmp(1:nmlen) = line(n1:n2)
        atmnm = strtmp(1:natmnm)
        nl1 = n2 + 1
c
c       First, check if atoms input as number sequence.
c       If they are, check that atoms are indeed in sequence.
        read( atmnm, * , err=120 ) jatm
        if( jatm .ne. iatm ) call STOPXERR( 'atom out of sequence' )
c       Shift atom name to right aligned 6-char deep
        atmnm = ' '
        write( atmnm, '(i6)' ) iatm
c
c       Parse the atom type:
c
  120   continue
        call STRPARS( line, nl1,nl2, n1,n2 )
        if( n1 .eq. 0 ) call STOPXERR( 'no atom type found on line' )
        nmlen = n2 - n1 + 1
        if( nmlen .gt. natmnm ) call STOPXERR( 'type name too long' )
        nl1 = n2 + 1
c
c       And now try and get the atom type:
c
        if( iatmfmt .eq. 2 )then
          itypa(iatm) = 0
          do  ityp=1,ntyp
            strtmp = typnm(ityp)
            call STRPARS( strtmp, 1,nline, nt1,nt2 )
            ntlen = nt2 - nt1 + 1
            if( ntlen .eq. nmlen .and.
     $          line(n1:n2) .eq. strtmp(nt1:nt2) )then
              itypa(iatm) = ityp
              goto 200
            endif
          enddo
        endif
c       Did not find type in list of type names, perhaps as type #?
        read( line(n1:n2), * , err=130 ) ityp
        if( ityp.lt.1 .or. ityp.gt.ntyp ) call STOPXERR( 'bad type' )
        itypa(iatm) = ityp
c
c       Atom type are input as numbers, not names:
        iatmfmt = 1
c
        goto 200
c
  130   call STOPXERR( 'atom type unknown' )
c
  200   continue
c
c       Get the atom coordinates:
        read( line(nl1:nl2), * )  ratm
c
      else
c       Unknown geometry format
        call STOPXERR( 'unknown geometry (input) format' )
      endif
c
      RETURN
Cc
Cc >>>> ERROR HANDLING
Cc
C1301 call STOPXERR( 'error (or eof) reading atom coordinates' )
C     RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ATOMWR
c
c
       entry ATOMWR( IDT, iatmfmt, natmnm, ntyp,typnm,
     $ atmnm, iatm,itypa, ratm )
c---------------------------------------------------------------
c Purpose: output atom coordinates
c
c Written: Peter A. Schultz, 26-November-2001, for v2.51
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      if( iatmfmt .eq. 0 )then
c       Write out raw coordinates without atomic id's
        write(IDT,9100)  ratm
c
      elseif( iatmfmt .eq. 1 .or. iatmfmt .eq. 2 )then
c       Build line with the atomic information:
        line = ' '
        nl1 = 2
        nl2 = nline
c
c       Parse and incorporate the atom name:
        call STRPARS( atmnm, 1,natmnm, n1,n2 )
        if( n1 .eq. 0 ) call STOPXERR( 'nameless atom in atom output' )
        nmlen = n2
        nl2 = nl1 + nmlen - 1
        line(nl1:nl2) = atmnm(1:n2)
        nl1 = nl1 + natmnm + 1
c
c       Parse and incorporate the atom type name:
        ityp = itypa(iatm)
        strtmp = ' '
        if( iatmfmt .eq. 1 )then
c         Output type as type #, not type name
          n2 = 6
          write( strtmp(1:6), '(i6)' ) ityp
        else
c         Output type as type name
          call STRPARS( typnm(ityp), 1,natmnm, n1,n2 )
          if( n1 .eq. 0 ) call STOPXERR( 'nameless type in output' )
          strtmp(1:natmnm) = typnm(ityp)
        endif
        nmlen = n2
        nl2 = nl1 + nmlen - 1
        line(nl1:nl2) = strtmp(1:n2)
        nl1 = nl1 + natmnm + 1
c
c       Incorporate the atom coordinates:
        nl2 = nl1 + 1 + 3*16
        if( nl2 .gt. nline ) call STOPXERR( 'atom type/coord too long' )
        write( line(nl1:nl2), 9100 )  ratm
c
        write(IDT,'(a)')  line(1:nl2)
c
      else
c       Unknown geometry format
        call STOPXERR( 'unknown geometry (output) format' )
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RATMRD
c
c
      entry RATMRD( IDT, iatmfmt, ratm )
c---------------------------------------------------------------
c Purpose: output atom coordinates
c
c Written: Peter A. Schultz, 10-January-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      if( iatmfmt .eq. 0 )then
c       Read the raw coordinates
        read(IDT,*)  ratm
c
      elseif( iatmfmt .eq. 1 .or. iatmfmt .eq. 2 )then
c
c       Read the line with the atomic information:
c
        read(IDT,'(a80)',end=1301,err=1301 )  line
        nl1 = 1
        nl2 = nline
c
c       Skip the atom number/name (first string on line):
c
        call STRPARS( line, nl1,nl2, n1,n2 )
        if( n1 .eq. 0 ) call STOPXERR( 'no atom name found' )
        nl1 = n2 + 1
c
c       Skip the atom type (second string on line):
c
        call STRPARS( line, nl1,nl2, n1,n2 )
        if( n1 .eq. 0 ) call STOPXERR( 'no atom type found on line' )
        nl1 = n2 + 1
c
c       Get the atom coordinates:
        read( line(nl1:nl2), * )  ratm
c
      else
c       Unknown geometry format
        call STOPXERR( 'unknown geometry (input) format' )
c
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RATMWR
c
c
      entry RATMWR( IDT, ratm )
c---------------------------------------------------------------
c Purpose: output atom coordinates
c
c Written: Peter A. Schultz, 10-January-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      write(IDT,9100)  ratm
c
      RETURN
c
c >>>> ERROR HANDLING
c
 1301 call STOPXERR( 'error (or eof) reading atom coordinates' )
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CONVCHK
c
c
      subroutine CONVCHK( IWR, chglbl, istat, iter,itstop, convrg,
     $ chgmax,chgrms,  nd1,nd2, dvec )
c-->                           (nd1*nd2)
c---------------------------------------------------------------
c Purpose: test for convergence/completion
c
c Written: Peter A. Schultz, 25-September-1997, v2.21
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c
      CHARACTER*(*)  chglbl
      DIMENSION  dvec(nd1,*)
C     DIMENSION  dvec(nd1,nd2)
c
c >>>> EXECUTABLE CODE:
c
      nmx = 1
      chgmax = zero
      chgrms = zero
      do  id2=1,nd2
        chg = zero
        do  id1=1,nd1
          chg = chg + dvec(id1,id2)**2
        enddo
        chgrms = chgrms + chg
        if( chg .gt. chgmax )then
          nmx = id2
          chgmax = chg
        endif
      enddo
      chgmax =  SQRT( chgmax )
      chgrms = chgrms / DBLE( nd2 )
      chgrms = SQRT( chgrms )
c
      write(IWR,9005)  chglbl, chgrms,chgmax, nmx
 9005 format(1x,'rms,max ',a,'=',1p2d12.4,' for component#',i9)
c
      istat = 0
      if( iter .eq. itstop ) istat = 1
      if( chgmax .lt. convrg ) istat = 2
c
      RETURN
      END
c
c
c  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SCFCHECK
c
c
      subroutine SCFCHECK( IWR, chglbl, iscfstat,
     $ iter,itstop, convrg,  chgmax,chgrms,  ndvloc,
     $ dvscf )
c --> (ndvloc)
c---------------------------------------------------------------
c Purpose: test for convergence/completion, k-parallel distributed vector
c
c Written: Andrew C. Pineda and PAS, Nov-2009 - Apr 2012, for 2.63
c          Adapted from convchk
c
c Revision history:
c---------------------------------------------------------------
c Notes:
c  On entry and exit:  dvscf=dv
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c
      CHARACTER*(*)  chglbl
      DIMENSION  dvscf(*)  
C     DIMENSION  dvscf(ndvloc)
c
c >>>> EXECUTABLE CODE:
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
c  Set local variables: 
      idvmx = 1
      chgmax = zero
      chgrms = zero
c
c  The next block is only done by processors having part of this vector
      if( ndvloc .gt. 0 )then
c       Accumulate chgmax & idvmx, and chgrms on active processors
        do 100 idv=1,ndvloc
          chg = dvscf(idv)**2
          chgrms = chgrms + chg
          if( chg .gt. chgmax )then
            idvmx = idv
            chgmax = chg
          endif
  100   continue
        chgmax = SQRT( chgmax )
      endif
c
c  Reduce ndv, chgmax & idvmx, and chgrms back to master.
c
      ndvtot = 0
      chgrmstot = zero
      lenmsg = 1
c
      do 500 jproc=0,nprocs-1
c
        if( jproc .eq. master )then
c         Local accumulation on the master
c
          if( iproc .eq. master .and. ndvloc .gt. 0 )then
            ndvtot = ndvtot + ndvloc
            chgrmstot = chgrmstot + chgrms
          endif
c
        else
c         Accumulate results from procs at master
c
          if( iproc .eq. master )then
c
c           Image master receives size of vector on jproc ...
            call MPRECVI( jproc, lenmsg, ndvjpr, icomm )
c            ... and receives results if jproc had part of vector
            if( ndvjpr .gt. 0 ) then
              call MPRECVI(  jproc, lenmsg, idvmxjpr,  icomm )
              call MPRECVR8( jproc, lenmsg, chgmaxjpr, icomm )
              call MPRECVR8( jproc, lenmsg, chgrmsjpr, icomm )
              if( chgmaxjpr .gt. chgmax )then
                idvmx = ndvtot + idvmxjpr
                chgmax = chgmaxjpr
              endif
              chgrmstot = chgrmstot + chgrmsjpr
              ndvtot = ndvtot + ndvjpr
            endif
c
          elseif( iproc .eq. jproc )then
c
c           This proc sends size of its vector to image master
            call MPSENDI( master, lenmsg, ndvloc, icomm )
c           Send convergnce analysis to master, if jproc had part of vector
            if( ndvloc .gt. 0 )then
              call MPSENDI(  master, lenmsg, idvmx,  icomm )
              call MPSENDR8( master, lenmsg, chgmax, icomm )
              call MPSENDR8( master, lenmsg, chgrms, icomm )
            endif
c
          endif
        endif
  500 continue
c
      if( iproc .eq. master )then
c       Only master dumps a record to the listing file
        chgrms = chgrmstot / DBLE( ndvtot )
        chgrms = SQRT( chgrms )
c
        write(IWR,9005)  chglbl, chgrms,chgmax, idvmx
 9005   format(1x,'rms,max ',a,'=',1p2d12.4,' for component#',i10)
c
        iscfstat = 0
        if( iter .eq. itstop ) iscfstat = 1
        if( chgmax .lt. convrg ) iscfstat = 2
      endif
c
c Broadcast status to all processors:
      if( nprocs .gt. 1 ) call MPBCASTI( master, 1, iscfstat, icomm )
c
c    That's all, Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CORFORC
c
c
      subroutine CORFORC( IWR, ndim, frccor, strcor,
     $ natm,ntyp,nrd, nlat,  itypa,numshl, ratm,rlat,
     $ hh, weight, ndbox,nbox,nrec,inrec,noboxs,inboxs, boxrad,
     $ nrcor, radmsh,corden, y2,u,
     $ vxcgrd, r, wkb )
c---------------------------------------------------------------
c Purpose: compute parts of force due to partial core charge
c
c Written: Peter A. Schultz, 29-August-1995
c
c Revision history:
c  24May00-PAS/2.43h: bugfix of ndim=1,2 code
c  21Dec99-PAS/2.42: cosmetic clean-up
c  27Sep99-PAS/2.40: full three-dimensional stress tensor
c  17Dec98-PAS/2.30: clean force/stress arrays
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  30Jan98-PAS/2.21: adapted for boxed grid
c   1May97-PAS/2.17: naming conventions, new grid coord rtn
c  15Dec95-PAS/2.14: shell-by-shell ranges
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output arrays:
      DIMENSION  frccor(3,natm), strcor(3,3)
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp)
      DIMENSION  ratm(3,natm),rlat(3,nlat), hh(3,3)
      DIMENSION  ndbox(2,2,3),noboxs(nbox),inboxs(nrec,nbox)
      DIMENSION  nrcor(ntyp), radmsh(nrd,*),corden(nrd,*)
      DIMENSION  vxcgrd(*)
c scratch arrays:
      DIMENSION  y2(*),u(*)
      DIMENSION  r(3,*), wkb(*)
c local declarations:
      DIMENSION  str(3,3)
      DIMENSION  ratom(3)
      DIMENSION  r0box(3),boxctr(3)
      DATA  zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      call MKZERO( 9, strcor )
      call MKZERO( 3*natm, frccor )
c
c >>>>>>>>>> Set up grid:
c
      irpot = 0
      do 30 ibox=1,nbox
c
c  Get basic box info
        call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $   ira0,irb0,irc0, idra,idrb,idrc )
        nrbox = idra*idrb*idrc
c
        iv0 = irpot
        irpot = irpot + nrbox
c
        nobox = noboxs(ibox)
        if( nobox.le.0 ) goto 30
c
c  Generate coordinates
c
        call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
        call MKRBOX( hh,r0box, idra,idrb,idrc, r(1,iv0+1) )
c
   30 continue
c
c >>>> Atom loop:
c
      inext = 1
      do 1000 iatm=1,natm
        ityp = itypa(iatm)
c
        irec0 = irec00
        inbox0 = inbox00
        iatshl0 = iatshl00
        do  ishl=1,numshl(ityp)
          inbox00 = 2*inbox00
          if( inrec*(iatshl00/inrec).eq.iatshl00 )then
            irec00 = irec00 + 1
            inbox00 = 1
          endif
          iatshl00 = iatshl00 + 1
        enddo
c
        nrsc = nrcor(ityp) + 1
c check if this center has any core charge associated with it
        if( nrsc.eq.1 ) goto 1000
c
c Interpolate core density
        ddy0 = 1.d31
        ddy1 = 1.d31
        call SPLINE( nrsc, radmsh(1,ityp),corden(1,ityp),
     $   ddy0,ddy1,y2,u )
        rngcor = radmsh(nrsc,ityp)
c
        fx = zero
        fy = zero
        fz = zero
        call MKZERO( 9, str )
c
c  Cycle over boxes:
c
        irpot = 0
        do 300 ibox=1,nbox
c
c  Get basic box info
          call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $     ira0,irb0,irc0, idra,idrb,idrc )
          nrbox = idra*idrb*idrc
c
          iv0 = irpot
          irpot = irpot + nrbox
c
          nobox = noboxs(ibox)
          if( nobox.le.0 ) goto 300
c
          call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
c
c  Set up for scratch space below:
          ir0 = 0
          irmag = ir0
          idcor = irmag + nrbox
c
c >>>> Lattice loop:
c
          do 900 ilat=1,nlat
c
            rngbox = zero
            do  jr=1,3
              ratom(jr) = ratm(jr,iatm) + rlat(jr,ilat)
              rngbox = rngbox + (ratom(jr)-boxctr(jr))**2
            enddo
            rngbox = SQRT(rngbox) - boxrad
            if( rngbox.gt.rngcor ) goto 900
c
c  Generate r**2 on mesh ...
            do  nr=1,nrbox
              wkb(irmag+nr) = SQRT( (r(1,iv0+nr)-ratom(1))**2
     $                            + (r(2,iv0+nr)-ratom(2))**2
     $                            + (r(3,iv0+nr)-ratom(3))**2 )
            enddo
c
c interpolate to get deriv. of core density from radial core density
            call SPLIND( nrsc, radmsh(1,ityp),corden(1,ityp),y2,
     $                   nrbox,wkb(irmag+1),wkb(idcor+1) )
c
c to prevent divide-by-zeroes
            do  nr=1,nrbox
              if( wkb(irmag+nr) .lt. 1.d-8 ) wkb(irmag+nr) = 1.d-8
            enddo
c
            if( ndim.eq.0 )then
              do  nr=1,nrbox
                dx = r(1,iv0+nr) - ratom(1)
                dy = r(2,iv0+nr) - ratom(2)
                dz = r(3,iv0+nr) - ratom(3)
                rfac = wkb(idcor+nr)*vxcgrd(iv0+nr)/wkb(irmag+nr)
                fx = fx + rfac*dx
                fy = fy + rfac*dy
                fz = fz + rfac*dz
              enddo
            elseif( ndim.eq.1 )then
              do  nr=1,nrbox
                dx = r(1,iv0+nr) - ratom(1)
                dy = r(2,iv0+nr) - ratom(2)
                dz = r(3,iv0+nr) - ratom(3)
                rfac = wkb(idcor+nr)*vxcgrd(iv0+nr)/wkb(irmag+nr)
                fx = fx + rfac*dx
                fy = fy + rfac*dy
                fz = fz + rfac*dz
                str(1,1) = str(1,1) + rfac*dx*dx
              enddo
            elseif( ndim.eq.2 )then
              do  nr=1,nrbox
                dx = r(1,iv0+nr) - ratom(1)
                dy = r(2,iv0+nr) - ratom(2)
                dz = r(3,iv0+nr) - ratom(3)
                rfac = wkb(idcor+nr)*vxcgrd(iv0+nr)/wkb(irmag+nr)
                fx = fx + rfac*dx
                fy = fy + rfac*dy
                fz = fz + rfac*dz
                str(1,1) = str(1,1) + rfac*dx*dx
                str(2,1) = str(2,1) + rfac*dy*dx
                str(1,2) = str(1,2) + rfac*dx*dy
                str(2,2) = str(2,2) + rfac*dy*dy
              enddo
            elseif( ndim.eq.3 )then
              do  nr=1,nrbox
                dx = r(1,iv0+nr) - ratom(1)
                dy = r(2,iv0+nr) - ratom(2)
                dz = r(3,iv0+nr) - ratom(3)
                rfac = wkb(idcor+nr)*vxcgrd(iv0+nr)/wkb(irmag+nr)
                fx = fx + rfac*dx
                fy = fy + rfac*dy
                fz = fz + rfac*dz
                str(1,1) = str(1,1) + rfac*dx*dx
                str(2,1) = str(2,1) + rfac*dy*dx
                str(3,1) = str(3,1) + rfac*dz*dx
                str(1,2) = str(1,2) + rfac*dx*dy
                str(2,2) = str(2,2) + rfac*dy*dy
                str(3,2) = str(3,2) + rfac*dz*dy
                str(1,3) = str(1,3) + rfac*dx*dz
                str(2,3) = str(2,3) + rfac*dy*dz
                str(3,3) = str(3,3) + rfac*dz*dz
              enddo
            endif
c
c Close lattice vector loop:
c
  900     continue
c
c Close box loop:
c
  300   continue
c
        frccor(1,iatm) = frccor(1,iatm) + weight*fx
        frccor(2,iatm) = frccor(2,iatm) + weight*fy
        frccor(3,iatm) = frccor(3,iatm) + weight*fz
        do  jd=1,3
          do  id=1,3
             strcor(id,jd) = strcor(id,jd) + weight*str(id,jd)
          enddo
        enddo
c
c Close atom loop:
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CROSS
c
c
      subroutine CROSS( a,b, axb )
c---------------------------------------------------------------
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c axb() = a() X b()
      DIMENSION  a(3),b(3), axb(3)
c
      axb(1) = a(2)*b(3) - a(3)*b(2)
      axb(2) = a(3)*b(1) - a(1)*b(3)
      axb(3) = a(1)*b(2) - a(2)*b(1)
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DAT0ANG
c
c
      subroutine DAT0ANG( nang, angwts,angpts )
c---------------------------------------------------------------
c Purpose: initialize angular grid sample points
c          For non-standard (development) xc1c fit code.
c
c Written: Peter A. Schultz, 23-May-2001, for v2.47
c
c Revision history:
c  21Jun01-PAS/2.48: replace STOPs
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input/output arrays:
      DIMENSION  angwts(nang), angpts(3*nang)
c local declarations:
      DIMENSION  angwt0( 72),angpt0(216)
c  For angular xc-fits (non-functional test code):
      DATA  (angwt0(i),i=1,12) / 12*0.15583297d0 /
      DATA  (angpt0(i),i=1,36) /
     & 0.d0     , 0.52573d0, 0.85065d0, 0.d0     ,-0.52573d0, 0.85065d0,
     &-0.85065d0, 0.d0     , 0.52573d0, 0.85065d0, 0.d0     , 0.52573d0,
     &-0.52573d0, 0.85065d0, 0.d0     , 0.52573d0, 0.85065d0, 0.d0     ,
     & 0.d0     ,-0.52573d0,-0.85065d0, 0.d0     , 0.52573d0,-0.85065d0,
     & 0.85065d0, 0.d0     ,-0.52573d0,-0.85065d0, 0.d0     ,-0.52573d0,
     & 0.52573d0,-0.85065d0, 0.d0     ,-0.52573d0,-0.85065d0, 0.d0     /
      DATA  (angwt0(i),i=13,72) / 60*0.17827292d0 /
      DATA  (angpt0(i),i=37,112) /
     &-0.15111d0, 0.15524d0, 0.97626d0, 0.97626d0,-0.15111d0, 0.15524d0,
     & 0.15524d0, 0.97626d0,-0.15111d0,-0.15111d0,-0.15524d0,-0.97626d0,
     &-0.97626d0,-0.15111d0,-0.15524d0,-0.15524d0,-0.97626d0,-0.15111d0,
     & 0.15111d0, 0.15524d0,-0.97626d0,-0.97626d0, 0.15111d0, 0.15524d0,
     & 0.15524d0,-0.97626d0, 0.15111d0, 0.15111d0,-0.15524d0, 0.97626d0,
     & 0.97626d0, 0.15111d0,-0.15524d0,-0.15524d0, 0.97626d0, 0.15111d0,
     & 0.31584d0, 0.25705d0, 0.91334d0, 0.91334d0, 0.31584d0, 0.25705d0,
     & 0.25705d0, 0.91334d0, 0.31584d0, 0.31584d0,-0.25705d0,-0.91334d0,
     &-0.91334d0, 0.31584d0,-0.25705d0,-0.25705d0,-0.91334d0, 0.31584d0,
     &-0.31584d0, 0.25705d0,-0.91334d0,-0.91334d0,-0.31584d0, 0.25705d0,
     & 0.25705d0,-0.91334d0,-0.31584d0,-0.31584d0,-0.25705d0, 0.91334d0,
     & 0.91334d0,-0.31584d0,-0.25705d0,-0.25705d0, 0.91334d0,-0.31584d0,
     & 0.34631d0, 0.66628d0, 0.66042d0, 0.66042d0 /
      DATA  (angpt0(i),i=113,216) /
     & 0.34631d0, 0.66628d0, 0.66628d0, 0.66042d0, 0.34631d0, 0.34631d0,
     &-0.66628d0,-0.66042d0,-0.66042d0, 0.34631d0,-0.66628d0,-0.66628d0,
     &-0.66042d0, 0.34631d0,-0.34631d0, 0.66628d0,-0.66042d0,-0.66042d0,
     &-0.34631d0, 0.66628d0, 0.66628d0,-0.66042d0,-0.34631d0,-0.34631d0,
     &-0.66628d0, 0.66042d0, 0.66042d0,-0.34631d0,-0.66628d0,-0.66628d0,
     & 0.66042d0,-0.34631d0,-0.10181d0, 0.81739d0, 0.56702d0, 0.56702d0,
     &-0.10181d0, 0.81739d0, 0.81739d0, 0.56702d0,-0.10181d0,-0.10181d0,
     &-0.81739d0,-0.56702d0,-0.56702d0,-0.10181d0,-0.81739d0,-0.81739d0,
     &-0.56702d0,-0.10181d0, 0.10181d0, 0.81739d0,-0.56702d0,-0.56702d0,
     & 0.10181d0, 0.81739d0, 0.81739d0,-0.56702d0, 0.10181d0, 0.10181d0,
     &-0.81739d0, 0.56702d0, 0.56702d0, 0.10181d0,-0.81739d0,-0.81739d0,
     & 0.56702d0, 0.10181d0,-0.40923d0, 0.50155d0, 0.76223d0, 0.76223d0,
     &-0.40923d0, 0.50155d0, 0.50155d0, 0.76223d0,-0.40923d0,-0.40923d0,
     &-0.50155d0,-0.76223d0,-0.76223d0,-0.40923d0,-0.50155d0,-0.50155d0,
     &-0.76223d0,-0.40923d0, 0.40923d0, 0.50155d0,-0.76223d0,-0.76223d0,
     & 0.40923d0, 0.50155d0, 0.50155d0,-0.76223d0, 0.40923d0, 0.40923d0,
     &-0.50155d0, 0.76223d0, 0.76223d0, 0.40923d0,-0.50155d0,-0.50155d0,
     & 0.76223d0, 0.40923d0 /
c
c >>>> EXECUTABLE CODE:
c
      if( nang.eq.12 .or. nang.eq.72 )then
        do  iang=1,nang
          angwts(iang) = angwt0(iang)
        enddo
        do  iang=1,3*nang
          angpts(iang) = angpt0(iang)
        enddo
      else
        call STOPXERR( 'dat0ang-bad angular grid' )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DAT0CELL
c
c
      subroutine DAT0CELL(
     $ do_cell, ndim, iuctype, icellscheme,strsbroy,
     $ iucstep,iuciter,maxucstep,nhistuc, cellconv,strxtrnl,
     $ strnmax, ucstepfac,cellstepdecr,cellstepincr, ucblend,
     $ strlast )
c---------------------------------------------------------------
c Purpose: initialize user-adjustable parameters for cell opt
c
c Written: Peter A. Schultz, 1-May-2002, v2p53 (cell opt)
c
c Revision history:
c   6Apr13-PAS/2.65: independdent tensor opts
c  23Sep08-PAS/2.62: isotropic cell opt
c  11Sep03-PAS/2.57: remove itmaxd-dependence
c  10Jan03-PAS/2.55: limited-history option
c   1May02-PAS/2.53: adapted Rick Muller's original cell code
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      LOGICAL    do_cell
      DIMENSION  strxtrnl(3,3)
      DIMENSION  strlast(3*3), ucstepfac(3*3)
c
c >>>> EXECUTABLE CODE:
c
c Initialization:
c  iucstep = Cell optimization step number
c  iuciter = Cell step in iterative method (broyden)
      iucstep = 1
      iuciter = 1
c
c Standard user-settable parameters:
c
c  maxucstep = Maximum number of cell steps
      maxucstep = 50
c  nhistuc = Length of history used in blend optimizations
      nhistuc = 10
c  cellconv = Max cell stress convergence criteria (GPa)
      cellconv = 0.0020d0
c  strxtrnl = External stress applied to crystal (GPa)
      call MKZERO( 9, strxtrnl )
c
c Slightly non-standard user-settable parameters:
c
c iuctype=type of constraints on cell opt; 0=none,1=isotropic,>1 restrictions
      iuctype = 0
c  icellscheme = Cell optimization method
c   1=steepest descent; 2=broyden; 0=steepest then broyden
      icellscheme = 0
c  strsbroy = Stress at which to start doing broyden (GPa)
      strsbroy = 5.0d0
c
c Non-standard user-settable parameters:
c
c  strnmax = Size limit on strain in initial cell step (unitless)
      strnmax = 0.05d0
c  ucstepfac = Initial cell stress (GPa) to strain conversion
c       (NB: negative to reflect sign convention for stress)
c       pas: best(?) ~( 1 / (3*bulk_modulus) ), use B=133 GPa
      do  ij=1,3*3
        ucstepfac(ij) = -0.0025d0
      enddo
c  cellstepdecr/incr = Ratio to increase/decrease the step size
      cellstepdecr = 0.5d0
      cellstepincr = 1.5d0
c  ucblend = Initial broyden blend (best as 1.0)
      ucblend = 1.0d0
c  strlast = Previous cell max stress in cell sequence
      do  ij=1,3*3
        strlast(ij) = 9.d9
      enddo
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DAT0GEOM
c
c
      subroutine DAT0GEOM( do_neb,
     $ natm,nafrc,iforce,ifdefct,
     $ nhistg,gblend,gconv,tstep,igstart,igstop,
     $ nslics,     iatframe )
c---------------------------------------------------------------
c Purpose: initialize parameters for geometry phase
c
c Written: Peter A. Schultz, 23-May-2001, for v2.47
c
c Revision history:
c   1Aug17-PAS/2.68: unified SLICS
c   6Feb13-PAS/2.65: new default settings (gconv)
c   9Sep08-PAS/2.62: option to freeze atoms along vector
c    Oct06-RMV/2.60: initial SLIC options
c  25Apr04-PAS/2.58: purge "igtype"
c  11Sep03-PAS/2.57: remove itmaxd-dependence
c  10Jan03-PAS/2.55: limited-history option
c  28Jan02-PAS/2.54: fixed frame data
c   2Oct01-PAS/2.50: damped dynamics params
c---------------------------------------------------------------
c
c Version 2.65 new default setttings
c   gconv:   old = 0.0020 to new = 0.0008 Ry.bohr ~ 0.02 eV/A
c    - using 4-4 amd even 1-4 for many apps, need at least this
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      LOGICAL    do_neb
      DIMENSION  iforce(natm)
cRMV array for projection flag
      DIMENSION  iatframe(3)
c
c >>>> EXECUTABLE CODE:
c
c For geometry phase ...
c  number of atoms to relax (default to full relax all)
      nafrc = natm
      nvgfix = 0
      do  iatm=1,natm
        iforce(iatm) = 1
      enddo
c  nslics = number of constraints
      nslics = 0
c  iatframe = defines frame, (1)=0 -> no fixed frame
      iatframe(1) = 0
      call SLICINIT( 'INIT2 ' )
c  ifdefct = atom to which to apply force defect (imbalance)
      ifdefct = 0
c  gblend = force blend factor (suggested: [0.5:(1.5):6.0])
      gblend = 1.5d0
c  gconv = max force convergence criterion (Ry/bohr)
      gconv = 0.0008d0
c  tstep = time step for dynamics (suggested: [0.1:(1.0):2.0])
      tstep = 1.0d0
c  set geom blend relaxation type(broyden/asd/damped/dmd-at):
      if( do_neb )then
        call GTYPSET( 'ASD     ' )
      else
        call GTYPSET( 'BROYDEN ' )
      endif
c
c  igstart = initial geometry step for this run
      igstart = 1
c  igstop = maximum number of geometry relaxations steps
      igstop = 50
c  nhistg = number of steps in history to use for geom update
      nhistg = 10
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DAT0NEB
c
c
      subroutine DAT0NEB( nimg_neb, nimg_max,
     $  ea_neb,eb_neb, spring_neb,
     $  Lantikink_neb,Loptall_neb, 
     $  Lclimb_neb, Lnoninteract, Lrestart_neb,
     $  imgstat, natm, ratm, ratma )
c---------------------------------------------------------------
c Purpose: initialize parameters for nudged elastic band calc
c
c Written: Peter A. Schultz, 10-Jan-2002, for v2.54
c
c Revision history:
c  11May05-RMV/2.59: new flags for climb, noninteracting images
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      LOGICAL    Lantikink_neb, Loptall_neb, Lrestart_neb
      LOGICAL    Lclimb_neb, Lnoninteract
      DIMENSION  imgstat(*)
      DIMENSION  ratm(3,natm),ratma(3,natm)
c
      DATA       zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Set total number of neb images to one (need as non-0 dim):
      nimg_neb = 1
c
c Total energy of initial and final (endpoint) geometries:
      ea_neb = zero
      eb_neb = zero
c
c Spring constant (artificial) between different images:
      spring_neb = 1.0d0
c
c NEB anti-kink (uphill-only tangents) machinery is: ON
      Lantikink_neb = .true.
c
c NEB optall (min/max images head down-/up-hill) is: OFF
      Loptall_neb = .false.
c
c NEB climbing image is (uphill hill opt only): OFF
      Lclimb_neb = .false.
c
c NEB noninteracting images is: OFF
      Lnoninteract = .false.
c
c NEB restart calculation is: OFF
      Lrestart_neb = .false.
c
c Initialize status to all empty images:
      do  img=1,nimg_max
        imgstat(img) = 0
      enddo
c
c Default the initial image coordinates to the setdata coords:
      do  iatm=1,natm
        ratma(1,iatm) = ratm(1,iatm)
        ratma(2,iatm) = ratm(2,iatm)
        ratma(3,iatm) = ratm(3,iatm)
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DAT0OPT
c
c
      subroutine DAT0OPT( lvlout, mkrhopt, ion_opt, kparopt,
     $ dotests, dosetup,doiters,doforce,dorelax,do_cell, do_pvcalc,
     $ opt_spin, do_md, do_neb, do_post,
     $ do_bands,bvl, do_optic, do_nonscf,
     $ dosplit,doblas3, redusym, dolocxc,
     $ dospars,doeigen,doprjct,dorspsy,dodefct,
     $ do_kppsolve, do_psolv )
c---------------------------------------------------------------
c Purpose: initialize options for code
c
c Written: Peter A. Schultz, 23-May-2001, for v2.47
c
c Revision history:
c   5Aug15-PAS/2.67: initialize "bvl" along with do_bands
c  24Sep13-PAS/2.65a: install flag to compute ehthalpy (E+PV)
c  10Jan13-ACP/2.64: kppsolve flag
c  06Dec10-ACP+AHE/2.63: band structure; 05Dec12-PAS/2.63: psolv flag
c  22Nov08-PAS/2.62: k-parallel flag
c  10Jan08-PAS/2.61: spin optimization
c   7May04-RPM/2.58: add MD flag
c   5Jan02-PAS/2.52: do_cell flag installed
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      LOGICAL  dotests
      LOGICAL  dosetup,doiters,doforce,dorelax,do_cell, do_pvcalc
      LOGICAL  opt_spin, do_md, do_neb, do_post
      LOGICAL  do_bands,do_optic,do_nonscf
      LOGICAL  dosplit,doblas3, redusym, dolocxc
      LOGICAL  dospars,doeigen,doprjct,dorspsy,dodefct
      LOGICAL  do_kppsolve, do_psolv
      CHARACTER*3  bvl
c
c >>>> EXECUTABLE CODE:
c
c Set modest level of output (lvlout: 0=least ... 5=most):
      lvlout = 2
c Grid density scheme (if not 0, 1 compels DM scheme; 2,EF scheme)
      mkrhopt = 0
c Choice for treating charge/moments in supercells:
      ion_opt = 2
c        ABS(ion_opt) = 1: flat jellium countercharge
c        ABS(ion_opt) = 2: local gaussian countermoment
c        ion_opt<0: exclude dipole correction
c        ion_opt>0: include dipole correction
c Use whatever parallelism code decides later (-1=compel std, -2=compel kpar)
      kparopt = 0
C        call SET_KPFLAGS( kparopt )
c By default, attempt  k-parallel-parallel solver (no CTP in subroutines)
      do_kppsolve = .true.
C      do_kppsolve = .false.
c Compel a sequence of all-parallel solves: NO
      do_psolv = .false.
c
c Do not merely test problem setup:
      dotests = .false.
c By default, do just thru scf/iters; no frc, relax, cells, or NEB
      dosetup = .true.
      doiters = .true.
      doforce = .false.
      dorelax = .false.
      do_cell = .false.
      do_pvcalc = .false.
      do_neb  = .false.
      do_md   = .false.
      opt_spin = .false.
c
c output of data for post-processing: OFF
      do_post = .false.
c do non-selfconsistent calculations: OFF
      do_nonscf = .false.
c do bands: OFF, preset Bravais lattice to "nil"
      do_bands=.false.
      bvl = 'nil'
c do optical properties: OFF
      do_optic=.false.
c split basis calculation is: ON
      dosplit = .true.
c blas level 3 use is: ON
      doblas3 = .true.
c allowing symmetry to be reduced: OFF
      redusym = .false.
c
c And some stuff which is not standard usage yet, or not
c yet integrated into production code, and these flags
c should not be altered ...
c
c dolocxc - treat reference atom xc potential in forces is OFF
c   (locxc gives bad forces in current code)
      dolocxc = .false.
c dospars - sparse matrix storage is OFF
      dospars = .false.
c eigensolver is: ON
      doeigen = .true.
c doprjct - project is OFF
      doprjct = .false.
c dorspsy - real space symmetrization is ON
      dorspsy = .true.
c dodefct - defect calculation for linear scaling is OFF
      dodefct = .false.
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DAT0RUN
c
c
      subroutine DAT0RUN( doforce, do_post, dokdefct,icloseocc,
     $ itstart,itstop,meth_bl,nhiste,igesopt,  nocc0k,norb,nstate,
     $ convgr,convs,convsl,convii, conv1c, alfast,
     $ opt_spin, meth_sp,conv_sp,nstep_sp,blend_sp,istart_sp,
     $ edegen,etemp, scfblnd,scfbl2,scfconv, idosolv, scut )
c---------------------------------------------------------------
c Purpose: initialize parameters for run (scf) phase
c
c Written: Peter A. Schultz, 23-May-2001, for v2.47
c
c Revision history:
c  25Mar16-PAS/2.67c: nhist default to 4 (from 6)
c  14Dec14-PAS/2.66: install ASD e-blend option
c  11Mar13-PAS/2.65: change nhiste from 10 to 6, itstop fr. 30 to 50
c  10Jan08-PAS/2.61: spin optimization
c  14Jun05-RPM/2.59: added scut variable to set cutoff for
c                    small eigenvalues of the overlap matrix
c  14Feb05-PAS/2.59: defect k-sampling
c  25Nov03-PAS/2.58: remove scf blend reset feature
c  11Sep03-PAS/2.57: remove itmaxd-dependence
c   9Jan03-PAS/2.55: blending changes, and cosmetics
c   9Aug02-PAS/2.53(f): fix nocc0k for spin-pol calculation
c  16May02-PAS/2.53: cutoff params moved to "rundata"
c   8Mar02-PAS/2.52: literal constants to d0
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
      LOGICAL    doforce, do_post, dokdefct, opt_spin
c Output:
      DIMENSION  convs(8)
c
c Local:
      DIMENSION  convs0(8)
      DATA  convs0 / 3.0d-9 , 3.0d-9 ,1.5d-7 , 6.0d-8,
     $               3.0d-7 , 3.0d-7 ,0.5d-5 , 6.0d-6 /
c Defines blending type
      DATA    methbl_broy,methbl_asd / 1,2 /
c
c >>>> EXECUTABLE CODE:
c
c itstart,itstop = initial/final iteration to be max:
      itstart = 0
      itstop = 50
c meth_bl = blending type: 1=broyden (default), 2=asd (alternate)
      meth_bl = methbl_broy
c nhiste = max number of steps in scf blend
      nhiste =  4
c igesopt = scf ges: 0=raw,1=full d-Ham,2=true d-Ham,3=d-atHam
      igesopt = -2
c
c Default number of occupied states ...
      nstate = MIN( nocc0k+10, norb )
c      ... if post-process, and not a force calc, do all states
c       (at AFRL request)
      if( do_post .and. .not. doforce ) nstate = norb
c
c icloseocc = 0/normal fermi occs; 1/binned by k; 2/0K (binned)
      icloseocc = 0
      if( dokdefct ) icloseocc = 1
c
c convgr = cutoff value for range of grid orbitals/shells:
      convgr = 2.d-8
       call FLGETIWR( IWR )
      write(IWR,*) '************** VERSION 2.65 CHANGE: ***************'
      write(IWR,*) '**** grid range default changed from 2.d-7 to 2.d-8'
      write(IWR,*) '**** This will cause numerical changes in results'
      write(IWR,*) '**** To recover pre-2.65, use input cutgrd/2.d-7'
      write(IWR,*) '***************************************************'
c convs() = cutoffs for the various (semi-)analytic routines:
c         setup: (1) ovlp (2) kin (3) nloc (4) local
c        &force: (5) ovlp (6) kin (7) nloc (8) local
      do  ic=1,8
        convs(ic) = convs0(ic)
      enddo
c convsl = cutoff for pairs of slow gaussians
      convsl = 1.d-1
c convii = cutoff Vnuc:II (bf on same atom
      convii = 1.d-2
c conv1c = cutoff for scf fast potential integrals (non-std)
      conv1c = 1.d-4
c
c alfast = Gaussian exponent defining "slow/fast"
      alfast = 0.6d0
c
c etemp = Temperature for occupation weighting
      etemp = 0.003d0
c edegen = criterion for degeneracy of two states for pop.
      edegen = 0.0002
c scfblnd = Initial blend factor for Hamiltonian
      scfblnd = 0.30d0
c scfbl2 = Initial blend factor for Ham after first geometry
      scfbl2 = 0.30d0
c scfconv =  SCF convergence criterion:
      scfconv = 0.00030d0
c
c  idosolv = 1 full eigensolve, using dsygv/zhegv lapack routines
c  idosolv = 2 uses faster dsygvx/zhegv selected eigenvec routines
c  idosolv = 3 uses dsyev with a routine to remove basis linear dependence
      idosolv = 2
      if (idosolv .eq. 3 .or. idosolv .eq. 1) nstate = norb
c
c  scut = Cutoff below which eigenpairs of S are ignored if idosolv=3
      scut = 1d-6
c
c Spin optimization:
c  meth_sp = method for spin optimization (0=simple,1=linear)
      meth_sp = 1
c  conv_sp = spin convergence criterions (polarization, in e)
      conv_sp = 0.004d0
c  blend_sp = slope for updating spin polarization (should be 1.0-2.0)
      blend_sp = 1.5d0
c  nstep_sp = maximum number of steps for spin convergence
      nstep_sp = 10
c  istart_sp = initial start (do not change from 0)
      istart_sp = 0
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DATSAVE
c
c
      subroutine DATSAVE( norb, natm,ntyp,nshld,nald,noad,
     $ itypa, numshl,lshel,nala,ala,cala, znuc,occ,
     $ ratm, rprim,nlat,rlat, hh, n1r,n2r,n3r,
     $ orig, rscale,
     $ lshl2, nal2,al2,cal2 )
c---------------------------------------------------------------
c Purpose: write to disk file geometry and basis set data
c          so as to (1) give imp code something it can check
c          against, and (2) give density fitting routine info
c          necessary to attempt fit of output rho with
c          overlapping spherical atoms
c
c Written: Peter A. Schultz, 9-December-1989
c
c Revision History:
c  26Jan09-PAS/2.62j: convert rhosave into subroutine
c   6Dec01-PAS/2.51: file mgmt
c   2Jul01-PAS/2.48: replace writes
c   7Jul00-PAS/2.45: unified scaling
c  19Dec99-PAS/2.42: cleanup; read/write big grid records
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  22May98-PAS/2.22: bugfix
c   5Mar98-PAS/2.21: give data for charge plotting
c  24Apr97-PAS/2.17: naming conventions
c  15Dec95-PAS/2.14: shell-by-shell grid ranges
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  znuc(ntyp), occ(noad,ntyp)
      DIMENSION  ratm(3,natm), rprim(3,3), rlat(3,nlat), hh(3,3)
      DIMENSION  orig(3),rscale(3)
c Scratch arrays:
      DIMENSION  lshl2(nshld*ntyp),nal2(nshld*ntyp)
      DIMENSION  al2(nald*nshld*ntyp),cal2(nald*nshld*ntyp)
c
c >>>> EXECUTABLE CODE:
c
      call FLGETIWR( IWR )
C      OPEN(unit=idatsav,file='lcao.data',status='unknown',
C     $ form='unformatted',err=1300)
      call FLOPENB( idatsav, 'data' )
c
c  Compact the arrays with big holes in 'em:
c
      nrf = 0
      nal = 0
      do 1000 ityp=1,ntyp
c
        do 100 ishl=1,numshl(ityp)
          nrf = nrf + 1
          lshl2(nrf) = lshel(ishl,ityp)
          nal2(nrf) = nala(ishl,ityp)
c
          do 10 ial=1,nala(ishl,ityp)
            nal = nal + 1
            cal2(nal) = cala(ial,ishl,ityp)
            al2(nal) = ala(ial,ishl,ityp)
   10     continue
  100   continue
 1000 continue
c
c  Write out the good stuff:
c
      write(idatsav)  natm,ntyp,nrf,nal,n1r,n2r,n3r,nlat,noad
      write(idatsav)  itypa,numshl,occ,znuc
      write(idatsav)  (lshl2(irf),irf=1,nrf),(nal2(irf),irf=1,nrf)
      write(idatsav)  (cal2(ial),ial=1,nal),(al2(ial),ial=1,nal)
      write(idatsav)  hh,rprim,ratm,rlat,orig,rscale
c
      call FLCLOSE( idatsav )
c
      write(IWR,*) '>>>>> geom/basis data saved to file'
c
      RETURN
c
c >>>> ERROR HANDLING:
c
 1300 write(IWR,*)  ' '
      write(IWR,*)  '*****  ERROR  *****'
      write(IWR,*)  '>>>>> cannot open unit #',idatsav
      write(IWR,*)  '>>>>> geometry/basis data NOT saved'
      write(IWR,*)  ' '
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RHOSAVE
c
c
      subroutine RHOSAVE( nptr, delrho )
c---------------------------------------------------------------
c Purpose: write density to disk file
c
c Written: Peter A. Schultz, 9-December-1989
c
c Revision History:
c  26Jan09-PAS/2.62j: converted rhosave into subroutine
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input arrays:
      DIMENSION  delrho(*)
c
c >>>>> EXECUTABLE CODE:
c
      call FLGETIWR( IWR )
C      OPEN(unit=idatsav,file='lcao.data',status='old',
C     $ form='unformatted', err=1310 )
      call FLOPENB( idatsav, 'data' )
c
c read through header data:
      read(idatsav)   dum
      read(idatsav)  idum
      read(idatsav)  idum
      read(idatsav)   dum
      read(idatsav)   dum
c output the delta-density:
c     write(idatsav)  (delrho(i),i=1,nptr)
      call WRITBIG( idatsav, nptr, delrho )
c
      call FLCLOSE( idatsav )
c
      write(IWR,*) '>>>>> grid delta-density saved to file'
c
      RETURN
c
 1310 write(IWR,*)  ' '
      write(IWR,*)  '*****  ERROR  *****'
      write(IWR,*)  '>>>>> cannot open unit #',idatsav
      write(IWR,*)  '>>>>> geometry/basis data NOT saved'
      write(IWR,*)  ' '
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DEFBOX
c
c
      subroutine DEFBOX( IWR, ndim, n1r,n2r,n3r,
     $ nbox,mxrbox, ndbox )
c---------------------------------------------------------------
c Purpose: carve up grid unit cell into smaller boxes
c
c Written: Peter A. Schultz,  3-June-1997, for v2.20 (boxes)
c
c Revision history:
c  21Jun01-PAS/2.48: replace STOPs
c  18Dec00-PAS/2.46: tune to limit box sizes to 216 or less.
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c Notes:
c   What we would like to do here is divide the grid points
c   in a unit cell into boxes, in such a way as to:
c     1.  keep grid calcns within cache, requiring smaller boxes.
c     2.  keep vectorization, requiring larger boxes
c     3.  keep overhead low, also requiring larger boxes
c     4.  get maximum benefit of cutoffs, requiring smaller
c         boxes in those directions that cutoffs can take effect.
c     5.  keep boxes relatively uniformly sized/shaped.
c   What I adopt as a default is boxes that have edges of length
c   four or five grid points, defining boxes with 64-125 total
c   grid points in them.  However, in lower dimension calcs,
c   e.g. slabs, this could be wasteful - you would like smaller
c   divisions in the z-directions.  So the following code does
c   some ad hoc division for breaking up the unit cell that
c   hopefully is more efficient.  A 6/5 rather than a 5/4 scheme
c   might be more efficient, but will depend on machine cache
c   sizes, and number of orbitals and k-points.
c
c   The difficulty with using reduced dimension slicing is that
c   main code may not be smart enough to take advantage of the
c   thinner slicing in one direction, and you end up with a more
c   expensive calculation rather than cheaper one.
c   "reduce_d" controls whether effective dimension changed.
c   I may just purge this special case treatment in the future.
c
c   I impose a limit of nrboxd=216 for the biggest possible box.
c   DO NOT CHANGE this value from 216!!!!!!
c   This enables me to make viable (but checked) assumptions in
c   main routine about amount of work space needed in some rtns
c   that are called from main (e.g. "grid0xc").
c   The scheme implemented here will produce boxes up to 216,
c   for either default box edges of 5 or 6.  This rtn has been
c   tested thoroughly for both default=5 and default=6.
c
c Variables:
c  ndim         - input dimension (periodicity) of problem
c  n1r,n2r,n3r  - input grid dimensions of unit cell
c  nbox         - output number of boxes
c  mxrbox       - output size of largest box
c  ndbox(2,2,3) - output breakup of cell into boxes
c  Along direction "iu":
c    (1,1,iu),(2,1,iu)  is number of boxes with ...
c    (1,2,iu),(2,2,iu)   ... points along the side of the box
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c local parameters:
c   Restrict biggest box to 216 pts (DO NOT CHANGE!):
      PARAMETER  (nrboxd=216)
c   Set default box edge length (must be five or six!!!)
c    idefr1=5 -> (4:5)*(4:5)*(4:5)=[ 64:125] pts/box default
c    idefr1=6 -> (5:6)*(5:6)*(5:6)=[125:216] pts/box default
      PARAMETER  (idefr1=5)
c
c output array:
      DIMENSION  ndbox(2,2,3)
c
c local declarations:
      DIMENSION  nrv(3),idrv(3)
      LOGICAL    reduce_d
      LOGICAL    booboo
c
c >>>> EXECUTABLE CODE:
c
c Our box breakdown only works for: default=5 or default=6.
      if( idefr1.lt.5 .or. idefr1.gt.6 ) call STOPXERR( 'defbox-d' )
c
c Set up default box dimensions:
c
      nrv(1) = n1r
      nrv(2) = n2r
      nrv(3) = n3r
      do  idim=1,3
c       Set (large) box edge to default value ...
        idrv1 = idefr1
c        ... and fix small cell dimension cases:
        nvr = nrv(idim)
        if( nvr.eq.19 .or. nvr.eq.14 .or. nvr.eq.13 .or. nvr.eq.9 )then
c         This fixes bad cases specific for default=6
          idrv1 = 5
        elseif( nvr.eq.11 )then
c         This fixes bad case specific for default=5
          idrv1 = 6
        elseif( nvr.eq.8 .or. nvr.eq.7 )then
          idrv1 = 4
        elseif( nvr.lt.7 )then
c         Should *never* have cell this small, but for completeness:
          idrv1 = nvr
        endif
        idrv(idim) = idrv1
      enddo
      idra1 = idrv(1)
      idrb1 = idrv(2)
      idrc1 = idrv(3)
c
c The reduce-dimensions special cases can be skipped (reduce_d=F)
c
      reduce_d = .true.
      if( reduce_d )then
c
c       Determine effective system dimension:
c
        mdim = ndim
c       Try to reduce dimension:
        if( mdim.eq.3 .and. n3r.gt.64 ) mdim = 2
        if( mdim.eq.2 .and. n2r.gt.64 ) mdim = 1
        if( mdim.eq.1 .and. n1r.gt.64 ) mdim = 0
c       Try to increase dimension (this to catch pathologies):
        if( mdim.eq.1 .and. n2r.lt.32 ) mdim = 2
        if( mdim.eq.1 .and. n3r.lt.32 ) mdim = 3
        if( mdim.eq.2 .and. n3r.lt.32 ) mdim = 3
c
        if( mdim.eq.1 )then
c
c         Have a 1-D unit cell (n1r.le.64)
c         Presume: (n2r.gt.64).and.(n3r.gt.64), but unknown
c
          if( n1r.lt.12 )then
c           n1r=( 1:11) -> ( 1:11)x4x4=[ 16:176]
            idra1 = n1r
            idrb1 = 4
            idrc1 = 4
          elseif( n1r.lt.20 )then
c           n1r=(12:19) -> (12:19)x3x3=[108:171]
            idra1 = n1r
            idrb1 = 3
            idrc1 = 3
          elseif( n1r.lt.55 )then
c           n1r=(20:54) -> (20:54)x2x2=[ 80:216]
            idra1 = n1r
            idrb1 = 2
            idrc1 = 2
          elseif( n1r.le.64 )then
c           n1r=(55:64) -> (28:32)x2x2=[112:128]
            idra1 = (n1r-1)/2 + 1
            idrb1 = 2
            idrc1 = 2
          else
c           cannot be
            call STOPXERR( 'defbox1d' )
          endif
c
        elseif( mdim.eq.2 )then
c
c         Have 2-D unit cell (n2r.le.64)
c         Presume: (n3r.gt.64).and.(n1r.le.64), but unknown
c         Want: thin slabs.  Get: no more than 14 on a side
c         with 14**2=196 in each layer of slice.
c         n1r,n2r    box edge
c         (57+  ) ->  (6:7)      -> ( 6: 7)
c         (43:56) -> (n-1)/4 + 1 -> (11:14)
c         (29:42) -> (n-1)/3 + 1 -> (10:14)
c         (15:28) -> (n-1)/2 + 1 -> ( 8:14)
c         ( 1:14) ->   n         -> ( 1:14)
c
c         Divide up x-vector
          if( n1r.gt.56 )then
            idra1 = 7
          elseif( n1r.gt.42 )then
            idra1 = (n1r-1)/4 + 1
          elseif( n1r.gt.28 )then
            idra1 = (n1r-1)/3 + 1
          elseif( n1r.gt.14 )then
            idra1 = (n1r-1)/2 + 1
          else
            idra1 = n1r
          endif
c         Divide up y-vector
          if( n2r.gt.56 )then
            idrb1 = 7
          elseif( n2r.gt.42 )then
            idrb1 = (n2r-1)/4 + 1
          elseif( n2r.gt.28 )then
            idrb1 = (n2r-1)/3 + 1
          elseif( n2r.gt.14 )then
            idrb1 = (n2r-1)/2 + 1
          else
            idrb1 = n2r
          endif
c
          n12d = idra1*idrb1
c         Divide up z-vector, with n12d=(1:14)*(1:14)=(1:196)
c
          if( n12d.lt.26 )then
c           ( 1:25)*5 = [  5:125]
            idrc1 = 5
          elseif( n12d.lt.41 )then
c           (26:40)*4 = [104:160]
            idrc1 = 4
          elseif( n12d.lt.56 )then
c           (41:55)*3 = [123:165]
            idrc1 = 3
          elseif( n12d.lt.91 )then
c           (56:90)*2 = [112:180]
            idrc1 = 2
          else
c           (91:196)*1 = [91:196]
            idrc1 = 1
          endif
c
        endif
c
      endif
c
c  Box edge lengths determined, now get number of boxes ...
c
c   ... first define smaller box edge length
      idra2 = idra1 - 1
      idrb2 = idrb1 - 1
      idrc2 = idrc1 - 1
c   ... get number of short lengths
      nboxa2 = ( (n1r+idra2) / idra1 )*idra1 - n1r
      nboxb2 = ( (n2r+idrb2) / idrb1 )*idrb1 - n2r
      nboxc2 = ( (n3r+idrc2) / idrc1 )*idrc1 - n3r
c   ... and get number of longer lengths
      nboxa1 = (n1r - nboxa2*idra2)/idra1
      nboxb1 = (n2r - nboxb2*idrb2)/idrb1
      nboxc1 = (n3r - nboxc2*idrc2)/idrc1
c   ... shift if have zero larger boxes
      if( nboxa1.eq.0 )then
        nboxa1 = nboxa2
        nboxa2 = 0
        idra1 = idra2
        idra2 = idra1 - 1
      endif
      if( nboxb1.eq.0 )then
        nboxb1 = nboxb2
        nboxb2 = 0
        idrb1 = idrb2
        idrb2 = idrb1 - 1
      endif
      if( nboxc1.eq.0 )then
        nboxc1 = nboxc2
        nboxc2 = 0
        idrc1 = idrc2
        idrc2 = idrc1 - 1
      endif
c
c Do all sorts of idiot double checks ...
c   ... we only get failure if code design is messed up, default ok:
      booboo = .false.
c   ... see if we get nonsense breakdown:
      if( nboxa1.lt.1 .or. nboxa2.lt.0 .or. idra1.lt.1 .or.
     $    nboxb1.lt.1 .or. nboxb2.lt.0 .or. idrb1.lt.1 .or.
     $    nboxc1.lt.1 .or. nboxc2.lt.0 .or. idrc1.lt.1 ) booboo =.true.
c   ... and check to be sure it hangs together:
      m1r = nboxa1*idra1 + nboxa2*idra2
      m2r = nboxb1*idrb1 + nboxb2*idrb2
      m3r = nboxc1*idrc1 + nboxc2*idrc2
      if( m1r.ne.n1r .or. m2r.ne.n2r .or. m3r.ne.n3r ) booboo = .true.
c   ... and double-check that box size conforms to design:
      mxrbox = idra1*idrb1*idrc1
      if( mxrbox.gt.nrboxd ) booboo = .true.
c
      if( booboo )then
c       Code is designed to work right, yet somehow we missed
c       something.  DO NOT simply change dimensioning (nrboxd)
c       or hack code to make this error go away.  This branch
c       is only hit if above code has a very bad error in logic
c       somewhere, or if defaults changed to unacceptable range.
        write(IWR,*) '>>>>> coding failure! (this is VERY bad)'
        write(IWR,*) 'Report grid dimensions to code architect:'
        write(IWR,*) 'n1r,n2r,n3r=',n1r,n2r,n3r
        write(IWR,*) ' nboxa1,idra1;[b];[c]=',
     $   nboxa1,idra1,nboxb1,idrb1,nboxc1,idrc1
        write(IWR,*) ' nboxa2,idra2;[b];[c]=',
     $   nboxa2,idra2,nboxb2,idrb2,nboxc2,idrc2
        write(IWR,*) 'yielding n1r,n2r,n3r=',m1r,m2r,m3r
        write(IWR,*) 'box size,max=',mxrbox,nrboxd
        call STOPXERR( 'defbox - error defining box sizes' )
      endif
c
c  Load up the unit cell box break-up
c
      nbox = (nboxa1+nboxa2)*(nboxb1+nboxb2)*(nboxc1+nboxc2)
      ndbox(1,1,1) = nboxa1
      ndbox(2,1,1) = nboxa2
      ndbox(1,2,1) = idra1
      ndbox(2,2,1) = idra2
      ndbox(1,1,2) = nboxb1
      ndbox(2,1,2) = nboxb2
      ndbox(1,2,2) = idrb1
      ndbox(2,2,2) = idrb2
      ndbox(1,1,3) = nboxc1
      ndbox(2,1,3) = nboxc2
      ndbox(1,2,3) = idrc1
      ndbox(2,2,3) = idrc2
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DF_SGGA0
c
c
      subroutine DF_GGA0( rho, grho,g2rho,gpggp,  zet,grhup,grhdn,
     $ g, rs, twokf,twoksg, s,u,v, t,uu,vv, ww )
c---------------------------------------------------------------
c Purpose: set up gga inputs from raw electron density/gradients
c
c Written: Peter A. Schultz, January-2001, for v2.46 (gga)
c
c Revision history:
c   3Apr02-PAS/2.53: gga stress
c   8Aug01-PAS/2.49: spin-polarized dft, entry df_gga0x added
c---------------------------------------------------------------
c
c Input quantities:
c   rho   = total electron number density
c   grho  = | GRAD[rho] |
c   g2rho = GRAD**2[rho]
c   gpggp = GRAD[rho] DOT GRAD[ | GRAD[rho] | ]
c   grhup = | GRAD[rhup] |
c   grhdn = | GRAD[rhdn] |
c   zet = (up-dn)/rho = relative spin polarization
c Output quantities:
c   described individually below
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Set parameters needed to construct various terms:
      PARAMETER  ( zero = 0.d0, one = 1.d0, two = 2.d0 )
      PARAMETER  ( twothrd = 0.6666666666666667 d0 )
      PARAMETER  ( thrd = 0.3333333333333333 d0 )
      PARAMETER  ( C_pi = 3.141592653589793 d0 )
      PARAMETER  ( C_pi2= 9.869604401089358 d0 )
c
c C_Rs = (3/(4pi))**(1/3)
      PARAMETER  ( C_Rs = 0.6203504908994001 d0 )
c C_Kf = (3*pi**2)**(1/3)
      PARAMETER  ( C_Kf = 3.093667726280136 d0 )
c C_Ks = sqrt( 4*C_Kf / pi )
      PARAMETER  ( C_Ks = 1.984686395219856 d0 )
c C_Rf = C_Rs*C_Kf = ( 9*pi/4 )**(1/3) = Burke's "alpha"
      PARAMETER  ( C_Rf = 1.919158292677513 d0 )
c
c >>>> EXECUTABLE CODE:
c
c  g = ( (1+zet)**(2/3) + (1-zet)**(2/3) ) / 2
c     With no spin, zet=0, and g=1.
      if( zet .eq. zero )then
        g = one
      else
        g = ( ( one + zet )**twothrd + ( one - zet )**twothrd ) / two
      endif
c
      rhthrd = rho**thrd
c
c  rs = (3/(4pi*rho))**(1/3) = local Seitz radius=alpha/fk
      rs = C_Rs / rhthrd
c
      s0 = grho / rho
      u0 = gpggp / (rho*rho)
      v0 = g2rho / rho
c
c  fk = Kf = C_Kf * rho**(1/3) = local fermi wavevector
      fk = C_Kf*rhthrd
c  s = |grho| / (rho * (2*Kf))
c  u =  gpggp / (rho**2 * (2*Kf)**3)
c  v =  g2rho / (rho * (2*Kf)**2)
      twokf = two * fk
      s = s0 / (twokf)
      u = u0 / (twokf**3)
      v = v0 / (twokf**2)
c
c  sk = Ks = C_Ks * rho**(1/6) = Thomas-Fermi screening wavevector
      sk = C_Ks*SQRT( rhthrd )
c  t  = |grho| / (rho * (2*Ks*g))
c  uu =  gpggp / (rho**2 * (2*Ks*g)**3)
c  vv =  g2rho / (rho * (2*Ks*g))**2)
      twoksg = two * sk * g
      t  = s0 / (twoksg)
      uu = u0 / (twoksg**3)
      vv = v0 / (twoksg**2)
c
c  ww = zero for non-spin-polarized
c  ww = GRAD[rho]*GRAD[zet] / ( rho * (2*Ks*g)**2 ) [Hamann pspot]
c  ww=(|grad up|^2-|grad dn|^2-zet*|grad rho|^2)/(rho*twoksg)^2 [Burke]
      if( zet .eq. zero )then
        ww = zero
      else
        ww = ( grhup**2 - grhdn**2 - zet*grho**2 )
     $       / ( rho*twoksg )**2
      endif
c
c Put rho into twokf and twoksg for use in stress gga term:
      twokf = rho*twokf
      twoksg = rho*twoksg
c
c    That's all Folks!
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DF_GGA0X
c
c
      entry DF_GGA0X( rho, grho,g2rho,gpggp, twokf, s,u,v )
c---------------------------------------------------------------
c Purpose: set up gga exchange inputs from electron density/gradients
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Input quantities:
c   rho   = electron number density
c   grho  = | GRAD[rho] |
c   g2rho = GRAD**2[rho]
c
c >>>> EXECUTABLE CODE:
c
      rhthrd = rho**thrd
c
      s0 = grho / rho
      u0 = gpggp / (rho*rho)
      v0 = g2rho / rho
c
c  fk = Kf = C_Kf * rho**(1/3) = local fermi wavevector
      fk = C_Kf*rhthrd
c  s = |grho| / (rho * (2*Kf))
c  u =  gpggp / (rho**2 * (2*Kf)**3)
c  v =  g2rho / (rho * (2*Kf)**2)
      twokf = two * fk
      s = s0 / (twokf)
      u = u0 / (twokf**3)
      v = v0 / (twokf**2)
c
c Put rho into twokf for use in stress gga term:
      twokf = rho*twokf
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DF_GGA
c
c
c---------------------------------------------------------------
c Purpose: combine under one roof all gga functional code
c
c Adapted: Peter A. Schultz, 28-December-2000, for SeqQuest 2.46
c
c Original code from official version of PBE kept by Kieron Burke:
c http://crab.rutgers.edu/~dft/pubs/PBE.asc
c
c Revision history:
c  13Nov12-JEM/2.65: HSE semilocal term added
c  17Dec08-RJM/2.62: AM05 spin added
c  24May06-AEM/2.60: AM05 added
c  11Oct03-PAS/2.57: fix pw91x stress terms
c   8Oct03-AEM/2.57: stress corrected for spin. argument eliminated.
c   7Oct03-AEM/2.57: stress added to blypsp. Non spin lyp eliminated.
c   2Jul03-AEM/2.56: blypsp added
c  11Jun03-AEM/2.55: blyp added (with stress)
c   8Apr02-PAS/2.53: gga (unpolarized) stress
c  28Dec00-PAS/2.46: adapted for Quest - routine names
c---------------------------------------------------------------
c
c Notes:
c  I substituted calls to the "slimmed" version of routine "GCOR"
c  in the PW91 potential, as had been done for the PBE potential
c  in the official version of the PBE code.
c  I also made changes in routine names to standardize everything
c  All modifications are denoted by "cpas"
c   - 28Dec00-PAS
c
c  I have implemeted blyp directly from Becke PRA 38, 3098 (1988)
c  and Lee, Yang, and Parr PRB 37, 785 (1988). All errors are mine.
c   - 11Jun03-AEM
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
cpas      SUBROUTINE CORLSD(RS,ZET,EC,VCUP,VCDN,ECRS,ECZET,ALFC)
      SUBROUTINE DF_LSDC(RS,ZET,EC,VCUP,VCDN,ECRS,ECZET,ALFC)
C  UNIFORM-GAS CORRELATION OF PERDEW AND WANG 1991
C  INPUT: SEITZ RADIUS (RS), RELATIVE SPIN POLARIZATION (ZET)
C  OUTPUT: CORRELATION ENERGY PER ELECTRON (EC), UP- AND DOWN-SPIN
C     POTENTIALS (VCUP,VCDN), DERIVATIVES OF EC WRT RS (ECRS) & ZET (ECZET)
C  OUTPUT: CORRELATION CONTRIBUTION (ALFC) TO THE SPIN STIFFNESS
      IMPLICIT REAL*8 (A-H,O-Z)
      parameter(gam=0.5198421D0,fzz=1.709921D0)
      parameter(thrd=0.333333333333D0,thrd4=1.333333333333D0)
      F = ((1.D0+ZET)**THRD4+(1.D0-ZET)**THRD4-2.D0)/GAM
cpas: added rtRS, and replaced calls to gcor with calls to df_gcor/28dec00
      rtRS = DSQRT( RS )
cpas: I disapprove of passing explicit constants, but ...
cpas      CALL GCOR(0.0310907D0,0.21370D0,7.5957D0,3.5876D0,1.6382D0,
cpas     1    0.49294D0,1.00D0,RS,EU,EURS)
      CALL DF_GCOR(0.0310907D0,0.21370D0,7.5957D0,3.5876D0,1.6382D0,
     1    0.49294D0,   rtRS,EU,EURS)
cpas      CALL GCOR(0.01554535D0,0.20548D0,14.1189D0,6.1977D0,3.3662D0,
cpas     1    0.62517D0,1.00D0,RS,EP,EPRS)
      CALL DF_GCOR(0.01554535D0,0.20548D0,14.1189D0,6.1977D0,3.3662D0,
     1    0.62517D0,   rtRS,EP,EPRS)
cpas      CALL GCOR(0.0168869D0,0.11125D0,10.357D0,3.6231D0,0.88026D0,
cpas     1    0.49671D0,1.00D0,RS,ALFM,ALFRSM)
      CALL DF_GCOR(0.0168869D0,0.11125D0,10.357D0,3.6231D0,0.88026D0,
     1    0.49671D0,   rtRS,ALFM,ALFRSM)
C  ALFM IS MINUS THE SPIN STIFFNESS ALFC
      ALFC = -ALFM
      Z4 = ZET**4
      EC = EU*(1.D0-F*Z4)+EP*F*Z4-ALFM*F*(1.D0-Z4)/FZZ
C  ENERGY DONE. NOW THE POTENTIAL:
      ECRS = EURS*(1.D0-F*Z4)+EPRS*F*Z4-ALFRSM*F*(1.D0-Z4)/FZZ
      FZ = THRD4*((1.D0+ZET)**THRD-(1.D0-ZET)**THRD)/GAM
      ECZET = 4.D0*(ZET**3)*F*(EP-EU+ALFM/FZZ)+FZ*(Z4*EP-Z4*EU
     1        -(1.D0-Z4)*ALFM/FZZ)
      COMM = EC -RS*ECRS/3.D0-ZET*ECZET
      VCUP = COMM + ECZET
      VCDN = COMM - ECZET
      RETURN
      END
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
cpas      SUBROUTINE GCOR2(A,A1,B1,B2,B3,B4,rtrs,GG,GGRS)
      SUBROUTINE DF_GCOR(A,A1,B1,B2,B3,B4,rtrs,GG,GGRS)
c slimmed down version of GCOR used in PW91 routines, to interpolate
c LSD correlation energy, as given by (10) of
c J. P. Perdew and Y. Wang, Phys. Rev. B {\bf 45}, 13244 (1992).
c K. Burke, May 11, 1996.
      IMPLICIT REAL*8 (A-H,O-Z)
      Q0 = -2.D0*A*(1.D0+A1*rtrs*rtrs)
      Q1 = 2.D0*A*rtrs*(B1+rtrs*(B2+rtrs*(B3+B4*rtrs)))
      Q2 = DLOG(1.D0+1.D0/Q1)
      GG = Q0*Q2
      Q3 = A*(B1/rtrs+2.D0*B2+rtrs*(3.D0*B3+4.D0*B4*rtrs))
      GGRS = -2.D0*A*A1*Q2-Q0*Q3/(Q1*(1.d0+Q1))
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DF_GGA
c
c
cpas      SUBROUTINE EXCHPBE(rho,S,U,V,lgga,lpot,EX,VX)
      SUBROUTINE DF_PBEX( rho, S,U,V, lgga,lpot, EX,VX, dexs )
c----------------------------------------------------------------------
C  PBE EXCHANGE FOR A SPIN-UNPOLARIZED ELECTRONIC SYSTEM
c  K Burke's modification of PW91 codes, May 14, 1996
c  Modified again by K. Burke, June 29, 1996, with simpler Fx(s)
c----------------------------------------------------------------------
c----------------------------------------------------------------------
C  INPUT rho : DENSITY
C  INPUT S:  ABS(GRAD rho)/(2*KF*rho), where kf=(3 pi^2 rho)^(1/3)
C  INPUT U:  (GRAD rho)*GRAD(ABS(GRAD rho))/(rho**2 * (2*KF)**3)
C  INPUT V: (LAPLACIAN rho)/(rho*(2*KF)**2)
c   (for U,V, see PW86(24))
c  input lgga:  (=0=>don't put in gradient corrections, just LDA)
c  input lpot:  (=0=>don't get potential and don't need U and V)
C  OUTPUT:  EXCHANGE ENERGY PER ELECTRON (EX) AND POTENTIAL (VX)
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c References:
c [a]J.P.~Perdew, K.~Burke, and M.~Ernzerhof, submiited to PRL, May96
c [b]J.P. Perdew and Y. Wang, Phys. Rev.  B {\bf 33},  8800  (1986);
c     {\bf 40},  3399  (1989) (E).
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c Formulas:
c   	e_x[unif]=ax*rho^(4/3)  [LDA]
c ax = -0.75*(3/pi)^(1/3)
c	e_x[PBE]=e_x[unif]*FxPBE(s)
c	FxPBE(s)=1+uk-uk/(1+ul*s*s)                 [a](13)
c uk, ul defined after [a](13)
c----------------------------------------------------------------------
c----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      parameter(thrd=1.d0/3.d0,thrd4=4.d0/3.d0)
      parameter(pi=3.14159265358979323846264338327950d0)
      parameter(ax=-0.738558766382022405884230032680836d0)
      parameter(um=0.2195149727645171d0,uk=0.8040d0,ul=um/uk)
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c construct LDA exchange energy density
      exunif = AX*rho**THRD
      if(lgga.eq.0)then
        ex=exunif
        vx=ex*thrd4
        return
      endif
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c construct PBE enhancement factor
      S2 = S*S
      P0=1.d0+ul*S2
      FxPBE = 1d0+uk-uk/P0
      EX = exunif*FxPBE
      if(lpot.eq.0)return
c----------------------------------------------------------------------
c----------------------------------------------------------------------
C  ENERGY DONE. NOW THE POTENTIAL:
c  find first and second derivatives of Fx w.r.t s.
c  Fs=(1/s)*d FxPBE/ ds
c  Fss=d Fs/ds
      Fs=2.d0*uk*ul/(P0*P0)
      Fss=-4.d0*ul*S*Fs/P0
cpas: stress term dexs = (1/s) * d[Ex]/ds = exunif * (1/s) * dFxBPE/ds
      dexs = exunif*Fs
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c calculate potential from [b](24)
      VX = exunif*(THRD4*FxPBE-(U-THRD4*S2*s)*FSS-V*FS)
      RETURN
      END
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
cpas      SUBROUTINE CORPBE(RS,ZET,T,UU,VV,WW,lgga,lpot,ec,vcup,vcdn,
      SUBROUTINE DF_PBEC(RS,ZET,T,UU,VV,WW,lgga,lpot,ec,vcup,vcdn,
     1                  H,DVCUP,DVCDN, dht )
c----------------------------------------------------------------------
c  Official PBE correlation code. K. Burke, May 14, 1996.
C  INPUT: RS=SEITZ RADIUS=(3/4pi rho)^(1/3)
C       : ZET=RELATIVE SPIN POLARIZATION = (rhoup-rhodn)/rho
C       : t=ABS(GRAD rho)/(rho*2.*KS*G)  -- only needed for PBE
C       : UU=(GRAD rho)*GRAD(ABS(GRAD rho))/(rho**2 * (2*KS*G)**3)
C       : VV=(LAPLACIAN rho)/(rho * (2*KS*G)**2)
C       : WW=(GRAD rho)*(GRAD ZET)/(rho * (2*KS*G)**2
c       :  UU,VV,WW, only needed for PBE potential
c       : lgga=flag to do gga (0=>LSD only)
c       : lpot=flag to do potential (0=>energy only)
c  output: ec=lsd correlation energy from [a]
c        : vcup=lsd up correlation potential
c        : vcdn=lsd dn correlation potential
c        : h=NONLOCAL PART OF CORRELATION ENERGY PER ELECTRON
c        : dvcup=nonlocal correction to vcup
c        : dvcdn=nonlocal correction to vcdn
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c References:
c [a] J.P.~Perdew, K.~Burke, and M.~Ernzerhof,
c     {\sl Generalized gradient approximation made simple}, sub.
c     to Phys. Rev.Lett. May 1996.
c [b] J. P. Perdew, K. Burke, and Y. Wang, {\sl Real-space cutoff
c     construction of a generalized gradient approximation:  The PW91
c     density functional}, submitted to Phys. Rev. B, Feb. 1996.
c [c] J. P. Perdew and Y. Wang, Phys. Rev. B {\bf 45}, 13244 (1992).
c----------------------------------------------------------------------
c----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
c thrd*=various multiples of 1/3
c numbers for use in LSD energy spin-interpolation formula, [c](9).
c      GAM= 2^(4/3)-2
c      FZZ=f''(0)= 8/(9*GAM)
c numbers for construction of PBE
c      gamma=(1-log(2))/pi^2
c      bet=coefficient in gradient expansion for correlation, [a](4).
c      eta=small number to stop d phi/ dzeta from blowing up at
c          |zeta|=1.
      parameter(thrd=1.d0/3.d0,thrdm=-thrd,thrd2=2.d0*thrd)
      parameter(sixthm=thrdm/2.d0)
      parameter(thrd4=4.d0*thrd)
      parameter(GAM=0.5198420997897463295344212145565d0)
      parameter(fzz=8.d0/(9.d0*GAM))
      parameter(gamma=0.03109069086965489503494086371273d0)
      parameter(bet=0.06672455060314922d0,delt=bet/gamma)
      parameter(eta=1.d-12)
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c find LSD energy contributions, using [c](10) and Table I[c].
c EU=unpolarized LSD correlation energy
c EURS=dEU/drs
c EP=fully polarized LSD correlation energy
c EPRS=dEP/drs
c ALFM=-spin stiffness, [c](3).
c ALFRSM=-dalpha/drs
c F=spin-scaling factor from [c](9).
c construct ec, using [c](8)
      rtrs=dsqrt(rs)
cpas: I still disapprove of passing explicit constants, but ...
cpas      CALL gcor2(0.0310907D0,0.21370D0,7.5957D0,3.5876D0,1.6382D0,
      CALL DF_GCOR(0.0310907D0,0.21370D0,7.5957D0,3.5876D0,1.6382D0,
     1    0.49294D0,rtrs,EU,EURS)
cpas      CALL gcor2(0.01554535D0,0.20548D0,14.1189D0,6.1977D0,3.3662D0,
      CALL DF_GCOR(0.01554535D0,0.20548D0,14.1189D0,6.1977D0,3.3662D0,
     1    0.62517D0,rtRS,EP,EPRS)
cpas      CALL gcor2(0.0168869D0,0.11125D0,10.357D0,3.6231D0,0.88026D0,
      CALL DF_GCOR(0.0168869D0,0.11125D0,10.357D0,3.6231D0,0.88026D0,
     1    0.49671D0,rtRS,ALFM,ALFRSM)
      ALFC = -ALFM
      Z4 = ZET**4
      F=((1.D0+ZET)**THRD4+(1.D0-ZET)**THRD4-2.D0)/GAM
      EC = EU*(1.D0-F*Z4)+EP*F*Z4-ALFM*F*(1.D0-Z4)/FZZ
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c LSD potential from [c](A1)
c ECRS = dEc/drs [c](A2)
c ECZET=dEc/dzeta [c](A3)
c FZ = dF/dzeta [c](A4)
      ECRS = EURS*(1.D0-F*Z4)+EPRS*F*Z4-ALFRSM*F*(1.D0-Z4)/FZZ
      FZ = THRD4*((1.D0+ZET)**THRD-(1.D0-ZET)**THRD)/GAM
      ECZET = 4.D0*(ZET**3)*F*(EP-EU+ALFM/FZZ)+FZ*(Z4*EP-Z4*EU
     1        -(1.D0-Z4)*ALFM/FZZ)
      COMM = EC -RS*ECRS/3.D0-ZET*ECZET
      VCUP = COMM + ECZET
      VCDN = COMM - ECZET
      if(lgga.eq.0)return
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c PBE correlation energy
c G=phi(zeta), given after [a](3)
c DELT=bet/gamma
c B=A of [a](8)
      G=((1.d0+ZET)**thrd2+(1.d0-ZET)**thrd2)/2.d0
      G3 = G**3
      PON=-EC/(G3*gamma)
      B = DELT/(DEXP(PON)-1.D0)
      B2 = B*B
      T2 = T*T
      T4 = T2*T2
      RS2 = RS*RS
      RS3 = RS2*RS
      Q4 = 1.D0+B*T2
      Q5 = 1.D0+B*T2+B2*T4
cpas: to refactor, and add compute of stress term
cpas      H = G3*(BET/DELT)*DLOG(1.D0+DELT*Q4*T2/Q5)
      hfac = G3*(BET/DELT)
      hargln = 1.D0+DELT*Q4*T2/Q5
c
c gradient correction to energy density:
      H = hfac *DLOG( hargln )
c
      if( lpot.eq.0 ) RETURN
c
c gradient derivative for stress:
      Q7 = 1.d0 + 2.d0*B*T2
c     Stress term: dht = (1/t) * dH[t]/dt
      dht = 2.d0*hfac*(DELT/hargln) * ( Q7 / Q5**2 )
c----------------------------------------------------------------------
c----------------------------------------------------------------------
C ENERGY DONE. NOW THE POTENTIAL, using appendix E of [b].
      G4 = G3*G
      T6 = T4*T2
      RSTHRD = RS/3.D0
      GZ=(((1.d0+zet)**2+eta)**sixthm-
     1((1.d0-zet)**2+eta)**sixthm)/3.d0
      FAC = DELT/B+1.D0
      BG = -3.D0*B2*EC*FAC/(BET*G4)
      BEC = B2*FAC/(BET*G3)
      Q8 = Q5*Q5+DELT*Q4*Q5*T2
      Q9 = 1.D0+2.D0*B*T2
      hB = -BET*G3*B*T6*(2.D0+B*T2)/Q8
      hRS = -RSTHRD*hB*BEC*ECRS
      FACT0 = 2.D0*DELT-6.D0*B
      FACT1 = Q5*Q9+Q4*Q9*Q9
      hBT = 2.D0*BET*G3*T4*((Q4*Q5*FACT0-DELT*FACT1)/Q8)/Q8
      hRST = RSTHRD*T2*hBT*BEC*ECRS
      hZ = 3.D0*GZ*h/G + hB*(BG*GZ+BEC*ECZET)
      hT = 2.d0*BET*G3*Q9/Q8
      hZT = 3.D0*GZ*hT/G+hBT*(BG*GZ+BEC*ECZET)
      FACT2 = Q4*Q5+B*T2*(Q4*Q9+Q5)
      FACT3 = 2.D0*B*Q5*Q9+DELT*FACT2
      hTT = 4.D0*BET*G3*T*(2.D0*B/Q8-(Q9*FACT3/Q8)/Q8)
      COMM = H+HRS+HRST+T2*HT/6.D0+7.D0*T2*T*HTT/6.D0
      PREF = HZ-GZ*T2*HT/G
      FACT5 = GZ*(2.D0*HT+T*HTT)/G
      COMM = COMM-PREF*ZET-UU*HTT-VV*HT-WW*(HZT-FACT5)
      DVCUP = COMM + PREF
      DVCDN = COMM - PREF
      RETURN
      END
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
      SUBROUTINE DF_HSEX_HELPER(S,A,F,X,DXDS,DXDA,DXDF,D2XDS2,D2XDA2,
     1                          D2XDF2,D2XDSA,D2XDSF,D2XDAF)
c----------------------------------------------------------------------
c  COMPUTES THE EXCHANGE HOLE INTEGRAL THAT IS CENTRAL TO HSE EXCHANGE
c----------------------------------------------------------------------
c  INPUT S: same as in DF_HSEX (S>=0)
c  INPUT A: exponent of gaussian envelope in the integral (A>0)
c  INPUT F: parameter that defines the exchange hole (F>=0)
c  OUTPUT X: exchange hole integral
c  OUTPUT DXDS: derivative of X with S
c  OUTPUT DXDA: derivative of X with A
c  OUTPUT DXDF: derivative of X with F
c  OUTPUT D2XDS2: 2nd derivative of X with S
c  OUTPUT D2XDA2: 2nd derivative of X with A
c  OUTPUT D2XDF2: 2nd derivative of X with F
c  OUTPUT D2XDSA: derivative of X with S & A
c  OUTPUT D2XDSF: derivative of X with S & F
c  OUTPUT D2XDAF: derivative of X with A & F
c----------------------------------------------------------------------
c----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      parameter(pi=3.14159265358979323846264338327950d0)
      parameter(euler=0.5772156649015329d0,c1=0.4516064d0)
      parameter(c2=0.57786348d0,c3=0.16520372d0,c4=0.0068635965d0)
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c rescale the S input to avoid the undefined large-S regime of HSE
      if(S.le.8.d0) then
        S2 = S
        DS2DS = 1.d0
        D2S2DS2 = 0.d0
      else
        S2 = S-DEXP(DLOG(S-8.d0)-3.d0/(S-8.d0))
        DS2DS = 1.d0-(1.d0/(S-8.d0)+3.d0/(S-8.d0)**2)
     1          *DEXP(DLOG(S-8.d0)-3.d0/(S-8.d0))
        D2S2DS2 = (1.d0/(S-8.d0)**2+6.d0/(S-8.d0)**3
     1            -(1.d0/(S-8.d0)+3.d0/(S-8.d0)**2)**2)
     2            *DEXP(DLOG(S-8.d0)-3.d0/(S-8.d0))
      endif
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c compute the set of redundant terms that appear in several places
      r1 = DSQRT(c1)*DEXP(F/c1)*DERFC(DSQRT(F/c1))
      Dr1DF = r1/c1-DSQRT(1.0/(pi*F))
      r2 = 1.d0/(c2+F+A)
      r3 = (c4+F*2.d0/45.d0+S2**2*4.d0/1215.d0)*(c2+F+5.d0*A)
     1      +(8.d0/15.d0)*(2.d0*c1*(c2+F)**3-c3*(c2+F)**2)
     2      +(16.d0*DSQRT(pi)/15.d0)*(2.d0/3.d0-r1)
     3       *(c2+F)**3.5d0
      Dr3DF = (2.d0/45.d0)*(c2+F+5.d0*A)+c4+F*2.d0/45.d0
     1        +S2**2*4.d0/1215.d0
     2        +(8.d0/15.d0)*(6.d0*c1*(c2+F)**2-2.d0*c3*(c2+F))
     3        +(56.d0*DSQRT(pi)/15.d0)*(2.d0/3.d0-r1)*(c2+F)**2.5d0
     4        -(16.d0*DSQRT(pi)/15.d0)*Dr1DF*(c2+F)**3.5d0
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c special function is ln(1+(c2/c1)/y) - exp(y)*E1(y)
      y = (A+F)/c1
      SP = 0.d0
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c power series expansion for y <= 2.0
      if(y.le.2.d0) then
        do i = 22, 1, -1
          SP = -(y/DBLE(i))*(1.d0/DBLE(i) + SP)
        enddo
        SP = (DEXP(y)-1.d0)*DLOG(y)+DLOG(y+c2/c1)+DEXP(y)*(euler+SP)
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c continued fraction expansion for y > 2.0
      else
        do i = 45, 1, -1
          SP = DBLE(i*i)/(y+1.d0+2.d0*DBLE(i) - SP)
        enddo
        SP = DLOG(1.d0+(c2/c1)/y) - 1.d0/(y+1.d0-SP)
      endif
      dSP = SP+1.d0/(y+c2/c1)-DLOG(1.d0+(c2/c1)/y)
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c value of the integral
      X = c1*SP + c3*r2 + r3*r2**3
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c first derivatives
      DXDS = S2*DS2DS*(8.d0/1215.d0)*(c2+F+5.d0*A)*r2**3
      DXDy = dSP-c3*r2**2-3.d0*r3*r2**4
      DXDA = DXDy+5.d0*(c4+F*2.d0/45.d0+S2**2*4.d0/1215.d0)*r2**3
      DXDF = DXDy+Dr3DF*r2**3
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c second derivatives
      D2XDS2 = (DS2DS**2+S2*D2S2DS2)*(8.d0/1215.d0)*(c2+F+5.d0*A)*r2**3
      D2XDSA = -3.d0*DXDS*r2+S2*DS2DS*(8.d0/243.d0)*r2**3
      D2XDSF = -3.d0*DXDS*r2+S2*DS2DS*(8.d0/1215.d0)*r2**3

      D2XDy2 = (dSP-1.d0/(y+c2/c1)**2+1.d0/(y+(c1/c2)*y**2))/c1
     1         +2.d0*c3*r2**3+12.d0*r3*r2**5
      D2XDA2 = D2XDy2-30.d0*(c4+F*2.d0/45.d0+S2**2*4.d0/1215.d0)*r2**4
      D2XDAF = D2XDy2-15.d0*(c4+F*2.d0/45.d0+S2**2*4.d0/1215.d0)*r2**4
     1         -3.d0*Dr3DF*r2**4+(2.d0/9.d0)*r2**3
      D2XDF2 = D2XDy2-6.d0*Dr3DF*r2**4
     1         +(4.d0/45.d0+(8.d0/15.d0)*(12.d0*c1*(c2+F)-2.d0*c3)
     2         +(28.d0*DSQRT(pi)/3.d0)*(2.d0/3.d0-r1)*(c2+F)**1.5d0
     3       +(56.d0/15.d0)*(F**(-0.5d0)-DSQRT(pi)*r1/c1)*(c2+F)**2.5d0
     4         -(8.d0/15.d0)*(c2+F)**3.5d0*F**(-1.5d0)
     5         -(16.d0*DSQRT(pi)/15.d0)*((c2+F)/c1+3.5d0)*(c2+F)**2.5d0
     6         *Dr1DF)*r2**3
c----------------------------------------------------------------------
      RETURN
      END
c----------------------------------------------------------------------
c----------------------------------------------------------------------
      SUBROUTINE DF_HSEX( rho, S,U,V, omega, EX,VX, dexs )
c----------------------------------------------------------------------
C  HSE EXCHANGE FOR A SPIN-UNPOLARIZED ELECTRONIC SYSTEM
c----------------------------------------------------------------------
C  INPUT rho : DENSITY
C  INPUT S:  ABS(GRAD rho)/(2*KF*rho), where kf=(3 pi^2 rho)^(1/3)
C  INPUT U:  (GRAD rho)*GRAD(ABS(GRAD rho))/(rho**2 * (2*KF)**3)
C  INPUT V:  (LAPLACIAN rho)/(rho*(2*KF)**2)
c  INPUT omega:  (range separation parameter, =0.11 in HSE06)
C  OUTPUT:  EXCHANGE ENERGY PER ELECTRON (EX), POTENTIAL (VX),
C           and stress term dexs
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c References:
c [a]J. E. Moussa and P. A. Schultz, J. Comp. Chem. ??, ??? (2012).
c----------------------------------------------------------------------
c----------------------------------------------------------------------
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 w(26),a(26)
      parameter(pi=3.14159265358979323846264338327950d0)
      parameter(um=0.2195149727645171d0,uk=0.804d0)
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c coefficients of erfc(x) ~= w(i) exp(-a(i)*x**2) fit
      w(1) = 2.6444678d-1
      w(2) = 2.1518752d-1
      w(3) = 1.5602599d-1
      w(4) = 1.0941077d-1
      w(5) = 7.6737994d-2
      w(6) = 5.4113816d-2
      w(7) = 3.8233937d-2
      w(8) = 2.6951074d-2
      w(9) = 1.8891822d-2
      w(10) = 1.3138701d-2
      w(11) = 9.0507222d-3
      w(12) = 6.1667803d-3
      w(13) = 4.1504553d-3
      w(14) = 2.7553333d-3
      w(15) = 1.8013008d-3
      w(16) = 1.1574260d-3
      w(17) = 7.2924425d-4
      w(18) = 4.4921162d-4
      w(19) = 2.6952465d-4
      w(20) = 1.5673828d-4
      w(21) = 8.7754201d-5
      w(22) = 4.6852295d-5
      w(23) = 2.3512291d-5
      w(24) = 1.0830436d-5
      w(25) = 4.3824327d-6
      w(26) = 1.4089207d-6
      a(1) = 1.0461980d0
      a(2) = 1.4529966d0
      a(3) = 2.4816609d0
      a(4) = 4.6668302d0
      a(5) = 9.1647121d0
      a(6) = 1.8453344d1
      a(7) = 3.7911389d1
      a(8) = 7.9437595d1
      a(9) = 1.6994660d2
      a(10) = 3.7184035d2
      a(11) = 8.3377708d2
      a(12) = 1.9206304d3
      a(13) = 4.5580211d3
      a(14) = 1.1182009d4
      a(15) = 2.8473892d4
      a(16) = 7.5635070d4
      a(17) = 2.1088326d5
      a(18) = 6.2204592d5
      a(19) = 1.9611688d6
      a(20) = 6.7003372d6
      a(21) = 2.5288181d7
      a(22) = 1.0845899d8
      a(23) = 5.5279640d8
      a(24) = 3.6218918d9
      a(25) = 3.5946468d10
      a(26) = 8.7787680d11
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c use Newton's method to find the value of the HSE fitting parameter
      if(S .gt. 1d16) then
        S = 1d16
      endif
      if(S .lt. 0.0002d0) then
c regularization of S: this perturbs the result less than the
c single-precision accuracy target & avoids resolving 0/0 cancellations
        S =   0.0002D0
        F =   6.387488276512606D-018
        DFDS =   2.613912033810124D-013
        D2FDS2 =   6.655331272050626D-009
      else
        F = (0.00979681d0*S**4 + 0.0410834d0*S**6) / (1.d0
     1       + 0.187440d0*S**4 + 0.00120824d0*S**5 + 0.0347188d0*S**6)
        call DF_HSEX_HELPER(S,0.d0,F,X,
     1        DXDS,DXDA,DXDF,D2XDS2,D2XDA2,D2XDF2,D2XDSA,D2XDSF,D2XDAF)
        Rnew = 1.d0+uk-uk/(1.d0+(um/uk)*S**2)-X
        Rold = DABS(Rnew) + 1.d0
        do while(DABS(Rnew) .lt. DABS(Rold))
          Rold = Rnew
          dF = Rold/DXDF
cxxxhse       if(F+dF > 0.d0) then
          if( (F+dF) .gt. 0.d0 )then
            F = F+dF
          else
            F = 0.5d0*F
          endif
          call DF_HSEX_HELPER(S,0.d0,F,X,
     1        DXDS,DXDA,DXDF,D2XDS2,D2XDA2,D2XDF2,D2XDSA,D2XDSF,D2XDAF)
          Rnew = 1.d0+uk-uk/(1.d0+(um/uk)*S**2)-X
        enddo
        DX0DS = 2.d0*um*S/(1.d0+(um/uk)*S**2)**2
        D2X0DS2 = (2.d0*um-6.d0*(um*S)**2/uk)/(1.d0+(um/uk)*S**2)**3
        DFDS = (DX0DS-DXDS)/DXDF
        D2FDS2 = (D2X0DS2-D2XDS2-D2XDF2*DFDS**2-2.d0*D2XDSF*DFDS)/DXDF
      endif
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c construct HSE enhancement factor, X2, and derivatives
      X2 = 0.d0
      DX2DP = 0.d0
      DX2DS = 0.d0
      D2X2DPS = 0.d0
      D2X2DS2 = 0.d0
      fermiK = (3.d0*pi**2*rho)**(1.d0/3.d0)
      afact = (omega/fermiK)**2
      do i = 1, 26
        call DF_HSEX_HELPER(S,a(i)*afact,F,X,
     1        DXDS,DXDA,DXDF,D2XDS2,D2XDA2,D2XDF2,D2XDSA,D2XDSF,D2XDAF)
        X2 = X2 + w(i)*X
        DX2DP = DX2DP - w(i)*(2.d0/3.d0)*afact*a(i)*DXDA/rho
        DX2DS = DX2DS + w(i)*(DXDS+DXDF*DFDS)
        D2X2DPS = D2X2DPS - w(i)*(2.d0/3.d0)*afact*a(i)
     1                     *(D2XDSA+D2XDAF*DFDS)/rho
        D2X2DS2 = D2X2DS2 + w(i)*(D2XDS2+2.d0*D2XDSF*DFDS+DXDF*D2FDS2
     1                            +D2XDF2*DFDS**2)
      enddo
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c construct LDA & HSE exchange energy density (and stress term)
      EXlda = -(0.75d0/pi)*fermiK
      dEXlda = EXlda/(3.d0*rho)
      EX = EXlda*X2
cpas: stress term dexs = (1/s) * d[Ex]/ds
      dexs = EXlda*DX2DS/S
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c convert derivatives to rho/sigma(=M) to simplify potential formula
      G1 = S*rho*2.d0*fermiK
      G2 = V*rho*(2.d0*fermiK)**2
      G3 = U*rho**2*(2.d0*fermiK)**3
      DSDP = -(4.d0/3.d0)*S/rho
      DSDG = 1.d0/(rho*2.d0*fermiK)
      D2SDPG = -(4.d0/3.d0)*DSDG/rho
      DEXDP = dEXlda*X2+EXlda*(DX2DP+DX2DS*DSDP)
      DEXDG = EXlda*DX2DS*DSDG
      D2EXDPG = dEXlda*DX2DS*DSDG+EXlda*(D2X2DPS*DSDG+D2X2DS2*DSDP*DSDG
     1         +DX2DS*D2SDPG)
      D2EXDG2 = EXlda*D2X2DS2*DSDG**2
c----------------------------------------------------------------------
c----------------------------------------------------------------------
c potential formula from [PRB 54, 1568 (1996)]
      VX = EX+rho*DEXDP-G1*DEXDG-rho*G1*D2EXDPG-rho*DEXDG*G2/G1
     1    +(rho/G1)*(DEXDG/G1-D2EXDG2)*G3
      RETURN
      END
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
cpas      SUBROUTINE EXCHPW91(D,S,U,V,EX,VX)
      SUBROUTINE DF_PW91X( D, S,U,V, EX,VX, dexs )
C  GGA91 EXCHANGE FOR A SPIN-UNPOLARIZED ELECTRONIC SYSTEM
C  INPUT D : DENSITY
C  INPUT S:  ABS(GRAD D)/(2*KF*D)
C  INPUT U:  (GRAD D)*GRAD(ABS(GRAD D))/(D**2 * (2*KF)**3)
C  INPUT V: (LAPLACIAN D)/(D*(2*KF)**2)
C  OUTPUT:  EXCHANGE ENERGY PER ELECTRON (EX) AND POTENTIAL (VX)
      IMPLICIT REAL*8 (A-H,O-Z)
      parameter(a1=0.19645D0,a2=0.27430D0,a3=0.15084D0,a4=100.d0)
      parameter(ax=-0.7385588D0,a=7.7956D0,b1=0.004d0)
      parameter(thrd=0.333333333333D0,thrd4=1.33333333333D0)
c for Becke exchange, set a3=b1=0
      FAC = AX*D**THRD
      S2 = S*S
      S3 = S2*S
      S4 = S2*S2
      P0 = 1.D0/DSQRT(1.D0+A*A*S2)
      P1 = DLOG(A*S+1.D0/P0)
      P2 = DEXP(-A4*S2)
      P3 = 1.D0/(1.D0+A1*S*P1+B1*S4)
      P4 = 1.D0+A1*S*P1+(A2-A3*P2)*S2
      F = P3*P4
      EX = FAC*F
c
caem: start of stress term additions
cpas: stress term dexs = (1/s) * d[Ex]/ds = FAC * (1/s) * dFx[s]/ds
      if( s .gt. 1.d-8 )then
cpas: There was a couple of sign errors here in the original code
        dfx1 = -( a1*P1 + 4.d0*b1*S3 + a1*a*s*P0 ) * F
        dfx2 = a1*P1 + a1*a*s*P0 + 2.d0*s*(a2-a3*P2) + 2.d0*a4*a3*S3*P2
        dfxs = P3 * ( dfx1 + dfx2 )
        dexs =  FAC * dfxs / s
      else
cpas:   dexs = a2 + a3 ! since I multiply by "s" later, can blank out:
        dexs = 0.d0
      endif
caem: end of stress term additions
c
C  LOCAL EXCHANGE OPTION
C     EX = FAC
C  ENERGY DONE. NOW THE POTENTIAL:
      P5 = B1*S2-(A2-A3*P2)
      P6 = A1*S*(P1+A*S*P0)
      P7 = 2.D0*(A2-A3*P2)+2.D0*A3*A4*S2*P2-4.D0*B1*S2*F
      FS = P3*(P3*P5*P6+P7)
      P8 = 2.D0*S*(B1-A3*A4*P2)
      P9 = A1*P1+A*A1*S*P0*(3.D0-A*A*S2*P0*P0)
      P10 = 4.D0*A3*A4*S*P2*(2.D0-A4*S2)-8.D0*B1*S*F-4.D0*B1*S3*FS
      P11 = -P3*P3*(A1*P1+A*A1*S*P0+4.D0*B1*S3)
      FSS = P3*P3*(P5*P9+P6*P8)+2.D0*P3*P5*P6*P11+P3*P10+P7*P11
      VX = FAC*(THRD4*F-(U-THRD4*S3)*FSS-V*FS)
C  LOCAL EXCHANGE OPTION:
C     VX = FAC*THRD4
      RETURN
      END
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
cpas      SUBROUTINE CORpw91(RS,ZET,G,EC,ECRS,ECZET,T,UU,VV,WW,H,
      SUBROUTINE DF_PW91C( RS,ZET,G,EC,ECRS,ECZET,T,UU,VV,WW,H,
     1                   DVCUP,DVCDN, dht )
C  pw91 CORRELATION, modified by K. Burke to put all arguments
c  as variables in calling statement, rather than in common block
c  May, 1996.
C  INPUT RS: SEITZ RADIUS
C  INPUT ZET: RELATIVE SPIN POLARIZATION
C  INPUT T: ABS(GRAD D)/(D*2.*KS*G)
C  INPUT UU: (GRAD D)*GRAD(ABS(GRAD D))/(D**2 * (2*KS*G)**3)
C  INPUT VV: (LAPLACIAN D)/(D * (2*KS*G)**2)
C  INPUT WW:  (GRAD D)*(GRAD ZET)/(D * (2*KS*G)**2
C  OUTPUT H: NONLOCAL PART OF CORRELATION ENERGY PER ELECTRON
C  OUTPUT DVCUP,DVCDN:  NONLOCAL PARTS OF CORRELATION POTENTIALS
      IMPLICIT REAL*8 (A-H,O-Z)
      parameter(xnu=15.75592D0,cc0=0.004235D0,cx=-0.001667212D0)
      parameter(alf=0.09D0)
      parameter(c1=0.002568D0,c2=0.023266D0,c3=7.389D-6,c4=8.723D0)
      parameter(c5=0.472D0,c6=7.389D-2,a4=100.D0)
      parameter(thrdm=-0.333333333333D0,thrd2=0.666666666667D0)
      BET = XNU*CC0
      DELT = 2.D0*ALF/BET
      G3 = G**3
      G4 = G3*G
      PON = -DELT*EC/(G3*BET)
      B = DELT/(DEXP(PON)-1.D0)
      B2 = B*B
      T2 = T*T
      T4 = T2*T2
      T6 = T4*T2
      RS2 = RS*RS
      RS3 = RS2*RS
      Q4 = 1.D0+B*T2
      Q5 = 1.D0+B*T2+B2*T4
      Q6 = C1+C2*RS+C3*RS2
      Q7 = 1.D0+C4*RS+C5*RS2+C6*RS3
      CC = -CX + Q6/Q7
      R0 = 0.663436444d0*rs
      R1 = A4*R0*G4
      COEFF = CC-CC0-3.D0*CX/7.D0
      R2 = XNU*COEFF*G3
      R3 = DEXP(-R1*T2)
      H0 = G3*(BET/DELT)*DLOG(1.D0+DELT*Q4*T2/Q5)
      H1 = R3*R2*T2
      H = H0 + H1
C  LOCAL CORRELATION OPTION:
C     H = 0.0D0
C  ENERGY DONE. NOW THE POTENTIAL:
      CCRS = (C2+2.*C3*RS)/Q7 - Q6*(C4+2.*C5*RS+3.*C6*RS2)/Q7**2
      RSTHRD = RS/3.D0
      R4 = RSTHRD*CCRS/COEFF
      GZ = ((1.D0+ZET)**THRDM - (1.D0-ZET)**THRDM)/3.D0
      FAC = DELT/B+1.D0
      BG = -3.D0*B2*EC*FAC/(BET*G4)
      BEC = B2*FAC/(BET*G3)
      Q8 = Q5*Q5+DELT*Q4*Q5*T2
      Q9 = 1.D0+2.D0*B*T2
cpasaem:start add terms for stress calculation
c stress terms: dht=(1/t)*dH[t]/dt
      dht = 2.d0*( G3*BET*Q9/Q8 + R2*R3*( 1.D0 - R1*T2 ) )
cpasaem:end
      H0B = -BET*G3*B*T6*(2.D0+B*T2)/Q8
      H0RS = -RSTHRD*H0B*BEC*ECRS
      FACT0 = 2.D0*DELT-6.D0*B
      FACT1 = Q5*Q9+Q4*Q9*Q9
      H0BT = 2.D0*BET*G3*T4*((Q4*Q5*FACT0-DELT*FACT1)/Q8)/Q8
      H0RST = RSTHRD*T2*H0BT*BEC*ECRS
      H0Z = 3.D0*GZ*H0/G + H0B*(BG*GZ+BEC*ECZET)
      H0T = 2.*BET*G3*Q9/Q8
      H0ZT = 3.D0*GZ*H0T/G+H0BT*(BG*GZ+BEC*ECZET)
      FACT2 = Q4*Q5+B*T2*(Q4*Q9+Q5)
      FACT3 = 2.D0*B*Q5*Q9+DELT*FACT2
      H0TT = 4.D0*BET*G3*T*(2.D0*B/Q8-(Q9*FACT3/Q8)/Q8)
      H1RS = R3*R2*T2*(-R4+R1*T2/3.D0)
      FACT4 = 2.D0-R1*T2
      H1RST = R3*R2*T2*(2.D0*R4*(1.D0-R1*T2)-THRD2*R1*T2*FACT4)
      H1Z = GZ*R3*R2*T2*(3.D0-4.D0*R1*T2)/G
      H1T = 2.D0*R3*R2*(1.D0-R1*T2)
      H1ZT = 2.D0*GZ*R3*R2*(3.D0-11.D0*R1*T2+4.D0*R1*R1*T4)/G
      H1TT = 4.D0*R3*R2*R1*T*(-2.D0+R1*T2)
      HRS = H0RS+H1RS
      HRST = H0RST+H1RST
      HT = H0T+H1T
      HTT = H0TT+H1TT
      HZ = H0Z+H1Z
      HZT = H0ZT+H1ZT
      COMM = H+HRS+HRST+T2*HT/6.D0+7.D0*T2*T*HTT/6.D0
      PREF = HZ-GZ*T2*HT/G
      FACT5 = GZ*(2.D0*HT+T*HTT)/G
      COMM = COMM-PREF*ZET-UU*HTT-VV*HT-WW*(HZT-FACT5)
      DVCUP = COMM + PREF
      DVCDN = COMM - PREF
C  LOCAL CORRELATION OPTION:
C     DVCUP = 0.0D0
C     DVCDN = 0.0D0
      RETURN
      END
c
c
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
      subroutine DF_B1X( rho, s, u, v, ex, vx, dexs )
c Becke exchange for a spin-unpolarized electron system
c A. D. Becke, PRA 38, 3098 (1988).
c Input quantities:
c   rho = total electron number density
c   s = ABS(GRAD D)/(2*KF*D)
c   u = (GRAD D)*GRAD(ABS(GRAD D))/(D**2 * (2*KF)**3)
c   v = (LAPLACIAN D)/(D*(2*KF)**2)
c Output quantities:
c   ex = exchange energy per electron
c   vx = exchange potential (in rydbergs)
c   dexs = term needed in stress calculation. See GGASTRESS.
c
c Note: Becke's original form (with beta=0.0042 as parameter)
c   is translated into the PW91 form. This means:
c   c3 = 2 (6 pi^2)^(1/3), c2 = 6 beta c3, and
c   c1 = beta c3^2 / (3/4 (6/pi)^(1/3)). Note the similarity
c   to the PW91 parameters above (c2 to a1, c1 to a2, and c3 to a).
c   ex0 is the LDA prefactor: -3/4 (3/pi)^(1/3).
c
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER ( c1 = 0.2742931042d0, c2 = 0.1964479653d0 )
      PARAMETER ( c3 = 7.795554179d0, ex0 = -0.7385587664d0 )
      PARAMETER ( one = 1.d0, two = 2.d0, three = 3.d0, four = 4.d0 )
      PARAMETER ( five = 5.d0, thrd = one / three )
c
c Intermediate quantities formed.
c   fx = enhancement factor Fx(s)
c   vx0 = zeroth order prefactor in vx
c       = 3/4 Fx(s)
c   vxv = first order prefactor for v in vx
c       = -1/s dFx(s)/ds
c   vxu = first order prefactor for u in vx
c       = - d( 1/s dFx(s)/ds )/ds
c   vxs3 = first order prefactor for s^3 in vx
c        = 4/3 d( 1/s dFx(s)/ds )/ds
c   exlda = LDA exchange
c
      a = SQRT( one + (c3*s)**2 )
      b = LOG( c3*s + a )
      c = one + c2*s*b
      d = five + four*(c3*s)**2 - two*c2*c3*a*s**2
      e = c2*c3*s**2 + three*a**3
      fx = one + c1*s**2 / c
      vx0 = four*fx / three
      vxv = -c1*( two*a + c2*s*a*b - c2*c3*s**2 ) / ( a*c**2 )
      vxu = c1*c2*( c3*s*d + b*e + c2*s*a**3*b**2 ) / ( (a*c)**3 )
      vxs3 = -four*vxu / three
      exlda = ex0*rho**thrd
c
c Assemble ex, vx and dexs
c
      ex = exlda*fx
      vx = exlda*( vx0 + vxv*v + vxu*u + vxs3*s**3 )
      dexs = -exlda*vxv
c
c
c
c
      RETURN
      END
c
c
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
      subroutine DF_LYP( rhup,rhdn, grho, grhup,grhdn, g2rhup,g2rhdn,
     $   ec, vcup, vcdn, dcgrho, dcgrup, dcgrdn, dcg2rup, dcg2rdn )
c LYP correlation for a spin-polarized electron system.
c Lee, Yang, and Parr, PRB 37, 785 (1988).
c Input quantities:
c   rhup   = spin-up electron density
c   rhdn   = spin-down electron density
c   grho   = | GRAD[rho] |
c   grhup  = | GRAD[rhup] |
c   grhdn  = | GRAD[rhdn] |
c   g2rhup = GRAD**2[rhup]
c   g2rhdn = GRAD**2[rhdn]
c Output quantities:
c   ec   = correlation energy per particle
c   vcup = spin-up correlation potential
c   vcdn = spin-down correlation potential
c   dcgrho = stress correction for gradients (grho)
c   dcgrup = spin-up stress correction for gradients (grhup)
c   dcgrdn = spin-down stress correction for gradients (grhdn)
c   dcg2rup = spin-up stress correction for laplacians
c   dcg2rdn = spin-down stress correction for laplacians
c
c Note: The constants a, b, c, d, have dimensions
c   Hartree, dimensionless, bohr and bohr
c   and are given in the original LYP paper.
c   cf = 3/10 (3 pi^2)^(2/3)
c
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER ( a = 0.04918d0, b = 0.132d0 )
      PARAMETER ( c = 0.2533d0, d = 0.349d0, cf = 2.871234 )
      PARAMETER ( one = 1.d0, two = 2.d0, three = 3.d0, four = 4.d0 )
      PARAMETER ( five = 5.d0, thrd = one / three, snth = -one / 9.d0 )
c
c Intermediate quantities are formed.
c      ec = ec0 + ecgg*grho**2 + ecggu*grhup**2 +
c           + ecggd*grhdn + eclu*g2rhup + ecld*g2rhdn
c      vca = vca0 + vcagg*grho**2 + vcaggu*grhup**2 +
c           + vcaggd*grhdn + vcalu*g2rhup + vcald*g2rhdn
c      where a is u(p) or d(own).
c      ec = fc/rho where fc is the integrand of Eq. (22) in the LYP paper.
c      Each of the three terms in the definition of vca,
c      vcup = d[fc]/d(rhup) - GRAD dot d[fc]/d(GRAD[rhup]) +
c             + GRAD**2 d[fc]/d(GRAD**2[rhup]),
c      contribute to the prefactors above.
c      In LYP the task of forming vcud and vcdn is somewhat simplified by simple
c      relations between all ec prefactors except ec0.
c      I use ec0 and ecgg as primary quantities.
c      Primary intermediate quantities that are formed are:
c      vcu0 and vcd0: spin up and spin down derivatives of rho*ec0
c      db0du and db0dd: spin up and spin down derivatives of rho*ecgg
c      d2b0du2, d2b0dd2, and d2b0dudd: second derivatives of rho*ecgg
c
c      Most quantities are spin independent, if not they are clearly marked
c      with u(p) or d(own) in the parameter name.
c
      rho = rhup + rhdn
      r13 = rho**thrd
      r23 = r13*r13
      r33 = rho
      r43 = rho*r13
      r53 = r43*r13
      ru83 = rhup**(8.d0*thrd)
      rd83 = rhdn**(8.d0*thrd)
      rurdr = ( ru83 + rd83 ) / r43**2
      paru = 12.d0*rhup + 9.d0*rhdn
      pard = 12.d0*rhdn + 9.d0*rhup
      aa = d + r13
      argexp = -c / r13
      if ( argexp .gt. -60.d0 ) then
        bb = a*b*exp( argexp )
      else
        bb = 0.d0
      endif
      a0 = two**( five*thrd ) * cf * bb
      b0 = bb / ( aa * r13 * rho**4 )
c
c Energy density prefactors formed
c     In lyp ecggu=ecggd=ecggs
c
      ec0 = -four*rhup*rhdn*( a0*rurdr + a ) / ( aa * r53 )
      ecgg = rhup*rhdn*b0
      ecggs = snth*ecgg
      eclu = ecggs*paru
      ecld = ecggs*pard
c
c vcu0 and vcd0 formed
c
      ceven = ru83 + rd83
      codd = rhdn*ru83 - rhup*rd83
      ccu = ( c*rhup + three*rhdn*r13 )*ceven + 8.d0*r13*codd
      ccd = ( c*rhdn + three*rhup*r13 )*ceven - 8.d0*r13*codd
      ddu = a0*( aa*ccu + d*rhup*r13*ceven ) +
     $             a*rho**3*(d*rhup + three*rhdn*aa)
      ddd = a0*( aa*ccd + d*rhdn*r13*ceven ) +
     $             a*rho**3*(d*rhdn + three*rhup*aa)
      vcu0 = -four*rhdn*ddu*r13 / ( three * aa**2 * rho**5 )
      vcd0 = -four*rhup*ddd*r13 / ( three * aa**2 * rho**5 )
c
c Mess, sorry no way to make it nice
c
      ee = rhup*rhdn*( c*aa / r13 - 7.d0*aa - r13 )
      db0du = ( ee + three * rhdn**2 * aa ) * b0 / ( aa * three )
      db0dd = ( ee + three * rhup**2 * aa ) * b0 / ( aa * three )
      ff0 = r13*aa*( 30.d0*aa + three*r13 )
      ff1 = r13*( 35.d0*aa**2 + 8.d0*aa*r13 + r23 )
      ff2 = c*aa*three*aa
      ff3 = c*aa*( 9.d0*aa + r13 )
      ff5 = two*r13*( ff0 - ff2 )
      ff6 = ( c*aa )**2 + two*r13*( ff1 - ff3 )
      ffu = rhdn*ff5 - rhup*ff6
      ffd = rhup*ff5 - rhdn*ff6
      d2b0du2 = snth*bb*ffu*rhdn / ( rho**6 * aa**3 )
      d2b0dd2 = snth*bb*ffd*rhup / ( rho**6 * aa**3 )
      sq1 = three*( rhup**2 - 6.d0*rhup*rhdn + rhdn**2 )
      ff7 = ( 19.d0 * aa**2 ) + d*r13 + c*aa
      ff8 = ( c*aa )**2 - two*r23*ff7
      ff9 = r13*aa*( 7.d0*r13*aa - c*aa + r23 )
      ffud = rhup*rhdn*ff8 - sq1*ff9
      d2b0dudd =-snth*bb*ffud / ( rho**6 * aa**3 )
c
c Remaining potential prefactors formed
c
      vcugg = snth*(d2b0dudd*paru + 9.d0*db0du + 20.d0*db0dd)
      vcdgg = snth*(d2b0dudd*pard + 9.d0*db0dd + 20.d0*db0du)
      vcuggu = snth*((d2b0du2-d2b0dudd)*paru+23.d0*db0du-20.d0*db0dd)
      vcdggu = snth*((d2b0du2-d2b0dudd)*pard-17.d0*db0dd+16.d0*db0du)
      vcuggd = snth*((d2b0dd2-d2b0dudd)*paru-17.d0*db0du+16.d0*db0dd)
      vcdggd = snth*((d2b0dd2-d2b0dudd)*pard+23.d0*db0dd-20.d0*db0du)
      vculu = snth*(two*db0du*paru + 40.d0*rho*ecgg)
      vcdlu = snth*(db0dd*paru + db0du*pard) - four*rho*ecgg
      vculd = snth*(db0du*pard + db0dd*paru) - four*rho*ecgg
      vcdld = snth*(two*db0dd*pard + 40.d0*rho*ecgg)
c
c Final quantities.
c
      ec = ec0 + ecgg * grho**2 + ecggs * ( grhup**2 + grhdn**2 ) +
     $     eclu * g2rhup + ecld * g2rhdn
      vcup = vcu0 + vcugg * grho**2 +
     $       vcuggu * grhup**2 + vcuggd * grhdn**2 +
     $       vculu * g2rhup + vculd * g2rhdn
      vcdn = vcd0 + vcdgg * grho**2 +
     $       vcdggu * grhup**2 + vcdggd * grhdn**2 +
     $       vcdlu * g2rhup + vcdld * g2rhdn
      dcgrho = two * ecgg * rho
      dcgrup = two * ecggs * rho
      dcgrdn = two * ecggs * rho
      dcg2rup = -two * eclu * rho
      dcg2rdn = -two * ecld * rho
c
c
c
      RETURN
      END
c
c
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
      subroutine DF_AM05(n,s,u,v,ex,ec,vx,vc,dexs,decs)
c
c Armiento Mattsson am05 functional for exchange and correlation 
c "R. Armiento and A. E. Mattsson, PRB 72, 085108 (2005). " 
c input
c   n = electron density, D [bohr**(-3)]
c   s = ABS(GRAD D)/(2*KF*D) [dimless]
c   u = (GRAD D)*GRAD(ABS(GRAD D))/(D**2 * (2*KF)**3) [dimless]
c   v = (LAPLACIAN D)/(D*(2*KF)**2) [dimless]
c output
c   ex       exchange energy per electron [hartree]
c   ec       correlation energy per electron [hartree]
c   vx       exchange potential [hartree]
c   vc       correlation potential [hartree]
c   dexs     exchange stress term. See GGASTRESS.
c   decs     correlation stress term. See GGASTRESS.
c
      implicit none
c
c     ** Input parameters
      real*8 n, s, u, v
c
c     ** Output parameters
      real*8 ex, ec, vx, vc, dexs, decs
c
c     ** Constants and shorthand notation
      real*8 pi, g, a, s2, c
      parameter (pi = 3.141592653589793238462643383279502884197d0)
      parameter (g = 0.8098d0, a = 2.804d0)
      parameter (c = 0.7168d0)
c
c     ** Local variables
      real*8 exlda, vxlda, eclda, vclda, X, Xsos, Xsossos
      real*8 Hx, Hxsos, Hxsossos, Hc, Hcsos, Hcsossos
      real*8 F, Fsos, s2Fsossos
      real*8 szsoz, mixder
      real*8 denom, denomsos, sdenomsoss
      real*8 zfac, zosn, w
c
c     ** Cutoff 
      if((n .le. 1.0d-16)) then
         ex = 0.0d0
         ec = 0.0d0
         vx = 0.0d0
         vc = 0.0d0
         return
      endif
c
      s2 = s**2
c
c     *******************
c       LDA correlation
c     *******************
      call am05_ldapwc(n,eclda,vclda)
c
c     *******************
c        LDA exchange
c     *******************
      vxlda = -(3.0d0*n/pi)**(1.0d0/3.0d0)
      exlda = (3.0d0/4.0d0*vxlda)
c      
c     ********************
c          Exchange
c     ********************
c     ** Interpolation index
      X = 1.0d0/(1.0d0 + a*s2)
c      
c     ** Airy LAA refinement function
      call am05_labertw(s**(3.0d0/2.0d0)/sqrt(24.0d0),w)
c
c     ** am05_lambertw give back argument if it is < 1.0e-20
c     ** (1.0e-14)^{3/2} = 1.0e-21 => give  low s limit for z/s
c     ** zosn = normalized z/s
      if (s .lt. 1.0e-14) then
              zosn = 1.0d0
      else
              zosn = 24.0d0**(1.0d0/3.0d0)*w**(2.0d0/3.0d0)/s
      end if
      zfac = s2*(zosn*27.0d0/32.0d0/pi**2)**2
c
c     ** denom = denominator of Airy LAA refinement function
      denom = 1.0d0 + c*s2*zosn*(1.0d0 + zfac)**(1.0d0/4.0d0)
      F = (c*s2 + 1.0d0)/denom
c      
c     ** Exchange refinement function
      Hx = X + (1.0d0 - X)*F
c
c     ** Exchange energy per particle, Ex = Integrate[n*ex]
      ex = exlda*Hx
c      
c     ********************
c         Correlation
c     ********************
c     ** Correlation refinement function 
      Hc = X + g*(1.0d0 - X)
c      
c     ** Correlation energy per particle, Ec = Integrate[n*ec]
      ec = eclda*Hc
c      
c     ***************************
c         Exchange potential
c     ***************************
c     ** Interpolation index derivatives: 1/s dX/ds, 1/s d/ds(1/s dX/ds)                   
      Xsos = -2.0d0*a*X**2
      Xsossos = 8.0d0*a**2*X**3
c
c     ** Airy LAA refinement function derivatives, 1/s dF/ds and s^2 1/s d/ds (1/s dF/ds) 
c     ** szsoz = s*(dz/ds)/z, mixder = szsoz + s^2*(d^2z/ds^2)/z
      szsoz = 1.0d0/(1.0d0 + w)
      mixder = (2.0d0 - w)/(2.0d0*(1.0d0 + w)**3)
c
c     ** denomsos = 1/s d(denom)/ds, sdenomsoss = s*d/ds(1/s d(denom)/ds))
      denomsos = c*zosn/(1.0d0 + zfac)**(3.0d0/4.0d0)*
     *     (1.0d0 + zfac + (1.0d0 + 3.0d0/2.0d0*zfac)*szsoz)
      sdenomsoss = c*zosn/(1.0d0 + zfac)**(7.0d0/4.0d0)*
     *     (-1.0d0 - zfac*(2.0d0 + zfac)
     *      + (1.0d0 + zfac/2.0d0*(5.0d0 + 3.0d0*zfac))*mixder
     *      + 3.0d0/2.0d0*zfac*(1.0d0 + zfac/2.0d0)*szsoz**2)

      Fsos = c/denom**2*(2.0d0 - zosn*
     *            ((1.0d0 - c*s2)*(1.0d0 + zfac)**(1.0d0/4.0d0) +
     *             (1.0d0 + c*s2)*(1.0d0 + 3.0d0/2.0d0*zfac)/
     *                      (1.0d0 + zfac)**(3.0d0/4.0d0)*szsoz))
      s2Fsossos = (-4.0d0*c*s2*denom*denomsos + (c*s2 + 1.0d0)*
     *                    (2.0d0*s2*denomsos**2 - denom*sdenomsoss))/
     *                      denom**3
c
c     ** Refinement function derivatives, 1/s dHx/ds, 1/s d/ds (1/s dHx/ds) 
c     ** We use that (1 - X) = a*X*s2
      Hxsos = (1.0d0 - X)*Fsos - (F - 1.0d0)*Xsos
      Hxsossos = - 2.0d0*Fsos*Xsos + a*X*s2Fsossos -
     *                  (F - 1.0d0)*Xsossos
c
c     ** vx formula for gradient dependent functional,
      vx = vxlda*(Hx - s2*Hxsos) +
     *     exlda*((4.0d0/3.0d0*s2-v)*Hxsos - 
     *     (u-4.0d0/3.0d0*s**3)*s*Hxsossos)
c     **exchange stress term
      dexs = exlda*Hxsos
c
c     *****************************
c        Correlation potential
c     *****************************
c     ** Correlation refinement function derivatives, dF/ds 
      Hcsos = Xsos*(1.0d0 - g)
      Hcsossos = Xsossos*(1.0d0 - g)
c      
c     ** vc formula for gradient dependent functional,
c     Generalized form of Eq. (24) in PRB 33, 8800 (1986) 
      vc = vclda*(Hc - s2*Hcsos) +
     *     eclda*((4.0d0/3.0d0*s2 - v)*Hcsos - 
     *     (u - 4.0d0/3.0d0*s**3)*s*Hcsossos)
c     ** correlation stress term      
      decs = eclda*Hcsos
c
      return
      end
c
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
c I am repeating the LDA PW routine here even if it is available
c in DF_GCOR above. Once I clean up the PBE and PW91 implementations
c I'll eliminate DF_GCOR and replace it with something nicer. Until then
c I keep the am05 specific name since only DF_AM05 uses it.
c
      subroutine am05_ldapwc(n,ec,vc)
c***********************************************
c Local density approximation correlation
c
c input
c   n        electron density [bohr**(-3)]
c
c output
c   ec       correlation energy per electron [hartree]
c   vc       correlation potential [hartree]
c
c As parameterized by Perdew Wang,
c Phys. Rev. B 45, 13244 (1992) 
c Based on monte carlo data by Ceperley Alder, 
c Phys. Rev. Lett. 45, 566 (1980)
c
c (Clean room implementation from paper)
c
c***********************************************
      implicit none
c     ** Input parameters
      real*8 n
c
c     ** Output parameters
      real*8 ec, vc
c
c     ** Constants
      real*8 pi
      real*8 A0,a01,b01,b02,b03,b04
      parameter (pi = 3.141592653589793238462643383279502884197d0)
      parameter (a01 = 0.21370d0)
      parameter (b01 = 7.5957d0)
      parameter (b02 = 3.5876d0)
      parameter (b03 = 1.6382d0)
      parameter (b04 = 0.49294d0)
c     ** Paper actually use this:
c      parameter (A0 = 0.031091d0)
c     ** But routines now "defacto standard" was distributed using:
      parameter (A0 = 0.0310907d0)
c
c     ** Local variables
      real*8 rsq
      real*8 Q0, Q1, Q1p, ecrs
c
      rsq = (3.0d0/(4.0d0*pi*n))**(1.0d0/6.0d0)
c
      ec = -2.0d0*A0*(1.0d0 + a01*rsq**2)* 
     *     log(1.0d0 + 1.0d0/
     *     (2.0d0*A0*rsq*(b01 + rsq*(b02 + rsq*(b03 + b04*rsq)))))
c
      Q0 = -2.0d0*A0*(1.0d0 + a01*rsq**2)
      Q1 = 2.0d0*A0*rsq*(b01 + rsq*(b02 + rsq*(b03 + b04*rsq)))
      Q1p = A0*(b01/rsq+2.0d0*b02+3.0d0*b03*rsq+4.0d0*b04*rsq**2)
      ecrs = -2.0d0*A0*a01*log(1.0d0 + 1.0d0/Q1)-Q0*Q1p/(Q1**2+Q1)
c
      vc=ec - rsq**2/3.0d0*ecrs
c      
      return
      end
c
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
c This routine is only used by DF_AM05, and it will never be used by 
c any other routine. That's why I do not rename it according to QUEST
c standard.
c 
c 
c
      subroutine am05_labertw(z,result)
c     ***********************************************
c       LambertW function. 
c
c       Corless, Gonnet, Hare, Jeffrey, and Knuth (1996), 
c         Adv. in Comp. Math. 5(4):329-359. 
c       Implementation approach loosely inspired by the 
c       GNU Octave version by N. N. Schraudolph, but this 
c       implementation is only for real values and 
c       principal branch.
c
c       Copyright (c) 2005, Rickard Armiento
c       All rights reserved.
c     ***********************************************      
      implicit none
c
c     input
      real*8 z
c     output
      real*8 result
c     local variables
      real*8 e,t,p    
      integer i
c
c     ** If z too low, go with the first term of the power expansion, z
      if( z .lt. 1.0d-20) then
         result = z
         return
      endif
c
      e = exp(1.0d0)
c
c     ** Inital guess
      if( abs(z + 1.0d0/e) .gt. 1.45d0 ) then
c        ** Asymptotic expansion at 0 and Inf
         result = log(z)
         result = result - log(result)
      else
c        ** Series expansion about -1/e to first order
         result = 1.0d0*sqrt(2.0d0*e*z + 2.0d0) - 1.0d0
      endif
c
c     ** Find result through iteration
      do i=1,10
         p = exp(result)
         t = result*p - z
         if( result .ne. -1.0d0 ) then
            t = t/(p*(result + 1.0d0) - 
     *           0.5d0*(result + 2.0d0)*t/(result + 1.0d0))
         else
            t = 0.0d0
         endif
         result = result - t
         if(abs(t) .lt. (2.48d0*1.0d-14)*(1.0d0 + abs(result))) then
            return
         endif
      enddo
c     ** This should never happen!;
      write(*,*) 'am05_labertw: iteration limit reached.' 
      write(*,*) 'Should never happen: execution aborted.'
      stop
      end
c
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
      subroutine DF_AM05s1(n,nop,s,u,v,ex,vx,dexs)
c
c Armiento Mattsson am05 functional for exchange and correlation 
c "R. Armiento and A. E. Mattsson, PRB 72, 085108 (2005). " 
C 9/17/8:RJM spin dependence added 
C     Note: subroutine outputs ex 
C     and some convenient mixture of vx and vc 
C
c input
c   n = electron density, D [bohr**(-3)]
c   s = ABS(GRAD D)/(2*KF*D) [dimless]
c   u = (GRAD D)*GRAD(ABS(GRAD D))/(D**2 * (2*KF)**3) [dimless]
c   v = (LAPLACIAN D)/(D*(2*KF)**2) [dimless]
c output
c   ex       exchange energy per electron [hartree]
c   ec       correlation energy per electron [hartree]
c   vx       exchange potential [hartree]
c   vc       correlation potential [hartree]
c   dexs     exchange stress term. See GGASTRESS.
c   decs     correlation stress term. See GGASTRESS.
c
      implicit none
c
c     ** Input parameters
      real*8 n,nop, s, u, v
c
c     ** Output parameters
      real*8 ex, vx, dexs
c     ** Auxilliary parameters
      real*8 ec, vc, decs
c
c     ** Constants and shorthand notation
      real*8 pi, g, a, s2, c,two,third
      parameter (pi = 3.141592653589793238462643383279502884197d0)
      parameter (g = 0.8098d0, a = 2.804d0)
      parameter (c = 0.7168d0)
      parameter (two = 2.d0, third = 1d0/3d0)
c
c     ** Local variables
      real*8 exlda, vxlda, eclda, vclda, X, Xsos, Xsossos
      real*8 Hx, Hxsos, Hxsossos, Hc, Hcsos, Hcsossos
      real*8 F, Fsos, s2Fsossos
      real*8 szsoz, mixder
      real*8 denom, denomsos, sdenomsoss
      real*8 zfac, zosn, w
	  real*8 rs,zet,a1,a2,a3,a4,ntot	
c
c     ** Cutoff 
      if((n .le. 1.0d-16)) then
         ex = 0.0d0
         ec = 0.0d0
         vx = 0.0d0
         vc = 0.0d0
         return
      endif
c
      s2 = s**2
c
c     *******************
c       LDA correlation
c     *******************
      ntot=n/two+nop
      rs=(3./(4.*pi*ntot))**third
      zet=(n/two-nop)/ntot
      call DF_LSDC(rs,zet,eclda,vclda,a1,a2,a3,a4)
c     *******************
c        LDA exchange
c     *******************
      vxlda = -(3.0d0*n/pi)**(1.0d0/3.0d0)
      exlda = (3.0d0/4.0d0*vxlda)
c      
c     ********************
c          Exchange
c     ********************
c     ** Interpolation index
      X = 1.0d0/(1.0d0 + a*s2)
c      
c     ** Airy LAA refinement function
      call am05_labertw(s**(3.0d0/2.0d0)/sqrt(24.0d0),w)
c
c     ** am05_lambertw give back argument if it is < 1.0e-20
c     ** (1.0e-14)^{3/2} = 1.0e-21 => give  low s limit for z/s
c     ** zosn = normalized z/s
      if (s .lt. 1.0e-14) then
              zosn = 1.0d0
      else
              zosn = 24.0d0**(1.0d0/3.0d0)*w**(2.0d0/3.0d0)/s
      end if
      zfac = s2*(zosn*27.0d0/32.0d0/pi**2)**2
c
c     ** denom = denominator of Airy LAA refinement function
      denom = 1.0d0 + c*s2*zosn*(1.0d0 + zfac)**(1.0d0/4.0d0)
      F = (c*s2 + 1.0d0)/denom
c      
c     ** Exchange refinement function
      Hx = X + (1.0d0 - X)*F
c
c     ** Exchange energy per particle, Ex = Integrate[n*ex]
      ex = exlda*Hx
c      
c     ********************
c         Correlation
c     ********************
c     ** Correlation refinement function 
      Hc = X + g*(1.0d0 - X)
c      
c     ***************************
c         Exchange potential
c     ***************************
c     ** Interpolation index derivatives: 1/s dX/ds, 1/s d/ds(1/s dX/ds)                   
      Xsos = -2.0d0*a*X**2
      Xsossos = 8.0d0*a**2*X**3
c
c     ** Airy LAA refinement function derivatives, 1/s dF/ds and s^2 1/s d/ds (1/s dF/ds) 
c     ** szsoz = s*(dz/ds)/z, mixder = szsoz + s^2*(d^2z/ds^2)/z
      szsoz = 1.0d0/(1.0d0 + w)
      mixder = (2.0d0 - w)/(2.0d0*(1.0d0 + w)**3)
c
c     ** denomsos = 1/s d(denom)/ds, sdenomsoss = s*d/ds(1/s d(denom)/ds))
      denomsos = c*zosn/(1.0d0 + zfac)**(3.0d0/4.0d0)*
     *     (1.0d0 + zfac + (1.0d0 + 3.0d0/2.0d0*zfac)*szsoz)
      sdenomsoss = c*zosn/(1.0d0 + zfac)**(7.0d0/4.0d0)*
     *     (-1.0d0 - zfac*(2.0d0 + zfac)
     *      + (1.0d0 + zfac/2.0d0*(5.0d0 + 3.0d0*zfac))*mixder
     *      + 3.0d0/2.0d0*zfac*(1.0d0 + zfac/2.0d0)*szsoz**2)

      Fsos = c/denom**2*(2.0d0 - zosn*
     *            ((1.0d0 - c*s2)*(1.0d0 + zfac)**(1.0d0/4.0d0) +
     *             (1.0d0 + c*s2)*(1.0d0 + 3.0d0/2.0d0*zfac)/
     *                      (1.0d0 + zfac)**(3.0d0/4.0d0)*szsoz))
      s2Fsossos = (-4.0d0*c*s2*denom*denomsos + (c*s2 + 1.0d0)*
     *                    (2.0d0*s2*denomsos**2 - denom*sdenomsoss))/
     *                      denom**3
c
c     ** Refinement function derivatives, 1/s dHx/ds, 1/s d/ds (1/s dHx/ds) 
c     ** We use that (1 - X) = a*X*s2
      Hxsos = (1.0d0 - X)*Fsos - (F - 1.0d0)*Xsos
      Hxsossos = - 2.0d0*Fsos*Xsos + a*X*s2Fsossos -
     *                  (F - 1.0d0)*Xsossos
c
c     ** vx formula for gradient dependent functional,
      vx = vxlda*(Hx - s2*Hxsos) +
     *     exlda*((4.0d0/3.0d0*s2-v)*Hxsos - 
     *     (u-4.0d0/3.0d0*s**3)*s*Hxsossos)
c     **exchange stress term
      dexs = exlda*Hxsos
c
c     *****************************
c        Correlation potential
c     *****************************
c     ** Correlation refinement function derivatives, dF/ds 
      Hcsos = Xsos*(1.0d0 - g)
      Hcsossos = Xsossos*(1.0d0 - g)
c      
c     ** vc formula for gradient dependent functional,
c     Generalized form of Eq. (24) in PRB 33, 8800 (1986) 
      vc = vclda*(Hc - s2*Hcsos) +
     *     eclda*((4.0d0/3.0d0*s2 - v)*Hcsos  
     *     +(4.0d0/3.0d0*s**3-u)*s*Hcsossos)
c
      vx=vx+vc
C
      return
      end
c
c----------------------------------------------------------------------
c######################################################################
c----------------------------------------------------------------------
      subroutine DF_AM05s2(nup,ndn,dup,ddn,dtot,ec,
     &                     vcup,vcdn,decsup,decsdn)
c
c Armiento Mattsson am05 functional for exchange and correlation 
c "R. Armiento and A. E. Mattsson, PRB 72, 085108 (2005). " 
C 9/17/8:RJM spin dependence added 
C Note: subroutine outputs ec and some fraction of vc 
C
c input
c   nup,ndn = electron density, D [bohr**(-3)]
c output
c   ec       correlation energy per electron [hartree]
c   vc       correlation potential [hartree]
c   decs     correlation stress term. See GGASTRESS.
c
      implicit none
c
c     ** Input parameters
      real*8 n,kf,ex,vx,ntot,s,v,u
      real*8 nup,ndn,dup,ddn,sup,sdn,dtot
      real*8 vcldaup,vcldadn,dudotdd
      real*8 decsup,decsdn
c
c     ** Auxilliary parameters
      real*8 ec, vc, decs
c
c     ** Constants and shorthand notation
      real*8 pi, g, a, s2, c, two, third
      parameter (pi = 3.141592653589793238462643383279502884197d0)
      parameter (g = 0.8098d0, a = 2.804d0)
      parameter (c = 0.7168d0)
      parameter (two = 2.d0, third =1.d0/3.d0 )
c
c     ** Local variables
      real*8 eclda, vclda
	  real*8 rs,zet,a1,a2,a3,a4	
          real*8 vcup,vcdn,vcuplda,vcdnlda
          real*8 xup,xdn,xsosup,xsosdn,hcup,hcdn
	Real*8 hcsosup,hcsosdn 
c
c     ** Cutoff 
      if((n .le. 1.0d-16)) then
         ex = 0.0d0
         ec = 0.0d0
         vx = 0.0d0
         vc = 0.0d0
         return
      endif
c
c     *******************
c       LDA correlation
c     *******************
           ntot=nup+ndn
C check factors of 2. before nup
           kf=(3.*pi**2.*two*nup)**third
           sup=dup/(2.*kf*nup)
           kf=(3.*pi**2.*two*ndn)**third
           sdn=ddn/(two*kf*ndn)
           rs=(3./(4.*pi*ntot))**third
           zet=(nup-ndn)/(ntot)
           call DF_LSDC(rs,zet,eclda,vcldaup,vcldadn,a2,a3,a4)
C note eclda is the energy per particle eps
           dudotdd=(dtot**two-ddn**two-dup**two)/two
c     ********************
c         Correlation Energy
c     ********************
      s2=sup**2.
c     ** Interpolation index
      Xup = 1.0d0/(1.0d0 + a*s2)
c     ** Correlation refinement function 
      Hcup = Xup + g*(1.0d0 - Xup)
      s2=sdn**2.
c     ** Interpolation index
      Xdn = 1.0d0/(1.0d0 + a*s2)
c     ** Correlation refinement function 
      Hcdn = Xdn + g*(1.0d0 - Xdn)
c      
c     ** Correlation energy per particle, Ec = Integrate[n*ec]
      ec = eclda*(Hcup*nup+Hcdn*ndn)/ntot
C
c     *****************************
c        Correlation potential
c     *****************************
c     ** Interpolation index derivatives: 1/s dX/ds
      Xsosup = -2.0d0*a*Xup**2
      Xsosdn = -2.0d0*a*Xdn**2
c     ** Correlation refinement function derivatives, dF/ds 
      Hcsosup = Xsosup*(1.0d0 - g)
      Hcsosdn = Xsosdn*(1.0d0 - g)
c     ** vc formula for gradient dependent functional,
c     Generalized form of Eq. (24) in PRB 33, 8800 (1986) 
      vcup = 
     & (eclda-vcuplda)*ndn/ntot*(Hcup-Hcdn-sup**2.*Hcsosup)
     & +(eclda-vcdnlda)*nup/ntot*(sup**2.*Hcsosup)*dudotdd/dup**two
      vcdn = 
     & (eclda-vcdnlda)*nup/ntot*(Hcdn-Hcup-sdn**2.*Hcsosdn)
     & +(eclda-vcuplda)*ndn/ntot*(sdn**2.*Hcsosdn)*dudotdd/ddn**two
c     ** correlation stress term      
      decsup = eclda*(Hcsosup)
      decsdn = eclda*(Hcsosdn)
      return
      end
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTCGGA
c
c
      subroutine DFTCGGA( rhup, grho,g2rho,gpggp, vxcup,excup,
     $                    rhdn, grhup,grhdn,g2rhup, vxcdn,excdn,
     $                    dcgrho, dcgrhup, dcgrhdn,
     $                    dcg2rhup, dcg2rhdn )
c---------------------------------------------------------------
c Purpose: compute spin-polarized gga correlation potential
c
c Written: Peter A. Schultz, 10-August-2001, for v2.49 (spin)
c
c Revision history:
c  13Nov12-JEM/2.65: HSE added, piggybacked on PBE
C  17Spt08-RJM/2.62: added call to am05 spin  
c   8Oct03-AEM/2.57: 5 stress arguments added
c   8Oct03-AEM/2.57: argument deleted in DF_PW91C and DF_PBEC
c   7Oct03-AEM/2.57: added 5 arguments to DF_LYP
c  26Jun03-AEM/2.56: added g2rhup as argument, needed for blypsp.
c   8Apr02-PAS/2.53: gga stress
c---------------------------------------------------------------
c
c Input quantities
c   rhup = up-electron density
c   grho  = | GRAD[rho] |
c   g2rho = GRAD**2[rho]
c   gpggp = GRAD[rho] DOT GRAD[ | GRAD[rho] | ]
c   rhdn = dn-electron density
c   grhup = | GRAD[rhup] |
c   grhdn = | GRAD[rhdn] |
c   g2rhup = GRAD**2[rhup]
c Output quantities [up/dn]:
c   vxc = xc-potential (in rydbergs)
c   exc = xc energy density
c   dcgrho = stress term due to gradients (grho)
c   dcgrhup = stress term due to gradients up (grhup)
c   dcgrhdn = stress term due to gradients down (grhdn)
c   dcg2rhup = stress term due to laplacian up (g2rhup)
c   dcg2rhdn = stress term due to laplacian down (g2rhdn)
c
c Note:
c  Have to convert to Rydbergs for the GGA functionals
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Set parameters needed to construct various terms:
      PARAMETER  ( zero = 0.d0, one = 1.d0, two = 2.d0 )
      PARAMETER  ( third = 1.d0/3.d0, fourthrd = 4.d0/3.d0 )
c
      PARAMETER  ( xcrhocut = 1.d-21 )
c

      REAL*8  decsup,decsdn,decsupr,decsdnr
      REAL*8  twokfup,twokfdn

      COMMON  /DFTTYPS/ i_fcnal, i_gga,i_spin,
     $ i_capz,i_pw91,i_pbe,i_blyp,i_am05,i_hse,i_hse2
c
c >>>> EXECUTABLE CODE:
c
      rho = rhup + rhdn
      if( rho .lt. xcrhocut )then
        excup = zero
        vxcup = zero
        excdn = zero
        vxcdn = zero
        RETURN
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c           Need to assemble inputs to gga routines:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c     Relative spin polarization
      if( rhdn .gt. zero )then
        zet = ( rhup - rhdn ) / rho
      else
        zet = one
      endif
c
      call DF_GGA0( rho, grho,g2rho,gpggp,  zet, grhup,grhdn,
     $ g, rs, twokf,twoksg, s,u,v, t,uu,vv, ww )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                      Flavors of DFT:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c Output quantities:
c  vxc = total xc potential (Rydberg units)
c  exc = total xc energy density (Rydberg units)
c Intermediate quantities:
c  ex    = exchange energy
c  vx    = exchange potential
c  ec    = lsd correlation energy
c  vcup  = lsd up correlation potential
c  vcdn  = lsd down correlation potential
c  h     = gradient correction to correlation energy
c  dvcup = gradient correction to up correlation potential
c  dvcdn = gradient correction to down correlation potential
c  ecrs  = d(ec)/d(rs)
c  eczet = d(ec)/d(zet)
c  zlfc  = "spin stiffness"
c
      if( i_fcnal .eq. i_pw91 )then
c
c       >>>>>>>>> PW91/GGA <<<<<<<<<
c
        call DF_LSDC( rs,zet,ec,vcup,vcdn,ecrs,eczet,zlfc )
        call DF_PW91C( rs,zet,g,ec,ecrs,eczet,t,uu,vv,ww,
     $   h,dvcup,dvcdn, dht )
c
        vxcup = vcup + dvcup
        vxcdn = vcdn + dvcdn
        exc = ec + h
c
c       Gradient terms for stress calculation:
        dht  = dht  * ( rho / twoksg**2 )
        dcgrho = dht
        dcgrhup = zero
        dcgrhdn = zero
        dcg2rhup = zero
        dcg2rhdn = zero
c
c       Convert to Rydberg units:
        vxcup = two*vxcup
        vxcdn = two*vxcdn
        excup = two*exc
        excdn = two*exc
        dcgrho = two*dcgrho
c
      elseif( i_fcnal .eq. i_pbe .or. i_fcnal .eq. i_hse
     $         .or. i_fcnal .eq. i_hse2 )then
c
c       >>>>>>>>> PBE/GGA <<<<<<<<<
c
c       lgga: 0=local exchange; 1=gga exchange
c       lpot: 0=only energy;    1=potential, too.
        lgga = 1
        lpot = 1
        call DF_PBEC( rs,zet,t,uu,vv,ww,lgga,lpot, ec,vcup,vcdn,
     $   h,dvcup,dvcdn, dht )
c
        vxcup = vcup + dvcup
        vxcdn = vcdn + dvcdn
        exc = ec + h
c
c       Gradient terms for stress calculation:
        dht  = dht  * ( rho / twoksg**2 )
        dcgrho = dht
        dcgrhup = zero
        dcgrhdn = zero
        dcg2rhup = zero
        dcg2rhdn = zero
c
c       Convert to Rydberg units:
        vxcup = two*vxcup
        vxcdn = two*vxcdn
        excup = two*exc
        excdn = two*exc
        dcgrho = two*dcgrho
c
      elseif( i_fcnal .eq. i_blyp )then
c
c       >>>>>>>>> BLYP/GGA <<<<<<<<<
c
        g2rhdn = g2rho - g2rhup
        call DF_LYP( rhup, rhdn, grho, grhup, grhdn, g2rhup, g2rhdn,
     $                 ec, vcup, vcdn, dcgrho, dcgrhup, dcgrhdn,
     $                 dcg2rhup, dcg2rhdn )
c
c       Convert to Rydberg units:
        vxcup = two*vcup
        vxcdn = two*vcdn
        excup = two*ec
        excdn = two*ec
        dcgrho = two*dcgrho
        dcgrhup = two*dcgrhup
        dcgrhdn = two*dcgrhdn
        dcg2rhup = two*dcg2rhup
        dcg2rhdn = two*dcg2rhdn
c

      elseif( i_fcnal .eq. i_am05 )then
c
c       >>>>>>>>>AM05/GGA <<<<<<<<<
c
        call DF_AM05s2( rhup, rhdn,grhup,grhdn,grho,ec,
     &                  vcup,vcdn,decsup,decsdn)
c       Gradient terms for stress calculation:
        twokfup=twokf*(two*rhup/(rhup+rhdn))**fourthrd
        twokfdn=twokf*(two*rhdn/(rhup+rhdn))**fourthrd
c
        decsup = decsup * two*( two*rhup / twokfup**two )
        decsdn = decsdn * two*( two*rhdn / twokfdn**two )
c
        dcgrho = zero
        dcgrhup = decsup
        dcgrhdn = decsdn
        dcg2rhup = zero
        dcg2rhdn = zero
c       Convert to Rydberg units:
        vxcup = two*vcup
        vxcdn = two*vcdn
        excup = two*ec
        excdn = two*ec
        dcgrhup = two*dcgrhup
        dcgrhdn = two*dcgrhdn
c
      else
c
c       >>>>>>>>> ERROR <<<<<<<<<
c
        call STOPXERR( 'gga-type/unknown gga type 1' )
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTGET
c
c
c---------------------------------------------------------------
c Purpose: access information about the nature of the dft
c
c Written: Peter A. Schultz, 7-August-2001, for v2.49 (spin)
c          based on a suggestion by Richard P. Muller (Caltech)
c
c Revision history:
c  13Nov12-JEM/2.65: HSE flags added
c  24May06-AEM/2.60: AM05 added
c  11Jun03-PAS/2.55: add query about Laplacian
c   7Aug01-PAS/2.49: adapted from implied Muller routines
c---------------------------------------------------------------
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTGETGGA
c
c
      subroutine DFTGETGGA( do_gga )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /DFTTYPS/ i_fcnal, i_gga,i_spin,
     $ i_capz,i_pw91,i_pbe,i_blyp,i_am05,i_hse,i_hse2
c
c output declaration:
      LOGICAL  do_gga, do_spin, do_lap
      CHARACTER*6  fcnal
c
c >>>> EXECUTABLE CODE:
c
      if( i_gga .eq. 0 )then
        do_gga = .false.
      elseif( i_gga .eq. 1 )then
        do_gga = .true.
      else
        call STOPXERR( 'dftget - bad record of gga' )
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTGETLAP
c
c
      entry DFTGETLAP( do_lap )
c
      do_lap = .false.
c Right now, the only laplacian-based functional is BLYP:
      if( i_fcnal .eq. i_blyp )then
        do_lap = .true.
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTGETSPIN
c
c
      entry DFTGETSPIN( do_spin )
c
      if( i_spin .eq. 0 )then
        do_spin = .false.
      elseif( i_spin .eq. 1 )then
        do_spin = .true.
      else
        call STOPXERR( 'dftget - bad record of spin' )
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTGETTYP
c
c
      entry DFTGETTYP( fcnal )
c
      if( i_fcnal .eq. 0 )then
c
        fcnal = 'NONE  '
c
      elseif( i_fcnal .eq. i_capz )then
c
        if( i_spin .eq. 0 )then
          fcnal = 'CAPZ  '
        else
          fcnal = 'CAPZSP'
        endif
c
      elseif( i_fcnal .eq. i_pw91 )then
c
        if( i_spin .eq. 0 )then
          fcnal = 'PW91  '
        else
          fcnal = 'PW91SP'
        endif
c
      elseif( i_fcnal .eq. i_pbe )then
c
        if( i_spin .eq. 0 )then
          fcnal = 'PBE   '
        else
          fcnal = 'PBE-SP'
        endif
c
      elseif( i_fcnal .eq. i_blyp )then
c
        if( i_spin .eq. 0 )then
          fcnal = 'BLYP  '
        else
          fcnal = 'BLYPSP'
        endif
c
      elseif( i_fcnal .eq. i_am05 )then
c
        if( i_spin .eq. 0 )then
          fcnal = 'AM05  '
        else
          fcnal = 'AM05SP'      
        endif  
c
      elseif( i_fcnal .eq. i_hse )then
c
        if( i_spin .eq. 0 )then
          fcnal = 'HSE   '
        else
          fcnal = 'HSE-SP'      
        endif  
c
      elseif( i_fcnal .eq. i_hse2 )then
c
        if( i_spin .eq. 0 )then
          fcnal = 'HSE2  '
        else
          fcnal = 'HSE2SP'      
        endif  
c
      else
c
        fcnal = 'UNKNOW'
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTGGA
c
c
      subroutine DFTGGA( rho, grho,g2rho,gpggp, vxc,exc, dexc,dexc2 )
c---------------------------------------------------------------
c Purpose: compute gga potentials of selected functional flavor
c          ***** spin-unpolarized version *****
c
c Written: Peter A. Schultz, Dec-2000, for v2.46 (gga)
c
c Revision history:
c  13Nov12-JEM/2.65: HSE added
c  24May06-AEM/2.60: AM05 added
c  14Oct03-AEM/2.57: LYP stress term corrected
c   8Oct03-AEM/2.57: argument deleted in DF_PW91C and DF_PBEC
c   7Oct03-AEM/2.56: Spin lyp used instead of non-spin lyp
c  13Jun03-AEM/2.55: dexc2 stress term due to Laplacians added
c  11Jun03-AEM/2.55: blyp added (with stress)
c   3Apr02-PAS/2.53: gga stress
c   7Aug01-PAS/2.49: spin-polarization
c  21Jun01-PAS/2.48: replace STOPs
c---------------------------------------------------------------
c
c Input quantities
c   rho   = electron number density
c   grho  = | GRAD[rho] |
c   g2rho = GRAD**2[rho]
c   gpggp = GRAD[rho] DOT GRAD[ | GRAD[rho] | ]
c Output quantities:
c   vxc = xc-potential in rydbergs
c   exc = xc energy density
c   dexc = ( d[exc*rho] / d[ d[rho]/d[x_i] ] ) / d[rho]/d[x_i]
c        = term needed for stress calculation in gga.
c   dexc2 = 2 * d[exc*rho] / d[ grad**2[rho] ]
c Note:
c  Must convert functionals to Rydbergs
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Set parameters needed to construct various terms:
      PARAMETER  ( zero = 0.d0, one = 1.d0, two = 2.d0 )
c
      PARAMETER  ( xcrhocut = 1.d-21 )
c
      COMMON  /DFTTYPS/ i_fcnal, i_gga,i_spin,
     $ i_capz,i_pw91,i_pbe,i_blyp,i_am05,i_hse,i_hse2
c
c >>>> EXECUTABLE CODE:
c
      if( rho .lt. xcrhocut )then
        exc = zero
        vxc = zero
        dexc = zero
        dexc2 = zero
        RETURN
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c           Need to assemble inputs to gga routines:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c No spin polarization (zet=0), and up/dn gradients are half of total
      zet = zero
      grhup = grho/two
      grhdn = grho/two
c
c LYP uses grho, grhup, grhdn, and g2rho as inparameters.
c Please never change them!
c
      call DF_GGA0( rho, grho,g2rho,gpggp,  zet, grhup,grhdn,
     $ g, rs, twokf,twoksg, s,u,v, t,uu,vv, ww )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                      Flavors of DFT:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c Output quantities:
c  vxc = total xc potential (Rydberg units)
c  exc = total xc energy density (Rydberg units)
c Intermediate quantities:
c  ex    = exchange energy
c  vx    = exchange potential
c  ec    = lsd correlation energy
c  vcup  = lsd up correlation potential
c  vcdn  = lsd down correlation potential
c  h     = gradient correction to correlation energy
c  dvcup = gradient correction to up correlation potential
c  dvcdn = gradient correction to down correlation potential
c  ecrs  = d(ec)/d(rs)
c  eczet = d(ec)/d(zet)
c  zlfc  = "spin stiffness"
c
      if( i_fcnal .eq. i_capz )then
c
c       >>>>>>>>> CAPZ/LDA <<<<<<<<<
c
c       Ceperley/Alder parameterized by Perdew/Zunger
c       D.M. Ceperley and B.J. Alder, PRL 45, 566 (1980).
c       J. Perdew and A. Zunger,  PRB 23, 5048 (1981).
c
        call DFTLDA( rho, vxc,exc )
c
      elseif( i_fcnal .eq. i_pw91 )then
c
c       >>>>>>>>> PW91/GGA <<<<<<<<<
c
        call DF_PW91X( rho, s,u,v, ex,vx, dexs )
        call DF_LSDC( rs,zet,ec,vcup,vcdn,ecrs,eczet,zlfc )
        call DF_PW91C( rs,zet,g,ec,ecrs,eczet,t,uu,vv,ww,
     $   h,dvcup,dvcdn, dht )
c
        vxc = vx + ( vcup + vcdn + dvcup + dvcdn ) / two
        exc = ex + ec + h
c
c       Gradient terms for stress calculation:
        dexs = dexs * ( rho / twokf**2 )
        dht  = dht  * ( rho / twoksg**2 )
        dexc = dexs + dht
        dexc2 = zero
c
c       Convert to Rydberg units:
        vxc = two*vxc
        exc = two*exc
        dexc = two*dexc
c
      elseif( i_fcnal .eq. i_pbe )then
c
c       >>>>>>>>> PBE/GGA <<<<<<<<<
c
c       lgga: 0=local exchange; 1=gga exchange
c       lpot: 0=only energy;    1=potential, too.
        lgga = 1
        lpot = 1
        call DF_PBEX( rho, s,u,v, lgga,lpot, ex,vx, dexs )
        call DF_PBEC( rs,zet,t,uu,vv,ww,lgga,lpot, ec,vcup,vcdn,
     $   h,dvcup,dvcdn, dht )
c
        vxc = vx + ( vcup + vcdn + dvcup + dvcdn ) / two
        exc = ex + ec + h
c
c       Gradient terms for stress calculation:
        dexs = dexs * ( rho / twokf**2 )
        dht  = dht  * ( rho / twoksg**2 )
        dexc = dexs + dht
        dexc2 = zero
c
c       Convert to Rydberg units:
        vxc = two*vxc
        exc = two*exc
        dexc = two*dexc
c
      elseif( i_fcnal .eq. i_blyp )then
c
c       >>>>>>>>> BLYP/GGA <<<<<<<<<
c
        call DF_B1X( rho, s, u, v, ex, vx, dexs )
c
c
c       Note: LYP use the bare gradient and laplacians, grho and g2rho.
c       It also gives the full correlation out in ec, in contrast
c       to other correlation functionals.
c
        rhup = rho / two
        rhdn = rho / two
        g2rhup = g2rho / two
        g2rhdn = g2rho / two
        call DF_LYP( rhup, rhdn, grho, grhup, grhdn, g2rhup, g2rhdn,
     $                 ec, vcup, vcdn, dcgrho, dcgrhup, dcgrhdn,
     $                 dcg2rhup, dcg2rhdn )
c
c
        vxc = vx + ( vcup + vcdn ) / two
        exc = ex + ec
c
c       Gradient terms for stress calculation:
        dexs = dexs * ( rho / twokf**2 )
        dexc = dexs + dcgrho + ( dcgrhup + dcgrhdn ) / ( two*two )
        dexc2 = ( dcg2rhup + dcg2rhdn ) / two
c
c       Convert to Rydberg units:
        vxc = two*vxc
        exc = two*exc
        dexc = two*dexc
        dexc2 = two*dexc2
c
      elseif( i_fcnal .eq. i_am05 )then 
c
c       >>>>>>>>> AM05 <<<<<<<<<
c
        call DF_AM05( rho, s, u, v, ex, ec, vx, vc, dexs, decs )
c
c
c       Note: Implemented without separate exchange
c       and correlation. Only spinless am05
c       available yet, thus I use vc, not vcup and vcdn.
c
        vxc = vx + vc
        exc = ex + ec
        dexc = ( dexs + decs ) * ( rho / twokf**2 )
        dexc2 = zero
c        
c       Convert to Rydberg units:
        vxc = two*vxc
        exc = two*exc
        dexc = two*dexc
c
      elseif( i_fcnal .eq. i_hse )then
c
c       >>>>>>>>> HSE/GGA <<<<<<<<<
c
c       NOTE: HSE06 parameters, omega=0.11, fraction=0.25
c       lgga: 0=local exchange; 1=gga exchange
c       lpot: 0=only energy;    1=potential, too.
        lgga = 1
        lpot = 1
        call DF_HSEX(rho,s,u,v,0.11d0,ex,vx,dexs)
        call DF_PBEC( rs,zet,t,uu,vv,ww,lgga,lpot, ec,vcup,vcdn,
     $   h,dvcup,dvcdn, dht )
        ex = ex * 0.25d0
        vx = vx * 0.25d0
        dexs = dexs * 0.25d0
c
        vxc = vx + ( vcup + vcdn + dvcup + dvcdn ) / two
        exc = ex + ec + h
c
c       Gradient terms for stress calculation:
        dexs = dexs * ( rho / twokf**2 )
        dht  = dht  * ( rho / twoksg**2 )
        dexc = dexs + dht
        dexc2 = zero
c
c       Convert to Rydberg units:
        vxc = two*vxc
        exc = two*exc
        dexc = two*dexc
c
      elseif( i_fcnal .eq. i_hse2 )then
c
c       >>>>>>>>> HSE/GGA <<<<<<<<<
c
c       NOTE: HSE12 parameters, omega=0.098, fraction=0.313
c       lgga: 0=local exchange; 1=gga exchange
c       lpot: 0=only energy;    1=potential, too.
        lgga = 1
        lpot = 1
        call DF_HSEX(rho,s,u,v,0.098d0,ex,vx,dexs)
        call DF_PBEC( rs,zet,t,uu,vv,ww,lgga,lpot, ec,vcup,vcdn,
     $   h,dvcup,dvcdn, dht )
        ex = ex * 0.313d0
        vx = vx * 0.313d0
        dexs = dexs * 0.313d0
c
        vxc = vx + ( vcup + vcdn + dvcup + dvcdn ) / two
        exc = ex + ec + h
c
c       Gradient terms for stress calculation:
        dexs = dexs * ( rho / twokf**2 )
        dht  = dht  * ( rho / twoksg**2 )
        dexc = dexs + dht
        dexc2 = zero
c
c       Convert to Rydberg units:
        vxc = two*vxc
        exc = two*exc
        dexc = two*dexc
c
      else
c
c       >>>>>>>>> ERROR <<<<<<<<<
c
        call STOPXERR( 'gga-type/unknown gga type' )
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTLDA
c
c
      subroutine DFTLDA( rho, vxc,exc )
c---------------------------------------------------------------
c Purpose: compute lda xc-potentials
c
c Written: Peter A. Schultz, Dec-2000, for v2.46 (gga)
c
c Revision history:
c  23Jun15-PAS/2.67: fix dfttyps declare
c   7Mar02-PAS/2.52: all explicit constants to d0
c   7Aug01-PAS/2.49: spin-polarization, and mimic PZ formulas
c  21Jun01-PAS/2.48: replace STOPs
c  19Dec00-PAS/2.46: to accomodate gga, renamed to "dftlda"
c---------------------------------------------------------------
c
c Input quantity:
c   rho = total electron number density
c Output quantities:
c   vxc = xc-potential (in rydbergs)
c   exc = xc energy density
c
c Notes:
c   For CAPZ = Perdew/Zunger param of Ceperley/Alder:
c   Potential not fully consistent with pseudo-potential generator.
c   Most notably, relativistic factors are NOT in the pseudopotential.
c   Otherwise minor numerics (it works out, trust me).  5Aug94-PAS
c
c   Fixed constants for vxc to at least 8 digits, noting that
c     vxc = exc - (rs/3)*(d[exc]/d[rs]) - 9Dec94-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0, one = 1.d0, two = 2.d0 )
      PARAMETER  ( third = 0.3333333333333333 d0 )
c  volfac=3/(4*pi)
      PARAMETER  ( volfac = 0.23873241463784 d0 )
      PARAMETER  ( xcrhocut = 1.d-21 )
c
      COMMON  /DFTTYPS/ i_fcnal, i_gga,i_spin,
     $ i_capz,i_pw91,i_pbe,i_blyp,i_am05,i_hse,i_hse2
c
c >>>> EXECUTABLE CODE:
c
      if( rho .lt. xcrhocut )then
        exc = zero
        vxc = zero
        RETURN
      endif
c
c Flavors of LDA (only one right now):
c
      if( i_fcnal .eq. i_capz )then
c
c       CAPZ: Ceperley/Alder, parameterized by Perdew/Zunger:
c       Phys. Rev. B 23, 5048 (1981)
c
        rs = (volfac/rho)**third
c
crelativistics turned on:
        beta = 0.014d0 / rs
        rtb = SQRT( one + beta**2 )
        blog = LOG( beta + rtb )
        vrelfac = -one/two + 1.5d0*blog/(beta*rtb)
        erelfac = one - 1.5d0*((beta*rtb-blog)/beta**2)**2
c
crelativistics turned off:
crel        vrelfac = -one/two
crel        erelfac = one
c
c       Compute exchange part:
        Ex  =  -0.4582d0*erelfac/rs
        Vx  =  -0.61093333d0*vrelfac/rs
c
c       Compute correlation part:
        if( rs.lt.one )then
          rslog = LOG( rs )
          Ec  = 0.0311d0*rslog - 0.0480d0
     $        + 0.0020d0*rs*rslog       - 0.0116d0*rs
          Vc  = 0.0311d0*rslog - 0.058366665d0
     $        + 0.0013333333d0*rs*rslog - 0.0084d0*rs
        else
          rtrs = SQRT( rs )
          denom = 1.d0 + 1.0529d0*rtrs + 0.3334d0*rs
          Ec  = -0.1423d0 / denom
          Vc  = Ec *(1.d0+1.22838333d0*rtrs+0.44453333d0*rs) / denom
        endif
c
        exc = Ex + Ec
c
        vxc = Vx + Vc
c
c       End CAPZ potential
c
      else
c
        call STOPXERR( 'lda-type unknown' )
c
      endif
c
c Convert to Rydberg:
      exc = two*exc
      vxc = two*vxc
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTSET
c
c
      subroutine DFTSET( dftlbl )
c---------------------------------------------------------------
c Purpose: set up for flags for dft of particular flavor
c
c Written: Peter A. Schultz, December-2000, for v2.46 (gga)
c
c Revision history:
c  13Nov12-JEM/2.65: HSE added
C  17Spt08-RJM/2.62: added AM05 spin 
c  24May06-AEM/2.60: AM05 added      
c  25Jun03-AEM/2.56: BLYPSP added
c  10Jun03-AEM/2.55: BLYP added
c   7Aug01-PAS/2.49: spin-polarized dft
c  21Jun01-PAS/2.48: replace STOPs, writes
c  25Mar01-PAS/2.46a: make gga default be PBE
c---------------------------------------------------------------
c
c  Set i_fcnal (communicated via common) for a given dftlbl,
c  and set whether gga/spin with i_gga/i_spin
c
c  Default lda is capz=ceperley/alder param'd by perdew/zunger
c  Default gga is pbe
c
c  To add new functionals, extend COMMON/DFTTYPS/ with new
c  i_{labels}, add new unique integer values below, add
c  check for label in if-block here, and add code in
c  routines "dft*gga"/"dft*lda" for new gga/lda functionals.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /DFTTYPS/ i_fcnal, i_gga,i_spin,
     $ i_capz,i_pw91,i_pbe,i_blyp,i_am05,i_hse,i_hse2
c
c input declarations:
      CHARACTER*(*)  dftlbl
c local declarations:
      CHARACTER*6  fcnal
c
c >>>> EXECUTABLE CODE:
c
c The following are fcnal id tags.  They must be distinct
c from one another.
      i_capz = 1
      i_pw91 = 2
      i_pbe  = 3
      i_blyp = 4
      i_am05 = 5
      i_hse  = 6
      i_hse2 = 7
c      i_newdft = 6 i.e. extend existing sequence
c
c Now go looking for a matching fcnal:
c
      fcnal = dftlbl(1:6)
c
      if(     fcnal .eq. 'capz  ' .or. fcnal .eq. 'CAPZ  '
     $   .or. fcnal .eq. 'lda   ' .or. fcnal .eq. 'LDA   ' )then
c
        i_fcnal = i_capz
        i_gga = 0
        i_spin = 0
c
      elseif( fcnal .eq. 'capzsp' .or. fcnal .eq. 'CAPZSP'
     $   .or. fcnal .eq. 'lsd   ' .or. fcnal .eq. 'LSD   '
     $   .or. fcnal .eq. 'lda-sp' .or. fcnal .eq. 'LDA-SP' )then
c
        i_fcnal = i_capz
        i_gga = 0
        i_spin = 1
c
      elseif( fcnal .eq. 'pw91  ' .or. fcnal .eq. 'PW91  ' )then
c
        i_fcnal = i_pw91
        i_gga = 1
        i_spin = 0
c
      elseif( fcnal .eq. 'pw91sp' .or. fcnal .eq. 'PW91SP' )then
c
        i_fcnal = i_pw91
        i_gga = 1
        i_spin = 1
c
      elseif( fcnal .eq. 'pbe   ' .or. fcnal .eq. 'PBE   '
     $   .or. fcnal .eq. 'gga   ' .or. fcnal .eq. 'GGA   ' )then
c
        i_fcnal = i_pbe
        i_gga = 1
        i_spin = 0
c
      elseif( fcnal .eq. 'pbe-sp' .or. fcnal .eq. 'PBE-SP'
     $   .or. fcnal .eq. 'gga-sp' .or. fcnal .eq. 'GGA-SP' )then
c
        i_fcnal = i_pbe
        i_gga = 1
        i_spin = 1
c
      elseif( fcnal .eq. 'blyp  ' .or. fcnal .eq. 'BLYP  ' )then
c
        i_fcnal = i_blyp
        i_gga = 1
        i_spin = 0
c
      elseif( fcnal .eq. 'blypsp' .or. fcnal .eq. 'BLYPSP' )then
c
        i_fcnal = i_blyp
        i_gga = 1
        i_spin = 1
c
      elseif( fcnal .eq. 'am05  ' .or. fcnal .eq. 'AM05  ' )then
c
        i_fcnal = i_am05
        i_gga = 1
        i_spin = 0
c
      elseif( fcnal .eq. 'am05sp' .or.  fcnal .eq. 'AM05SP' )then
c
        i_fcnal = i_am05
        i_gga = 1
        i_spin = 1
c
      elseif( fcnal .eq. 'hse   ' .or. fcnal .eq. 'HSE   ' )then
c
        i_fcnal = i_hse
        i_gga = 1
        i_spin = 0
c
      elseif( fcnal .eq. 'hse-sp' .or. fcnal .eq. 'HSE-SP' )then
c
        i_fcnal = i_hse
        i_gga = 1
        i_spin = 1
c
      elseif( fcnal .eq. 'hse2  ' .or. fcnal .eq. 'HSE2  ' )then
c
        i_fcnal = i_hse2
        i_gga = 1
        i_spin = 0
c
      elseif( fcnal .eq. 'hse2sp' .or. fcnal .eq. 'HSE2SP' )then
c
        i_fcnal = i_hse2
        i_gga = 1
        i_spin = 1
c
      else
c
        call STOPXERR( 'no fcnal/this dft flavor not available' )
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTSLDA
c
c
      subroutine DFTSLDA( rhup, vxcup,excup, rhdn, vxcdn,excdn )
c---------------------------------------------------------------
c Purpose: compute spin-polarized lda xc-potentials
c
c Written: Peter A. Schultz, 7-August-2001, for v2.49 (spin)
c
c Revision history:
c  23Jun15-PAS/2.67: fix dfttyps declare
c   7Mar02-PAS/2.52: all explicit constants to d0
c---------------------------------------------------------------
c
c Input quantities:
c   rh[up/dn] = [up/dn]-spin electron number density
c Output quantities:
c   vxc = xc-potential (in rydbergs)
c   exc = xc energy density
c
c Notes:
c   For CAPZ = Perdew/Zunger param of Ceperley/Alder:
c   Potential not fully consistent with pseudo-potential generator.
c   Most notably, relativistic factors are NOT in the pseudopotential.
c   Otherwise minor numerics (it works out, trust me).  5Aug94-PAS
c
c   Fixed constants for vxc to at least 8 digits, noting that
c     vxc = exc - (rs/3)*(d[exc]/d[rs]) - 9Dec94-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0, one = 1.d0, two = 2.d0 )
      PARAMETER  ( third = 0.3333333333333333 d0 )
      PARAMETER  ( r4d3  = 1.333333333333333 d0 )
c  volfac=3/(4*pi)
      PARAMETER  ( volfac = 0.23873241463784 d0 )
      PARAMETER  ( xcrhocut = 1.d-21 )
c
      COMMON  /DFTTYPS/ i_fcnal, i_gga,i_spin,
     $ i_capz,i_pw91,i_pbe,i_blyp,i_am05,i_hse,i_hse2
c
c >>>> EXECUTABLE CODE:
c
      rho = rhup + rhdn
      if( rho .lt. xcrhocut )then
        excup = zero
        vxcup = zero
        excdn = zero
        vxcdn = zero
        RETURN
      endif
c
c zet = relative spin polarization
c fzet = spin interpolation factor (PZ's, from von Barth/Hedin)
c dfzet = d(fzet)/d(zet)
c
      if( rhdn .ne. zero )then
        zet = ( rhup - rhdn ) / rho
        fzet = ( one + zet )**r4d3 + ( one - zet )**r4d3 - two
        fdenom = two**r4d3 - two
        fzet = fzet / fdenom
        dfzet = r4d3*( (one + zet)**third - (one - zet)**third )
        dfzet = dfzet / fdenom
      else
c       Get the hydrogen atom right
        zet = one
        fzet = one
        dfzet = two * third * ( one + one / ( two**third - one ) )
      endif
c
c Flavors of LDA (only one right now):
c
      if( i_fcnal .eq. i_capz )then
c
c       CAPZ: Ceperley/Alder, parameterized by Perdew/Zunger:
c       Phys. Rev. B 23, 5048 (1981)
c
        rs = (volfac/rho)**third
c
crelativistics turned on:
        beta = 0.014d0 / rs
        rtb = SQRT( one + beta**2 )
        blog = LOG( beta + rtb )
        vrelfac = -one/two + 1.5d0*blog/(beta*rtb)
        erelfac = one - 1.5d0*((beta*rtb-blog)/beta**2)**2
c
crelativistics turned off:
crel        vrelfac = one
crel        erelfac = one
c
c U/P=Unpolarized/Polarized limits
c
c       Compute exchange part:
        ExU =  -0.4582d0*erelfac/rs
        VxU =  -0.61093333d0*vrelfac/rs
        ExP =  ExU * two**third
        VxP =  VxU * two**third
c
c       Compute correlation part:
        if( rs.lt.one )then
          rslog = LOG( rs )
          EcU = 0.0311d0*rslog - 0.0480d0
     $        + 0.0020d0*rs*rslog       - 0.0116d0*rs
          VcU = 0.0311d0*rslog - 0.058366666d0
     $        + 0.0013333333d0*rs*rslog - 0.0084d0*rs
          EcP = 0.01555d0*rslog - 0.0269d0
     $        + 0.0007d0*rs*rslog       - 0.0048d0*rs
          VcP = 0.01555d0*rslog - 0.032083333d0
     $        + 0.0004666666d0*rs*rslog - 0.0034333333d0*rs
        else
          rtrs = SQRT( rs )
          denom = 1.d0 + 1.0529d0*rtrs + 0.3334d0*rs
          EcU = -0.1423d0 / denom
          VcU = EcU*(1.d0+1.22838333d0*rtrs+0.44453333d0*rs) / denom
          denom = 1.d0 + 1.3981d0*rtrs + 0.2611d0*rs
          EcP = -0.0843d0 / denom
          VcP = EcP*(1.d0+1.63111666d0*rtrs+0.34813333d0*rs) / denom
        endif
c
        ExcU = ExU + EcU
        ExcP = ExP + EcP
        Exc = ExcU + fzet * ( ExcP - ExcU )
        excup = Exc
        excdn = Exc
c
        VxcU = VxU + VcU
        VxcP = VxP + VcP
        Vxc0 = VxcU + fzet * ( VxcP - VxcU )
        Vxc1 = ( ExcP - ExcU )*dfzet
        facup =  one - zet
        facdn = -one - zet
        vxcup = Vxc0 + facup*Vxc1
        vxcdn = Vxc0 + facdn*Vxc1
c
c       End CAPZ potential
c
      else
c
        call STOPXERR( 'lda-type unknown' )
c
      endif
c
c Convert to Rydberg:
      excup = two*excup
      vxcup = two*vxcup
      excdn = two*excdn
      vxcdn = two*vxcdn
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTSTR2
c
c
      subroutine DFTSTR2( idrhfl0,idrhofl,idrhsfl,
     $ ndim, strlap, nptr,weight,
     $ dxc2, ddrho0,dddrho )
c---------------------------------------------------------------
c Purpose: compute, on grid, integrals needed for non-spin gga
c          stress calculation from 2nd derivatives.
c
c Written: Peter A. Schultz, 11-June-2003, for 2.55 (BLYP)
c
c Revision history:
c  10Oct03-PAS/2.57: accommodate spin-dependent stress for GGA
c---------------------------------------------------------------
c
c Notes:
c   Evaluate the grid integral for non-spin GGA stress evaulation
c   coming from the Laplacian term (e.g. BLYP):
c
c     stress(i,j) = INT( dxc2(r) * d2_rh(r)/(dx_i*dx_j) )
c
c  On disk(s) we have all first and second derivatives of rho:
c    d/dx,d/dy,d/dz
c    d2/dxdx, d2/dydy, d2/dzdz, d2/dxdy, d2/dydz, d2/dzdx
c
c Variables:
c    idrhfl0 - file with derivatives from reference density
c    idrhofl - file with derivatives from delta (scf) density
c    nptr    - size of grid field
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0 )
c
c Input declarations:
      DIMENSION  dxc2(nptr)
c Output stuff:
      DIMENSION  strlap(3,3)
c Scratch:
      DIMENSION  ddrho0(nptr), ddrho(nptr)
c
c >>>> EXECUTABLE CODE:
c
      if( ndim .eq. 0 ) RETURN
c
c  Diagonal terms
c
      do  iu=1,3
        if( iu .le. ndim )then
c         Retrieve double (XX,YY,ZZ) derivs of reference ...
          call READBIG( idrhfl0, nptr, ddrho0 )
c          ... and scf delta-density
          call READBIG( idrhofl, nptr, ddrho )
c          ... combine
          do  nr=1,nptr
            ddrho(nr) = ddrho(nr) + ddrho0(nr)
          enddo
c          ... and evaluate integral
          strii = zero
          do  nr=1,nptr
            strii = strii + dxc2(nr)*ddrho(nr)
          enddo
          strlap(iu,iu) = weight*strii
        else
c         Skip thru to position files at beginning of off-diags
          call READSKP( idrhfl0, nptr )
          call READSKP( idrhofl, nptr )
        endif
      enddo
c
c  Off-diagonal terms
c
      do  iu=1,3
        iv = iu + 1
        if( iv .eq. 4 ) iv = 1
        if( MAX(iu,iv) .le. ndim )then
c         Retrieve 2nd (XY,YZ,ZX) derivs of reference ...
          call READBIG( idrhfl0, nptr, ddrho0 )
c          ... and scf delta-density
          call READBIG( idrhofl, nptr, ddrho )
c          ... combine
          do  nr=1,nptr
            ddrho(nr) = ddrho(nr) + ddrho0(nr)
          enddo
c          ... and evaluate integral
          strij = zero
          do  nr=1,nptr
            strij = strij + dxc2(nr)*ddrho(nr)
          enddo
          strlap(iu,iv) = weight*strij
          strlap(iv,iu) = weight*strij
C        else
C          call READSKP( idrhfl0, nptr )
C          call READSKP( idrhofl, nptr )
        endif
      enddo
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTSTR2
c
c
      subroutine DFTSTR2SP( idrhfl0,idrhofl,idrhsfl,
     $     ndim, strlap, nptr,weight,
     $     dxc2up,  dxc2dn,   ddrho0,    ddrhoa,    ddrhob )
c---------------------------------------------------------------
c Purpose: compute, on grid, integrals needed for spin gga
c          stress calculation from 2nd derivatives.
c
c Written: Peter A. Schultz, 10-October-2003, for 2.57
c
c Revision history:
c  10Oct03-PAS/2.57: modeled off DFTSTR2
c---------------------------------------------------------------
c
c Notes:
c   Evaluate the grid integrals for spin-GGA stress evaluation
c   coming from the Laplacian term (e.g. BLYP):
c
c     stress(i,j) = INT( dxc2(r) * d2_rh(r)/(dx_i*dx_j) )
c
c  On disk(s) we have all first and second derivatives of rho:
c    d/dx,d/dy,d/dz
c    d2/dxdx, d2/dydy, d2/dzdz, d2/dxdy, d2/dydz, d2/dzdx
c
c Variables:
c    idrhfl0 - file with derivatives from reference density
c    idrhofl - file with derivatives from delta (scf) density
c    idrhsfl - file with derivatives from up-spin del-density
c    nptr    - size of grid field
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, half=0.5d0 )
c
c Input declarations:
      DIMENSION  dxc2up(nptr), dxc2dn(nptr)
c Output stuff:
      DIMENSION  strlap(3,3)
c Scratch:
      DIMENSION  ddrho0(nptr), ddrhoa(nptr), ddrhob(nptr)
c
c >>>> EXECUTABLE CODE:
c
      if( ndim .eq. 0 ) RETURN
c
c  Diagonal terms
c
      do  iu=1,3
        if( iu .le. ndim )then
c         Retrieve double (XX,YY,ZZ) derivs of reference ...
          call READBIG( idrhfl0, nptr, ddrho0 )
c          ... and scf delta-density
          call READBIG( idrhofl, nptr, ddrhob )
c          ... and spin-up del-density
          call READBIG( idrhsfl, nptr, ddrhoa )
c          ... construct dd-del-dn = dd-rho - dd-del-up
          do  nr=1,nptr
            ddrhob(nr) = ddrhob(nr) - ddrhoa(nr)
          enddo
c          ... construct dd-up&dn = dd-del-up&dn + dd-rho0/2
          do  nr=1,nptr
            ddrhoa(nr) = ddrhoa(nr) + half*ddrho0(nr)
            ddrhob(nr) = ddrhob(nr) + half*ddrho0(nr)
          enddo
c          ... and evaluate integrals
          striia = zero
          striib = zero
          do  nr=1,nptr
            striia = striia + dxc2up(nr)*ddrhoa(nr)
            striib = striib + dxc2dn(nr)*ddrhob(nr)
          enddo
          strlap(iu,iu) = weight * ( striia + striib )
        else
c         Skip thru to position files at beginning of off-diags
          call READSKP( idrhfl0, nptr )
          call READSKP( idrhofl, nptr )
          call READSKP( idrhsfl, nptr )
        endif
      enddo
c
c  Off-diagonal terms
c
      do  iu=1,3
        iv = iu + 1
        if( iv .eq. 4 ) iv = 1
        if( MAX(iu,iv) .le. ndim )then
c         Retrieve 2nd (XY,YZ,ZX) derivs of reference ...
          call READBIG( idrhfl0, nptr, ddrho0 )
c          ... and scf delta-density
          call READBIG( idrhofl, nptr, ddrhob )
c          ... and spin-up del-density
          call READBIG( idrhsfl, nptr, ddrhoa )
          do  nr=1,nptr
            ddrhob(nr) = ddrhob(nr) - ddrhoa(nr)
          enddo
          do  nr=1,nptr
            ddrhoa(nr) = ddrhoa(nr) + half*ddrho0(nr)
            ddrhob(nr) = ddrhob(nr) + half*ddrho0(nr)
          enddo
          strija = zero
          strijb = zero
          do  nr=1,nptr
            strija = strija + dxc2up(nr)*ddrhoa(nr)
            strijb = strijb + dxc2dn(nr)*ddrhob(nr)
          enddo
          strlap(iu,iv) = weight * ( strija + strijb )
          strlap(iv,iu) = weight * ( strija + strijb )
C        else
C          call READSKP( idrhfl0, nptr )
C          call READSKP( idrhofl, nptr )
C          call READSKP( idrhsfl, nptr )
        endif
      enddo
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTSTR
c
c
      subroutine DFTSTR( ndim, strdxc, nptr,weight,
     $ dxc, drho )
c---------------------------------------------------------------
c Purpose: evaluate grid integral for 1st derivative GGA stress
c
c Written: Peter A. Schultz, 5-April-2002, for v2.53 (gga stress)
c
c Revision history:
c  10Oct03-PAS/2.57: accomodate spin-dependent GGA stress
c---------------------------------------------------------------
c
c Notes:
c   Evaluate the grid integral for GGA stress evaulation:
c
c     stress(i,j) = INT( dxc(r) * drh[i](r) * drh[j](r) )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0 )
c
c Input declarations:
      DIMENSION  dxc(nptr)
      DIMENSION  drho(nptr,3)
c Output stuff:
      DIMENSION  strdxc(3,3)
c
c >>>> EXECUTABLE CODE:
c
c If molecule, no stress to evaluate
      if( ndim .eq. 0 ) RETURN
c
      do  jd=1,ndim
        do  id=1,jd
          strij = zero
          do  nr=1,nptr
            strij = strij + dxc(nr)*drho(nr,id)*drho(nr,jd)
          enddo
          strdxc(id,jd) = strdxc(id,jd) + weight*strij
        enddo
      enddo
c
c Load the flip side
      do  jd=2,ndim-1
        do  id=1,jd-1
          strdxc(jd,id) = strdxc(id,jd)
        enddo
      enddo
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DFTXGGA
c
c
      subroutine DFTXGGA( rho, rop,grho,g2rho,gpggp, vxr,exr, dexsr )
c---------------------------------------------------------------
c Purpose: compute spin-polarized gga exchange potentials
c
c Written: Peter A. Schultz, 10-August-2001, for v2.49 (spin)
c
c Revision history:
c  13Nov12-JEM/2.65: HSE added
c  17Spt08-RJM/2.62: added opp spin passing for AM05 spin stress 
c  14Oct03-AEM/2.57: stress terms doubled to give correct value
c   7Oct03-AEM/2.57: stress term added
c  25Jun03-AEM/2.55: blyp added
c   8Apr02-PAS/2.53: gga stress
c---------------------------------------------------------------
c
c Input quantities
c   rho   = total electron number density
c   grho  = | GRAD[rho] |
c   g2rho = GRAD**2[rho]
c   gpggp = GRAD[rho] DOT GRAD[ | GRAD[rho] | ]
c Output quantities
c   vxr = xc-potential (in rydbergs)
c   exr = xc energy density
c   dexs = stress term
c
c Note:
c  Have to convert to Rydbergs for the GGA functionals
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Set parameters needed to construct various terms:
      PARAMETER  ( zero = 0.d0, one = 1.d0, two = 2.d0 )
c
      PARAMETER  ( xcrhocut = 1.d-21 )
c
      COMMON  /DFTTYPS/ i_fcnal, i_gga,i_spin,
     $ i_capz,i_pw91,i_pbe,i_blyp,i_am05,i_hse,i_hse2
c
c >>>> EXECUTABLE CODE:
c
      if( rho .lt. xcrhocut )then
        exr = zero
        vxr = zero
        dexsr = zero
        RETURN
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c           Need to assemble inputs to gga routines:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      call DF_GGA0X( rho, grho,g2rho,gpggp, twokf, s,u,v )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                      Flavors of DFT:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if( i_fcnal .eq. i_pw91 )then
c
c       >>>>>>>>> PW91/GGA <<<<<<<<<
c
        call DF_PW91X( rho, s,u,v, ex,vx, dexs )
c
c       Gradient terms for stress calculation:
        dexs = dexs * ( rho / twokf**2 )
c       This only gives half the required term, so double dexs
        dexs = two*dexs
c
c       Convert to Rydberg units:
        vxr = two*vx
        exr = two*ex
        dexsr = two*dexs
c
      elseif( i_fcnal .eq. i_pbe )then
c
c       >>>>>>>>> PBE/GGA <<<<<<<<<
c
c       lgga: 0=local exchange; 1=gga exchange
c       lpot: 0=only energy;    1=potential, too.
        lgga = 1
        lpot = 1
        call DF_PBEX( rho, s,u,v, lgga,lpot, ex,vx, dexs )
c
c       Gradient terms for stress calculation:
        dexs = dexs * ( rho / twokf**2 )
c       This only gives half the required term, so double dexs
        dexs = two*dexs
c
c       Convert to Rydberg units:
        vxr = two*vx
        exr = two*ex
        dexsr = two*dexs
c
      elseif( i_fcnal .eq. i_blyp )then
c
c       >>>>>>>>> BLYP/GGA <<<<<<<<<
c
        call DF_B1X( rho, s, u, v, ex,vx, dexs )
c
c       Gradient terms for stress calculation:
        dexs = dexs * ( rho / twokf**2 )
c       This only gives half the required term, so double dexs
        dexs = two*dexs
c
c       Convert to Rydberg units:
        vxr = two*vx
        exr = two*ex
        dexsr = two*dexs
c
      elseif( i_fcnal .eq. i_am05 )then
c
c       >>>>>>>>>AM05/GGA <<<<<<<<<
c
c       Note: rho=2*spin a, rop=spin b
c
        call DF_AM05s1( rho, rop,s, u, v, ex,vx, dexs )
c
c       Gradient terms for stress calculation:
        dexs = dexs * ( rho / twokf**2 )
c       This only gives half the required term, so double dexs
        dexs = two*dexs
c       Convert to Rydberg units:
        vxr = two*vx
        exr = two*ex
        dexsr = two*dexs
c
      elseif( i_fcnal .eq. i_hse )then
c
c       >>>>>>>>> HSE/GGA <<<<<<<<<
c
c       NOTE: HSE06 parameters, omega=0.11, fraction=0.25
c
        call DF_HSEX(rho,s,u,v,0.11d0,ex,vx,dexs)
        ex = ex * 0.25d0
        vx = vx * 0.25d0
        dexs = dexs * 0.25d0
c
c       Gradient terms for stress calculation:
        dexs = dexs * ( rho / twokf**2 )
c       This only gives half the required term, so double dexs
        dexs = two*dexs
c
c       Convert to Rydberg units:
        vxr = two*vx
        exr = two*ex
        dexsr = two*dexs
c
      elseif( i_fcnal .eq. i_hse2 )then
c
c       >>>>>>>>> HSE/GGA <<<<<<<<<
c
c       NOTE: HSE12 parameters, omega=0.098, fraction=0.313
c
        call DF_HSEX(rho,s,u,v,0.098d0,ex,vx,dexs)
        ex = ex * 0.313d0
        vx = vx * 0.313d0
        dexs = dexs * 0.313d0
c
c       Gradient terms for stress calculation:
        dexs = dexs * ( rho / twokf**2 )
c       This only gives half the required term, so double dexs
        dexs = two*dexs
c
c       Convert to Rydberg units:
        vxr = two*vx
        exr = two*ex
        dexsr = two*dexs
c
      else
c
c       >>>>>>>>> ERROR <<<<<<<<<
c
        call STOPXERR( 'gga-type/unknown gga type' )
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DIPPOT
c
c
      subroutine DIPPOT( ion_opt, dipole,rdipole, ndim, esion,
     $ rprim, n1r,n2r,n3r,  hh, weight, ndbox,nbox,
     $ rhion, vion, r )
c---------------------------------------------------------------
c Purpose: Compute potential on grid from dipole correction
c          treating background counterdipole as gaussians.
c
c Written: Peter A. Schultz,  2-Movember-1998 (for v2.27)
c
c Revision history:
c   8Mar02-PAS/2.52: clean unused variables/literal constants d0
c   7Feb99-PAS/2.42: bugfix for bulk dipole range
c  29Mar99-PAS/2.32: to accomodate periodic systems
c  15Dec98-PAS/2.30: put into boxes
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  10Nov98-PAS/2.27: position of dipole included
c   5Nov98-PAS/2.27: 2D slab dipole correction built
c---------------------------------------------------------------
c
c  Notes:
c   What I will do here to cancel the grid charge dipole is
c   construct a charge density with the same dipole from a pair
c   of Gaussians, of opposite sign, centered about the origin,
c   and separated by the distance 2*rdip, where rdip is specified
c   in this routine.  I will take this dipole density and remove
c   it from the delta-density, leaving the fft density dipole-free.
c   This routine should only be necessary for neutral systems,
c   as the dipole is corrected in charged systems by shifting the
c   origin of the neutralizing charge.  2Nov98-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c input arrays:
      DIMENSION  dipole(3), rdipole(3)
c  grid generating primitive vector, and unit cell vectors
      DIMENSION  rprim(3,3), hh(3,3)
      DIMENSION  ndbox(2,2,3)
c output arrays:
c  neutralizing density, and associated electrostatic potential:
      DIMENSION  rhion(*),vion(*)
c scratch arrays:
      DIMENSION  r(3,*)
c local declarations:
      DIMENSION  zchrg(2),rchrg(3,2)
      DIMENSION  orig(3), gg(3,3)
      DIMENSION  nrx(3)
c
      DATA  zero,half,one / 0.d0,0.5d0,1.d0 /
      DATA  four / 4.d0 /
c Exponent for Gaussian neutralizing charge:
      DATA  alfion / 0.30d0 /, rdip / 1.5d0 /
c   Should be small enough to be well integrable on any reasonable
c   grid but large enough to be contained within any viable unit cell.
c
c >>>> EXECUTABLE CODE:
c
      esion = zero
      dipmag = SQRT( dipole(1)**2 + dipole(2)**2 + dipole(3)**2 )
      if( ion_opt.le.0 .or. (dipmag .lt. 2.d-2) ) RETURN
c
c  We have a finite cluster system for which we wish to construct a
c  density that will cancel the dipole.
c
c Set up some constants:
      pi = four*ATAN( one )
      fourpi = pi + pi + pi + pi
      rtalf = SQRT( alfion )
      aldpi = alfion / pi
c
c Get me the net charge I will need to place in each Gaussian:
      zgaus = half*dipmag/rdip
c
c  Get range of Gaussians on the grid:
      rngalf = SQRT( cutgrid/alfion )
c
      call CROSS( hh(1,2),hh(1,3), gg(1,1) )
      call CROSS( hh(1,3),hh(1,1), gg(1,2) )
      call CROSS( hh(1,1),hh(1,2), gg(1,3) )
      do  j=1,3
        gmag = SQRT( gg(1,j)**2 + gg(2,j)**2 + gg(3,j)**2 )
        gg(1,j) = gg(1,j)/gmag
        gg(2,j) = gg(2,j)/gmag
        gg(3,j) = gg(3,j)/gmag
      enddo
c
      do  id=1,3
        rhh = ABS( gg(1,id)*hh(1,id) + gg(2,id)*hh(2,id)
     $           + gg(3,id)*hh(3,id) )
        rnx = rngalf/rhh + half
        nrx(id) = rnx
      enddo
c
c  Branch to correct location:
c
      if( ion_opt.eq.2 )then
c
c First, put center of neutralizing dipole at center of dipole:
        do  j=1,3
          orig(j) = rdipole(j)
        enddo
c
c Give charge and position of our two-Gaussian array:
        nglm = 0
        zchrg(nglm+1) = -zgaus
        zchrg(nglm+2) =  zgaus
        do  j=1,3
          rchrg(j,nglm+1) = orig(j) - rdip* dipole(j)/dipmag
          rchrg(j,nglm+2) = orig(j) + rdip* dipole(j)/dipmag
        enddo
        nglm = nglm + 2
c
CC The following check is wrong for the new WS scheme in bulk
Cc  Check position of coordinate origin on the grid:
C        do 200 iglm=nglm-1,nglm
C          do  j=1,3
C            r1(j) = rchrg(j,iglm)
C          enddo
C          call PROJLV( r1, hh(1,1), hh(1,2), hh(1,3), t )
C          do  id=1,3
C            if( t(id).lt.zero )
C     $       call STOPXERR( 'DIPPOT: LMCC gaussian outside unit cell' )
C          enddo
C  200   continue
c
c  Go ahead and compute Gaussian LMCC array:
        call IONGPOT( ndim, esion, nglm,zchrg,rchrg,
     $   rprim, n1r,n2r,n3r, hh, weight, ndbox,nbox,
     $   rhion, vion, r )
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DIPSLAB
c
c
      subroutine DIPSLAB( ion_opt,ndim,
     $ dipole,rdipole,  esion,vacplus,
     $ rprim, n1r,n2r,n3r,  hh, weight, ndbox,nbox,
     $ rhlmcc, vlmcc, r )
c---------------------------------------------------------------
c Purpose: Compute countercharge density and potential to treat
c          slab dipole moment
c
c Written: Peter A. Schultz, 30-March-1999 (for v2.32)
c
c Revision history:
c   1Jul11-PAS/2.62: adapted for consistency w/ double-layer
c  15Feb11-PAS/2.62: naming and cosmetics, slab dipole vacuum potl
c   8Mar02-PAS/2.52: clean unused variables/literal constants d0
c---------------------------------------------------------------
c
c  Notes:
c   To compute potential due to a slab dipole, construct a pair
c   of one-dimensional Gaussians planes, of opposite sign, separated
c   by the distance 2*dzlmcc. dzlmcc is specified in this routine.
c   Dipole potential is computed here, remove the lmcc dipole density
c   from the delta-density, leaving the fft density dipole-free.
c
c   Implements method set out in: P.A.Schultz, PRB 60, 1551 (1999).
c
c   Key assumption: z-axis is surface normal
c
c   Should be merged with SLABCHRG after code is vetted.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  (zero=0.d0,half=0.5d0,one=1.d0,two=2.d0)
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
      COMMON  /CONST/ pi,rtpi,cutexp
c
c Input arrays:
      DIMENSION  dipole(3), rdipole(3)
c  unit cell vectors, and grid generating basis vectors
      DIMENSION  rprim(3,3), hh(3,3)
      DIMENSION  ndbox(2,2,3)
c Output arrays:
c  lmcc slab dipole density, and associated electrostatic potential:
      DIMENSION  rhlmcc(*),vlmcc(*)
c
c Scratch arrays:
      DIMENSION  r(3,*)
c
c Local declarations:
      LOGICAL    ingaus
      DIMENSION  r0box(3),boxctr(3)
      DIMENSION  origlm(3), rvec3(3), gg(3,3)
      DIMENSION  nro(3),nrx(3)
c
      DATA  four / 4.d0 /
c
c   Parameters for slab lmcc:
      DATA  alflmcc / 0.30d0 /, dzlmcc / 1.5d0 /
c      alflmcc = Gaussian exponent for dipole charges
c      dzlmcc  = z-offset from dipole center for lmcc gaussian planes
c   These are adjustable parameters, constrained by the need to be ...
c    ... small enough to be well integrable on any reasonable grid
c    ... but large enough to be contained within any viable unit cell
c
c >>>> EXECUTABLE CODE:
c
      esion = zero
      vacplus = zero
c
c Routine is for neutral slab, with planar dipole
c
      if( ndim.ne.2 .or. ion_opt.ne.2 ) RETURN
c
c Set up some constants 
      fourpi = four*pi
      rtalf = SQRT( alflmcc )
      alfdpi = alflmcc / pi
c
c Compute slab normal vector
      call CROSS( rprim(1,1),rprim(1,2), rvec3 )
      area = SQRT( rvec3(1)**2 + rvec3(2)**2 + rvec3(3)**2 )
      vol = rvec3(1)*rprim(1,3) + rvec3(2)*rprim(2,3)
     $    + rvec3(3)*rprim(3,3)
      if( vol .lt. zero )then
        rvec3(1) = -rvec3(1)
        rvec3(2) = -rvec3(2)
        rvec3(3) = -rvec3(3)
      endif
      rvec3(1) = rvec3(1)/area
      rvec3(2) = rvec3(2)/area
      rvec3(3) = rvec3(3)/area
c
c Project dipoles and grid spacing onto slab normal (z-vector)
      z0dipole = rvec3(1)*rdipole(1) + rvec3(2)*rdipole(2)
     $         + rvec3(3)*rdipole(3)
      zhh = rvec3(1)*hh(1,3) + rvec3(2)*hh(2,3) + rvec3(3)*hh(3,3)
c
      dipolez = rvec3(1)*dipole(1) + rvec3(2)*dipole(2)
     $        + rvec3(3)*dipole(3)
      dipzmag = ABS( dipolez )
c
      if( dipzmag .lt. 2.d-2 ) RETURN
c
c----------------------------------------------------------------------
c  Slab system has significant dipole.
c  Construct lmcc density that matches dipole normal to the surface,
c  and compute associate potential from this density.
c----------------------------------------------------------------------
c
c Compute net charge needed for each Gaussian to cancel dipole
      qgaus = dipzmag * half/dzlmcc
c
c Get range of lmcc Gaussians on the grid:
      rngalf = SQRT( cutgrid/alflmcc )
c
      call CROSS( hh(1,2),hh(1,3), gg(1,1) )
      call CROSS( hh(1,3),hh(1,1), gg(1,2) )
      call CROSS( hh(1,1),hh(1,2), gg(1,3) )
      do  j=1,3
        gmag = SQRT( gg(1,j)**2 + gg(2,j)**2 + gg(3,j)**2 )
        gg(1,j) = gg(1,j)/gmag
        gg(2,j) = gg(2,j)/gmag
        gg(3,j) = gg(3,j)/gmag
      enddo
c
      do  id=1,3
        rhh = ABS( gg(1,id)*hh(1,id) + gg(2,id)*hh(2,id)
     $           + gg(3,id)*hh(3,id) )
        rnx = rngalf/rhh + half
        nrx(id) = rnx
      enddo
c
c  Branch to correct location:
c
      if( ion_opt .eq. 2 )then
c
c      ***** Slab system *****
c
       pole = one
 2100   continue
c       Start with negative-z pole of dipole, then switch to z(+)
        pole = -pole
        qgaus = -qgaus
c
c       First, offset gaussian pole from center of neutralizing dipole:
        zgaus = - z0dipole - pole*(dipolez/dipzmag)*dzlmcc
c
        nro(3) = (-zgaus/zhh) + half + one
c
        ic1 = nro(3) - nrx(3)
        icn = nro(3) + nrx(3)
        if( ic1.lt.1 ) ic1 = 1
        if( icn.gt.n3r ) icn = n3r
c
        gcoef = qgaus* SQRT( alfdpi ) / area
c       Coefficients for gaussian and error function terms
        vgcoef = -gcoef*fourpi / alflmcc
        vecoef = -gcoef*fourpi / SQRT( alfdpi )
c
        origlm(1) = zero
        origlm(2) = zero
        origlm(3) = zgaus
c
        esiongr = zero
        irpot = 0
        do 2250 ibox=1,nbox
c
c         Get basic box info
          call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $     ira0,irb0,irc0, idra,idrb,idrc )
          nrbox = idra*idrb*idrc
c
          iv0 = irpot
          irpot = irpot + nrbox
c
          ingaus = .true.
          if( (irc0+idrc).lt.ic1 .or. icn.le.irc0 ) ingaus = .false.
c
c         Generate coordinates of points within box
          call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
          r0box(1) = r0box(1) + origlm(1)
          r0box(2) = r0box(2) + origlm(2)
          r0box(3) = r0box(3) + origlm(3)
          call MKRBOX( hh,r0box, idra,idrb,idrc, r )
c
          if( ingaus )then
c           This box is within the gaussian range
c
            rhcoef = gcoef
            do  nr=1,nrbox
              zval = r(3,nr)
              zmag =  ABS( zval )
              zsq = zmag*zmag
              rhadd = rhcoef* EXP( -alflmcc*zsq )
              vadd = vgcoef* EXP( -alflmcc*zsq )
     $         + vecoef*zmag*DERF( rtalf*zmag )
              rhlmcc(iv0+nr) = rhlmcc(iv0+nr) + rhadd
              vlmcc(iv0+nr) = vlmcc(iv0+nr) + vadd
              esiongr = esiongr + vlmcc(iv0+nr)*rhlmcc(iv0+nr)
            enddo
          else
c           Outside gaussian range, asymptotic potential
c
            do  nr=1,nrbox
              zval = r(3,nr)
              zmag =  ABS( zval )
              rhadd = zero
              vadd = vecoef*zmag
              vlmcc(iv0+nr) = vlmcc(iv0+nr) + vadd
              esiongr = esiongr + vlmcc(iv0+nr)*rhlmcc(iv0+nr)
            enddo
          endif
c
c         Close loop over boxes
 2250   continue
c
c       Compute self-energy of dipole on grid:
        esiongr = weight*esiongr/two
c
        esion = esiongr
c
       if( pole.lt.zero ) goto 2100
c
c      Compute asymptotic vacuum potential (due to dipole)
       vacplus = -vecoef*two*dzlmcc*(dipolez/dipzmag)
C       write(IWR,*) 'Vacuum(-z),vacuum(+z)[Ry]=', -vacplus, vacplus
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DMD
c
c
      subroutine DMD( IWR, sufx, igstep, igdmdmod,
     $ nrlx, natmg,nxatm, dt,
     $ am, ri,vi,fi, wt )
c---------------------------------------------------------------
c Purpose: damped dynamics update of particle positions
c
c Written: Aidan Thompson (SNL), September 2001
c
c Revision History:
c   28Aug28-PAS/2.61f: set ASD atomic masses to one (vary just inertial)
c    4Feb02-PAS/2.51c: added restart (v,m) file
c   11Oct01-PAS/2.50: adapted to SeqQuest conventions; more options
c---------------------------------------------------------------
c
c Variables:
c  nrlx = total number of independent components to be relaxed
c  natmg = number of "atoms" to be relaxed
c  nxatm = number of components to be relaxed for each atom
c   (this will usually be 3-vectors, but *could* be potentially
c    less if one introduces constraints on the geometry, e.g.
c    fixing the z-coordinate of an atom to be a fixed number)
c  am() = masses for each of those components (NB: not by atom)
c  ri(),vi(),fi() = positions, velocities, and forces
c  wt() = inertia factor for velocity update
c
c igdmdmod  function
c    0      simple unquenched MD step
c    1      Jonsson's damped dynamics (component-wise)
c    2      Jonsson's damped dynamics (atom-by-atom)
c    3      PAS-modified damped dynamics: accelerated steepest descent
c   Split into unquenched and quenched if igdmdmod < 0
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input/output variables
      DIMENSION  am(*), ri(*),vi(*),fi(*), wt(*)
      DIMENSION  nxatm(*)
c file stuff:
      CHARACTER  sufx*(*), dmd_tag*40
c
c local declarations
      DATA  lstout / 2 /
      DATA  zero,one / 0.d0,1.d0 /
      DATA  two / 2.d0 /
c
c >>>> EXECUTABLE CODE:
c
      dmd_tag = 'dmd_' // sufx
      call FLOPENB( idmdfl, dmd_tag )
      REWIND( unit=idmdfl )
      if( igstep.eq.1 )then
c       Initialize velocities and inertia factors on first step
        call MKZERO( nrlx, vi )
        call DCOPY( natmg, one,0, wt,1 )
      else
c       Recover velocities, and inertia factors (if applicable):
        call READBIG( idmdfl, nrlx, vi )
        if( IABS( igdmdmod ) .ge. 3 )then
          call READBIG( idmdfl, natmg, wt )
        else
          call DCOPY( natmg, one,0, wt,1 )
        endif
      endif
c
      iquench = igdmdmod
      dtvel = dt
c
      if( igdmdmod .lt. 0 )then
c       Split the time interval into unquenched and quenched ...
        iquench = 0
        dtvel = dt / two
c        ... the unquenched velocity update in the first half-step:
        call DMDVELOC( nrlx, natmg,nxatm, vi,am,fi,wt, dtvel, iquench )
c
c        ... set up specified quench for second half of time-step:
        iquench = -igdmdmod
      endif
c
c Update velocity with specified quenching scheme:
      call DMDVELOC( nrlx, natmg,nxatm, vi,am,fi,wt, dtvel, iquench )
c
c Update the atomic coordinates along the velocity vector:
      call DMDSTEP( nrlx, ri,vi, dt )
c
c And output some diagnostics:
      if( lstout.gt.0 )
     $ write(IWR,*) 'dynamics update step #', igstep
c
c Put out the current velocity vector:
      REWIND( unit=idmdfl )
      call WRITBIG( idmdfl, nrlx, vi )
      if( IABS( igdmdmod ) .ge. 3 )then
        call WRITBIG( idmdfl, nrlx, wt )
        wtmin = ABS( wt(1) )
        wtmax = ABS( wt(1) )
        do  iatmg=1,natmg
          wti = ABS( wt(iatmg) )
          if( wti .lt. wtmin ) wtmin = wti
          if( wti .gt. wtmax ) wtmax = wti
        enddo
        if( lstout.gt.1 )
     $  write(IWR,'(a,2f9.4)') 'ASD: min/max mass factors=',wtmin,wtmax
c
        if( lstout.gt.2 )then
 9013     format(1x,'ASDWT:',2i4,2x,8f9.4)
          do  iatmg=1,natmg,8
            jatmg = MIN( iatmg+7, natmg )
            write(IWR,9013) iatmg,jatmg, (wt(i),i=iatmg,jatmg)
          enddo
        endif
      endif
c
      call FLCLOSE( idmdfl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DMDVELOC
c
c
      subroutine DMDVELOC( nrlx, natmg,nxatm, vi,am,fi,wt, dt, iquench )
c---------------------------------------------------------------
c Purpose: (damped) dynamics update of particle velocities
c
c Written: Peter A. Schultz, 12-October-2001, for v2.50
c
c Revision History:
c  12Oct01-PAS/2.50: developed new damped dynamics scheme
c---------------------------------------------------------------
c
c Parameters for modified damped dynamics:
c  dvup = boosting factor for rate of acceleration
c         must be .ge.1, should be .le.dvdn
c  dvdn = reducing factor (if rate deemed too fast)
c         must be .ge.1, should be between 2 and 4(?)
c  cutdn = v-par/dv-update ratio that triggers deceleration
c         must be .ge.1 (if dv bigger than v-par, must slow down)
c         should be ~1.5-3.0 (dv and v-par comparable, should slow)
c  Setting dvdn=dvup=1.0 reduces to simple Jonsson damped dynamics.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0 )
c input/output arrays:
      DIMENSION  am(*), vi(*),fi(*), wt(*)
      DIMENSION  nxatm(*)
c
c >>>> EXECUTABLE CODE:
c
c Set parameters for the damped acceleration dynamics ...
c  ... the acceleration factor (cube root of 2.0):
      dvup = 1.25992105d0
c      dvup = 1.414213562d0
c  ... the deceleration factor (2.0 seems good number):
      dvdn = 2.d0
c  ... and cutoff ratio for deceleration (2.0-3.0 appears to work):
      cutdn = 2.d0
cpas: set masses to **one** for ASD and related (this needs to cleaned up)
      if( iquench.gt.0 )then
c       set all mass elements to one
        do  irlx=1,nrlx
          am(irlx) = one
        enddo
      endif
c
      if( iquench .eq. 0 )then
c
c       >>>> No quench, strict dynamics update
c
        do  irlx=1,nrlx
          vi(irlx) = vi(irlx) + fi(irlx)* dt/am(irlx)
        enddo
c
      elseif( iquench .eq. 1 )then
c
c       >>>> Jonsson's damped dynamics (component-wise)
c
        do  irlx=1,nrlx
          if(  vi(irlx)*fi(irlx) .lt. zero )then
c           Quench velocity, and update
            vi(irlx) =            fi(irlx)* dt/am(irlx)
          else
c           Add to velocity ...
            vi(irlx) = vi(irlx) + fi(irlx)* dt/am(irlx)
          endif
        enddo
c
      elseif( iquench .eq. 2 )then
c
c       >>>> Jonsson's damped dynamics (atom-by-atom)
c
        irlx0 = 0
        do  iatmg=1,natmg
c         Get number of components on this atom to be relaxed
          lenvec = nxatm(iatmg)
c
          vdotf = zero
          fdotf = zero
          do  irlx=irlx0+1,irlx0+lenvec
            vdotf = vdotf + vi(irlx)*fi(irlx)
            fdotf = fdotf + fi(irlx)*fi(irlx)
          enddo
c
          if( vdotf .lt. zero )then
c           Velocity and force reversed: quench v, and update
            do  irlx=irlx0+1,irlx0+lenvec
              vi(irlx) =                fi(irlx)* dt/am(irlx)
            enddo
          else
c           Velocity and force aligned, update velocity along force
            if( fdotf .ne. zero )then
              fac = vdotf/fdotf
            else
              fac = zero
            endif
            do  irlx=irlx0+1,irlx0+lenvec
              vi(irlx) = fac*fi(irlx) + fi(irlx)* dt/am(irlx)
            enddo
          endif
c
        enddo
c
      elseif( iquench .eq. 3 )then
c
c       >>>> PAS modified damped dynamics, accel. steepest desc.
c
        irlx0 = 0
        do  iatmg=1,natmg
c         Get number of components on this atom to be relaxed
          lenvec = nxatm(iatmg)
c
c         Get size of force&velocity vectors, and dot product
          vdotf = zero
          fdotf = zero
          vdotv = zero
          do  irlx=irlx0+1,irlx0+lenvec
            vdotf = vdotf + vi(irlx)*fi(irlx)
            fdotf = fdotf + fi(irlx)*fi(irlx)
            vdotv = vdotv + vi(irlx)*vi(irlx)
          enddo
c
          if( vdotf .lt. zero )then
c           Velocity and force reversed: quench, and update
c
            dvfac = ABS( wt(iatmg) )
            dvfacx = dvfac
c
            dvmag = zero
            do  irlx=irlx0+1,irlx0+lenvec
              dvmag = dvmag + (fi(irlx)* dvfac*dt/am(irlx))**2
            enddo
            fac = vdotf/fdotf
            vpar = fac*fac*fdotf
            dvmag = SQRT( dvmag )
            vpar = SQRT( vpar )
c
c           If we have a big reversal ...
            if( cutdn*dvmag .gt. vpar .or.
c              ... or reversed twice in a row ...
     $                     wt(iatmg) .gt. zero )then
c              ... decrease acceleration rate:
              dvfac = dvfac / dvdn
              dvfacx = dvfac
c
c             If we still overshoot after damping ...
              if( (dvmag/dvdn) .gt. vpar )then
c                ... limit update size to previous step size:
                dvfacx = dvfac*( vpar / (dvmag/dvdn) )
              endif
c
            endif
c
            do  irlx=irlx0+1,irlx0+lenvec
              vi(irlx) = fi(irlx)* dvfacx*dt/am(irlx)
            enddo
c
c           We just reversed, set as boost-ineligible:
            wt(iatmg) = dvfac
c
          else
c           Velocity and force aligned, update velocity along force
c
            dvfac = ABS( wt(iatmg) )
c
            if( fdotf .ne. zero )then
              fac = vdotf/fdotf
              dvmag = zero
              do  irlx=irlx0+1,irlx0+lenvec
                dvmag = dvmag + (fi(irlx)* dvfac*dt/am(irlx))**2
              enddo
              vpar = fac*fac*fdotf
              dvmag = SQRT( dvmag )
              vpar = SQRT( vpar )
            else
              fac = zero
              dvmag = zero
              vpar = zero
            endif
c
            if( wt(iatmg) .lt. zero )then
c             We are repeatedly heading in the right direction ...
c
cpas: probably should do unconditional boost.
              if( two*dvmag .lt. vpar )then
c                ... and not accelerating fast enough - boost
                dvfac = dvfac * dvup
              endif
c             Note boost-eligibility in sign of mass factor:
              wt(iatmg) = -dvfac
c
            else
c             We recently (but not this time) reversed
c
              if( two*dvmag .lt. vpar )then
c               Looks like we are converging, quench velocity ...
                fac = zero
c                ... and leave this as boost-ineligible
                wt(iatmg) = dvfac
              else
c               We have healthly acceleration ...
                if( vpar .gt. zero )then
c                  ... and constructive (non-zero) alignment
                  if( two*dvmag .gt. vpar )then
c                    ... and the acceleration is hefty - boost
c                    (even though we were nominally ineligible)
                    dvfac = dvfac * dvup
                  endif
c                 Now boost-eligible, note in sign of mass factor:
                  wt(iatmg) = -dvfac
                endif
              endif
c
            endif
c
            do  irlx=irlx0+1,irlx0+lenvec
              vi(irlx) = fac*fi(irlx) + fi(irlx)*dvfac*dt/am(irlx)
            enddo
c
          endif
c
          irlx0 = irlx0 + lenvec
        enddo
c
      else
c
c       >>>> Invalid quenching option
c
        call STOPXERR( 'DMDVEL  - coding error/invalid iquench' )
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DMDSTEP
c
c
      subroutine DMDSTEP( nrlx, ri,vi, dt )
c
      implicit none
c
c     --- variables passed to and from subroutine
      DIMENSION  ri(*),vi(*)
      integer  nrlx
      real*8   ri,vi,   dt
c
c     --- local variables
      integer  irlx
c
c >>>> EXECUTABLE CODE:
c
      do  irlx=1,nrlx
        ri(irlx) = ri(irlx) + dt*vi(irlx)
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DOEBIND
c
c
      subroutine DOEBIND( IWR, engytotl, engyref, engybind,
     $ toev, natm, itypa, atengy )
c---------------------------------------------------------------
c Purpose: compute binding energy for system wrt reference atom
c
c Written: Peter A. Schultz, 3-October-2001, for v2.50
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  itypa(*)
      DIMENSION  atengy(natm)
c
c local declarations:
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      engyref = zero
      do  iatm=1,natm
        ityp = itypa(iatm)
        engyref = engyref + atengy(ityp)
      enddo
c
      engybind = engytotl - engyref
      if( engyref .ne. zero )then
        engybev = toev*engybind
        write(IWR,'(1x,a,f20.10,a,f20.4,a)')
     $   'Binding energy =',engybind,' Ry =',engybev,' eV'
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DOENG1C
c
c
      subroutine DOENG1C( ves1ctr,ves1c0,
     $ nk,norb,natm,ntyp,nshld, itypa,numshl,lshel, occij,wtk,
     $ ves, dmat )
c---------------------------------------------------------------
c Purpose: get 1-center es energies
c
c Written: Peter A. Schultz, 20-May-2001 for v2.47
c
c Revision history:
c  24Jul01-PAS/2.49: packed dmat/cpas=temp workaround
c  20May01-PAS/2.47: extracted from DOENGY
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  occij(nshld,nshld,ntyp), wtk(nk)
cpas  DIMENSION  ves(norb,norb,nk), dmat(norb,norb,nk)
      DIMENSION  ves(norb,norb,nk), dmat(2,norb,norb,nk)
c
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      ves1ctr = zero
      ves1c0  = zero
      do  k=1,nk
c
c  Non-spherical electrostatic energy (from 1-center stuff)
cpas        call DOTRACE( ves1ctr, norb, dmat(1,1,k), ves(1,1,k) )
c------------------
      diag = zero
      do  i=1,norb
        diag = diag + dmat(1,i,i,k)*ves(i,i,k)
      enddo
c
      offd = zero
      do  i=2,norb
        do  j=1,i-1
          offd = offd
     $         + ( dmat(1,i,j,k) + dmat(1,j,i,k) ) * ves(i,j,k)
     $         + (-dmat(2,i,j,k) + dmat(2,j,i,k) ) * ves(j,i,k)
        enddo
      enddo
c
      ves1ctr = ves1ctr + diag + offd
c------------------
        call DO0TRACE( ves1c0,  norb, natm,ntyp,nshld,
     $   itypa,numshl,lshel, occij,wtk(k), ves(1,1,k) )
c
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DOENGY
c
c
      subroutine DOENGY( engytotl, IWR,
     $ idmatfl,idmatsfl, iham0fl,ivxc0fl,iexc0fl,ih0tfl,ih0nlfl,
     $ nspin, nearopt,near2c,
     $ atm0engy,esnsgr,vesgrxc,excengy,esnsengy, ves1ctr,ves1c0,
     $ do_field, engydfld,engy0fld, engypol,
     $ xc0val,exctot,excslo,exc1c, corslow,
     $ norb, nk, natm,ntyp,nshld,
     $ itypa,numshl,lshel, znuc,occij, wtk,
     $ rhoatom, defatom,defatdn,
     $ vslnear,vesnear,excnear, norbd,
     $ vmat,          dmat, h0mat )
c      nmatloc*nspin  mat   mat   ; nmatloc=mat*nkloc
c---------------------------------------------------------------
c Purpose: perform energy analysis for this iteration
c
c Written: Peter A. Schultz, 7-June-1994 for v2.10
c
c Revision history:
c  13Feb12-PAS&ACP/2.63: k-parallel
c  22Sep08-PAS/2.62: split e/vxc0, h0t/nl files, dmat/spin file
c  20Jun07-PAS/2.60: merge serial and tp
c   6Jul06-APT/2.60: merged task parallel and image parallel
c  30Jul05-PAS/2.59-tp: master-only matrix files
c  17Sep03-PAS,JTK/2.57: install E-field terms; bulk polarization
c   3Oct02-PAS/2.54: rework storage of ham0 pieces
c  21Jul01-PAS/2.49: compact dmat; spin-polarized dft
c  21May01-PAS/2.47: extracted traces for (non-stardard) 1c es
c  15Feb99-PAS/2.31: routine to intercept perhaps too-big i/o
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  16Sep98-PAS/2.27: tweak the core nearby diagnostic
c  14Jul98-PAS/2.23: change energy to rid delh trace; split basis
c  26Oct97-PAS/2.21: clean up exc calc with output levels
c   3Jun97-PAS/2.17: naming conventions / do0trace used for es
c                    another exc correction
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input arrays:
      LOGICAL    do_field
      DIMENSION  xc0val(*)
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  znuc(ntyp), occij(nshld,nshld,ntyp), wtk(nk)
      DIMENSION  rhoatom(natm,*)
      DIMENSION  defatom(natm,*), defatdn(natm,*)
      DIMENSION  vslnear(norbd,nspin),vesnear(natm)
      DIMENSION  excnear(norbd,nspin)
c
C      DIMENSION  vmat(norb*norb,nkloc,nspin)
      DIMENSION  vmat(norb*norb,*)
c
c Scratch arrays:
      DIMENSION  dmat(norb*norb), h0mat(norb*norb)
c
c Local declarations:
      DIMENSION  vtrk(2)
      DATA  zero,half,one / 0.d0,0.5d0,1.d0 /
      DATA  lstout / 1 /
c
c Local/task-parallel data
      DIMENSION  traces(8)
c
c >>>> EXECUTABLE CODE:
c
 9010 format( 4x, a, (1x,3f20.10) )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c  First compute the contributions from the nearby corrections
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      spinfac = one
      if( nspin.eq.2 ) spinfac = half
      vesnr0 = zero
      vesnr1 = zero
      vesnr2 = zero
      excnr1 = zero
      excnr2 = zero
      excnrc = zero
      slonr1 = zero
      slonr2 = zero
c
      do 101 iatm=1,natm
        defatm0 = znuc(itypa(iatm)) - rhoatom(iatm,1)
        vesnr0 = vesnr0 + vesnear(iatm)*defatm0
c
        vesnr1 = vesnr1 + vesnear(iatm)*defatom(iatm,1)
        vesnr2 = vesnr2 + vesnear(iatm)*defatom(iatm,2)
        excnr1 = excnr1 + excnear(iatm,1)*defatom(iatm,1)
        excnr2 = excnr2 + excnear(iatm,1)*defatom(iatm,2)
        slonr1 = slonr1 + vslnear(iatm,1)*defatom(iatm,1)
        slonr2 = slonr2 + vslnear(iatm,1)*defatom(iatm,2)
c
        defcore = rhoatom(iatm,2) - rhoatom(iatm,3)
        excnrc = excnrc + excnear(iatm,1)*defcore*spinfac
  101 continue
c
      if( nspin .eq. 2 )then
        do 102 iatm=1,natm
          vesnr1 = vesnr1 + vesnear(iatm)*defatdn(iatm,1)
          vesnr2 = vesnr2 + vesnear(iatm)*defatdn(iatm,2)
          excnr1 = excnr1 + excnear(iatm,2)*defatdn(iatm,1)
          excnr2 = excnr2 + excnear(iatm,2)*defatdn(iatm,2)
          slonr1 = slonr1 + vslnear(iatm,2)*defatdn(iatm,1)
          slonr2 = slonr2 + vslnear(iatm,2)*defatdn(iatm,2)
c
          defcore = rhoatom(iatm,2) - rhoatom(iatm,3)
          excnrc = excnrc + excnear(iatm,2)*defcore*spinfac
  102   continue
      endif
c
      if( near2c.eq.0 )then
        slonr = zero
        excnr = zero
        vesnr = zero
      elseif( near2c.eq.1 )then
        slonr = slonr1
        excnr = excnr1
        vesnr = vesnr1
      elseif( near2c.eq.2 )then
        slonr = slonr1 + slonr2
        excnr = excnr1 + excnr2
        vesnr = vesnr1 + vesnr2
      endif
      esnsnr = half*(vesnr-vesnr0)
c
      if( lstout.gt.2 )then
        write(IWR,*) 'DOENGY: nearby construction energy analysis'
        write(IWR,910)
  910   format(1x,'E-nearby',9x,'total',10x,'1-ctr',10x,'2-ctr')
  911   format(2x,a6,2x,4f15.8)
        write(IWR,911) 'v-near',slonr,slonr1,slonr2
        write(IWR,911) 'exc-nr',excnr,excnr1,excnr2,excnrc
        write(IWR,911) 'ves-nr',vesnr,vesnr1,vesnr2
        write(IWR,911) 'ves0nr',vesnr0,vesnr0,zero,esnsnr
        write(IWR,*)
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c           Compute contributions from variety of traces
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      matsiz = norb*norb
      vtrc    = zero
      vtrcdn  = zero
      pseutrc = zero
      ekintrc = zero
      vxc0trc = zero
      exc0trc = zero
      h0trc   = zero
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
      call MPNODES_K( nprocs_k )
      call MPNODE_K( iproc_k )
      call MPNODE0_K( master_k )
      call MPCOMM_K( icomm_k )
c     And need nkloc to compute array offset for ispin!=1
      call KPMINE ( nk, nkloc, nk0 )
c
c  Only masters read files, do traces, and run the big calcs
      if( iproc .ne. master .and. iproc_k .ne. master_k ) goto 300
c     Skip if no local k-points, EXCEPT the image master who must read
      if( nkloc .eq. 0 .and. iproc .ne. master ) goto 300
c
      if( iproc .eq. master )then
        REWIND( unit=idmatfl )
        if( nspin .eq. 2 )then
c         We have spin-dependent potentials and density matrices,
c          position the spin-dn dmats
          REWIND( unit=idmatsfl )
        endif
        REWIND( unit=iham0fl )
        REWIND( unit=ivxc0fl )
        REWIND( unit=iexc0fl )
        REWIND( unit=ih0tfl )
        REWIND( unit=ih0nlfl )
      endif
c
      ikloc = 0
      do 250 ik=1,nk
c
        ispin = 1
c       Inform the k-parallel:
        lenmsg = matsiz
        call KPMASTER( nk, nprocs, ik, kmasterpr )
c       NB: kmasterpr = rank of master of ik, in image comm, DIFFERENT from
c           master_k = rank k-point master of this proc, in comm_k
c
c       Retrieve dmat(k;up) and send to its k-master
c       (This might need to be managed via tickets)
c
        if( iproc .eq. master )then
c         Image master reads in density matrix for this k-vector
          call READBIG( idmatfl, matsiz, dmat )
          if( kmasterpr .ne. master )then
c           ... and sends this dmat off to its k-master
            call MPSENDR8( kmasterpr, lenmsg, dmat , icomm )
            goto 220
          endif
        elseif( iproc .eq. kmasterpr )then
c         The k-master receives its dmat from master
          call MPRECVR8( master, lenmsg, dmat , icomm )
        else
c         This processor not involved with this k-point, skip
          goto 250
        endif
c
        ikloc = ikloc + 1
c
c       Trace with the delta-Ham
        vtrk(1) = zero
c       call DOTRACE( vtrk(1), norb, dmat, vmat(1,ikloc,ispin=1) )
        call DOTRACE( vtrk(1), norb, dmat, vmat(1,ikloc) )
c       The next line only matters on the image master
        vtrc = vtrc + vtrk(1)
c
  220   continue
c
        if( nspin .eq. 2 )then
c         The above was up-spin(in dmat), now must do down-spin(in h0mat):
          ispin = 2
          lenmsg = matsiz
          if( iproc .eq. master )then
c           Image master reads in dn-spin density matrix for this k-vector
            call READBIG( idmatsfl, matsiz, h0mat )
            if( kmasterpr .ne. master )then
c             ... and sends this dmat off to its k-master
              call MPSENDR8( kmasterpr, lenmsg, h0mat, icomm )
              goto 240
            endif
          elseif( iproc .eq. kmasterpr )then
c           The k-master receives its dmat from master
            call MPRECVR8( master, lenmsg, h0mat, icomm )
          else
c           This processor not involved in this k-point, skip
            goto 250
          endif
c
c         Trace with the dn-spin delta-Ham
          vtrk(2) = zero
c         call DOTRACE( vtrk(2), norb, h0mat, vmat(1,ikloc,ispin=2) )
          call DOTRACE( vtrk(2), norb, h0mat, vmat(1,ikloc+nkloc) )
c
c         The next line only matters on the image master
          vtrcdn = vtrcdn + vtrk(2)
        endif
c
  240   continue
c
c       At this point, traces with del-Hams are done,
c       the up-dmat is in dmat(), and the dn-dmat (if spin) is in h0mat.
c       Now need to do traces with iter-independent Ham components.
c       These are done only by image master, which has Ham0s on disk.
c
        lentrc = nspin
        if( iproc .eq. master )then
c
c         Combine up- and dn-spin density matrices:
          if( nspin.eq.2 ) call DAXPY( matsiz, one, h0mat,1, dmat,1 )
c
c         Full spherical atom trace term from matrix on ihamsfl:
          call READBIG( iham0fl, matsiz, h0mat )
          call DOTRACE( h0trc  , norb, dmat, h0mat )
c
c         Cutoff spherical-atom Vxc term from matrix on ihamsfl:
          call READBIG( ivxc0fl, matsiz, h0mat )
          call DOTRACE( vxc0trc, norb, dmat, h0mat )
c
c         Cutoff spherical-atom Exc term from matrix on ihamsfl:
          call READBIG( iexc0fl, matsiz, h0mat )
          call DOTRACE( exc0trc, norb, dmat, h0mat )
c
c         Kinetic energy from matrix on ihamsfl:
          call READBIG( ih0tfl , matsiz, h0mat )
          call DOTRACE( ekintrc, norb, dmat, h0mat )
c
c         Non-local pseudopotential energy from matrix on ihamsfl:
          call READBIG( ih0nlfl , matsiz, h0mat )
          call DOTRACE( pseutrc, norb, dmat, h0mat )
c
          if( master .ne. kmasterpr )then
c           Get del-Ham traces from k-master (if it is not master)
            call MPRECVR8( kmasterpr, lentrc, vtrk, icomm )
            vtrc = vtrc + vtrk(1)
            if( nspin .eq. 2 ) vtrcdn = vtrcdn + vtrk(2)
          endif
c
c         End master-only component traces
        elseif( iproc .eq. kmasterpr )then
c         The k-master sends its del-Ham traces to image master
c
c         The following if-statement is redundant with this if-black
          if( master .ne. kmasterpr )then
            call MPSENDR8( master, lentrc, vtrk, icomm )
          endif
c
        endif
c
c       End of k-point loop acquiring dmat(k) and doing traces
  250 continue
c
      vtrc = vtrc + vtrcdn
c
      traces(1) = vtrc
      traces(2) = h0trc
      traces(3) = vxc0trc
      traces(4) = exc0trc
      traces(5) = ekintrc
      traces(6) = pseutrc
c
c  Non-master processors return here ...
  300 continue
c
c     Broadcast result to everyone from master (synchronization step)
c
      lentrc = 6
      if( nprocs.gt.1 ) call MPBCAST8( master, lentrc, traces, icomm )
      vtrc    = traces(1)
      h0trc   = traces(2)
      vxc0trc = traces(3)
      exc0trc = traces(4)
      ekintrc = traces(5)
      pseutrc = traces(6)
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c        Put all the terms together and output analysis
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c non-standard 1c es term:
      esns1c = half*(ves1ctr-ves1c0)
      vxcengy = vxc0trc + vtrc - (vesgrxc + ves1ctr + vesnr)
      esnsengy = esnsgr + esns1c + esnsnr + engydfld
      engnoxc = h0trc - vxc0trc + atm0engy + esnsengy
c
c Break down details of xc energy evaluation
      exc0ptnr = xc0val(3)
      exc0wtnr = xc0val(4)
      cor0fix = -xc0val(5) + xc0val(6)
      corfast =  xc0val(7)
      exc0fix = -xc0val(1) + xc0val(2) + cor0fix
      exc0slo =  xc0val(8) - xc0val(9)
c
      if( nearopt.eq.1 )then
        exc0nr = exc0ptnr
      elseif( nearopt.eq.2 )then
        exc0nr = exc0wtnr
      else
        exc0nr = zero
      endif
      excnr0 = excnr - exc0nr
      eslofix = exc0slo - exc0nr
c
c Compute total xc energy using different schemes:
      excraw = exctot
      excpas = exc0trc + excslo + exc1c + excnr + corfast + cor0fix
      excnew = excpas + exc0slo - exc0nr
c
c Select xc energy to use, and construct total energy:
      excengy = excnew
      engytotl = engnoxc + excengy
c
      ecoulo   = engnoxc - ekintrc - pseutrc
c
c More detailed breakdown of xc-energy as diagnostics:
      if( lstout.gt.3 )then
        write(IWR,9010) 'VXCtrc0,vtrc   =',vxc0trc,vtrc
        write(IWR,9010) 'VESves1c,1c0,es=',ves1ctr,ves1c0,esns1c
        write(IWR,9010) 'VXCvesgr,1c,nr =',vesgrxc,ves1ctr,vesnr
        write(IWR,9010) ' esns(sl,1c,nr)=',esnsgr,esns1c,esnsnr
        write(IWR,*)'$$$$$$$$$$$$$$$$$$$ EXC ANALYSIS $$$$$$$$$$$$$$$$$'
        write(IWR,9010) 'EXC0(gr,at,fix)= ',xc0val(1),xc0val(2),exc0fix
        write(IWR,9010) 'CORE(fst,sl,fix)=',corfast,corslow,cor0fix
      endif
      etotraw = engnoxc + excraw
      etotpas = engnoxc + excpas
      etotnew = engnoxc + excnew
      if( lstout.gt.3 )then
        if( nearopt.eq.1 )then
          write(IWR,9010) 'EXCnr(0,it,dif)=',exc0ptnr,excnr,excnr0
        elseif( nearopt.eq.2 )then
          write(IWR,9010) 'EXCwt(0,it,dif)=',exc0wtnr,excnr,excnr0
        else
          excnr0 = zero
        endif
        write(IWR,9010) 'EXC0slo,nr,dif=',exc0slo,exc0nr,eslofix
        write(IWR,9010) 'EXCgrd,1c,nr0=', exctot, exc1c, excnr0
        write(IWR,9010) 'EXCtrc,slo,nr=', exc0trc,excslo,excnr
        write(IWR,9010)' **** total energy without EXC =       ',engnoxc
        write(IWR,9010) 'EXC(raw,pas,new) =',excraw, excpas, excnew
        write(IWR,9010) 'Etot with EXC =   ',etotraw,etotpas,etotnew
        write(IWR,*) ' '
      endif
c     Note that "corslow"=INT(delexc*rhocor) contained in excslo
c
c Output full energy analysis:
c
      write(IWR,*)
     $'######################  ENERGY ANALYSIS  #######################'
      if( lstout.gt.0 )then
        write(IWR,9010)'Spherical-atom es ENERGY correction =', atm0engy
        write(IWR,9010)'Full spherical atom trace ENERGY =   ', h0trc
        write(IWR,9010)'Spherical-atom-Vxc trace ENERGY =    ',-vxc0trc
        write(IWR,9010)'non-spherical es ENERGY =            ', esnsengy
        write(IWR,9010)'Total Exc ENERGY =                   ', excengy
        write(IWR,*)
        write(IWR,9010)'total kinetic trace ENERGY =   ', ekintrc
        write(IWR,9010)'non-local ps-pot trace ENERGY =', pseutrc
        write(IWR,9010)'total electrostatic ENERGY =   ', ecoulo
        write(IWR,9010)'Total Vxc ENERGY =             ', vxcengy
        if( do_field )then
        es_nofield = esnsengy - engydfld
        write(IWR,9010)'non-spherical ENERGY w/o field =', es_nofield
        write(IWR,9010)'Total electric-field ENERGY =   ', engydfld
        endif
      endif
      write(IWR,*)
      write(IWR,9010)'TOTAL ENERGY (Rydberg) =             ', engytotl
      if( ABS( engypol ) .gt. 1.d-6 )then
        write(IWR,9010) 'Bulk polarization ENERGY(Ry) =',-ABS( engypol )
        write(IWR,9010) 'TOTAL ENERGY w/bulk polarization=',
     $    engytotl - ABS( engypol )
      endif
      write(IWR,*)
      write(IWR,*)
     $'################################################################'
c
      RETURN
c
c    That's all Folks!
c
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DOSDUMP
c
c
      subroutine DOSDUMP( ipostfl,
     $ nspin, norb,nstate,nk,ncplx, natm,ntyp,nshld,nald,
     $ itypa,numshl,lshel,
     $ ala,cala,nala,
     $ temp, efermi, eigval,eigpop,wtk,veck, typnm )
c---------------------------------------------------------------
c Purpose: write out data necessary to compute DOS and properly
c          identify the data
c
c Written: 30-May-2001, for v2.47
c
c Revision history:
c   9Sep14-PAS/2.66: cosmetics (units/params)
c   3May12-ACP&AHE/2.63:  output ityp, 11Oct12-PAS: fix format
c  29May10-AHE&PAS/2.61k: fix formating problems
c   9Apr07-AHE&PAS/2.59c: new output for dosdump put into master
c  15Sep05-AHE/2.58: placed contracted basis set information for
c                    matrix element calculations
c  11Dec01-PAS/2.51: add spin, pop, temp output; self-doc labels
c  31Oct01-PAS/2.50: naming convention change
c  30May01-PAS/2.47: modified Art Edwards code for output
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
c
c input arrays:
      DIMENSION  itypa(natm), numshl(ntyp), lshel(nshld,ntyp)
      DIMENSION nala(nshld,ntyp),ala(nald,nshld,ntyp),
     $     cala(nald,nshld,ntyp)
      DIMENSION  efermi(*)
      DIMENSION  eigval(*),eigpop(*)
      DIMENSION  wtk(nk),veck(3,nk)
      CHARACTER*(*)  typnm(ntyp)
c
c local declarations:
c     basis function labels
      CHARACTER*6  orblbl(9)
      DATA  orblbl / 's     ','x     ','y     ','z     ',
     $      'xy    ','yz    ','zx    ','x2-y2 ','3z2-r2' /
c
c >>>> EXECUTABLE CODE:
c
 9000 format(a)
c Output the parameters that define the size of everything:
      write(ipostfl,9000) 'norb,ntyp,nstate,nk,ncplx,nspin'
      write(ipostfl,9011)  norb,ntyp,nstate,nk,ncplx,nspin
 9011 format( 6(1x,i6) )
c
c Output fermi level(s) and temperature for occupying states:
      if( nspin.eq.1 )then
        write(ipostfl,9000) 'fermi level and electron temperature (Ry)'
      else
        write(ipostfl,9000) 'fermi levels (up/dn) and temperature (Ry)'
      endif
      write(ipostfl,9021)  (efermi(ispin),ispin=1,nspin), temp
 9021 format( 5(1x,f14.8) )
 9023 format( 3(1x,f14.8) )
c
c Output weights for k-vectors ...
      write(ipostfl,9000) 'weights for k-points'
      write(ipostfl,9021)  (wtk(k), k=1,nk)
c
c Output k-vectors (in cartesian coordinates)
      write(ipostfl,9000) 'k-points (bohr^-1)'
      write(ipostfl,9023)  ((veck(ic,ik),ic=1,3),ik=1,nk)
c  ... and output the eigenvalues:
      nksp = nstate*nk*nspin
      write(ipostfl,9000)
     $  'eigval (((i,k,isp),i=1,nstate),k=1,nk),isp=1,nspin (Ry)'
      write(ipostfl,9021) (eigval(iksp),iksp=1,nksp)
c  ... and output the level occupations:
      write(ipostfl,9000)
     $  'eigpop (((i,k,isp),i=1,nstate),k=1,nk),isp=1,nspin'
      write(ipostfl,9021) (eigpop(iksp),iksp=1,nksp)
c
c Output of orbital id information:
      write(ipostfl,9000) 'labels for basis functions and atoms'
      write(ipostfl,9041)
 9041 format(1x,'  bf# ',1x,' atm#',1x,'bftype',1x,'atomname',1x,
     &     'atomtype')
 9042 format(1x,   i6,   1x,   i5,  1x,   a6,   1x, a8, 1x, i2)
      iorb = 0
      do  iatm=1,natm
        ityp = itypa(iatm)
        nshl = numshl(ityp)
        do  ishl=1,nshl
          lshl = lshel(ishl,ityp)
          norbat = 2*lshl + 1
          lmorb = lshl**2
          do  iorbat=1,norbat
            iorb = iorb + 1
            lmorb = lmorb + 1
cACP            write(ipostfl,9042)  iorb,iatm,orblbl(lmorb),typnm(ityp)
            write(ipostfl,9042)iorb,iatm,orblbl(lmorb),typnm(ityp),ityp
          enddo
        enddo
      enddo
c
c Output the (segmented) internal basis set contractions:
      write(ipostfl,9000) 'contracted basis fcns for each atom type'
      write(ipostfl,9043)  (numshl(ityp),ityp=1,ntyp)
      do  ityp=1,ntyp
         nshl = numshl(ityp)
         write(ipostfl,9043)  (nala(ishl,ityp),ishl=1,nshl)
         write(ipostfl,9043)  (lshel(ishl,ityp),ishl=1,nshl)
         do  ishl=1,nshl
            nal = nala(ishl,ityp)
            write(ipostfl,9044)  (ala(ial,ishl,ityp),ial=1,nal)
            write(ipostfl,9044)  (cala(ial,ishl,ityp),ial=1,nal)
         enddo
      enddo
 9043 format(5(2x,i2))
 9044 format(5(2x,f15.8))
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DOTRACE
c
c
      subroutine DOTRACE( trace, norb, dmat,vmat )
c---------------------------------------------------------------
c Purpose: take trace of matrix with (complex) density matrix
c
c Written: Peter A. Schultz, 7-June-1993
c
c Revision history:
c   5Dec07-PAS/2.60c: split off entry DO0TRACE from DOTRACE
c  23Jul01-PAS/2.49: compact dmat; wtk norm convention
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  23Jul98-PAS/2.23: split basis
c  29Apr97-PAS/2.17: spherical atom trace do0trace installed
c---------------------------------------------------------------
c
c Variables:
c   trace  - output trace = Tr[dmat*vmat]
c   norb   - number of orbitals/dimension of matrices
c   dmat(i,j) - input complex density matrix
c   vmat(i,j) - matrix elements of quantity to be traced
c       (i,j real part i>j; imag part j>i)
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c Input arrays:
      DIMENSION  dmat(norb,norb)
      DIMENSION  vmat(norb,norb)
c
c >>>> EXECUTABLE CODE:
c
      diag = zero
      do  i=1,norb
        diag = diag + dmat(i,i)*vmat(i,i)
      enddo
c
      offd = zero
      do  i=2,norb
        do  j=1,i-1
          offd = offd + dmat(i,j)*vmat(i,j) + dmat(j,i)*vmat(j,i)
        enddo
      enddo
c
      trace = trace + diag + offd + offd
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DO0TRACE
c
c
      subroutine DO0TRACE( trace0,  norb, natm,ntyp,nshld,
     $ itypa,numshl,lshel, occij, wtk, vmat )
c---------------------------------------------------------------
c Purpose: take trace of matrix with (complex) density matrix
c
c Written: Peter A. Schultz, 7-June-1993 (in DOTRACE)
c
c Revision history:
c   5Dec07-PAS/2.60c: split off entry DO0TRACE from DOTRACE
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c Input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  occij(nshld,nshld,ntyp)
c
      DIMENSION  vmat(norb,norb)
c
c >>>> EXECUTABLE CODE:
c
c  Compute trace of spherical-atoms = Tr[ dmat-atom0 x V]:
c
      tii = zero
      tij = zero
      i0 = 0
      do 100 iatm=1,natm
        ityp = itypa(iatm)
        nshli = numshl(ityp)
        istart = i0
        i0 = istart
        do 90 ishl=1,nshli
          lshli = lshel(ishl,ityp)
          norbshi = 2*lshli + 1
          j0 = istart
          do 80 jshl=1,ishl
            lshlj = lshel(jshl,ityp)
            norbshj = 2*lshlj + 1
            occ = occij(ishl,jshl,ityp)
            if( occ.ne.zero )then
              sum = zero
              do  iorbsh=1,norbshi
                sum = sum + occ*vmat(i0+iorbsh,j0+iorbsh)
              enddo
              if( ishl.eq.jshl )then
                tii = tii + sum
              else
                tij = tij + sum
               endif
            endif
            j0 = j0 + norbshj
   80     continue
          i0 = i0 + norbshi
   90   continue
  100 continue
c
c  I need to double off-diags as only tracing triangle
      trace0 = trace0 + wtk*(tii + tij + tij)
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DUPEMAT
c
c
      subroutine DUPEMAT( nd, kv, rv, nv,rvset )
c---------------------------------------------------------------
c Purpose: find a match, if there is one, for a candidate
c          vector in a set of vectors.
c
c Written: Peter A. Schultz, 4-January-1999, for v2.30
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c  Variables:
c   nd      - dimension of vector
c   rv()    - vector to be checked
c   rvset() - set of vectors to be checked against
c   nv      - number of vectors in set to be checked against
c   kv      - index of matched vector (0 if there is none)
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  rv(nd), rvset(nd,*)
c
c  criteria for difference:
      DATA  vsmall / 2.d-6 /
c
c >>>> EXECUTABLE CODE
c
      kv = 0
      do 20 iv=1,nv
        do 10 id=1,nd
          dif = ABS( rv(id) - rvset(id,iv) )
          if( dif.gt.vsmall ) goto 20
   10   continue
        kv = iv
        goto 90
   20 continue
c
   90 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DVSTRES
c
c
      subroutine DVSTRES( IWR, ndim, vstress,
     $ n1r,n2r,n3r,nptr,weight, gprim,ws1,ws2,ws3,ftarray,
     $ rhoslo,  espot,rhofft )
c---------------------------------------------------------------
c Purpose: assemble hartree stress-potential for volume term
c
c Written: P.J. Feibelman, 10/12/90
c
c Revision history:
c  27Sep99-PAS/2.40: full three-dimensional stress tensor
c   9Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c Notes:
c  Only need the diagonal terms.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c output array:
      DIMENSION  vstress(3,3)
c input arrays:
      DIMENSION  rhoslo(nptr)
      DIMENSION  gprim(3,3)
c scratch arrays:
      DIMENSION  ws1(*),ws2(*),ws3(*), ftarray(*)
      DIMENSION  espot(2,nptr),rhofft(2,nptr)
c local declarations:
      DIMENSION  ave(2)
      DIMENSION  g(3),g2(3),g3(3)
      DATA  extra / 1.d-15 /
      DATA  zero, eight / 0.d0, 8.d0 /
      DATA  lstout / 0 /
      DATA  IWRT / 0 /
c
c >>>> EXECUTABLE CODE:
c
      eightpi = eight*pi
c
      if( lstout.gt.2 ) IWRT = IWR
      if( lstout.gt.1 )
     $ call GRIDAVE(IWR,n1r,n2r,n3r,1,rhoslo,ave,ftarray,'slow density')
c
      call MKZERO( 2*nptr, espot )
      call DCOPY( nptr, rhoslo,1, espot,2 )
c
c  Fourier transform density:
c
      call CFFT3D( espot, n1r,n2r,n3r, ws1,ws2,ws3, ftarray )
c
c  Set rho(g=0), ie. net charge, to zero:
c
      indexg0 = (n1r+2)/2 + n1r*(n2r/2) + n1r*n2r*(n3r/2)
      defect = weight*DBLE(nptr)*espot(1,indexg0)
      if( lstout.gt.2 )
     $ write(IWR,900) indexg0, espot(1,indexg0),espot(2,indexg0)
      if( lstout.gt.0 )
     $ write(IWR,910) 'charge defect (electrons)=',defect
  900 format(/1x,'indexg0=',i8,'; rho(g=0)=',1p2d22.12)
  910 format(1x,a,1p2d22.12)
c
      espot(1,indexg0) = zero
      espot(2,indexg0) = zero
      if( ndim.gt.1 )  call DCOPY( 2*nptr, espot,1, rhofft,1 )
c
      f1 = DBLE((n1r+2)/2)
      f2 = DBLE((n2r+2)/2)
      f3 = DBLE((n3r+2)/2)
c
c  Compute 0.5*Hartree stress potential in g-space.
c
      do 1000 idim=1,ndim
c
        if( idim.gt.1 )  call DCOPY( 2*nptr, rhofft,1, espot,1 )
c
        do  i=1,3
          g3(i) = - f1*gprim(i,1) - f2*gprim(i,2) - f3*gprim(i,3)
        enddo
c
        nr = 0
        do 53 j3=1,n3r
          do  i=1,3
            g3(i) = g3(i) + gprim(i,3)
            g2(i) = g3(i)
          enddo
          do 52 j2=1,n2r
            do  i=1,3
              g2(i) = g2(i) + gprim(i,2)
              g(i)  = g2(i)
            enddo
            do 51 j1=1,n1r
              g(1) = g(1) + gprim(1,1)
              g(2) = g(2) + gprim(2,1)
              g(3) = g(3) + gprim(3,1)
              gsq = g(1)*g(1) + g(2)*g(2) + g(3)*g(3)
              gsqsq = gsq*gsq + extra
              gii = g(idim)*g(idim)
              gfac = eightpi*gii/gsqsq
              nr = nr + 1
              espot(1,nr) = gfac*espot(1,nr)
              espot(2,nr) = gfac*espot(2,nr)
   51       continue
   52     continue
   53   continue
c
c  Fourier transform it back to coordinate space
c
        call CFFT3DB( espot, n1r,n2r,n3r, ws1,ws2,ws3, ftarray )
c
        call GRIDAVE( IWRT, n1r,n2r,n3r,2,espot,ave,ftarray, 'slow Ves')
c
c  Compute contribution to electrostatic stress:
c
c PAS: why is a vacuum potential not extracted here?
        esstres = zero
        do  nr=1,nptr
          esstres = esstres + rhoslo(nr)*espot(1,nr)
        enddo
        vstress(idim,idim) = esstres*weight
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DYLM
c
c
      subroutine DYLM( ylm,gradylm,lmax,r )
c---------------------------------------------------------------
c Purpose: Calculate real spherical harmonics for
c      m=0,l=0,1,...,lmax;m=1,l=1,2,...,lmax;...;m=lmax,l=lmax
c
c Revision history:
c  11Mar02-PAS/2.52: last literal reals to d0
c  21Jun01-PAS/2.48: replace STOPs
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c  2*(lmax+1)**2 real ylm's are stored in the complex array "ylm."
c  The real ylm's are defined by:
c                   m=0         m.ne.0
c      ylm-plus  =  ylm    sqrt(2.)*real(ylm)
c      ylm-minus =   0     sqrt(2.)*imag(ylm)
c  ylm-pluses returned real part of "ylm", ylm-minus in imaginary
c
c  Also calculate:   rmag**(-l) * grad (rmag**l * ylmreal)
c  These results are returned in the array "gradylm"
c  To generate gradylm's, make use of the inhomogeneous recursion
c  formula they satisfy, which can be applied once the ylm's known
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DOUBLE COMPLEX    ylm(*),gradylm(3,*)
c local declarations:
      DOUBLE COMPLEX    recur
      DIMENSION  r(3)
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /
c
c >>>> EXECUTABLE CODE:
c
      sq2 = SQRT( two )
      rpsq = r(1)**2 + r(2)**2
      rpar = SQRT( rpsq )
      rsq = r(3)**2 + rpsq
      rmag = SQRT( rsq )
      if( rmag.eq.zero ) call STOPXERR( 'dylm-r=0' )
c
c    Compute theta and phi
c
      costh = r(3)/rmag
      sinth = rpar/rmag
      if( rpar.eq.zero )then
        sinph = zero
        cosph = one
      else
        cosph = r(1)/rpar
        sinph = r(2)/rpar
      endif
c
c    Compute ylm's
c
      lmaxp1 = lmax + 1
      rtom = one
      do 100 mm=1,lmaxp1
        m = mm - 1
        mstore = 1 + (lmax+2)*m - (m*(m+1))/2
        mstmm1 = 1 + (lmax+2)*(m-1) - (m*(m-1))/2
        call YMM( ylm(mstore),sinth,cosph,sinph,m )
        gradylm(3,mstore) = zero
        if( m.eq.0 )then
          gradylm(1,1) = zero
          gradylm(2,1) = zero
        else
          ylm(mstore) = ylm(mstore)*sq2
          recur = -SQRT( DBLE((2*m+1)*2*m) )*ylm(mstmm1)*rtom/two
          rtom = rtom*rmag
          if( mstmm1.eq.1 ) recur = recur*sq2
          gradylm(1,mstore) = recur
          gradylm(2,mstore) = recur*(0.d0,1.d0)
        endif
        if( m.eq.lmax ) goto 110
c
        mstore = mstore + 1
        sq2mp3 = SQRT( DBLE(2*m+3) )
        ylm(mstore) = sq2mp3*costh*ylm(mstore-1)
        recur = sq2mp3*r(3)
        do 20 n=1,3
          gradylm(n,mstore)=recur*gradylm(n,mstore-1)
   20   continue
        gradylm(3,mstore) = gradylm(3,mstore) + sq2mp3*rtom*
     $   ylm(mstore-1)
        if(m.eq.lmax-1) goto 100
c
c    Generate remaining ylm's by recursion
c
        mp2 = m + 2
        rtol = rmag**m
        do 90 l=mp2,lmax
          mstore = mstore + 1
          call YRECUR( clp1m,clm,l-2,m )
          ylm(mstore) = costh*clp1m*ylm(mstore-1) - clm*ylm(mstore-2)
          do 30 n=1,3
            gradylm(n,mstore) = clp1m*r(3)*gradylm(n,mstore-1) -
     $       clm*(rsq*gradylm(n,mstore-2)+two*r(n)*rtol*ylm(mstore-2))
   30     continue
          gradylm(3,mstore) = gradylm(3,mstore) +
     $     clp1m*rtol*rmag*ylm(mstore-1)
          rtol = rtol*rmag
   90   continue
c
  100 continue
c
c    Scale gradylm's so the output includes rmag**(-l)
c
  110 mstore = 0
      do 200 mm=1,lmaxp1
        m = mm - 1
        rtol = rmag**m
        do 190 ll=mm,lmaxp1
          mstore = mstore + 1
          do 180 n=1,3
            gradylm(n,mstore) = gradylm(n,mstore)/rtol
  180     continue
          rtol = rtol*rmag
  190   continue
  200 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> EF2DM
c
c
      subroutine EF2DM( IWR,lvlout,doblas3,npop0k,npopdm,nbox,noboxs )
c---------------------------------------------------------------
c Purpose: determine number of occupied states at which the cost
c          of the density matrix (DM) scheme for generating the
c          density on the grid becomes cheaper the eigenfunction
c          (EF) scheme.
c
c Written: Peter A. Schultz, 22-May-2001, for v2.47
c
c Revision history:
c   8Jan08-PAS/2.61: min/max orb-in-box diagnostic added
c  28Jun02-PAS/2.54: add comment to document, fix output diagnostics
c   3Dec01-PAS/2.51: purge uninitialized variable
c  18May01-PAS/2.47: extract from main routine
c---------------------------------------------------------------
c
c  Summed over boxes, the DM scheme costs SUM[ nobox*(nobox+1)/2 ]
c  and the EF scheme costs SUM[ nobox*numpop ], where nobox is the
c  number of orbitals having non-negligible density in a box, and
c  numpop is the number of occupied levels.
c  The rub: the explicit code takes advantage of the symmetric/
c  Hermitian density matrix to do only triangle of matrix, while
c  the code employing blas3 does a full square because the sym-blas3
c  is slower than full-blas3 (why? who knows). Hence, the crossover
c  depends on whether we have blas3 on or off.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  noboxs(nbox)
      LOGICAL    doblas3
c
c >>>> EXECUTABLE CODE:
c
c Silence output if invalid write unit
      lvlprnt = lvlout
      if( IWR .lt. 0 ) lvlprnt = -1
c
      minobox = noboxs(1)
      maxobox = noboxs(1)
      nsum = 0
      n2sum = 0
      n3sum = 0
      do  ibox=1,nbox
        nobox = noboxs(ibox)
        if( nobox .lt. minobox ) minobox = nobox
        if( nobox .gt. maxobox ) maxobox = nobox
        if( nobox.gt.0 )then
          nsum = nsum + nobox
c         In the following arithmetic, I remove nobox*npop0k
c         from the sum in order to keep n?sum small so that
c         this arithmetic does not overflow the integer variable.
c         I add SUM[nobox*npop0k] = SUM[nobox]*npop0k later
c         when I add to npopdm: npop0k = SUM[nobox*npop0k]/nsum
          n2sum = n2sum + (nobox*(nobox+1-2*npop0k)) / 2
          n3sum = n3sum + nobox*(nobox-npop0k)
        endif
      enddo
c
      if( doblas3 )then
c       Using full rectangle in dm density routines with blas3
        npopdm = npop0k + (n3sum+nsum-1)/nsum
      else
c       Using triangle only in dm compiled density routines
        npopdm = npop0k + (n2sum+nsum-1)/nsum
      endif
c
      if( lvlprnt.gt.1 )then
        write(IWR,*) 'Turnover EF->DM npopdm, npop0k=',npopdm,npop0k
        if( lvlout.gt.2 )then
          write(IWR,'(1x,a,2i7)')  'EF2DM: grid boxes(nbox)=', nbox
          aveobox = DBLE( nsum ) / DBLE( nbox )
          write(IWR,'(1x,a,f8.2,2(1x,i6))') 'Ave/min/max orbitals/box=',
     $     aveobox, minobox, maxobox
        endif
        if( lvlprnt.gt.4 )then
          if( doblas3 )then
            write(IWR,'(1x,a,2i12)') 'EF: n3sum,nsum=',n3sum,nsum
          else
            write(IWR,'(1x,a,2i12)') 'EF: n2sum,nsum=',n2sum,nsum
          endif
        endif
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> EIGSOLV
c
c
      subroutine EIGSOLV(
     $ icluster, gapp,
     $ do_eigvecs,do_eigpops, idosolv,scut, nspin,
     $ idhamfl,iham0fl,iovlpfl,
     $ ivecfl, idmatfl,idmatsfl, iematfl,iematsfl,
     $ icloseocc,dokdefct,doblas3, ikdefct,nstbulk,
     $ etemp,edegen, elecno, efermi,egap, esumsp,
     $ norb,nstate, nk, veck,wtk, eigval,eigpop,npop, wksml,
     $ wmat )
c---------------------------------------------------------------
c Purpose: calling routine to solve for density matrix, given
c          hamiltonian and overlap matrices of current iteration
c
c Written: Peter A. Schultz
c
c Revision history:
c   3May12-ACP/2.64: Add vector/pop flags (PAS) to support nonscf
c  22Sep08-PAS/2.62: spin-split dmat/emat
c  12Jan08-PAS/2.61: spin optimization
c  25Jun07-PAS/2.60: merge tp and serial
c  11Sep05-PAS/2.59: remove schroed lin.dep.-based dynamic mem
c  14Aug05-PAS/2.59: read multi-k Hams
c  15Feb05-PAS/2.59: options to impose 0K occs, and defect sampling
c   8Aug03-PAS/2.56: cosmetics: clean up k-vector usage
c   5Oct01-PAS/2.50: remove backspace, and compress restart
c  20Jul01-PAS/2.49: spin-polarized dft, fpop made scratch, dmat
c  17May01-PAS/2.47: extract listing output (eigenspectrum)
c  23Aug99-PAS/2.38: install zhegvx/selected eigvec solver
c  10May99-PAS/2.35: eigenfunction grid density, pass npop
c   9Apr99-PAS/2.34: complex lapack eigensolver installed
c  31Mar99-PAS/2.33: clean out green fcn stuff, tighten mem use
c   9Feb99-PAS/2.31: pass write unit into routine
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  14Jul98-PAS/2.23: pass option for un-chol'd d-Ham into schroed
c  10Oct97-PAS/2.21: change convention for fpop
c  13Sep93-PAS: rhoofr extracted out of routine, calling arguments
c               rationalized, dimensions fixed, renamed "eigsolv"
c---------------------------------------------------------------
c
c  On input, idhamfl contains full input delta-hamiltonian.
c  To obtain full hamiltonian, delta-H needs to be combined with
c  H0 (computed in setup and saved in iham0fl; overlap in iovlpfl),
c  done in routine "schroed", which also solves the Schroedinger
c  eqn. Routine "pop" populates the resulting levels and finds the
c  fermi energy, then "rhoij" takes the eigenfcns and occupations
c  and builds and saves to disk the density matrix for each k-vector.
c
c  When this routine is done:
c   (1) eigenvectors are saved to "ivecfl" (if do_eigvecs)
c   (2) density matrix is saved to "idmat" (and if do_eigpops)
c   (3) energy-weighted density matrix is saved to "iemat"
c   (4) eigenvalue spectrum is returned in "eigval()" (not written)
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c Input:
      LOGICAL    do_eigvecs, do_eigpops
      LOGICAL    dokdefct
      LOGICAL    doblas3
      DIMENSION  veck(3,nk),wtk(nk)
      DIMENSION  elecno(2)
      DIMENSION  nstbulk(2)
c Output:
      DIMENSION  efermi(2),egap(2)
      DIMENSION  eigval(nstate*nk,nspin),eigpop(nstate*nk,nspin)
c Scratch:
      DIMENSION  wksml(norb,*)
      DIMENSION  wmat(*)
c Scratch/parallel:
      INTEGER    icluster(*)
      DIMENSION  gapp(*)
c
c Local:
      DATA       itimlog / 0 /
      DIMENSION  occlvl(2)
      DATA       occlvl / 2.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
c  Solve Schroedinger equation for the various k-vectors
c
      mat = norb*norb
      nmat = nk*mat
c
c Partition space within wmat() for schroed:
      iw1 = 1
      iww = iw1 + mat
      nwsch = norb*(4*norb + 2*nstate)
      iwx = iww + nwsch
c
      call MPNODES( nproc )
      call MPNODE( iproc )
      call MPNODE0( masterp )
      if( iproc .eq. masterp )then
c       Go to start of idhamfl, to get ready for dHam reads
        REWIND( unit=idhamfl )
c       Go to start of ivecfl, to get ready for eigvec writes
        REWIND( unit=ivecfl )
      endif
c
      if( itimlog.gt.0 ) call TIMER( 'eigsolv/begin      ' )
c
      if( nproc.eq.1 .or. nk.gt.1 )then
c       Parallel over k-points - single-proc solves
c
        do  ispin=1,nspin
c
          call SCHROED( do_eigvecs,
     $     idhamfl,iham0fl,iovlpfl,ivecfl, idosolv,
     $     norb,nstate,nk, eigval(1,ispin), wksml,    wksml(1,9), scut,
c -->                                       rwork-7ns seval(n)-s
     $     wmat(iw1), wmat(iww), wmat(iwx) )
c -->      vmat-s     wmat-6ks   iwork-6ns
c
          if( itimlog.gt.1 ) call TIMER( 'eigsolv/psch2 k-par' )
        enddo
c
      else
c       Parallel solvers
c
c       Not available here:
        call STOPXERR( 'Parallel solver not enabled' )
c
      endif
c
      if( .not. do_eigpops )then
c       Skip state populations and density-matrix construction
        RETURN
      endif
c
c  Evaluate density matrix in diagonal (eigfcn) representation
c
      nstk = nstate*nk
c
      npop = 0
      esumsp = zero
      occfull = occlvl(nspin)
c
      do  ispin=1,nspin
        elnumbr = elecno(ispin)
c
        if( ( icloseocc .gt. 0 ) .or. dokdefct )then
c         Use closed-shell occupations, or defect sampling
          call POPCLOSE( icloseocc,dokdefct,ikdefct,
     $     efermi(ispin),egap(ispin), nstbulk(ispin),
     $     etemp,edegen, elnumbr,esum1e, occfull,
     $     nstate,nk, wtk, eigval(1,ispin),eigpop(1,ispin),numpop,
     $     wmat )
c -->      wlvl-s(nstate)
c
        else
c         Use standard metallic occupations, spin
          mspin = 1
          call POP( mspin, popnumbr,
     $     efermi(ispin),egap(ispin),
     $     etemp,        elnumbr,esum1e, occfull,
     $     nstate,nk, wtk, eigval(1,ispin),eigpop(1,ispin),numpop,
     $     wmat(1), wmat(1+nstk),wmat(1+2*nstk),
     $     wmat(1+3*nstk), wmat(1+4*nstk) )
c -->      elvl wlvl klvl nlvl flvl - all scratch (nk*state)
        endif
c
        npop = MAX( npop,numpop )
        esumsp = esumsp + esum1e
      enddo
c
      if( itimlog.gt.0 ) call TIMER( 'eigsolv/pop        ' )
c
      if( .not. do_eigvecs )then
c       Do not compute density matrix if do not have vectors ...
        RETURN
      endif
c
c  Evaluate density matrix in orbital basis
c
      mat = norb*norb
c
      call MPNODES( nproc )
      call MPNODE( iproc )
      call MPNODE0( masterp )
      if( iproc .eq. masterp )then
        REWIND( unit=ivecfl )
        REWIND( unit=idmatfl )
        REWIND( unit=iematfl )
        if( nspin.eq. 2 )then
          REWIND( unit=idmatsfl )
          REWIND( unit=iematsfl )
        endif
      endif
      iw1 = 1
      iw2 = iw1 + mat
      iw3 = iw2 + mat
c
      idmfile = idmatfl
      iemfile = iematfl
      do  ispin=1,nspin
c
        if( nk .ge. nproc )then
c         Then distribute full k-points over processors
c
          call RHOIJ( ivecfl, idmfile,iemfile,
     $     norb,nstate,nk,
     $     eigval(1,ispin),eigpop(1,ispin),wksml,npop, wtk,
     $     wmat(iw1), wmat(iw2), wmat(iw3) )
c -->      dmat-(2)s  emat-s     eigvec-2s(n,nst)
c
        else
c         Distribute every k-point over all processors
c
c         Not available in serial
          call STOPXERR( 'Parallel dmat not enabled' )
c 
        endif
c       Switch to spin-dn:
        idmfile = idmatsfl
        iemfile = iematsfl
c
      enddo
      if( itimlog.gt.0 ) call TIMER( 'eigsolv/rhoij      ' )
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000
characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> EQTRIP
c
c
      subroutine EQTRIP( ntest, iateq,jateq,iatm,jatm,nuc,
     $ natm, itypa,ratm )
c---------------------------------------------------------------
c Purpose: look through previous atom triplets to see if earlier
c          triplet of same atom types separated by same vectors.
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION itypa(natm),ratm(3,natm)
      LOGICAL  ntest
c NB: this term must be identical in eqtrip and gttrip and it is a
c     good idea to use some "odd" number to prevent accidental match
      DATA  rtol / 9.96340732d-7 /
c
      ntest = .false.
      if( iatm.ge.jatm )then
        ntrip = jatm + (iatm-1)*natm + (nuc-1)*natm**2
      else
        ntrip = iatm + (jatm-1)*natm + (nuc-1)*natm**2
      endif
      do 100 nuceq=1,natm
        if( itypa(nuceq).ne.itypa(nuc) ) goto 100
        do 50 iateq=1,natm
          if( itypa(iateq).ne.itypa(iatm) ) goto 50
          do 10 jr=1,3
            dr = ratm(jr,iatm)  - ratm(jr,nuc)
     $         - ratm(jr,iateq) + ratm(jr,nuceq)
            if( ABS(dr).gt.rtol ) goto 50
   10     continue
          do 40 jateq=1,iateq
            neqtrip = jateq + (iateq-1)*natm + (nuceq-1)*natm**2
            if( neqtrip.ge.ntrip ) RETURN
            if( itypa(jateq).ne.itypa(jatm) ) goto 40
            do 20 jr=1,3
              dr = ratm(jr,jatm)  - ratm(jr,nuc)
     $           - ratm(jr,jateq) + ratm(jr,nuceq)
              if( ABS(dr).gt.rtol ) goto 40
   20       continue
            ntest = .true.
            RETURN
   40     continue
   50   continue
  100 continue
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GTTRIP
c
c
      entry GTTRIP( ntest, iateq,jateq,nateq,iatm,jatm,nuc,
     $ natm, itypa,ratm )
c---------------------------------------------------------------
c Purpose: look through later atom pairs to see if later
c          triplet of same atom types separated by same vectors.
c---------------------------------------------------------------
c
      ntest = .false.
      if( iatm.ge.jatm )then
        ntrip = jatm + (iatm-1)*natm + (nuc-1)*natm**2
      else
        ntrip = iatm + (jatm-1)*natm + (nuc-1)*natm**2
      endif
      if( itypa(nateq).ne.itypa(nuc) )RETURN
      do 150 iateq=1,natm
        if( itypa(iateq).ne.itypa(iatm) ) goto 150
        do 110 jr=1,3
          dr = ratm(jr,iatm)  - ratm(jr,nuc)
     $       - ratm(jr,iateq) + ratm(jr,nateq)
          if( ABS(dr).gt.rtol ) goto 150
  110   continue
        do 140 jateq=1,iateq
          neqtrip = jateq + (iateq-1)*natm + (nateq-1)*natm**2
          if( neqtrip.le.ntrip ) goto 140
          if( itypa(jateq).ne.itypa(jatm) ) goto 140
          do 120 jr=1,3
            dr = ratm(jr,jatm)  - ratm(jr,nuc)
     $         - ratm(jr,jateq) + ratm(jr,nateq)
            if( ABS(dr).gt.rtol ) goto 140
  120     continue
          ntest = .true.
          RETURN
  140   continue
  150 continue
c
      RETURN
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ERLSOLV
c
c
      subroutine ERLSOLV(
     $ idosolv,scut, nspin,
     $ idhamfl,iham0fl,iovlpfl,
     $ ivecfl, idmatfl,idmatsfl, iematfl,iematsfl,
     $ icloseocc, doblas3,
     $ etemp,edegen, elecno, efermi,egap, esumsp,
     $ norb,nstate, wtk, eigval,eigpop,sefp,npop, iwork,ifail, lwork4,
     $ vmat,  tempio )
c---------------------------------------------------------------
c Purpose: solve real (double precision) Schroedinger equation
c
c Written: Dave Raczkowski and Peter A. Schultz
c
c Revision history:
c  10Jan13-PAS/2.64: add (here, dummy) tempio arg to simplify seq/mpi
c  22Sep08-PAS/2.62: split smat/spin files; 14Nov-perlsolv compatibility
c  08Jun05-RPM/2.59: added ability to do a canonical orthogonalization
c                    to remove linear dependence in the basis set
c  15Feb05-PAS/2.59: add option to impose closed shell occs
c   8Mar02-PAS/2.52: clean unused/const d0; closed-spin bug
c   5Oct01-PAS/2.50: remove backspace, and compress restart
c  20Jul01-PAS/2.49: spin-polarized dft, compact dmat
c  21Jun01-PAS/2.48: replace STOPs
c  17May01-PAS/2.47: extract listing output (eigenspectrum)
c  20Dec00-PAS/2.46: patch for small basis problems
c  20Aug99-PAS/2.38: bugfix in call to dsygvx; full dsygvx
c                    implemented, doblas3 passed
c  10May99-PAS/2.35: eigenfunction grid density, pass npop
c   2Apr99-PAS/2.33: tighten big memory usage
c  15Feb99-PAS/2.31: routine to intercept perhaps too-big i/o
c  11Feb99-PAS/2.31: adapted for archival code
c---------------------------------------------------------------
c
c Notes:
c  The routine dsygvx, unlike dsygv, is not standard lapack.
c  Dave Raczkowski found the routine dsygvx that is used here
c  for solving the eigenproblem.  It is typically 2X faster
c  than solving the full eigenproblem using dsygv. 23Aug99
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
      DIMENSION  wtk(1), elecno(nspin)
      DIMENSION  vmat(norb,norb,*)
      LOGICAL    doblas3
c Output:
      DIMENSION  efermi(nspin),egap(nspin)
      DIMENSION  eigval(nstate,nspin),eigpop(nstate,nspin)
c Scratch:
c     sefp first used to store eigenvalues of S in algorithm
c     to remove linear dependence from basis, and then as
c     occupation factor to set up density matrix construction
      DIMENSION  sefp(nstate)
      DIMENSION  iwork(5*norb),ifail(norb)
c Scratch/parallel:
      DIMENSION  tempio(*)
c
c Local:
      LOGICAL    closeshl
      DIMENSION  npops(2)
      DIMENSION  occlvl(2)
      DATA       occlvl / 2.d0,1.d0 /
      LOGICAL    pos,neg
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
      DATA  elcerr,elconv / 1.d-6,1.d-11 /
c     "occupied" criterion for constructing number of occupied levels
      DATA  occnil / 1.d-9 /
c
c >>>> EXECUTABLE CODE:
c
      mat = norb*norb
c
      REWIND( unit=ivecfl )
c
      do 100 ispin=1,nspin
c
        call RSCHROED( idosolv,scut,ispin,nspin,
     $   idhamfl,iham0fl,iovlpfl, ivecfl,
     $   norb,nstate,eigval(1,ispin),
     $   sefp,iwork,ifail,lwork4,vmat)
c
  100 continue
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c   Construct level populations, i.e. dmat in diagonal representation
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
crpm Misc Notes:
c     vmat(,,1)   Eigenvectors
c     vmat(,,2)   Destroyed H
c     vmat(,,3)   S
c     vmat(,,4)   Scratch
c
      npop = 0
      esumsp = zero
      occfull = occlvl(nspin)
c
c Set closed shell flag if to populate using 0K
      closeshl = .false.
      if( icloseocc .eq. 2 ) closeshl = .true.
c
      do 300 ispin=1,nspin
        elnumbr = elecno(ispin)
c
        call POP1K( closeshl,
     $   fermilvl,gap,ehomo,elumo,
     $   etemp,edegen, elnumbr,occfull,
     $   nstate,numpop, wtk(1),
     $   eigval(1,ispin),eigpop(1,ispin), sefp )
c -->                                     fpop
c
        efermi(ispin) = fermilvl
        egap(ispin) = gap
        npops(ispin) = numpop
        npop = MAX( npop, numpop )
c
        esum1e = zero
        do  i=1,numpop
          esum1e = esum1e + eigpop(i,ispin)*eigval(i,ispin)
        enddo
        esumsp = esumsp + wtk(1)*esum1e
  300 continue
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c       Construct density-matrix, e-matrix over basis functions
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if( nspin .eq. 2 )then
c       Then vectors are NOT in mem, must read
        REWIND( unit=ivecfl )
      endif
      REWIND( unit=idmatfl )
      REWIND( unit=iematfl )
      if( nspin .eq. 2 )then
c       Rewind the spin-dn mats files
        REWIND( unit=idmatsfl )
        REWIND( unit=iematsfl )
      endif
      idmfile = idmatfl
      iemfile = iematfl
c
      do 400 ispin=1,nspin
        if( nspin .eq. 2 )then
c         Retrieve spin-dependent eigenstates (in mem if non-spin)
          call READBIG( ivecfl, norb*nstate, vmat(1,1,1) )
        endif
        call RRHOIJ( doblas3,
     $       idmfile,iemfile,
     $       norb,nstate,
     $       eigval(1,ispin),eigpop(1,ispin),sefp,
     $       npops(ispin),wtk(1),
     $       vmat(1,1,3),vmat(1,1,4),vmat(1,1,1),vmat(1,1,2))
c       Switch to dn-spin:
        idmfile = idmatsfl
        iemfile = iematsfl
  400 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000
characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ESLOFRC
c
c
      subroutine ESLOFRC( IWR, do_gga, ndim,
     $ frcesl,stresl, frcxc0,strxc0, frcxcc,strxcc,
     $ xcalcut,xcfac,xcrhocut,  natm,ntyp,nshld,nald, nlat  ,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ znuc,occsh,  nrd,nrcor,radmsh,corden, y2, u,  ratm,rlat,
     $ hh, weight, ndbox,nbox,nrec,inrec,noboxs,inboxs, boxrad,
     $ wkr, frctp,
     $ ves, rv )
c---------------------------------------------------------------
c Purpose: compute grid force term from spherical atom es, and
c          get "phantom" force from grid due to spherical xc
c
c Written: Peter A. Schultz, 17-December-1998, v2.30
c
c Revision history:
c  11May07-PAS/2.60: merged tp and serial
c   6Jul06-APT/2.59: merged task parallel and image parallel
c  23Jan06-PAS/2.59: align tp/serial
c  24Sep04-PAS:2.59-tp: clean-up task-parallel routines
c   6May03-DMC: Add local copies of the three frc* arrays, an array to
c               hold a local copy of the str* arrays, and work space
c               to hold a second copy of each array.  This space is
c               contiguous, and thus can be distributed across procs
c               with a single send.  All this for parallelization.
c   6Nov04-PAS/2.58a: add dGGA stress analytic-grid correction
c   8Apr02-PAS/2.53: gga stress
c   7Mar02-PAS/2.52: explicit constants to d0.
c  15Nov00-PAS/2.46: GGA
c  18Nov99-PAS/2.42: phantom stress terms for xc
c  27Sep99-PAS/2.40: full three-dimensional stress tensor
c  23Sep99-PAS/2.39: countercharge bug: fix density derivatives
c  22Sep99-PAS/2.39: simple bugfix (thx Dave Raczkowski)
c---------------------------------------------------------------
c
c Note:
c  This routine modelled off the "grid0xc" routine.
c
c  *** NB *** Changes to this routine should only be done in
c  tandem with changes to "grid0xc" and "potnr0".
c
c  The use of cutoffs in this routine should be compatible
c  with that used in calculating the grid wave functions.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
c Output arrays:
      DIMENSION  frcesl(3,natm), stresl(3,3)
      DIMENSION  frcxc0(3,natm), strxc0(3,3)
      DIMENSION  frcxcc(3,natm), strxcc(3,3)
c Input arrays:
      LOGICAL    do_gga
      DIMENSION  itypa(natm)
      DIMENSION  numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $  nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  znuc(ntyp)
      DIMENSION  occsh(nshld,ntyp)
      DIMENSION  nrcor(ntyp),radmsh(nrd,*),corden(nrd,*)
      DIMENSION  ratm(3,natm),rlat(3,*), hh(3,3)
      DIMENSION  ndbox(2,2,3),noboxs(nbox),inboxs(nrec,nbox)
      DIMENSION  ves(*)
c Scratch arrays:
      DIMENSION  y2(*),u(*)
      DIMENSION  rv(3,*), wkr(*)
c parallel scratch:
      DIMENSION  frctp(3,natm,6)
      DIMENSION  strtp(3,3,10)
c
c Local declarations:
      DIMENSION  strdxc0(3,3),strdxcc(3,3)
      DIMENSION  stre(3,3),strx(3,3),strc(3,3), strd0(3,3),strdc(3,3)
      DIMENSION  ratom(3), r0box(3),boxctr(3)
      LOGICAL  poorho, cntrch
      DATA  gdrho / 0.001d0 /, badrho / 0.05d0 /, cutocc / 0.9d-8 /
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
      DATA  three / 3.d0 /
      DATA  alcutfac / 1.33333333d0 /
c flag for additional output 0-none/1-some/2-full
      DATA  lstout  / 0 /
c
c Statement function:
      LOGICAL    EVEN
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      fourpi = pi + pi + pi + pi
      argmx = half*cutgaus
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
      call MKZERO( 3*natm, frcesl )
      call MKZERO( 9, stresl )
      call MKZERO( 3*natm, frcxc0 )
      call MKZERO( 9, strxc0 )
      call MKZERO( 3*natm, frcxcc )
      call MKZERO( 9, strxcc )
c
      call MKZERO( 9, strdxc0 )
      call MKZERO( 9, strdxcc )
c
      if( lstout.gt.0 )  write(IWR,9010)
 9010 format(/1x,'ESLOFRC: analysis on grid of isolated atom forces')
c
      nlatmx = 1
c
c >>>>>>>>>> Cycle over atoms:
c
c  Initialize bitmap index for shell/box occupancy:
      irec00 = 0
      inbox00 = 0
      iatshl00 = 0
      iorb00 = 0
c
      do 1000 iatm=1,natm
        ityp = itypa(iatm)
c
        nshli = nocc(ityp)
c
c       Initialize shell/box bitmap index for this atom ...
        irec0 = irec00
        inbox0 = inbox00
        iatshl0 = iatshl00
c        ... and prepare index for the *next* atom:
        do  ishl=1,numshl(ityp)
          inbox00 = 2*inbox00
          if( inrec*(iatshl00/inrec).eq.iatshl00 )then
            irec00 = irec00 + 1
            inbox00 = 1
          endif
          iatshl00 = iatshl00 + 1
        enddo
c
c       Each processor will do every nprocs element in this loop.
        if( MOD( iatm, nprocs ) .ne. iproc ) goto 1000
c
        noccsh = 0
        occatxc = zero
        occatm = zero
        almina = 9.d9
        do 38 ishl=1,nshli
          lshl = locc(ishl,ityp)
          occshl = occsh(ishl,ityp)
          if( occshl.eq.zero ) goto 38
c
          occatm = occatm + occshl
          if( occshl.gt.zero ) occatxc = occatxc + occshl
          noccsh = noccsh + 1
c
          almins = alsh(1,ishl,ityp)
          do  ial=2,nalsh(ishl,ityp)
            ali = alsh(ial,ishl,ityp)
            if( ali.lt.almins ) almins = ali
          enddo
          if( almins.lt.almina ) almina = almins
   38   continue
c
        if( noccsh.eq.0 ) goto 1000
c
        rhoatm = zero
        rhoatxc = zero
        coratm = zero
        vxcatm = zero
        vxcfst = zero
        vxcasl = zero
        excatm = zero
        excfst = zero
        excasl = zero
        exccor = zero
        corfst = zero
        fxat = zero
        fyat = zero
        fzat = zero
        fxc = zero
        fyc = zero
        fzc = zero
        fxes = zero
        fyes = zero
        fzes = zero
        call MKZERO( 9, strx )
        call MKZERO( 9, stre )
        call MKZERO( 9, strc )
        call MKZERO( 9, strd0 )
        call MKZERO( 9, strdc )
c
c       Bring out xc slow/fast function parameters
c
        alminxc = two*almina
        if( xcalcut.lt.zero ) alminxc = -xcalcut*almina
        alcutxc = alcutfac*alminxc
        if( xcalcut.gt.zero ) alcutxc = xcalcut
c
        nrsc = nrcor(ityp) + 1
        if( nrsc.ne.1 )then
c         Interpolate core density
          ddy0 = 1.d31
          ddy1 = 1.d31
          call SPLINE(nrsc,radmsh(1,ityp),corden(1,ityp),ddy0,ddy1,y2,u)
        endif
c
        rngatm = SQRT( cutgrid / (almina+almina) )
c
c       Cycle over boxes:
c
        irpot = 0
        do 300 ibox=1,nbox
c
c         Get basic box info
          call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $     ira0,irb0,irc0, idra,idrb,idrc )
          nrbox = idra*idrb*idrc
c
          iv0 = irpot
          irpot = irpot + nrbox
c
          nobox = noboxs(ibox)
          if( nobox.le.0 ) goto 300
c
          call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
          call MKRBOX( hh,r0box, idra,idrb,idrc, rv )
c
c         Set up for scratch space below:
          ir0 = 0
          irsq  = ir0
          irngr = ir0 +  1*nrbox
          iatrh = ir0 +  2*nrbox
          icnrh = ir0 +  3*nrbox
          idrho = ir0 +  4*nrbox
          icndr = ir0 +  5*nrbox
          icore = ir0 +  6*nrbox
          idcor = ir0 +  7*nrbox
          ia0e  = icore
          ia1e  = idcor
          ia2e  = ir0 +  8*nrbox
          iddrh = ir0 +  9*nrbox
          inext = iddrh + nrbox
c         I neglect this memory check as I am in BIG workspace
c          if( inext.gt.mxwkrd )
c     $     call STOPXERR( 'ESLOFRC: not enough scratch memory' )
c
c         Lattice loop:
c
          do 900 ilat=1,nlat
c
            rngbox = zero
            do  jr=1,3
              ratom(jr) = ratm(jr,iatm) + rlat(jr,ilat)
              rngbox = rngbox + (ratom(jr)-boxctr(jr))**2
            enddo
            rngbox = SQRT( rngbox ) - boxrad
            if( rngbox.gt.rngatm ) goto 900
c
            rsqbox = rngbox**2
            if( rngbox.lt.zero ) rsqbox = zero
c
            if( ilat.gt.nlatmx ) nlatmx = ilat
c
c           Generate r**2 on mesh ...
            do  nr=1,nrbox
              wkr(irsq+nr) = ( rv(1,nr) - ratom(1) )**2
     $                     + ( rv(2,nr) - ratom(2) )**2
     $                     + ( rv(3,nr) - ratom(3) )**2
              wkr(irngr+nr) = SQRT( wkr(irsq+nr) )
              wkr(iatrh+nr) = zero
              wkr(icnrh+nr) = zero
              wkr(idrho+nr) = zero
              wkr(icndr+nr) = zero
              wkr(iddrh+nr) = zero
            enddo
c
c           Shell loop:
c
            irec = irec0
            inbox = inbox0
            iatshl = iatshl0
            do 800 ishl=1,nshli
              lshl = locc(ishl,ityp)
              twol = DBLE( 2*lshl )
c
              occshl = occsh(ishl,ityp)
              if( occshl.eq.zero ) goto 800
c
              cntrch = .false.
              if( occshl.lt.zero ) cntrch = .true.
c
c             Determine if shell occupies box.
c             NB: Box occupancy was set using *basis* shells, not the
c             occupied shells, and must convert to shell occupancy.
c
c             Determine min alpha for this *occupancy* shell
              almins = alsh(1,ishl,ityp)
              do  ial=2,nalsh(ishl,ityp)
                ali = alsh(ial,ishl,ityp)
                if( ali.lt.almins ) almins = ali
              enddo
c
c             Cycle over *basis* shells here, and try to find the
c              basis shell that best matches the occ shell above:
              irec = irec0
              inbox = inbox0
              iatshl = iatshl0
              keybox = 0
              alminl = zero
              do 58 jshl=1,numshl(ityp)
                inbox = 2*inbox
                if( inrec*(iatshl/inrec).eq.iatshl )then
                  irec = irec + 1
                  inbox = 1
                endif
                iatshl = iatshl + 1
                if( lshel(jshl,ityp).eq.lshl )then
c                 Determine min alpha for this *basis* shell
                  alminj = ala(1,jshl,ityp)
                  do  jal=1,nala(jshl,ityp)
                    alj = ala(jal,jshl,ityp)
                    if( alj.lt.alminj ) alminj = alj
                  enddo
                  if( alminj.eq.almins )then
c                   Perfect match, use this box occupancy
                    keybox = inboxs(irec,ibox) / inbox
                    goto 59
                  elseif( alminj.le.almins .and. alminj.gt.alminl )then
c                   Better match, provisionally load this box occupancy
                    keybox = inboxs(irec,ibox) / inbox
cpas: as of 2.58 this was unfortunately left out ... (inserted 2.60)
                    alminl = alminj
                  endif
                endif
c
   58         continue
   59         continue
c
              if( EVEN(keybox) ) goto 800
c
              nali = nalsh(ishl,ityp)
c
              almins = alsh(1,ishl,ityp)
              do  ial=2,nali
                ali = alsh(ial,ishl,ityp)
                if( ali.lt.almins ) almins = ali
              enddo
              almin = almina
              rsqshl = cutgrid / (almin +almins)
              if( rsqbox.gt.rsqshl ) goto 800
c
              do  nr=1,nrbox
                wkr(ia0e+nr) = zero
                wkr(ia1e+nr) = zero
                wkr(ia2e+nr) = zero
              enddo
c
              do 190 ial=1,nali
                ali = alsh(ial,ishl,ityp)
                cali = occshl*calsh(ial,ishl,ityp)
                cali0 = cali
c               Just do off-diags once, for Pete's sake:
                do 180 jal=ial,1,-1
                  alj = alsh(jal,ishl,ityp)
                  alsum = ali + alj
                  als2 = alsum*alsum
                  twoals = alsum + alsum
                  coef = cali*calsh(jal,ishl,ityp)/fourpi
c                 Double the off-diags:
                  cali = cali0 + cali0
c                 Looser cutoff used to get quicker convergence
                  algt = ali
                  if( alj.gt.ali ) algt = alj
                  twoalgt = algt + algt
                  twoalc = algt + almin
                  rsqcut = cutgrid/twoalc
c
c                 Skip if alphas too large
                  if( rsqbox.gt.rsqcut ) goto 180
c
c                 Sums: occ*Ca*Cb*(a+b)**n*exp(-(a+b)r**2); n=0,1,2
                  do  nr=1,nrbox
                    gauss = coef*EXP( -alsum*wkr(irsq+nr) )
                    wkr(ia0e+nr) = wkr(ia0e+nr) + gauss
                    wkr(ia1e+nr) = wkr(ia1e+nr) + gauss*alsum
                    wkr(ia2e+nr) = wkr(ia2e+nr) + gauss*als2
                  enddo
c
c                 Close alpha loops:
c
  180           continue
  190         continue
c
              if( do_gga .and. .not. cntrch )then
c               Assemble density and derivatives for GGA potential:
c
                call MKSHL2D( lshl, nrbox, wkr(irngr+1), wkr(irsq+1),
     $           wkr(ia0e+1),wkr(ia1e+1),wkr(ia2e+1),
     $           wkr(iatrh+1),wkr(idrho+1),wkr(iddrh+1) )
c
              else
c               Just need to assemble density and first derivatives ...
c
                if( cntrch )then
c                  ... to update compensating countercharge for es
                  iprho = icnrh
                  ipdrh = icndr
                else
c                  ... for LDA calculation (no second derivs needed)
                  iprho = iatrh
                  ipdrh = idrho
                endif
c
                call MKSHL1D( lshl, nrbox, wkr(irngr+1), wkr(irsq+1),
     $           wkr(ia0e+1),wkr(ia1e+1),
     $           wkr(iprho+1),wkr(ipdrh+1) )
c
              endif
c
c             Close shell loop:
c
  800       continue
c
c           Now check if we have core density to consider
c
            call MKZERO( nrbox, wkr(icore+1) )
            call MKZERO( nrbox, wkr(idcor+1) )
            if( nrsc.ne.1 )then
              rsqcut = radmsh(nrsc,ityp)**2
              if( rsqbox.gt.rsqcut ) goto 195
c
              if( do_gga )then
c               Do core 2nd deriv before 1st deriv, and use (idcor)
c               space for scratch  (do not need core 2nd deriv
c               separate from the total rho 2nd deriv).
c               Interpolate to get 2nd deriv. of core density ...
                call SPLIND2( nrsc, radmsh(1,ityp), corden(1,ityp),y2,
     $                        nrbox,wkr(irngr+1),wkr(idcor+1) )
c                ... and put into total 2nd deriv of density for GGA
                do  nr=1,nrbox
                  wkr(iddrh+nr) = wkr(iddrh+nr) + wkr(idcor+nr)
                enddo
              endif
c
c             Interpolate to get deriv. of core density ...
              call SPLIND( nrsc, radmsh(1,ityp),corden(1,ityp),y2,
     $                     nrbox,wkr(irngr+1),wkr(idcor+1) )
c
c             Interpolate to get core density on grid ...
              call SPLINT( nrsc, radmsh(1,ityp),corden(1,ityp),y2,
     $                     nrbox,wkr(irngr+1),wkr(icore+1) )
c
            endif
  195       continue
c
c         * * * * * * * * * * * * * * * * * * * * * * * * * * *
c             Have total isolated-atom density on this part
c                 of the grid; compute xc-quantities.
c         * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
            do 200 nr=1,nrbox
c
              rhoxc = wkr(iatrh+nr)
              rhoes = wkr(iatrh+nr) + wkr(icnrh+nr)
              corho = wkr(icore+nr)
              rhopt = rhoxc + corho
c
              if( rhopt.gt.xcrhocut )then
c
                if( do_gga )then
c
c                 Assemble gradient terms needed for GGA
c
                  rmag = wkr(irngr+nr)
                  if( rmag.gt.1.d-6 )then
c                   For r>0, general Cartesian derivs from radial
c                    ... note dcor already added into drho above
                    drh = wkr(idrho+nr) + wkr(idcor+nr)
c                    ... terms for Cartesian reference derivatives:
                    d1rhdr = drh/rmag
                    d2rh = wkr(iddrh+nr) - d1rhdr
c                    ... need gradients for atomic GGA potential
                    grho = ABS( drh )
                    g2rho = wkr(iddrh+nr) + two*d1rhdr
                    gpggp = grho*wkr(iddrh+nr)
                  else
c                   At r=0, dp/du=0, and only d2p/du2 survives limits ...
                    d2rh = wkr(iddrh+nr)
                    grho = zero
                    g2rho = three*wkr(iddrh+nr)
                    gpggp = zero
                  endif
c
                  call DFTGGA( rhopt, grho,g2rho,gpggp,
     $                         vxcpt,excpt, dxcpt,dxc2pt )
c
c                 End do_gga = .true.
                else
c                 do_gga = .false.
c
                  call DFTLDA( rhopt, vxcpt,excpt )
c
                endif
c
c               Construct "fast" xc-potentials, and update:
                cfac = EXP( -alcutxc*wkr(irsq+nr) )
                fstfcn = cfac / ( (one-xcfac)*cfac + xcfac )
c
                vfast = vxcpt*fstfcn
                vslow = vxcpt - vfast
                if( do_gga )then
                  dxcfast = fstfcn*dxcpt
                  dxc2fast = fstfcn*dxc2pt
                endif
c
                efast = excpt*fstfcn
                eslow = excpt - efast
c
c               Integrate atomic electron density and xc quantities
                rhoatm = rhoatm + rhoes
                rhoatxc = rhoatxc + rhoxc
                coratm = coratm + corho
                vxcatm = vxcatm + vxcpt*rhoxc
                vxcfst = vxcfst + vfast*rhoxc
                vxcasl = vxcasl + vslow*rhoxc
                excatm = excatm + excpt*rhoxc
                excfst = excfst + efast*rhoxc
                excasl = excasl + eslow*rhoxc
                exccor = exccor + excpt*corho
                corfst = corfst + efast*corho
c
                if( wkr(irngr+nr).gt.1.d-4 )then
                  dx = rv(1,nr) - ratom(1)
                  dy = rv(2,nr) - ratom(2)
                  dz = rv(3,nr) - ratom(3)
c
c                 Force due to slo grid es potential
                  drhoes = wkr(idrho+nr) + wkr(icndr+nr)
                  vesrpt = drhoes*ves(iv0+nr)/wkr(irngr+nr)
                  fxes = fxes + vesrpt*dx
                  fyes = fyes + vesrpt*dy
                  fzes = fzes + vesrpt*dz
                  stre(1,1) = stre(1,1) + vesrpt*dx*dx
                  stre(2,1) = stre(2,1) + vesrpt*dy*dx
                  stre(3,1) = stre(3,1) + vesrpt*dz*dx
                  stre(1,2) = stre(1,2) + vesrpt*dx*dy
                  stre(2,2) = stre(2,2) + vesrpt*dy*dy
                  stre(3,2) = stre(3,2) + vesrpt*dz*dy
                  stre(1,3) = stre(1,3) + vesrpt*dx*dz
                  stre(2,3) = stre(2,3) + vesrpt*dy*dz
                  stre(3,3) = stre(3,3) + vesrpt*dz*dz
c
c                 Phantom xc force grid term
c                 Note: d(rho)/dx = (d(rho)/dr)*(dr/dx); dr/dx = x/r
                  drhoxc = wkr(idrho+nr)
                  vxcrpt = drhoxc*vfast/wkr(irngr+nr)
                  fxat = fxat + vxcrpt*dx
                  fyat = fyat + vxcrpt*dy
                  fzat = fzat + vxcrpt*dz
                  strx(1,1) = strx(1,1) + vxcrpt*dx*dx
                  strx(2,1) = strx(2,1) + vxcrpt*dy*dx
                  strx(3,1) = strx(3,1) + vxcrpt*dz*dx
                  strx(1,2) = strx(1,2) + vxcrpt*dx*dy
                  strx(2,2) = strx(2,2) + vxcrpt*dy*dy
                  strx(3,2) = strx(3,2) + vxcrpt*dz*dy
                  strx(1,3) = strx(1,3) + vxcrpt*dx*dz
                  strx(2,3) = strx(2,3) + vxcrpt*dy*dz
                  strx(3,3) = strx(3,3) + vxcrpt*dz*dz
                  if( do_gga )then
c                   Phantom GGA stress grid term
                    dxcrpt = ( dxcfast * wkr(idrho+nr)**2 +
     $                         dxc2fast* wkr(iddrh+nr) )
     $                       / wkr(irsq+nr)
                    strd0(1,1) = strd0(1,1) - dxcrpt*dx*dx
                    strd0(2,1) = strd0(2,1) - dxcrpt*dy*dx
                    strd0(3,1) = strd0(3,1) - dxcrpt*dz*dx
                    strd0(1,2) = strd0(1,2) - dxcrpt*dx*dy
                    strd0(2,2) = strd0(2,2) - dxcrpt*dy*dy
                    strd0(3,2) = strd0(3,2) - dxcrpt*dz*dy
                    strd0(1,3) = strd0(1,3) - dxcrpt*dx*dz
                    strd0(2,3) = strd0(2,3) - dxcrpt*dy*dz
                    strd0(3,3) = strd0(3,3) - dxcrpt*dz*dz
                  endif
                  if( nrsc.ne.1 )then
c                   Phantom xc force grid term (core)
                    vxcrpt = wkr(idcor+nr)*vfast/wkr(irngr+nr)
                    fxc = fxc + vxcrpt*dx
                    fyc = fyc + vxcrpt*dy
                    fzc = fzc + vxcrpt*dz
                    strc(1,1) = strc(1,1) + vxcrpt*dx*dx
                    strc(2,1) = strc(2,1) + vxcrpt*dy*dx
                    strc(3,1) = strc(3,1) + vxcrpt*dz*dx
                    strc(1,2) = strc(1,2) + vxcrpt*dx*dy
                    strc(2,2) = strc(2,2) + vxcrpt*dy*dy
                    strc(3,2) = strc(3,2) + vxcrpt*dz*dy
                    strc(1,3) = strc(1,3) + vxcrpt*dx*dz
                    strc(2,3) = strc(2,3) + vxcrpt*dy*dz
                    strc(3,3) = strc(3,3) + vxcrpt*dz*dz
                    if( do_gga )then
c                     Phantom GGA stress grid term (core)
                      dxcrpt = ( dxcfast * wkr(idcor+nr)**2 )
     $                         / wkr(irsq+nr)
c                     Note that d2cor part inside ddrh above
                      strdc(1,1) = strdc(1,1) - dxcrpt*dx*dx
                      strdc(2,1) = strdc(2,1) - dxcrpt*dy*dx
                      strdc(3,1) = strdc(3,1) - dxcrpt*dz*dx
                      strdc(1,2) = strdc(1,2) - dxcrpt*dx*dy
                      strdc(2,2) = strdc(2,2) - dxcrpt*dy*dy
                      strdc(3,2) = strdc(3,2) - dxcrpt*dz*dy
                      strdc(1,3) = strdc(1,3) - dxcrpt*dx*dz
                      strdc(2,3) = strdc(2,3) - dxcrpt*dy*dz
                      strdc(3,3) = strdc(3,3) - dxcrpt*dz*dz
                    endif
                  endif
                endif
c
              endif
c
  200       continue
c
c           Close lattice loop:
c
  900     continue
c
c         Close box loop:
c
  300   continue
c
        fxes = weight*fxes
        fyes = weight*fyes
        fzes = weight*fzes
        frcesl(1,iatm) = -fxes
        frcesl(2,iatm) = -fyes
        frcesl(3,iatm) = -fzes
        fxat = weight*fxat
        fyat = weight*fyat
        fzat = weight*fzat
        frcxc0(1,iatm) = -fxat
        frcxc0(2,iatm) = -fyat
        frcxc0(3,iatm) = -fzat
        fxc = weight*fxc
        fyc = weight*fyc
        fzc = weight*fzc
        frcxcc(1,iatm) = -fxc
        frcxcc(2,iatm) = -fyc
        frcxcc(3,iatm) = -fzc
c
        do  jd=1,ndim
          do  id=1,ndim
            stresl(id,jd) = stresl(id,jd) - weight*stre(id,jd)
            strxc0(id,jd) = strxc0(id,jd) - weight*strx(id,jd)
            strxcc(id,jd) = strxcc(id,jd) - weight*strc(id,jd)
            strdxc0(id,jd) = strdxc0(id,jd) - weight*strd0(id,jd)
            strdxcc(id,jd) = strdxcc(id,jd) - weight*strdc(id,jd)
          enddo
        enddo
c
        rhoatm = weight*rhoatm
        rhoatxc = weight*rhoatxc
        coratm = weight*coratm
        vxcatm = weight*vxcatm
        vxcfst = weight*vxcfst
        vxcasl = weight*vxcasl
        excatm = weight*excatm
        excfst = weight*excfst
        excasl = weight*excasl
        exccor = weight*exccor
        corfst = weight*corfst
c
        grderr = ABS( rhoatm - znuc(ityp) )
        poorho = grderr .gt. gdrho
        if( lstout.gt.0 .or. poorho )then
 9021     format(1x,'Atom',i4,'   Z=',f5.1,'   occ=',f6.2,
     $              '   rho=',f14.10,'   core=',f14.10)
 9022     format( 5x, a, 5(1x,f12.8) )
          write(IWR,9021) iatm,znuc(ityp),occatm,rhoatm,coratm
          if( ABS(rhoatxc-rhoatm).gt.cutocc )
     $    write(IWR,9031)                        rhoatxc
 9031     format(1x,'    ',4x,'     ',5x  ,'       ',5x,
     $              'rho(xc)=',f14.10)
        endif
        if( lstout.gt.1 .or. poorho )then
          write(IWR,9022) 'vxc(afs ): ',vxcatm,vxcfst,vxcasl
          write(IWR,9022) 'exc(afs ): ',excatm,excfst,excasl
          if( nrsc.ne.1 )then
            write(IWR,9022) 'core(af): ',exccor,corfst
            write(IWR,9022) 'ectot',excatm+exccor,excfst+corfst,excasl
          endif
        endif
        if( lstout.gt.3 )then
          write(IWR,9023)'at,xc0frc=',iatm,fxat,fyat,fzat
          write(IWR,9023)'at,corfrc=',iatm,fxc,fyc,fzc
          write(IWR,9023)'at,vesfrc=',iatm,fxes,fyes,fzes
 9023     format(1x,a,i3,3x,3f12.8)
        endif
c
c       Close atom loop:
c
 1000 continue
c
      if( nprocs .gt. 1 )then
c       Each processor has forces/stress from its part if the grid.
c       Need to sum these into a single array, on master (node 0).
c       For now, also broadcast total back to all processors.
c
c       ... load all the force stuff into packed scratch space ...
        do  iatm=1,natm
          do  id=1,3
            frctp(id,iatm,4) = frcesl(id,iatm)
            frctp(id,iatm,5) = frcxc0(id,iatm)
            frctp(id,iatm,6) = frcxcc(id,iatm)
          enddo
        enddo
c
c        ... sum it onto master
        nreduc = 3*3*natm
        call MPREDUC8( master, nreduc,frctp(1,1,4),frctp(1,1,1),icomm )
C        call MPI_Reduce( frctp(1,1,4), frctp(1,1,1), nreduc,
C     $   MPI_DOUBLE_PRECISION, MPI_SUM,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'peslofrc - Reduce frc' )
c
c        ... broadcast summed total to everybody
        call MPBCAST8( master, nreduc, frctp , icomm )
C        call MPI_Bcast( frctp, nreduc, MPI_DOUBLE_PRECISION,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'peslofrc - Bcast frc' )
c
c        ... and put the final total forces where they belong:
        do  iatm=1,natm
          do  id=1,3
            frcesl(id,iatm) = frctp(id,iatm,1)
            frcxc0(id,iatm) = frctp(id,iatm,2)
            frcxcc(id,iatm) = frctp(id,iatm,3)
          enddo
        enddo
c
c       Repeat for process for the stress:
        do  jd=1,3
          do  id=1,3
            strtp(id,jd, 6) = stresl(id,jd)
            strtp(id,jd, 7) = strxc0(id,jd)
            strtp(id,jd, 8) = strxcc(id,jd)
            strtp(id,jd, 9) = strdxc0(id,jd)
            strtp(id,jd,10) = strdxcc(id,jd)
          enddo
        enddo
        nreduc = 5*9
        call MPREDUC8( master, nreduc,strtp(1,1,6),strtp(1,1,1),icomm )
C        call MPI_Reduce( strtp(1,1,4), strtp(1,1,1), nreduc,
C     $   MPI_DOUBLE_PRECISION, MPI_SUM,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'peslofrc - Reduce str' )
        call MPBCAST8( master, nreduc, strtp , icomm )
C        call MPI_Bcast( strtp, nreduc, MPI_DOUBLE_PRECISION,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'peslofrc - Bcast str' )
        do  jd=1,3
          do  id=1,3
            stresl(id,jd) = strtp(id,jd,1)
            strxc0(id,jd) = strtp(id,jd,2)
            strxcc(id,jd) = strtp(id,jd,3)
            strdxc0(id,jd) = strtp(id,jd,4)
            strdxcc(id,jd) = strtp(id,jd,5)
          enddo
        enddo
c
c       End tp
      endif
c
c Put gga-specific stress terms into total stress terms:
      if( do_gga .and. ndim.gt.0 )then
        do  jd=1,ndim
          do  id=1,ndim
            strxc0(id,jd) = strxc0(id,jd) + strdxc0(id,jd)
            strxcc(id,jd) = strxcc(id,jd) + strdxcc(id,jd)
          enddo
        enddo
      endif
c
      if( do_gga .and. ndim.gt.0 )then
        if( lstout.gt.2 )then
          write(IWR,*) 'eslofrc-258a: add new gga stress terms'
          write(IWR,*) 'gga stress grid reference'
 9040     format(5x,3f12.6)
          do  jd=1,ndim
            write(IWR,9040) (strdxc0(id,jd), id=1,ndim)
          enddo
          write(IWR,*) 'gga stress core grid reference'
          do  jd=1,ndim
            write(IWR,9040) (strdxcc(id,jd), id=1,ndim)
          enddo
        endif
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> EVPRNT
c
c
      subroutine EVPRNT( IWR, lprnt, nspin, efermi,egap, npop,nocc0k,
     $ nstate,nk, wtk,eigval,eigpop )
c---------------------------------------------------------------
c Purpose: output computed levels and occupations
c
c Written: Peter A. Schultz, 9-February-1999, for v2.31
c
c Revision history:
c   8Apr15-PAS/2.66: snipped printout of occupied states
c  12Nov08-PAS/2.62: check nstate vs. npop for sufficiency
c   8Mar02-PAS/2.52: clean unused variables
c  19Dec01-PAS/2.51: side-by-side spin up/dn output
c  20Jul01-PAS/2.49: spin-polarized dft
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input arrays:
      DIMENSION  efermi(2),egap(2)
      DIMENSION  wtk(nk)
      DIMENSION  eigval(nstate,nk,nspin),eigpop(nstate,nk,nspin)
c
c Local declarations:
      CHARACTER*7  spinlbl, spinless,spinup,spindn
      DATA  spinless /'       '/
      DATA  spinup /'spin-up'/, spindn /'spin-dn'/
      DIMENSION  tlvl(4),tpop(4)
      CHARACTER*(14) hdglbl(3)
      CHARACTER      headg*80,elips*21
c
      DIMENSION  occlvl(2)
      DATA       occlvl / 2.d0,1.d0 /
c
      DATA  toev / 13.605805 d0 /
      DATA  nloprnt, nhiprnt, nmtprnt / 4,20,8 /
c
c >>>> EXECUTABLE CODE:
c
c Set spin-type label for eigenspectrum
      occfull = occlvl(nspin)
      if( nspin.eq.2 )then
        spinlbl = spinup
      else
        spinlbl = spinless
      endif
      hdglbl(1) =        'level/DN/occup'
      hdglbl(2) =        'level    occup'
      hdglbl(3) =        'level/UP/occup'
c
      mxset = 4
  911 format(/1x,'k-vector:', i8,3i21 )
  912 format( 1x,' weight:',3x,f9.6,3(12x,f9.6) )
  914 format( 9x,      a)
  915 format( i5,      4(f13.6,f8.4) )
  916 format( 4x, a, a, a, a )
c
  921 format(/1x,'k-vector:',i19,i42)
  922 format( 1x,' weight:',14x,f9.6,  33x,f9.6 )
      elips = '         ...      ...'
c
c >>>>> Write out fermi level/gap info:
c
      write(IWR,*)
      do 100 ispin=1,nspin
        evgap = egap(ispin)*toev
c
        write(IWR,910)  spinlbl, efermi(ispin),egap(ispin),evgap
  910   format(1x,a,' fermi level =',f12.6,' Ry,',
     $   3x,'gap(0K)=',f9.6,' Ry =',f6.3,' eV' )
c
c       Switch to dn-spin label
        spinlbl = spindn
  100 continue
c
c Check for sufficiency of nstate vs. npop
c
      nufstate = 0
      npopmx = npop
      if( npopmx .ge. nstate )then
c       We might have a problem here.
        nufstate = 1
c
        popzero = 0.00004
        do  ispin=1,nspin
          do  k=1,nk
            if( eigpop(nstate,k,ispin) .gt. popzero ) nufstate = 2
          enddo
        enddo
      endif
c
      if( lprnt.lt.2 .and. nufstate.lt.2 ) goto 900
c
c  Determine is skipping over occupied in print, and how many
        nskip = nocc0k - nloprnt - nhiprnt
        if( nskip .lt. 8 )  nskip = 0
        kset = mxset/nspin
c
c >>>>> Write out levels and occupations:
c
        mtprnt0 = nmtprnt
        if( lprnt.gt.2 ) mtprnt0 = nstate
c
        icn =  -4
        headg = ' '
        jspin = 0
        if( nspin.eq.2 ) jspin = 1
        do  k=1,4
          ic1 = icn + 8
          icn = icn + 21
          mspin = 2 + jspin
          headg(ic1:icn) = hdglbl(mspin)
          jspin = -jspin
        enddo
c
c Set up partial prints of occupied states
        do 300 k1=1,nk,kset
          kn = MIN( k1-1+kset, nk )
          k0 = k1 - 1
          mk = kn - k1 + 1
c
          nksp = mk*nspin
          if( nspin.eq.1 )then
            write(IWR,911) ( k,      k=k1,kn )
            write(IWR,912) ( wtk(k), k=k1,kn )
          else
            write(IWR,921) ( k,      k=k1,kn )
            write(IWR,922) ( wtk(k), k=k1,kn )
          endif
          nc = 21*nksp - 4
          write(IWR,914)  headg(1:nc)
          write(IWR,*) ' '
c
c         Limit number of empty orbitals that are printed out:
          iskip0 = 1
          mtprnt = mtprnt0
          partocc = occfull - 0.00002
          do 200 n=1,nstate
            noccs = 0
            iskip = iskip0
            iksp = 0
            do  k=k1,kn
              do  ispin=1,nspin
                iksp = iksp + 1
                tlvl(iksp) = eigval(n,k,ispin)
                tpop(iksp) = eigpop(n,k,ispin)
                if( tpop(iksp) .gt. 0.000001 ) noccs = noccs + 1
                if( tpop(iksp) .lt. partocc ) iskip = 0
              enddo
            enddo
            iskip0 = iskip
c
c           Determine if we skip this occupied state
            if( nskip .gt. 0 .and. n.gt.nloprnt .and. n.lt.nocc0k )then
              if( iskip.eq.1 .and. n.eq.(nloprnt+1) )then
c               Our first skipped occupied level, write out our skip
                write(IWR,916) (elips,iksp=1,nksp)
                goto 200
              elseif( iskip.eq.1 .and. n .le. (nocc0k-nhiprnt) )then
                goto 200
              endif
            endif
c
            if( noccs.eq.0 ) mtprnt = mtprnt - 1
            if( mtprnt.lt.0 )then
              if( n.lt.nstate )then
c               Need to put out highest computed (empty) level ...
                write(IWR,916) (elips,iksp=1,nksp)
                write(IWR,915) nstate,
     $           (( eigval(nstate,k,ispin), eigpop(nstate,k,ispin),
     $             ispin=1,nspin ), k=k1,kn )
              endif
c              ... and jump to new set of k-points:
              goto 300
            endif
            write(IWR,915) n,( tlvl(iksp),tpop(iksp), iksp=1,nksp )
  200     continue
c
  300   continue
c
  900 continue
c
      if( nufstate .eq. 1 )then
        write(IWR,*) '***** CAUTION: number of solved states=',nstate
        write(IWR,*) '>>>>> This is only marginally sufficient'
      elseif( nufstate .eq. 2 )then
        write(IWR,*) '***** ERROR: number of solved states=',nstate
        write(IWR,*) '>>>>> Not enough to catch all populated states'
        write(IWR,*) '>>>>> Specify larger number of states',
     $              ' using >states< keyword in run phase input'
        call STOPXERR( 'Insufficient states for populations' )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FDEFECT
c
c
      subroutine FDEFECT( IWR, ifdefct, natm, frc,fdefct,
     $ nsyma,rmatsym,naofsym )
c---------------------------------------------------------------
c Purpose: symmetrize force defect (non-zero net drift)
c
c Written: Peter A. Schultz, 18-May-2001, for v2.47
c
c Revision history:
c  18May01-PAS/2.47: extract from main routine
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  frc(3,natm)
      DIMENSION  fdefct(3)
      DIMENSION  rmatsym(*)
      DIMENSION  naofsym(natm,*)
c local declarations:
      DIMENSION  vec0(3)
      DATA  vec0 / 0.d0,0.d0,0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      if( ifdefct.gt.0 .and. ifdefct.le.natm )then
c
c  Check that symmetry leaves defect atom fixed,
c  If not, then it is not symmetry preserving to install
c  a force defect, and we must skip this correction
        do  isym=1,nsyma
          jatm = naofsym(ifdefct,isym)
          if( jatm.ne.ifdefct ) RETURN
        enddo
c
c  Atom is fixed by symmetry, install force defect:
C        call SYMVEC( 1,fdefct, vec0, nsyma, rmatsym )
        write(IWR,'(a,3f12.6)') 'Force f-defect ->',fdefct
        frc(1,ifdefct) = frc(1,ifdefct) - fdefct(1)
        frc(2,ifdefct) = frc(2,ifdefct) - fdefct(2)
        frc(3,ifdefct) = frc(3,ifdefct) - fdefct(3)
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FERMIPOP
c
c
      subroutine FERMIPOP( efermi,etemp, eltotl,nlvl,nocc,
     $ occfull, occlvl, elvl, wlvl )
c---------------------------------------------------------------
c Purpose: find occupations and elec# for given efermi and temp.
c          Use a Fermi-Dirac filling function.
c
c Written: Peter A. Schultz, 15-February-2005, for v2.59
c          (extracted from solver/pop routines
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c  Routine assumes eigenvalues are ordered in increasing order.
c  Filling factor of state with eigenvalue e(i), fermi level Ef,
c   and electronic temperature et is given by the Fermi-Dirac
c   distribution:
c         1 / ( 1 + exp[ {e(i)-Ef}/et ] )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER ( zero=0.d0, one=1.d0 )
c
c Input:
      DIMENSION  elvl(nlvl), wlvl(nlvl)
c Output:
      DIMENSION  occlvl(nlvl)
c
c Local:
c   cutocc=argument cutoff for exp, to take exp(-tol)=0
c   Probably tol=19. is good enough (r*4 filling precision)
c   but we give it a little extra here just to be safe
c   We could also use a limit expansion computing the
c   filling factor for the larger exponents, but why?
      DATA  cutocc  / 30.d0 /
c
c >>>> EXECUTABLE CODE:
c
c  Standard Fermi-Dirac filling function
c
      elsum = zero
      do 210 ilvl=1,nlvl
        tol = cutocc
        xp = ( elvl(ilvl) - efermi ) / etemp
        if( xp .lt. -tol )then
          ff = one
        elseif( xp .lt. tol )then
          ff = one / ( one + EXP( xp ) )
        else
          ff = zero
          goto 211
        endif
        occlvl(ilvl) = ff*occfull
        elsum = elsum + occlvl(ilvl)*wlvl(ilvl)
        nocc = ilvl
  210 continue
  211 continue
c
      eltotl = elsum
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FFTDRHO
c
c
      subroutine FFTDRHO( idrhofl,  n1r,n2r,n3r,nptr,
     $ ws1,ws2,ws3,ftarray,
     $ rho,gvec, rhog, drhog )
c---------------------------------------------------------------
c Purpose: compute density derivatives from grid density via fft
c
c Written: Peter A. Schultz, 9-November-2000, for v2.46 (gga)
c
c Revision history:
c  26Jun07-PAS/2.60: task-parallel
c  20Jul01-PAS/2.49: spin-polarized dft, move rewind up.
c---------------------------------------------------------------
c
c First and second derivatives of the density are written to
c disk file unit "idrhofl" in order: X,Y,Z, XX,YY,ZZ, XY,YZ,ZX
c
c Can either keep, or destroy, rho() depending on "keeprh".
c rho() is preserved in this code.
c
c Transform the density p(r) into reciprocal space via FFT:
c    p(r) = SUM[G]: C[G] * exp(iG.r)
c C[G] are complex values obtained via forward fft of p(r)
c The real space derivatives of p(r) are taken in recip space:
c    d(p(r))/du = SUM[G]: (iGu*C[G]) * exp(iG.r)
c    d2(p)/dudv = SUM[G]: (-GuGvC[G]) * exp(iG.r)
c where u,v=x,y,z, and G=(Gx,Gy,Gz), a real three-vector.
c C'[G] = iGu*C[G] and C''[G] = -Gu*Gv*C[G] are the expansion
c coeffs in reciprocal space and are used to get derivatives in
c real space via back fft.  I do the forward fft once and save,
c and do repeated back fft's to collect all the derivatives.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c fft arrays:
      DIMENSION  ws1(*),ws2(*),ws3(*), ftarray(2,*)
c Input arrays: (density, recip space vectors)
      DIMENSION  rho(nptr), gvec(3,nptr)
c Scratch arrays: (fft of density, and fft derivs of density)
      DIMENSION  rhog(2,nptr)
      DIMENSION  drhog(2,nptr)
c
c Local declarations:
      LOGICAL    keeprh
c
c >>>> EXECUTABLE CODE:
c
c Do we destroy rho(), or keep rho() and compact drhog()?
      keeprh = .true.
c
c Load density into real part of complex array for the fft:
      call MKZERO( 2*nptr, rhog )
      call DCOPY( nptr, rho,1, rhog,2 )
c
c Set up parallelism
c   The derivatives and back fft's will be distributed over
c   processors, and the result shipped back to the master
c   for storage.
c
      call MPNODES( nprocs )
      call MPNODE0( master )
      call MPNODE( iproc )
      call MPCOMM( icomm )
c
c  Assume master is first (0) and procs sequential ranked
      iprocu1 = 0
c  With enough procs, make master fft-idle and just do i/o
      if( nprocs .gt. 3 ) iprocu1 = 1
c
c  Fourier transform density:
c
      if( iproc.ne.master .or. iprocu1.eq.0 )
     $call CFFT3D( rhog, n1r,n2r,n3r, ws1,ws2,ws3, ftarray )
c
c >>>> First derivatives: DX, DY, DZ
c
      iprocu = nprocs
      do 101 iu=1,3
        iprocu = iprocu + 1
        if( iprocu .ge. nprocs ) iprocu = iprocu1
c
        if( iproc .eq. iprocu )then
          do  ng=1,nptr
            drhog(1,ng) = -rhog(2,ng)*gvec(iu,ng)
            drhog(2,ng) =  rhog(1,ng)*gvec(iu,ng)
          enddo
          call CFFT3DB( drhog, n1r,n2r,n3r, ws1,ws2,ws3, ftarray )
        endif
c
        if( iproc .eq. iprocu  .or.  iproc .eq. master )then
          lenmsg = nptr
c
          if( keeprh )then
c           Compact transformed array to keep only the real part
            if( iproc .eq. iprocu )then
              iq = 2
              id = -1
              ir = 0
              do  nr=1,nptr
                ir = ir + iq - 1
                iq = iq + id
                id = -id
                drhog(iq,ir) = drhog(1,nr)
              enddo
              if( iproc .ne. master )then
                call MPSENDR8( master, lenmsg, drhog, icomm )
              endif
            elseif( iproc .eq. master )then
              call MPRECVR8( iprocu, lenmsg, drhog, icomm )
            endif
            if( iproc .eq. master )then
              call WRITBIG( idrhofl, nptr, drhog )
            endif
          else
c           Overwrite the density array
            if( iproc .eq. iprocu )then
              do  nr=1,nptr
                rho(nr) = drhog(1,nr)
              enddo
              if( iproc .ne. master )then
                call MPSENDR8( master, lenmsg, rho, icomm )
              endif
            elseif( iproc .eq. master )then
              call MPRECVR8( iprocu, lenmsg, rho, icomm )
            endif
            if( iproc .eq. master )then
              call WRITBIG( idrhofl, nptr, rho )
            endif
          endif
c
        endif
c
  101 continue
c
c >>>> Second derivatives: XX, YY, ZZ, XY, YZ, ZX
c
      do 202 idv=0,2
        do 201 iu=1,3-idv
          iv = iu + idv
          iprocu = iprocu + 1
          if( iprocu .ge. nprocs ) iprocu = iprocu1
c
          if( iproc .eq. iprocu )then
            do  ng=1,nptr
              drhog(1,ng) = -rhog(1,ng)*gvec(iu,ng)*gvec(iv,ng)
              drhog(2,ng) = -rhog(2,ng)*gvec(iu,ng)*gvec(iv,ng)
            enddo
            call CFFT3DB( drhog, n1r,n2r,n3r, ws1,ws2,ws3, ftarray )
          endif
c
          if( iproc .eq. iprocu  .or.  iproc .eq. master )then
            lenmsg = nptr
c
            if( keeprh )then
c             Compact transformed array to keep only the real part
              if( iproc .eq. iprocu )then
                iq = 2
                id = -1
                ir = 0
                do  nr=1,nptr
                  ir = ir + iq - 1
                  iq = iq + id
                  id = -id
                  drhog(iq,ir) = drhog(1,nr)
                enddo
                if( iproc .ne. master )then
                  call MPSENDR8( master, lenmsg, drhog, icomm )
                endif
              elseif( iproc .eq. master )then
                call MPRECVR8( iprocu, lenmsg, drhog, icomm )
              endif
              if( iproc .eq. master )then
                call WRITBIG( idrhofl, nptr, drhog )
              endif
            else
c             Overwrite density array
              if( iproc .eq. iprocu )then
                do  nr=1,nptr
                  rho(nr) = drhog(1,nr)
                enddo
                if( iproc .ne. master )then
                  call MPSENDR8( master, lenmsg, rho, icomm )
                endif
              elseif( iproc .eq. master )then
                call MPRECVR8( iprocu, lenmsg, rho, icomm )
              endif
              if( iproc .eq. master )then
                call WRITBIG( idrhofl, nptr, rho )
              endif
            endif
c
          endif
c
  201   continue
  202 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FIELDPOT
c
c
      subroutine FIELDPOT( efield, r0,nda,ndb,ndc,hh, vfield )
c---------------------------------------------------------------
c Purpose: generate potential on regular grid from electric field
c
c Written: Peter A. Schultz and Jamil Tahir-Kheli
c          17-September-2003 for v2.57
c
c Revision history:
c  17Sep03-PAS/2.57: pushed into subroutine; 3-vector E-field
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
c   efield - electric field, (Ry/bohr)
      DIMENSION  efield(3)
c   r0 - position of grid origin w.r.t. field origin.
      DIMENSION  r0(3)
c   hh(3,3) = grid interval vectors
      DIMENSION  hh(3,3)
c
c Output: potential (Ry) of E-field on grid
      DIMENSION  vfield(*)
c
c Local:
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      dpotc = efield(1)*hh(1,3) + efield(2)*hh(2,3) + efield(3)*hh(3,3)
      dpotb = efield(1)*hh(1,2) + efield(2)*hh(2,2) + efield(3)*hh(3,2)
      dpota = efield(1)*hh(1,1) + efield(2)*hh(2,1) + efield(3)*hh(3,1)
c Do not know how I will want to use this offset yet, so blank it out:
c      potc0 = -( efield(1)*r0(1) + efield(2)*r0(2) + efield(3)*r0(3) )
      potc0 = zero
c
      nr = 0
      do 300 idc=1,ndc
        potb0 = potc0
c
        do 200 idb=1,ndb
          potr = potb0
c
          do 100 ida=1,nda
            nr = nr + 1
            vfield(nr) = vfield(nr) + potr
            potr = potr + dpota
  100     continue
c
          potb0 = potb0 + dpotb
  200   continue
c
        potc0 = potc0 + dpotc
  300 continue
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FINTSUM
c
c
      subroutine FINTSUM( engrt,engrs,p,li,lj,
     $                    ci,cj,ali,alj,alsum,pmag )
c---------------------------------------------------------------
c Purpose: computes quintuple sum of symmetry coefficients
c          times the radial integrals.
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
      DIMENSION  engrt(3),engrs(3), p(3), ci(10),cj(10)
c local declarations:
      EQUIVALENCE  (nq(1),nq1),(nqmn(1),nqmn1),(psq(1),psq1)
      COMMON  /nqs/   nq1,nq2,nq3
      COMMON  /nqmns/ nqmn1,nqmn2,nqmn3
      COMMON  /psqs/  psq1,psq2,psq3
      DIMENSION  nq(3),nqmn(3),psq(3)
c
      LOGICAL    EVEN
      DIMENSION  apn(6),trad(6,4),lang(10)
      DATA  lang / 0, 1,1,1, 2,2,2,2,2,2/
c
      DIMENSION  ns(9),np(10,3),bpq(6,6),nqmin(6)
      DATA  ns / 1, 2,3,4, 5,6,7,9,10 /
      DATA  np / 0, 1,0,0, 1,0,1,2,0,0,
     $           0, 0,1,0, 1,1,0,0,2,0,
     $           0, 0,0,1, 0,1,1,0,0,2 /
      DATA  bpq / 1.d0, 0.d0, 0.d0, 0.d0, 0.d0,  0.d0,
     $            0.d0, 1.d0, 1.d0, 0.d0, 0.d0,  0.d0,
     $            0.d0, 0.d0, 1.d0, 3.d0, 3.d0,  0.d0,
     $            0.d0, 0.d0, 0.d0, 1.d0, 6.d0, 15.d0,
     $            0.d0, 0.d0, 0.d0, 0.d0, 1.d0, 10.d0,
     $            0.d0, 0.d0, 0.d0, 0.d0, 0.d0,  1.d0 /
      DATA  nqmin / 1,2,2,3,3,4 /
c
      DATA  zero,one,two,three,four / 0.d0,1.d0,2.d0,3.d0,4.d0 /
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      rtpid4 = rtpi/four
      twoalj = two*alj
      fouralj = two*twoalj
c
      apm = alsum*SQRT(alsum)
C     do 1 iqs=1,lang(li)+lang(lj)+2
      do  iqs=1,6
        apn(iqs) = rtpid4/apm
        apm = apm*(alsum+alsum)
      enddo
      trc = two*rtpi*alj*alj/(alsum*SQRT(alsum))
      cl = (three*ali/alj + two - pmag*pmag/(two*alsum))/two
C     do 3 lp1=1,4
      do  lp1=1,lang(lj)+2
        cliq = cl
        fiq = trc
C       do 2 iqs=1,lang(li)+lang(lj)+2
        do  iqs=1,6
          fiq = fiq/(alsum+alsum)
          cliq = cliq - one
          trad(iqs,lp1) = fiq*cliq
        enddo
        cl = cl + alsum/alj
      enddo
      do  j=1,3
        engrt(j) = zero
        engrs(j) = zero
        psq(j) = p(j)*p(j)
      enddo
c
      nsimx = ns(li)
      nsjmx = ns(lj)
c
      do 102 nsi=1,nsimx
        if( ci(nsi).eq.zero ) goto 102
c
        do 101 nsj=1,nsjmx
          if( cj(nsj).eq.zero ) goto 101
c
          lp1 = lang(nsj) + 1
          do 82 ngrad=1,3
            isign = 1
            idc = np(nsj,ngrad)
            scoeff = zero
            dcoeff = -twoalj
            do 81 igrad=1,2
              pr1 = ci(nsi)*cj(nsj)
              lpj = lp1 + isign
              do  j=1,3
                nq(j) = 0
              enddo
              nq(ngrad) = isign
              do  j=1,3
                nq(j) = nq(j) + np(nsi,j) + np(nsj,j) + 1
                nqmn(j) = nqmin(nq(j))
                if( EVEN(nq(j)) ) pr1 = pr1*p(j)
              enddo
c     cdir$ novector
              do 50 iq1=nqmn1,nq1
                pr12 = pr1
                do 40 iq2=nqmn2,nq2
                  pr123 = pr12
                  do 30 iq3=nqmn3,nq3
                    iqs = iq1 + iq2 + iq3 - 2
                    fmult = pr123*bpq(nq1,iq1)*bpq(nq2,iq2)*bpq(nq3,iq3)
                    fadds = dcoeff*apn(iqs)
                    faddt = dcoeff*trad(iqs,lpj) + scoeff*apn(iqs)
                    engrt(ngrad) = engrt(ngrad) + fmult*faddt
                    engrs(ngrad) = engrs(ngrad) + fmult*fadds
                    pr123 = pr123*psq3
   30             continue
                  pr12 = pr12*psq2
   40           continue
                pr1 = pr1*psq1
   50         continue
c     cdir$ vector
c skip isign.eq.-1 if nothing to derive down:
              if( idc.eq.0 ) goto 82
              isign = -isign
              dcoeff =  DBLE(idc)
              scoeff = dcoeff*fouralj
   81       continue
   82     continue
c
  101   continue
  102 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FIXFRAME
c
c
      subroutine FIXFRAME( natm, iatframe, ratm, fatm )
c---------------------------------------------------------------
c Purpose: Adjust the forces on a geometry in order to fix
c          the frame of reference.
c
c Written: Peter A. Schultz, 28-January-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input: frame-defining atoms, and atomic coordinates
      DIMENSION  iatframe(3)
      DIMENSION  ratm(3,natm)
c Input/Output: forces on atoms
      DIMENSION  fatm(3,natm)
c
c Local:
      DIMENSION    vecij(3), vecjk(3), vecijk(3)
      DATA         zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Identify the atoms which define the frame
c   iatmfix = is the atom which is fixed in place
c   iatmvec = atom fixed along vector from iatmfix
c   iatmpln = with iatmfix and iatmvec, defines fixed plane of atoms
c             (if iatmpln is negative, enforce collinearity)
c
      iatmfix = iatframe(1)
      if( iatmfix.eq.0 ) RETURN
      iatmvec = iatframe(2)
      iatmpln = iatframe(3)
c
c Enforce fixed atom by zeroing forces on iatmfix:
c
      do  i=1,3
        fatm(i,iatmfix) = zero
      enddo
c
c Enforce vector of iatmvec from iatmfix ...
c
c  ... compute normalized vector connecting atoms iatmfix amd iatmvec
      vecnrm = zero
      do  i=1,3
        vecij(i) = ratm(i,iatmvec) - ratm(i,iatmfix)
        vecnrm = vecnrm + vecij(i)**2
      enddo
      vecnrm = one / SQRT( vecnrm )
      do  i=1,3
        vecij(i) = vecnrm*vecij(i)
      enddo
c  ... project iatmvec force along vector
      fdotv = zero
      do  i=1,3
        fdotv = fdotv + fatm(i,iatmvec)*vecij(i)
      enddo
c  ... and keep only force along this vector
      do  i=1,3
        fatm(i,iatmvec) = fdotv*vecij(i)
      enddo
c
c Enforce iatmfix-iatmvec-iatmpln constraint
c
      if( iatmpln.gt.0 )then
c
c       Enforce plane ...
c
c        ... compute iatmvec-iatmpln normalized vector
        vecnrm = zero
        do  i=1,3
          vecjk(i) = ratm(i,iatmpln) - ratm(i,iatmvec)
          vecnrm = vecnrm + vecjk(i)**2
        enddo
        vecnrm = one / SQRT( vecnrm )
        do  i=1,3
          vecjk(i) = vecnrm*vecjk(i)
        enddo
c        ... compute normalized normal to plane
        call CROSS(  vecij,vecjk, vecijk )
        vecnrm = zero
        do  i=1,3
          vecnrm = vecnrm + vecijk(i)**2
        enddo
        vecnrm = one / SQRT( vecnrm )
        do  i=1,3
          vecijk(i) = vecnrm*vecijk(i)
        enddo
c        ... project iatmpln force along normal to plane ...
        fdotv = zero
        do  i=1,3
          fdotv = fdotv + fatm(i,iatmpln)*vecijk(i)
        enddo
c        ... and remove from force vector on this atom:
        do  i=1,3
          fatm(i,iatmpln) = fatm(i,iatmpln) - fdotv*vecijk(i)
        enddo
c
      elseif( iatmpln.lt.0 )then
c
c       Enforce collinearity of third atom with first two ...
c
        jatmpln = -iatmpln
c        ... project iatmpln force along iatmfix-iatmvec vector
        fdotv = zero
        do  i=1,3
          fdotv = fdotv + fatm(i,jatmpln)*vecij(i)
        enddo
c        ... and keep only that component of the force:
        do  i=1,3
          fatm(i,jatmpln) = fdotv*vecij(i)
        enddo
c
c     else
c       Nothing to enforce.
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FORCE_ELASTIC
c
c
      subroutine FORCE_ELASTIC( IWR,
     $     natom,ri,fi,kspring,fpt,fpn,fet,
     $     ti,driminus,driplus,energy_lo,energy_image,energy_hi,
     $     Loptall,Lclimb,fdottan )
c---------------------------------------------------------------
c     This subroutine takes the potential forces as input, and
c     computes the forces for the nudged elastic band simulation.
c     It does this by estimating the local MEP tangent vector for
c     each image, subtracting the forcefield component parallel to this
c     and adding on the elastic band force component parallel to this.
c
c Written: Aidan P. Thompson, Fall 2001
c
c Revision history:
c  14Jun05-PAS/2.59: File units; 27jan06 cosmetics
c  11May05-RMV/2.59: add climb, and post-processing output
c   7Oct02-PAS/2.54: adapted for Quest 2.54
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
      INTEGER  IWR
c
c     --- variables passed to and from subroutine
      real*8 ri(3,*),fi(3,*),ti(3,*)
      real*8 driminus(3,*),driplus(3,*)
c
      real*8 fpt,fpn,fet,kspring,fdottan
      real*8 energy_lo,energy_image,energy_hi
      integer natom
c
      LOGICAL  Loptall,Lclimb
c
c     --- local variables
      real*8 sumfpnsq,fti1,fti2,fti3,fni1,fni2,fni3
      real*8 deluplus,deluminus
      integer iatom
      real*8 zero
c
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE
c
c Calculate projection of potential force onto MEP
c     This is -delV(Ri).tau in Jonsson (1998)
cRMV original system force along path tangent
cRMV    Fsystem(atoms) dot Tangent(atoms)
cRMV  Tangent is already normalized
c
      fpt = zero
      fdottan= zero
      do  iatom=1,natom
         fpt = fpt + fi(1,iatom) * ti(1,iatom)
         fpt = fpt + fi(2,iatom) * ti(2,iatom)
         fpt = fpt + fi(3,iatom) * ti(3,iatom)
      enddo
cRMV output this force for useful post-processing
      fdottan = fpt
c
c Calculate projection of elastic force on MEP
c     This is Fis.tau in Jonsson (1998)
cRMV  elastic force along path tangent
cRMV    k *  Tangent(atoms) dot  DistancePrevNext(atoms)
c
      fet = zero
      do  iatom=1,natom
         fet = fet + kspring * ti(1,iatom) *
     $         ( driplus(1,iatom) - driminus(1,iatom) )
         fet = fet + kspring * ti(2,iatom) *
     $         ( driplus(2,iatom) - driminus(2,iatom) )
         fet = fet + kspring * ti(3,iatom) *
     $         ( driplus(3,iatom) - driminus(3,iatom) )
      enddo
c
c Calculate total force from normal and tangential components
c
      sumfpnsq = zero
cRMV begin loop over atoms
c
      do  iatom=1,natom
c
c        Calculate potential force normal to MEP
c            This is -delV(Ri)|perp in Jonnson (1998)
cRMV don't actually need to do this,
cRMV  useful for checking path convergence
c
         fni1 = fi(1,iatom) - fpt*ti(1,iatom)
         fni2 = fi(2,iatom) - fpt*ti(2,iatom)
         fni3 = fi(3,iatom) - fpt*ti(3,iatom)
         sumfpnsq = sumfpnsq + fni1**2 + fni2**2 + fni3**2
c
c        Calculate elastic force parallel to MEP
c            This is fis.tau tau in Jonnson (1998)
cRMV springforce * Tangent
c
         fti1 = fet*ti(1,iatom)
         fti2 = fet*ti(2,iatom)
         fti3 = fet*ti(3,iatom)
c
cRMV     climbing image method, to get clos(er)
cRMV  to the nearest saddle point 
cRMV  finds uphill extrema ONLY
c
         if( Lclimb )then  
c
            deluminus = energy_image - energy_lo
            deluplus = energy_hi - energy_image
c     
            if( deluminus .gt. zero .and. deluplus .lt. zero )then
c              Local maximum - climb to saddle point.
cRMV debugging
c               write(IWR,*)'climbing image invoked, this one climbs'
c              Reverse potential force parallel to MEP ...
               fi(1,iatom) = fni1 - fpt*ti(1,iatom)
               fi(2,iatom) = fni2 - fpt*ti(2,iatom)
               fi(3,iatom) = fni3 - fpt*ti(3,iatom)
c               ... and do not apply elastic force
               fet = zero
            else
c              Not a maxima, use normal NEB formula
c               write(IWR,*)'ci invoked, this images does not climb'
               fi(1,iatom) = fti1 + fni1
               fi(2,iatom) = fti2 + fni2
               fi(3,iatom) = fti3 + fni3
            endif
c     
         elseif( Loptall )then
c           Drive images to all local extrema stationary points
c     
            deluminus = energy_image - energy_lo
            deluplus = energy_hi - energy_image
c     
            if( deluminus*deluplus .ge. zero )then
c              Not an extremum - use normal NEB formula.
               fi(1,iatom) = fti1 + fni1
               fi(2,iatom) = fti2 + fni2
               fi(3,iatom) = fti3 + fni3
            elseif( deluminus .gt. zero )then
c              Local maximum - climb to saddle point.
c              Reverse potential force parallel to MEP ...
               fi(1,iatom) = fni1 - fpt*ti(1,iatom)
               fi(2,iatom) = fni2 - fpt*ti(2,iatom)
               fi(3,iatom) = fni3 - fpt*ti(3,iatom)
c               ... and do not apply elastic force
               fet = zero
            else
c              Local minimum - descend to minimum.
c              Use full (downhill) potential force ...
               fi(1,iatom) = fi(1,iatom)
               fi(2,iatom) = fi(2,iatom)
               fi(3,iatom) = fi(3,iatom)
c               ... and do not apply elastic force
               fet = zero
            endif
c     
         else
c           Normal nudged elastic band formula
c     
            fi(1,iatom) = fti1 + fni1
            fi(2,iatom) = fti2 + fni2
            fi(3,iatom) = fti3 + fni3
         endif
c
c        Close loop over atoms
      enddo
c
      fpn = SQRT( sumfpnsq )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FORCE_NEB
c
c
      subroutine FORCE_NEB( IWRNEB,
     $     natom,riminus,ri,riplus,fi,
     $     ti,driminus,driplus,kspring,
     $     energy_lo,energy_image,energy_hi,
     $     drsqplus,drsqminus,fpt,fpn,fet,
     $     Lantikink,Loptall,Lclimb,
     $     fdottan,dprev,dnext )
c---------------------------------------------------------------
c Purpose: generate band forces for individual NEB image
c
c Written: Aidan Thompson, Fall 2001
c
c Revision history:
c  14Jun05-PAS/2.59: File units
c  11May05-RMV/2.59: add climb, pass dprev and dnext, pass fdottan
c  14Feb02-PAS/2.54: adapted to SeqQuest - cosmetics
c---------------------------------------------------------------
c
c  fdottan = projection of system force along tangent
c
      IMPLICIT NONE
c
c     --- variables passed to and from subroutine
      real*8 ri(3,*),riminus(3,*),riplus(3,*),fi(3,*)
      real*8 ti(3,*),driminus(3,*),driplus(3,*)
c
      real*8 energy_lo,energy_image,energy_hi
      real*8 drsqplus,drsqminus,fpt,fpn,fet
      real*8 kspring,fdottan,dprev,dnext
      integer natom,IWRNEB
c
      LOGICAL  Lantikink,Loptall,Lclimb
c
c >>>> EXECUTABLE CODE:
c
c Calculate local tangents and segment lengths
c
      call TANGENT( IWRNEB,
     $     natom,riminus,ri,
     $     riplus,ti,
     $     driminus,driplus,
     $     drsqplus,drsqminus,
     $     Lantikink,
     $     energy_lo,energy_image,energy_hi,
     $     dprev,dnext)
c
c Modify computed forces with band forces:
c
      call FORCE_ELASTIC( IWRNEB,
     $     natom,ri,fi,kspring,
     $     fpt,fpn,fet,
     $     ti,driminus,driplus,energy_lo,energy_image,energy_hi,
     $     Loptall,Lclimb,fdottan)
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FRC2CTR
c
c
      subroutine FRC2CTR( ndim,
     $ nafrc,iforce, frcs,frct, strs,strt,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba,
     $ ratm, rlat,coskr,sinkr,
     $ dmat,emat, frctp )
c---------------------------------------------------------------
c Purpose: compute contribution to force and stress from the
c          kinetic and overlap matrices
c
c Written: Peter A. Schultz, based on original PJF routine stress2c
c
c Revision history:
c  15Oct08-PAS/2.62: stripe-parallel
c  21Jun07-PAS/2.60: task-parallelism
c   7Mar02-PAS/2.52: ang constants extracted
c  23Jul01-PAS/2.49: compact dmat, spin-polarized dft
c  21Dec99-PAS/2.42: cosmetic clean-up
c  27Sep99-PAS/2.40: full three-dimensional stress tensor;
c                    and upper triangle; renamed to frc2ctr
c  15Feb99-PAS/2.31: routine to intercept perhaps too-big i/o
c  17Dec98-PAS/2.30: clean force/stress arrays
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  13Aug98-PAS/2.24: cutoffs, names, restructure
c  16Jul98-PAS/2.23: fix label problem (thx D.Raczkowski)
c  28Apr97-PAS/2.17: naming conventions
c  10Feb96-PAS/2.13: standardize structure
c  14Apr94-PAS/2.10: cleanup and optimize
c  14Mar94-PAS/2.04: cleanup, match setup routines
c---------------------------------------------------------------
c
c This routine combines the kinetic energy and overlap matrix calcs
c  of the bulk setup phase with the corresponding impurity code
c  force calcs to give the kinetic energy and overlap contributions
c  to the stress of the slab, i.e., the derivative of the k.e.
c  and overlap trace with respect to expansion of the lattice in
c  the surface plane, as well as the corresponding normal forces on
c  various inequivalent layers. Since the calculations are based on
c  the Hellmann-Feynman theorem, the derivative of the density matrix
c  matrix is not included. Terms involving this derivative add to
c  zero, according to the theorem.
c
c  Calculates kinetic/overlap derivatives analytically
c  This routine is an adaptation of "enij"
c
c  Radial wave functions are assumed to have been normalized (this is
c  done in routine "orbbulk", where the cala coefficients have been
c  rescaled). Normalization of the angular wave functions is done in
c  the present routine via the division by the quantities "vnorm"
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, two=2.d0, half=0.5d0 )
c
c Output(/input) arrays:
      DIMENSION  iforce(*)
      DIMENSION  frcs(3,natm),frct(3,natm), strs(3,3),strt(3,3)
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  dmat(nk,*),emat(nk,*)
c Scratch/parallel:
      DIMENSION  frctp(3,natm), strtp(3,3)
c
c Local declarations:
      LOGICAL     diagshl
      DIMENSION   rij(3), p(3), ci(10,9),cj(10,9)
      DIMENSION   engrs(3),engrt(3), sgr(3),tgr(3)
c
      DIMENSION   vnorm(9)
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'FDEV/FRC2CTR: stripe-parallel'
c Get angular normalizations:
      call VNORMS9( vnorm )
      argmx = half*cutgaus
      emaxf = cutgwfn
      emaxsl = cutslow
c
      fourpi = pi + pi + pi + pi
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
c    Initialize stress and force
c
      call MKZERO( 3*natm, frcs )
      call MKZERO( 3*natm, frct )
      call MKZERO( 9, strs )
      call MKZERO( 9, strt )
c
c  Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmatstr = ncplx*nk*matstr
c
c  Figure out how much belongs on local processor:
      call MATLOCSTR( iproc,nprocs,nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmatpr = mymatpr*ncplx*nk
c
c     Atom j loop:
c
      jjnext = 0
      jnext = myj0
      do 2000 jatm=myatm1,myatm2
        jtyp = itypa(jatm)
        nshlj = numshl(jtyp)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        njstripe = norb - jstart
        matjstr = norbatj*njstripe
        jjstart = jjnext
        jjnext = jjstart + matjstr*ncplx
Cc     
Cc       Each processor will do every nprocs-th atom in this loop.
C        if( MOD( jatm, nprocs ) .ne. iproc ) goto 2000
c
        alaminj = alamin(jtyp)
        call CINIT( cj )
c     
c       Atom j shell loop:
c
        jorbatnxt = 0
        j = jstart
        do 1800 jshl=1,nshlj
          nalj = nala(jshl,jtyp)
          lshlj = lshel(jshl,jtyp)
          norbshj = 2*lshlj + 1
          lj0 = lshlj*lshlj
c
          j0 = j
          jorbat0 = jorbatnxt
          jorbatnxt = jorbat0 + norbshj
c
          alminj = ala(1,jshl,jtyp)
          almaxj = ala(nalj,jshl,jtyp)
          do  jal=1,nalj
            alj = ala(jal,jshl,jtyp)
            if( alj.lt.alminj ) alminj = alj
            if( alj.gt.almaxj ) almaxj = alj
          enddo
          alaminj = alminj
c
          emaxij = emaxf
          if( alminj.lt.alfast ) emaxij = emaxsl
c
c         Atom i loop:
c
          ijnext = jjstart
          inext = jstart
          do 1000 iatm=jatm,natm
            ityp = itypa(iatm)
            nshli = numshl(ityp)
            norbati = norba(ityp)
            istart = inext
            inext = istart + norbati
c
            matij = norbati*norbatj
            ijstart = ijnext
            ijnext = ijstart + matij*ncplx
c
c           Following helps ensure only i.ge.j done:
            iorbatn0 = 0
            ishl1 = 1
            if( iatm.eq.jatm )then
              ishl1 = jshl
              do  ishl=1,ishl1-1
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                istart = istart + norbshi
                iorbat0 = iorbatn0
                iorbatn0 = iorbat0 + norbshi
              enddo
            endif
c
            alamini = alamin(ityp)
            emax = emaxij
            rijmax = emax*(alamini+alaminj) / (alamini*alaminj)
c
c           Lattice vector loop for Atom i:
c
            do 900 ilat=1,nlat
c
              rijsq = zero
              do  ir=1,3
                rij(ir) =  ratm(ir,jatm) - ratm(ir,iatm) - rlat(ir,ilat)
                rijsq = rijsq + rij(ir)*rij(ir)
              enddo
              if( rijsq.gt.rijmax ) goto 900
c
              call CINIT( ci )
              call COFR( cj,rij )
c         
c             Atom i shell loop:
c 
              iorbatnxt = iorbatn0
              i = istart
              do 800 ishl=ishl1,nshli
                nali = nala(ishl,ityp)
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                li0 = lshli*lshli
c
                i0 = i
                iorbat0 = iorbatnxt
                iorbatnxt = iorbat0 + norbshi
c
                diagshl = .false.
                if( i0.eq.j0 ) diagshl = .true.
c
                almini = ala(1,ishl,ityp)
                almaxi = ala(nali,ishl,ityp)
                do  ial=1,nali
                  ali = ala(ial,ishl,ityp)
                  if( ali.lt.almini ) almini = ali
                  if( ali.gt.almaxi ) almaxi = ali
                enddo
c
                emax = emaxf
                if( almaxi.lt.alfast .and. almaxj.lt.alfast )
     $           emax = emaxsl
                rijmx = emax*(alaminj+almini) / (alaminj*almini)
                if( rijsq.gt.rijmx ) goto 799
c
c               Angular loops:
c
                ij0 = ijstart + jorbat0*norbati + iorbat0
                ij0 = ij0 - norbati
                mli1 = 1
                do 420 mlj=1,norbshj
c                 lj=1,....,9   is orbital symmetry index of orbital j
                  lj = lj0 + mlj
                  jorbat = jorbat0 + mlj
                  j = j0 + mlj
c
                  ij0 = ij0 + norbati
                  if( diagshl ) mli1 = mlj
                  do 410 mli=mli1,norbshi
c                   li=1,....,9   is orbital symmetry index of orbital i
                    li = li0 + mli
                    iorbat = iorbat0 + mli
                    i = i0 + mli
                    ij = ij0 + mli
c
c                   Alpha loops:
c
                    nx = 0
                    do  n=1,3
                      sgr(n) = zero
                      tgr(n) = zero
                    enddo
c
                    do 320 jal=1,nalj
                      alj = ala(jal,jshl,jtyp)
c
                      do 310 ial=1,nali
                        ali = ala(ial,ishl,ityp)
c
                        rijmx = emax*(ali+alj) / (ali*alj)
                        if( rijsq.gt.rijmx ) goto 310
c
                        nx = nx + 1
                        alsum = ali + alj
                        do  ir=1,3
                          p(ir) = two*alj*rij(ir)
                        enddo
                        pmag = SQRT( p(1)*p(1)+p(2)*p(2)+p(3)*p(3) )
c
c                       Evaluate contribution to stress and forces
c
                        call FINTSUM( engrt,engrs,p,lj,li,
     $                   cj(1,lj),ci(1,li), alj,ali,alsum, pmag )
c
                        ffac = EXP( -ali*alj*rijsq/alsum )*
     $                   cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
                        do  n=1,3
                          sgr(n) = sgr(n) + engrs(n)*ffac
                          tgr(n) = tgr(n) + engrt(n)*ffac
                        enddo
c
c                       Close alpha loops:
  310                 continue
  320               continue
c
c                   Multiply by Bloch phase factors and add to stress and forces
c
                    emfac = zero
                    dmfac = zero
                    if( i.eq.j )then
                      do  k=1,nk
C                        emfac = emfac + coskr(k,ilat)*emat(i,i,k)
C                        dmfac = dmfac + coskr(k,ilat)*dmat(i,i,k)
                        emfac = emfac + coskr(k,ilat)*emat(k,ij)
                        dmfac = dmfac + coskr(k,ilat)*dmat(k,ij)
                      enddo
                    else
c                     i.ne.j
                      do  k=1,nk
C                        emfac = emfac + coskr(k,ilat)*emat(i,j,k)
C                        dmfac = dmfac + coskr(k,ilat)*dmat(i,j,k)
                        emfac = emfac + coskr(k,ilat)*emat(k,ij)
                        dmfac = dmfac + coskr(k,ilat)*dmat(k,ij)
                      enddo
                      if( ncplx.eq.2 )then
                        ijc = ij + matij
                        do  k=1,nk
C                          emfac = emfac + sinkr(k,ilat)*emat(j,i,k)
C                          dmfac = dmfac + sinkr(k,ilat)*dmat(j,i,k)
                          emfac = emfac + sinkr(k,ilat)*emat(k,ijc)
                          dmfac = dmfac + sinkr(k,ilat)*dmat(k,ijc)
                        enddo
                      endif
c
c                     Double because only doing one triangle
                      emfac = emfac + emfac
                      dmfac = dmfac + dmfac
                    endif
c
                    facs = emfac*fourpi / ( vnorm(li)*vnorm(lj) )
                    fact = dmfac*fourpi / ( vnorm(li)*vnorm(lj) )
c
                    fxs = facs*sgr(1)
                    fys = facs*sgr(2)
                    fzs = facs*sgr(3)
                    fxt = fact*tgr(1)
                    fyt = fact*tgr(2)
                    fzt = fact*tgr(3)
c
                    frcs(1,iatm) = frcs(1,iatm) - fxs
                    frcs(2,iatm) = frcs(2,iatm) - fys
                    frcs(3,iatm) = frcs(3,iatm) - fzs
                    frcs(1,jatm) = frcs(1,jatm) + fxs
                    frcs(2,jatm) = frcs(2,jatm) + fys
                    frcs(3,jatm) = frcs(3,jatm) + fzs
                    strs(1,1) = strs(1,1) - fxs*rij(1)
                    strs(2,1) = strs(2,1) - fys*rij(1)
                    strs(3,1) = strs(3,1) - fzs*rij(1)
                    strs(1,2) = strs(1,2) - fxs*rij(2)
                    strs(2,2) = strs(2,2) - fys*rij(2)
                    strs(3,2) = strs(3,2) - fzs*rij(2)
                    strs(1,3) = strs(1,3) - fxs*rij(3)
                    strs(2,3) = strs(2,3) - fys*rij(3)
                    strs(3,3) = strs(3,3) - fzs*rij(3)
                    frct(1,iatm) = frct(1,iatm) + fxt
                    frct(2,iatm) = frct(2,iatm) + fyt
                    frct(3,iatm) = frct(3,iatm) + fzt
                    frct(1,jatm) = frct(1,jatm) - fxt
                    frct(2,jatm) = frct(2,jatm) - fyt
                    frct(3,jatm) = frct(3,jatm) - fzt
                    strt(1,1) = strt(1,1) + fxt*rij(1)
                    strt(2,1) = strt(2,1) + fyt*rij(1)
                    strt(3,1) = strt(3,1) + fzt*rij(1)
                    strt(1,2) = strt(1,2) + fxt*rij(2)
                    strt(2,2) = strt(2,2) + fyt*rij(2)
                    strt(3,2) = strt(3,2) + fzt*rij(2)
                    strt(1,3) = strt(1,3) + fxt*rij(3)
                    strt(2,3) = strt(2,3) + fyt*rij(3)
                    strt(3,3) = strt(3,3) + fzt*rij(3)
c
c                   Close orbital loops:
  410             continue
  420           continue
c
  799           continue
c               Close Atom i shell loop:
                i = i0 + norbshi
  800         continue
c
c             Close Atom i lattice loop:
  900       continue
c
c           Close Atom i loop:
 1000     continue
c
 1799     continue
c         Close Atom j shell loop:
          j = j0 + norbshj
 1800   continue
c
c       Close Atom j loop:
 2000 continue
c
c >>>> Collect final force/stress
c
      if( nprocs .gt. 1 )then
c       Each local processor has forces over its share of work.
c       Reduce(sum) these to master (node 0).
c       Separate reduces or combined reduce - no diff in performance
c       For now, also broadcast total to all processors.
c
        nreduc = 3*natm
c
        call MPREDUC8( master, nreduc, frcs, frctp , icomm )
        call DCOPY( 3*natm, frctp,1, frcs,1 )
        call MPBCAST8( master, nreduc, frcs, icomm )
c
        call MPREDUC8( master, nreduc, frct, frctp , icomm )
        call DCOPY( 3*natm, frctp,1, frct,1 )
        call MPBCAST8( master, nreduc, frct, icomm )
c       
        nreduc = 9
c       
        call MPREDUC8( master, nreduc, strs, strtp, icomm )
        call DCOPY( 9, strtp,1, strs,1 )
        call MPBCAST8( master, nreduc, strs, icomm )
c       
        call MPREDUC8( master, nreduc, strt, strtp, icomm )
        call DCOPY( 9, strtp,1, strt,1 )
        call MPBCAST8( master, nreduc, strt, icomm )
c       
c       End tp
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FTORB
c
c
      subroutine FTORB( orbint, norb,nk, natm,ntyp,nshld,nald,
     $ itypa, numshl,lshel,nala,ala,cala, norba, vk )
c---------------------------------------------------------------
c Purpose: compute exact fourier transform of each orbital
c
c Written: P.J. Feibelman, revised by P.A. Schultz
c
c Revision history:
c  14Jun05-PAS/2.59: File units
c   7Mar02-PAS/2.52: ang constants extracted
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Apr97-PAS/2.17: naming conventions
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c output array:
      DIMENSION  orbint(2,norb,nk)
c input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  norba(ntyp)
      DIMENSION  vk(3,nk)
c
c local declarations:
      DIMENSION  oint(5)
c ph() contains i**l
      DIMENSION  ph(2,0:3)
      DATA  ph / 1.d0,0.d0, 0.d0,1.d0, -1.d0,0.d0, 0.d0,-1.d0 /
      DIMENSION  vnorm(5)
c
      DATA  zero,one,two, four / 0.d0,1.d0,2.d0, 4.d0 /
      DATA  lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
c Get angular normalizations:
      call VNORMS( vnorm )
c
      do 200 k=1,nk
        xk = vk(1,k)
        yk = vk(2,k)
        zk = vk(3,k)
        vksq = xk*xk + yk*yk + zk*zk
        vksqd4 = vksq / four
c
        do 100 ityp=1,ntyp
c
          iorbat0 = 0
          do 80 ishl=1,numshl(ityp)
            lshl = lshel(ishl,ityp)
            norbsh = 2*lshl + 1
            nali = nala(ishl,ityp)
c
            sumg = zero
            do 30 ial=1,nali
              ali = ala(ial,ishl,ityp)
c 07dec93-PAS: following replaces dangerous construction
c      cali = (pi/ali)**1.5*cala(ial,ishl,ityp)* EXP(-0.25*vksq/ali)
              alfac = (pi/ali)*SQRT( pi/ali )
              addg = alfac*cala(ial,ishl,ityp)*EXP( -vksqd4/ali )
              if( lshl.gt.0 )then
                do  l=1,lshl
                  addg = addg/(ali+ali)
                enddo
              endif
              sumg = sumg + addg
   30       continue
c
c install angular factor
c
            goto (40,41,42), lshl+1
c     s-fcn
   40       fac = sumg/vnorm(1)
            oint(1) = fac
            goto 50
c     p-fcn
   41       fac = sumg/vnorm(2)
            oint(1) = -xk*fac
            oint(2) = -yk*fac
            oint(3) = -zk*fac
            goto 50
c     d-fcn
   42       fac = sumg/vnorm(3)
            oint(1) = xk*yk*fac
            oint(2) = yk*zk*fac
            oint(3) = zk*xk*fac
            fac = sumg/vnorm(4)
            oint(4) = (xk*xk-yk*yk)*fac
            fac = sumg/vnorm(5)
            oint(5) = (two*zk*zk-xk*xk-yk*yk)*fac
c
   50       continue
c
c search for atoms of this type, multiply by i**l, deposit values:
c
            i0 = 0
            do 60 iatm=1,natm
              if( itypa(iatm).eq.ityp )then
                i = i0 + iorbat0
                do  ish=1,norbsh
                  i = i + 1
                  orbint(1,i,k) = orbint(1,i,k) + oint(ish)*ph(1,lshl)
                  orbint(2,i,k) = orbint(2,i,k) + oint(ish)*ph(2,lshl)
                enddo
              endif
              i0 = i0 + norba(itypa(iatm))
   60       continue
            iorbat0 = iorbat0 + norbsh
c
   80     continue
c
  100   continue
c
  200 continue
c
      if( lstout.ge.1 )then
        call FLGETIWR( IWR )
        mk = nk
        if( lstout.eq.1 ) mk = 1
        kn = 0
        write(IWR,*) 'FTORB: Int(orb)='
  300   continue
        if( kn.lt.mk )then
          k1 = kn + 1
          kn = k1 + 2
          if( kn.gt.mk ) kn = mk
          write(IWR,9300) k1,k1+1,k1+2
 9300     format(1x,'i',2x, 3(1x, 9x,'#k=',i2,10x) )
          do  i=1,norb
            write(IWR,9310) i,(orbint(1,i,k),orbint(2,i,k),k=k1,kn)
 9310       format(1x,i3,   3(1x, 1p2d12.4) )
          enddo
          goto 300
        endif
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GEOMDAT
c
c
      subroutine GEOMDAT( IWR,IDAT, dorelax,
     $ natm,nafrc,iforce,ifdefct,
     $ atmnm, natmnm,
     $ nhistg,gblend,gconv,tstep,igstart,igstop,
     $ nslics,islics,islicats,vslics,    iatframe )
c---------------------------------------------------------------
c Purpose: read definition of geometry relaxation
c
c Written: Peter A. Schultz, 26-September-1997, v2.21
c
c Revision history:
c  31Jul17-PAS/2.68: layers and vgfgix into slics
c   5Jun15-PAS/2.67: select atom sequences by atom labals
c   9Apr15-PAS/2.66: lnwrite lines
c   5May11-PAS/2.62: enforce vgfix after grelax/gfixed requirement
c  20Feb09-PAS/2.62: refined options for constraining atoms along vector
c   9Sep08-PAS/2.62: option to freeze atoms along vector
c  21Jan08-PAS/2.61: mv igesopt to rundata
c  25Feb06-PAS/2.60: "do ges" added (to partner with "no ges")
c  31Aug05-RMV/2.60: add options for projected coordinates - SLIC
c  15Mar05-PAS/2.59: skip blank line, rather than treat as error
c   7May04-PAS/2.58: offer MD section here, too.
c  25Apr04-PAS/2.58: purge "igtype"
c  11Sep03-PAS/2.57: remove itmaxd-dependence
c  10Jan03-PAS/2.55: limited-history option
c  28Jan02-PAS/2.54: fixed frame atom data
c   6May02-PAS/2.53: reconcile with cell optimization
c   2Oct01-PAS/2.50: damped dynamics options, and time step
c  21Jun01-PAS/2.48: replace STOPs
c   5May01-PAS/2.47: clean echo
c  29Jul00-PAS/2.45: choose atoms to be relaxed
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  26Oct98-PAS/2.27: restart geometry
c   8Apr98-PAS/2.22: add igesopt for carrying ges option
c  31Mar98-PAS/2.21: bug fix for last/first relax atoms
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input declarations
      CHARACTER*(*)  atmnm
      DIMENSION  atmnm(*)
c Output declarations
      LOGICAL    dorelax
      DIMENSION  iforce(natm)
cRMV slic data
      DIMENSION  islics(4,*),islicats(*),vslics(3,*)
c
      DIMENSION  iatframe(3)
c
c Local declarations:
      PARAMETER  ( nline = 128 )
      CHARACTER    label*(nline), readlbl*6, glabel*8
      EQUIVALENCE  (label,readlbl)
      DIMENSION    vtmp(3)
      DIMENSION    itmp(3)
c
      DATA  zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
 8000 format(a128)
 9000 format(1x,a)
c
c  Set flag for whether force array cleared:
      itypfix = 0
      islicv = 0
      islicat = 0
c
  100 continue
      read(IDAT,8000,err=999,end=999)  label
      call LNWRIT( IWR, label, nline )
c
      if    ( readlbl.eq. 'stop' )then
        write(IWR,*) 'stop  relaxation'
        goto 999
c
      elseif( readlbl.eq. 'end ge' .or.
     $        readlbl.eq. 'end_ge' )then
c       End of geometry parameter input
        goto 990
c
      elseif( readlbl.eq. 'relax ' )then
c       Set relaxation to be on
        dorelax = .true.
        goto 990
c
      elseif( readlbl.eq. 'grelax' )then
c       From all-fixed, choose sequence of atoms to relax:
cpas    Note: need to fix grelax/gfixed/slics to allow general mixing
        if( itypfix .eq.  1 )then
          call STOPXERR( 'grelax-1/do not mix grelax and gfixed' )
        elseif( nslics .ne. 0 )then
          call STOPXERR( 'SLICS must be after all grelax' )
        elseif( itypfix .eq. 0 )then
c         Preset to fix everybody
          nafrc = 0
          do  iatm=1,natm
            iforce(iatm) = 0
          enddo
        endif
        itypfix = -1
c        read(IDAT,*)  irlx1,irlxn
        read(IDAT,8000,end=913,err=913)  label
        call INDATOM( 2, label,nline, natm,atmnm,natmnm, itmp )
        irlx1 = itmp(1)
        irlxn = itmp(2)
        write(IWR,'(2i6,a)')  irlx1,irlxn,' => relax atom sequence'
C        call LNWRIT( IWR, label, nline )
        if( irlx1.lt.1 .or. irlxn.gt.natm .or. irlxn.lt.irlx1 )then
          call STOPXERR( 'grelax-2/bad atom sequence' )
        endif
        do  iatm=irlx1,irlxn
          if( iforce(iatm) .eq. 0 )then
            iforce(iatm) = 1
            nafrc = nafrc + 1
          endif
        enddo
c
      elseif( readlbl.eq. 'gfixed' )then
c       From relax-all, fix atoms in place:
cpas    Note: need to fix grelax/gfixed/slics to allow general mixing
        if( itypfix .eq. -1 )then
          call STOPXERR( 'gfixed-1/do not mix gfixed and grelax' )
        elseif( nslics .ne. 0 )then
          call STOPXERR( 'SLICS must be after all gfixed' )
        elseif( itypfix .eq. 0 )then
c         Preset to relax everybody
          nafrc = natm
          do  iatm=1,natm
            iforce(iatm) = 1
          enddo
        endif
        itypfix = 1
C        read(IDAT,*)  irlx1,irlxn
        read(IDAT,8000,end=913,err=913)  label
        call INDATOM( 2, label,nline, natm,atmnm,natmnm, itmp )
        irlx1 = itmp(1)
        irlxn = itmp(2)
        write(IWR,'(2i5,a)')  irlx1,irlxn,' => fixed atom sequence'
        if( irlx1.lt.1 .or. irlxn.gt.natm .or. irlxn.lt.irlx1 )then
          call STOPXERR( 'gfixed-2/bad atom sequence' )
        endif
        do  iatm=irlx1,irlxn
          if( iforce(iatm) .eq. 1 )then
            iforce(iatm) = 0
            nafrc = nafrc - 1
          endif
        enddo
c
      elseif( readlbl(1:4) .eq. 'bond' )then
c       Constrain bond length
        islictyp = 4
        nslics = nslics + 1
        if( nslics.gt.natm ) call STOPXERR('Too many constraints')
        read(IDAT,8000,end=913,err=913)  label
        call INDATOM( 2     , label,nline, natm,atmnm,natmnm,
     $                itmp )
        write(IWR,'(1x,16i5)')  (itmp(i),i=1,2)
        islic = nslics
        islics(1,islic) = islictyp
        islics(2,islic) = itmp(1)
        islics(3,islic) = itmp(2)
c
        do  ia=1,2
          iatm = itmp(ia)
          if( iforce(iatm).eq.0 ) nafrc = nafrc + 1
          if( iforce(iatm).gt.1 ) call STOPXERR('constraint conflict')
          iforce(iatm) = islictyp
        enddo
c
      elseif( readlbl(1:5) .eq. 'vgfix' )then
c       Apply constraints connecting atoms along a vector
        if( readlbl(6:6) .eq. 'p' .or. readlbl(6:6) .eq. 'e' )then
c         Fix atoms in plane, no motion along vector, free in-plane
          islictyp = 5
        elseif( readlbl(6:6) .eq. 'd' )then
c         Fix distance between atom planes along vector, free in-plane
          islictyp = 6
        elseif( readlbl(6:6) .eq. 'a' )then
c         Limit atoms along axis, with free distance between planes
          islictyp = 7
        elseif( readlbl(6:6) .eq. 'l' )then
c         Limit atoms along axis, with fixed distance between planes
          islictyp = 8
        else
          call STOPXERR( 'Bad option for vgfixX (X=plane,dist,axis)' )
        endif
c
        read(IDAT,*)  nvgfix, vtmp
        write(IWR,'(i5,3x,3f12.8,a)')  nvgfix, vtmp,
     $   ' = # of atoms constrained with this vector, list is ...'
c
        vmag = vtmp(1)**2 + vtmp(2)**2 + vtmp(3)**2
        if( vmag .lt. 0.01 ) call STOPXERR( 'vgfix - zero vector' )
        vmag = DSQRT( vmag )
        do  ir=1,3
          vtmp(ir) = vtmp(ir) / vmag
        enddo
c
        nslics = nslics + 1
        if( nslics.gt.natm ) call STOPXERR('Too many constraints')
c
        isl1 = islicat + 1
C        read(IDAT,*)  (islicats(iatm),iatm=isl1,isln)
        read(IDAT,8000,end=913,err=913)  label
        if(     nvgfix.eq.-1 )then
c         Pick out a (single) sequence of atoms
          call INDATOM( 2     , label,nline, natm,atmnm,natmnm,
     $                  itmp )
          write(IWR,'(1x,16i5)')  itmp(1), itmp(2)
          if( itmp(1).lt.1 .or. itmp(2).lt.itmp(1) .or. itmp(2).gt.natm)
     $     call STOPXERR( 'vgfix - atoms out of boumds' )
          nvgatms = itmp(2) - itmp(1) + 1
          isln = islicat + nvgatms
          if( isln.gt.natm )call STOPXERR( 'Too many constrained atoms')
          iatm = itmp(1)
          do  isl=isl1,isln
            islicats(isl) = iatm
            iatm = iatm + 1
          enddo
        elseif( nvgfix.eq.0 )then
c         Select all the atoms
          nvgatms = natms
          isln = islicat + nvgatms
          if( isln.gt.natm )call STOPXERR( 'Too many constrained atoms')
          iatm = 1
          do  isl=isl1,isln
            islicats(isl) = iatm
            iatm = iatm + 1
          enddo
        elseif( nvgfix.ge.1 .and. nvgfix.le.natm )then
          nvgatms = nvgfix
          isln = islicat + nvgatms
          if( isln.gt.natm )call STOPXERR( 'Too many constrained atoms')
          call INDATOM( nvgfix, label,nline, natm,atmnm,natmnm,
     $                  islicats(isl1) )
          write(IWR,'(1x,16i5)')  (islicats(iatm),iatm=isl1,isln)
        else
          call STOPXERR( 'vgfix - bad number input' )
        endif
c
        isln = islicat + nvgatms
        if( isln.gt.natm )call STOPXERR('Too many constrained atoms')
        islicat = isln
        islic = nslics
        islicv = islicv + 1
c
        islics(1,islic) = islictyp
        islics(2,islic) = nvgatms
        islics(3,islic) = isl1  
        islics(4,islic) = islicv
        vslics(1,islicv) = vtmp(1)
        vslics(2,islicv) = vtmp(2)
        vslics(3,islicv) = vtmp(3)
c
c
        do  ivgatm=isl1,isln
          iatm = islicats(ivgatm)
          if( iatm.lt.1 .or. iatm.gt.natm )then
            call STOPXERR( 'vgfixed atom <1 or >natm')
          endif
c         Record this atom as a plane-fixed atom:
cpas:  vgfix-need to reconcile order of grelax/gfixed/vgfixed
          if( iforce(iatm).eq.0 ) nafrc = nafrc + 1
          if( iforce(iatm).gt.1 ) call STOPXERR('constraint conflict')
          iforce(iatm) = islictyp
        enddo
c
      elseif( readlbl(1:6) .eq. 'slinky' .or.
     $        readlbl(1:6) .eq. 'layers' )then
c       Apply constraints connecting atoms along a vector
        islictyp = 9
c
        read(IDAT,*)  nslink, vtmp
        write(IWR,'(i5,3x,3f12.8,a)')  nslink, vtmp,
     $   ' = # of atoms in slinky layers, list is ...'
c
        vmag = vtmp(1)**2 + vtmp(2)**2 + vtmp(3)**2
        if( nslink.lt.1 .or. nslink.gt.natm .or. vmag .lt. 0.01 )then
          call STOPXERR( 'slinky/layers - bad input' )
        endif
        vmag = DSQRT( vmag )
        do  ir=1,3
          vtmp(ir) = vtmp(ir) / vmag
        enddo
c
        nslics = nslics + 1
        isl1 = islicat + 1
        isln = islicat + nslink
        if( nslics.gt.natm ) call STOPXERR('Too many constraints')
        if( isln.gt.natm ) call STOPXERR('Too many total vgfix atoms')
        islicat = isln
        islic = nslics
        islicv = islicv + 1
c
        islics(1,islic) = islictyp
        islics(2,islic) = nslink
        islics(3,islic) = isl1  
        islics(4,islic) = islicv
        vslics(1,islicv) = vtmp(1)
        vslics(2,islicv) = vtmp(2)
        vslics(3,islicv) = vtmp(3)
c
C        read(IDAT,*)  (islicats(iatm),iatm=isl1,isln)
        read(IDAT,8000,end=913,err=913)  label
        call INDATOM( nslink, label,nline, natm,atmnm,natmnm,
     $                islicats(isl1) )
        write(IWR,'(1x,16i5)')  (islicats(iatm),iatm=isl1,isln)
c
        do  ivgatm=isl1,isln
          iatm = islicats(ivgatm)
          if( iatm.lt.1 .or. iatm.gt.natm )then
            call STOPXERR( 'slinky atom <1 or >natm')
          endif
c         Record this atom as a plane-fixed atom:
cpas:  vgfix-need to reconcile order of grelax/gfixed/vgfixed
          if( iforce(iatm).eq.0 ) nafrc = nafrc + 1
          if( iforce(iatm).gt.1 ) call STOPXERR('constraint conflict')
          iforce(iatm) = islictyp
        enddo
c
      elseif( readlbl.eq. 'only r' )then
c       Set only first n, or last n, atoms to be relaxed.
        read(IDAT,*)  irelax
        irlx1 = 1
        irlxn = natm
        if( irelax.lt.0 .and. irelax .ge. -natm )then
          write(IWR,'(i4,a)')  irelax,' => last n atoms relaxed'
          irlx1 = natm + irelax + 1
        elseif( irelax.gt.0 .and. irelax.le.natm )then
          write(IWR,'(i4,a)')  irelax,' => first n atoms relaxed'
          irlxn = irelax
        else
          write(IWR,'(i4,a)')  irelax,' => all atoms relaxed'
        endif
c       Preset to relax nobody:
        do  iatm=1,natm
          iforce(iatm) = 0
        enddo
c       Now set to relax specified set of atoms:
        nafrc = 0
        do  iatm=irlx1,irlxn
          iforce(iatm) = 1
          nafrc = nafrc + 1
        enddo
c
      elseif( readlbl.eq. 'frame ' )then
c       Atoms which define a fixed frame
C        read(IDAT,*) iatmfix,iatmvec,iatmpln
        islictyp = 3
        read(IDAT,8000,end=913,err=913)  label
        call INDATOM( 3     , label,nline, natm,atmnm,natmnm,
     $                itmp )
        iatmfix = itmp(1)
        iatmvec = itmp(2)
        iatmpln = itmp(3)
        if( iatmfix.ge.1 .and. iatmfix.le.natm .and.
     $      iatmvec.ge.1 .and. iatmvec.le.natm .and.
     $      iatmpln.ge.1 .and. iatmpln.le.natm .and.
     $      iatmfix.ne.iatmvec .and. iatmvec.ne.iatmpln .and.
     $      iatmpln.ne.iatmfix )then
          iatframe(1) = iatmfix
          iatframe(2) = iatmvec
          iatframe(3) = iatmpln
          write(IWR,'(1x,3i5,a)')  iatframe,' =fixed,vec,plane atoms'
        else
          call STOPXERR( 'GEOMDAT: ill-defined frame/bad atoms' )
        endif
        do  isl=1,3
          iatm = itmp(isl)
          if( iforce(iatm).gt.1 ) call STOPXERR('constraint conflict')
          if( iforce(iatm).eq.0 ) nafrc = nafrc + 1
          iforce(iatm) = islictyp
        enddo
c
      elseif( readlbl.eq. 'defect' )then
c       Atom to which defect force is to be applied
C        read(IDAT,*) ifdefct
        read(IDAT,8000,end=913,err=913)  label
        call INDATOM( 1, label,nline, natm,atmnm,natmnm, itmp )
        if( ifdefct.lt.1 .or. ifdefct.gt.natm ) ifdefct = 0
        write(IWR,'(1x,i4)')  ifdefct
c
      elseif( readlbl.eq. 'gblend' )then
c       "Force constant" for initial blend geometry
        read(IDAT,*)  gblend
        write(IWR,'(1x,f15.8)')  gblend
c
      elseif( readlbl.eq. 'gconv ' )then
c       Convergence criterion for geom: largest force magnitude.
        read(IDAT,*)  gconv
        write(IWR,'(1x,f15.8)')  gconv
c
      elseif( readlbl.eq. 'gstart' )then
c       Starting step for geometry relaxation
        read(IDAT,*)  igstart
        write(IWR,'(1x,i4)')  igstart
c
      elseif( readlbl.eq. 'gsteps' )then
c       Total number of steps in geometry relaxation
        read(IDAT,*)  igstop
        write(IWR,'(1x,i4)')  igstop
c
      elseif( readlbl.eq. 'ghisto' )then
c       Total number of steps to use in step updates
        read(IDAT,*)  nhistg
        if( nhistg.lt.0 ) nhistg = 0
        write(IWR,'(1x,i4)')  nhistg
c
      elseif( readlbl.eq. 'no ges' )then
c       Simple overlapping atom guess for new geom scf.
        call STOPXERR( 'no ges - moved to run phase data' )
        igesopt = 0
      elseif( readlbl.eq. 'do ges' )then
c       Use full dHam guess for scf ges for new geom scf.
        call STOPXERR( 'do ges - moved to run phase data' )
        igesopt = 2
      elseif( readlbl.eq. 'guess ' )then
c       Specify type of scf guess for new geometry
        call STOPXERR( 'guess - moved to run phase data' )
        read(IDAT,*)  igesopt
        write(IWR,'(1x,i4,5x,a)')  igesopt,' = option for scf ges'
c
      elseif( readlbl.eq. 'gmetho' )then
c       Pick a method for geometry stepping
        read(IDAT,8000,err=913,end=913)  label
        call LNWRIT( IWR, label, nline )
        call STRPARS( label, 1,60, ig1,ig2 )
c       We assume here that glabel is an 8-char string
        glabel = label(ig1:ig1+7)
        call GTYPSET( glabel )
c
      elseif( readlbl .eq. 'md dat' .or.
     $        readlbl .eq. 'dynami' )then
c        Molecular dynamics input.
         call QMDDAT( IWR,IDAT )
c
      elseif( readlbl.eq. 'timest' )then
c       Get time step for dynamics
        read(IDAT,*)  tstep
        if( tstep .le. zero ) tstep = one
        write(IWR,'(f12.4)')  tstep
c
cRMV:start
cDEV-Use these to reset and communicate slic params
      elseif( readlbl(1:6) .eq. 'slpar1' )then
        read(IDAT,*)  slicpar 
        write(IWR,'(f12.4,a)')  slicpar, ' reset sphere/scalephi'
        call SLICPSET( 'PAR1  ', slicpar,ipslic )
      elseif( readlbl(1:6) .eq. 'slpar2' )then
        read(IDAT,*)  slicpar 
        write(IWR,'(f12.4,a)')  slicpar, ' reset sphere/scaletheta'
        call SLICPSET( 'PAR2  ', slicpar,ipslic )
      elseif( readlbl(1:6) .eq. 'slpar3' )then
        read(IDAT,*)  slicpar 
        write(IWR,'(f12.4,a)')  slicpar, ' is unused'
        call SLICPSET( 'PAR3  ', slicpar,ipslic )
      elseif( readlbl(1:6) .eq. 'slpar4' )then
        read(IDAT,*)  slicpar 
        write(IWR,'(f12.4,a)')  slicpar, ' is unused'
        call SLICPSET( 'PAR4  ', slicpar,ipslic )
c         ... and we have PAR1-PAR9 available in the module
      elseif( readlbl(1:6) .eq. 'fank0 ' )then
        write(IWR,*) 'fank0   - use raw force on sphere anchor'
        call SLICPSET( 'FANK0 ', slicpar,ipslic )
      elseif( readlbl(1:6) .eq. 'fankf ' )then
        write(IWR,*) 'fankf   - add full 1-fold force onto anchor'
        call SLICPSET( 'FANKF ', slicpar,ipslic )
      elseif( readlbl(1:6) .eq. 'fankb ' )then
        write(IWR,*) 'fankb   - add bond-project 1-fold frc onto anchor'
        call SLICPSET( 'FANKB ', slicpar,ipslic )
c
      elseif( readlbl(1:4) .eq. 'slic' )then
c       Projection options for SLIC local cooordinate transforms
c
        write(IWR,*) '# Selected Local Internal Coordinates (SLIC)'
c       Get id of projected atom, type of projection, anchor atoms
C        read(IDAT,*) iatmproj,ityproj,iank1,iank2
        read(readlbl(5:5),'(i1)',err=713)  ityproj
        if( ityproj .eq. 1 .or. ityproj.eq.2 )then
c         1=Cylinder and 2=Sphere are only valid options
          read(IDAT,8000,end=913,err=913)  label
          call INDATOM( 3     , label,nline, natm,atmnm,natmnm,
     $                  itmp )
          iatmproj = itmp(1)
          iank1  = itmp(2)
          iank2  = itmp(3)
          goto 720
        endif
  713   continue
        write(IWR,*) 'ERROR reading SLIC type'
        write(IWR,*) ' Keyword = slic1 .or. slic2  ie. not just slic'
        write(IWR,*) '  projected-atom  anchor1-atom  anchor2-atom '
        call STOPXERR( 'bad slic definition' )
  720   continue
c
c       Set projection flag for atom iatmproj
        write(IWR,'(1x,3i6,2x,a)') iatmproj, iank1, iank2,
     $                          '= atom#,  ank1#, ank2#'
        if( ( iatmproj .le. 0 .or. iatmproj .gt. natm ) .or.
     $      ( iank1    .le. 0 .or. iank1    .gt. natm ) .or.
     $      ( iank2    .le. 0 .or. iank2    .gt. natm ) )then
          call STOPXERR( 'unknown atom(s) in slic' )
        endif
        if( iatmproj.eq.iank1 .or. iatmproj.eq.iank2 .or.
     $      iank1.eq.iank2 )then
          call STOPXERR( 'atoms in slic definition not distinct' )
        endif
c
c:      Load into (not yet integrated  unified-SLICS data
        islictyp = ityproj
        nslics = nslics + 1
        islic = nslics
        islics(1,islic) = islictyp
        islics(2,islic) = iatmproj
        islics(3,islic) = iank1
        islics(4,islic) = iank2
        if( iforce(iatmproj).gt.1 )call STOPXERR('constraints conflict')
        if( iforce(iatmproj).eq.0 ) nafrc = nafrc + 1
c       Set islictyp=2 for iforce(), to distinguish it from other relax
        iforce(iatmproj) = 2
c
cRMV:end
      elseif( readlbl.ne. '      ' )then
c
        call STOPXERR( 'geomdata/unknown input command' )
c
      endif
c
      goto 100
c
  913 continue
      write(IWR,*)  'ERROR reading/parsing geometry section'
      call STOPXERR( 'error in relaxation input' )
c
  990 continue
      write(IWR,9991) igstop,gblend,gconv, nafrc
 9991 format(
     $ /1x,'>>>> Relax params (gstop,gblend,gconv,atoms-relaxd):'
     $ /1x,'>>>> ',i6,1x,f10.7,1x,f15.12,1x,i6 / )
c
       RETURN
c
  999 continue
      dorelax = .false.
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> INDATOM
c
c
      subroutine INDATOM( mlist, line,nline, natm,atmnm,natmnm,
     $                    iatmlist )
c---------------------------------------------------------------
c Purpose: extract atom indices from line with atom specs
c
c Written: Peter A. Schultz, 5-June-2015, for 2.67
c
c Revision history:
c   none
c---------------------------------------------------------------
c
c On input:
c     line*(nline) = character string, presumably with atom list
c     mlist = number of presumptive atoms on line
c           = -1 -> open-ended list, then mlist returns total atoms found
c On output:
c     iatmlist(iatm) = indices of atoms found in list
c                    = -1 upon atom-not-found or other error
c     mlist = total number of valid atoms found
c
      IMPLICIT NONE
c
c Input declarations
      INTEGER  mlist,natm,natmnm
      INTEGER  nline
      CHARACTER*(*)  line
      CHARACTER*(*)  atmnm
      DIMENSION  atmnm(*)
c Output declaration
      INTEGER  iatmlist(*)
c Local declarations
      INTEGER  maxlist, nlist, iatm
      INTEGER  nl1,nl2,n1,n2,nmlen, nm1,nm2
c
c >>>> EXECUTABLE CODE
c
      if( mlist .eq. 0 )then
c       Nothing to look for
        RETURN
      elseif( mlist .lt. 0 )then
c       Open-ended, check against total number of atoms
        maxlist = natm
      else
        maxlist = mlist
        do  iatm=1,mlist
          iatmlist(iatm) = -1
        enddo
      endif
      nlist = 0
c n1 is first character in string, nlreadtyp self-indexes
      n1 = 1
c
  100 continue
      if( nlist .eq. maxlist ) goto 1000
      call LNREADTYP( line,n1,nline,  iatm,  natm,atmnm,natmnm )
      if( iatm .gt. 0 .and. iatm .le. natm )then
        nlist = nlist + 1
        iatmlist(nlist) = iatm
      else
c       We did not obtain a valid atom label
c       Either end of list, or error reading label in list
        goto 1000
      endif
      goto 100
c
 1000 continue
      if( mlist .eq. -1 ) mlist = nlist
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c*******************************************************************************
c GESSER  - routines to handle the scf-guessing machinery
c
C Routines:
c  GESSER   - construct and record guess info for next step
c  GESSET   - construct guess scf Ham for this step
c  GESOPEN  - open files needed for gesser
c  GESCLOSE - closed files used by gesser
c
c Revision history:
c  12Apr15-PAS/2.66: gesopen (use igesopt to determine if to open files)
c*******************************************************************************
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GESSER
c
c
      subroutine GESSER( iges0fl,igesfl, igesopt,
     $ do_geom, madeges, mat, nk, nspin,
     $ vij,       wk1 )
c      nmatskloc  mat ; nmatsloc= mat*nkloc*nspin
c---------------------------------------------------------------
c Purpose: construct guess for scf Hamiltonian in geom relax.
c
c Written: Peter A. Schultz, 23-July-2001, for v2.49 (spin)
c
c Revision history:
c  12Nov09-ACP/2.63: k-parallel I/O, PAS: k-master only executes
c   2Feb09-PAS/2.63: HKsp+H memory for k-parallel
c  25Feb07-PAS/2.60: flag-based disable of guess scf in step
c   4Oct02-PAS/2.54: image-specific guess files for NEB
c   3May02-PAS/2.53: make work with cell optimization
c  23Jul01-PAS/2.49: push down from main code, add spin-pol
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER( one = 1.d0 )
c
c Input/Output arrays:
      LOGICAL    do_geom
c      DIMENSION  vij(mat,nk,nspin)
      DIMENSION  vij(mat,*)
c Scratch arrays:
      DIMENSION  wk1(mat)
c
c >>>> EXECUTABLE CODE:
c
c  Get Local MP info
      call MPNODES_K( nprocs_k )
      call MPNODE_K( iproc_k )
      call MPNODE0_K( master_k )
      call MPCOMM_K( icomm_k )
c
      call KPMINE( nk, nkloc, nk0 )
c
c     Skip, if no k-points to work
      if( nkloc .eq. 0 ) goto 999
c     And only k-masters will be active ...
      if( iproc_k .ne. master_k ) goto 999
c
      if( do_geom .and. igesopt .eq. 2 )then
c
        REWIND( unit=iges0fl )
c
c       Skip if ges disabled/unavailable for this geom step:
        if( madeges .lt. 0 ) goto 90
c
c       Check that ges files in correct state for constructing ges
        read(iges0fl,err=90,end=90)  istatges
        if( istatges .eq. 0 )then
          call STOPXERR( 'GESSER: expected dHam, got dHam0' )
          REWIND( unit=iges0fl )
        endif
        goto 100
c
   90   continue
c       The ges file is empty or corrupted, or we ignore guess
        istatges = 0
c
  100   continue
        madeges = istatges
c
c       Store away current dHam0, stamped as 0-Ham-containing
        istatges = 0
        REWIND( unit=iges0fl )
        write(iges0fl)  istatges
        if( iproc_k .eq. master_k )then
c         Only kp-masters writes since within a k-group vij is the same.
c
          nkspin = 0
          do  ispin=1,nspin
            do  ikloc=1,nkloc
              call WRITBIG( iges0fl, mat, vij(1,ikloc+nkspin) )
            enddo
            nkspin = nkloc
          enddo
c
        endif
c
        if( madeges .gt. 0 )then
c         Construct guess Ham: augment current dHam0 with previous del-Ham
c
          REWIND( unit=igesfl )
c         Only the kp-masters do the big I/O and calculations.
          if( iproc_k .eq. master_k )then
c
            nkspin = 0
            do  ispin=1,nspin
              do  ikloc=1,nkloc
c               Get previous del-Ham  = ( dHam[scf] - dHam0 ) ...
                call READBIG( igesfl, mat, wk1 )
c     .          .. and add to current initial dHam0 to construct ges Ham
                call DAXPY( mat, one, wk1, 1, vij(1,ikloc+nkspin), 1 )
              enddo
              nkspin = nkloc
            enddo
c
          endif
        endif
c
      endif
c
  999 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GESSET
c
c
      subroutine GESSET( iges0fl,igesfl, igesopt,
     $ do_geom, madeges, mat, nk, nspin,
     $ vij, wk1 )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER( one = 1.d0 )
c
c Input/Output arrays:
      LOGICAL    do_geom
c      DIMENSION  vij(mat,nk,nspin)
      DIMENSION  vij(mat,*)
c Scratch arrays:
      DIMENSION  wk1(mat)
c
c >>>>> EXECUTABLE CODE:
c
c  Get Local MP info
      call MPNODES_K( nprocs_k )
      call MPNODE_K( iproc_k )
      call MPNODE0_K( master_k )
      call MPCOMM_K( icomm_k )
c
      call KPMINE( nk, nkloc, nk0 )
c
      if( nkloc .eq. 0 ) goto 1999
      if( iproc_k .ne. master_k ) goto 1999
c
      madeges = 0
      if( do_geom .and. igesopt .eq. 2 )then
c
        if( igesopt.gt.1 .and. do_geom )then
c         Construct del-Ham=(dHam(scf) - dHam0), and save
c
          REWIND( unit=iges0fl )
          read(iges0fl)  istatges
          if( istatges.ne.0 )
     $     call STOPXERR( 'GESSET: expected Ham0 in guess file' )
c
          REWIND( unit=igesfl )
c
          if( iproc_k .eq. master_k )then
c
            nkspin = 0
            do  ispin=1,nspin
              do  ikloc=1,nkloc
c               Retrieve dHam0 for this geometry ...
                call READBIG( iges0fl, mat, wk1 )
c               ... generate del-Ham = dHam[scf] - dHam0
                call DSCAL( mat, -one,  wk1, 1 )
                call DAXPY( mat,  one, vij(1,ikloc+nkspin), 1, wk1,1 )
c               ... and store away the del-Ham for the next geometry
                call WRITBIG( igesfl, mat, wk1 )
              enddo
              nkspin = nkloc
            enddo
          endif
c
c         Stamp dHam0 with record it is used up, del-Ham set ...
          madeges = 1
          istatges = 1
c         Everybody writes the flag.
          REWIND( unit=iges0fl )
          write(iges0fl)  istatges
c
        endif
c
      endif
c
c    That's all Folks!
c
 1999 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GESOPEN
c
c
      subroutine GESOPEN( image, iges0fl,igesfl,igesopt, nk )
c---------------------------------------------------------------
c Purpose: get appropriate ges file for this image
c
c Written: Peter A. Schultz, 3-October-2002, for 2.54 (neb)
c
c Revision history:
c  12Apr15-PAS/2.66: only open files if gesser is turned on
c  12Nov09-ACP/2.62: write separate files at k-local level
c   2Feb09-PAS/2.62: split into ges0+ges files
c---------------------------------------------------------------
c
c  Based on the image number, identify and open the appropriate
c  file for the scf guess for this image geometry
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      CHARACTER*10  imgname
      CHARACTER*10  kptname
c
c Every MPI task opens it's own version 
c
      call MPNODES_K( nprocs_k )
      call MPNODE_K( iproc_k )
      call MPNODE0_K( master_k )
      call MPCOMM_K( icomm_k )
c
      call KPMINE( nk, nkloc, nk0 )
c
c Set default unit=-1, to denote no file, so that gesclose knows:
      iges0fl = -1
      igesfl = -1
c     Skip, if no k-points to work
      if( nkloc .eq. 0 ) goto 999
c     Skip, if gessser is not on
      if( igesopt.ne.2 ) goto 999
c     And only k-masters will be active ...
      if( iproc_k .ne. master_k ) goto 999
c     
      if( nprocs_k.eq.0 ) then
        if( image.gt.0 )then
c         Image-specific ges file name
          call STRNUM( nstr, imgname, image,image )
          call FLOPENB( iges0fl, 'gesz'//imgname(1:nstr) )
          call FLOPENB( igesfl, 'ges'//imgname(1:nstr) )
        else
c         Blank name
          call FLOPENB( iges0fl, 'ges0' )
          call FLOPENB( igesfl, 'ges' )
        endif
      else
        call STRNUM( nstrk, kptname, iproc_k, iproc_k+1 )
        if( image.gt.0 )then
c         Image-specific ges file name
          call STRNUM( nstr, imgname, image,image )
          call FLOPENB( iges0fl,
     $         'gesz'//imgname(1:nstr)//'_'//kptname(1:nstrk) )
          call FLOPENB( igesfl,
     $         'ges'//imgname(1:nstr)//'_'//kptname(1:nstrk) )
        else
c         Blank name
          call FLOPENB( iges0fl, 'ges0'//'_'//kptname(1:nstrk) )
          call FLOPENB( igesfl, 'ges'//'_'//kptname(1:nstrk) )
        endif
      endif
c
  999 continue
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GESCLOSE
c
c
      subroutine GESCLOSE( iges0fl,igesfl )
c
c We do not need igesopt here. File units more definitive if files are open
c
      if( iges0fl .ge. 0 )then
c       igesfl exists iff iges0fl exists
        call FLCLOSE( iges0fl )
        call FLCLOSE( igesfl )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GETMIJK
c
c
      subroutine GETMIJK( imatfl, norb,nk, dmat )
c---------------------------------------------------------------
c Purpose: retrieve full density (or analogous) matrix.
c
c Written: Peter A. Schultz, 23-July-2001, for v2.49 (spin)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output array:
      DIMENSION  dmat(norb*norb,nk)
c
c >>>> EXECUTABLE CODE:
c
      do  k=1,nk
        call READBIG( imatfl, norb*norb, dmat(1,k) )
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GGASTRESS
c
c
      subroutine GGASTRESS( strgga, do_gga, do_spin,
     $ idrhfl0,idrhofl,idrhsfl,igrhofl,
     $ ndim, nptr,weight,xcrhocut,
     $ rhoa, rhob, g_dxc, g2_dxc2, gg_d2dn,
     $ drhoa, drhob )
c---------------------------------------------------------------
c Purpose: compute the extra GGA-specific terms needed in stress
c
c Written: Peter A. Schultz, 5-April-2002, for v2.53
c
c Revision history:
c  17Spt08-RJM/2.62: added opposite spin passing to GRIDXSTR needed for am05sp 
c  27Jun07-PAS/2.60: task-parallel - master-only
c   9Oct03-AEM+PAS/2.57: spin-dependent stress added for GGA
c  11Jun03-PAS/2.55: add Laplacian stress term (BLYP)
c   5Apr02-PAS/2.53: modeled off of "GRIDDFT"
c---------------------------------------------------------------
c
c Notes:
c   I need to acquire the extra term in the stress formula that
c   appears because of the gradient-rho that appears in the GGA
c   fcnal [See: A. Dal Corso and R. Resta, PRB 50, 4327 (1994)].
c
c   Let drh[i] = the i'th component of the density gradient:
c      drh[i] = d[rho]/dx[i]
c   Then need the integral over the unit cell:
c     stress(i,j) = INT( ( d[rho*exc]/d[drh[i]] ) * drh[j] )
c   I compute the potential in such a way that I get
c     dxc(r) = d[rho*exc]/d[drh[i]] / drh[i]
c   so that I need only to complete the integral as
c     stress(i,j) = INT( dxc(r) * drh[i](r) * drh[j](r) )
c   Hence, I need to compute dxc(r) in the functional, and sum
c   over the grid the product with the i'th and j'th component
c   of the density gradient.
c
c   For the Laplacian term need something analogous:
c     strlap(i,j) = INT( dxc2(r) * d2_rh(r)/d_x_i*d_x_j )
c
c   This calculation is moot in LDA.
c
c   Spin polarized GGA adds two spin-resolved forms of 1st derivative
c   integrals, and splits the Laplacian second derivative term
c   into two spin resolved pieces (thx to Ann Mattsson).
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, half=0.5d0, one=1.d0 )
c
c Output:
      DIMENSION  strgga(3,3)
c Input::
      LOGICAL    do_gga, do_spin
c Input/scratch: total xc-density (if spin, spin-up and spin-dn)
      DIMENSION  rhoa(nptr), rhob(nptr)
c Scratch:
      DIMENSION  g_dxc(nptr),g2_dxc2(nptr),gg_d2dn(nptr)
      DIMENSION  drhoa(nptr,3), drhob(nptr,3)
c
c Local:
      DIMENSION  strdxc(3,3), strlap(3,3)
      DIMENSION  strsav(3,3),strdel(3,3)
      LOGICAL    do_laplac
      DATA       lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
      if( lstout.gt.0 ) call FLGETIWR( IWR )
      if( IWR.le.0 ) lstout = 0
 9013 format(1x,a,3f16.8)
c
      call MKZERO( 9, strgga )
      call MKZERO( 9, strdxc )
      call MKZERO( 9, strlap )
c
c Get MP info
      call MPNODES( nprocs )
      call MPNODE0( master )
      call MPNODE( iproc )
      call MPCOMM( icomm )
c
c Only the master will do this work
      if( iproc .ne. master ) goto 990
c
      if( .not. do_gga .or. ndim .eq. 0 ) RETURN
c
c     Note if need concern ourselves with Laplacian in the energy fcnal
      call DFTGETLAP( do_laplac )
c
      if( do_gga )then
c       Retrieve grho, g2rho, and gpggp (gga gradients) from igrhofl
        REWIND( igrhofl )
        call READBIG( igrhofl, nptr, g_dxc )
        call READBIG( igrhofl, nptr, g2_dxc2 )
        call READBIG( igrhofl, nptr, gg_d2dn )
      endif
c
      if( do_spin )then
c       Spin-polarized GGA stress * * * * * * * * * * * * * * * * * * *
c
c       Retrieve grho-up, grho-*dn*, g2rho-up from igrhofl
        call READBIG( igrhofl, nptr, drhoa(1,1) )
        call READBIG( igrhofl, nptr, drhoa(1,3) )
        call READBIG( igrhofl, nptr, drhoa(1,2) )
c
c       Compute correlation stress fcnal on grid
        call GRIDCSTR( xcrhocut, nptr, weight,
     $   rhoa,  rhob,  g_dxc,   g2_dxc2,   gg_d2dn,
c -->    rhoa-i rhob-i g_dxc-io g2_d2up-io gg_d2dn-io
     $   drhoa(1,1),drhoa(1,3),drhoa(1,2), drhob(1,1),drhob(1,2) )
c -->    grhoa-i    grhob-i    g2rhoa-i    dxcup-o    dxcdn-o
c
c       Retrieve gpggp-up from igrhofl; grho-up,g2rho-up survived above
        call READBIG( igrhofl, nptr, drhoa(1,3) )
c
c       Compute spin-up exchange stress fcnal on grid
        call GRIDXSTR( xcrhocut, nptr, weight,
     $   rhoa,  rhob,drhoa(1,1),drhoa(1,2),drhoa(1,3),
c -->    rho-i  grho-i     g2rho-i    ggrho-i
     $   drhob(1,1) )
c -->    dxc-io[up]
c
c       Retrieve grho-dn, g2rho-dn, and gpggp-dn from igrhofl
        call READBIG( igrhofl, nptr, drhoa(1,1) )
        call READBIG( igrhofl, nptr, drhoa(1,2) )
        call READBIG( igrhofl, nptr, drhoa(1,3) )
c
c       Compute spin-dn exchange stress fcnal on grid
        call GRIDXSTR( xcrhocut, nptr, weight,
     $   rhob,  rhoa,drhoa(1,1),drhoa(1,2),drhoa(1,3),
c -->    rho-i  grho-i     g2rho-i    ggrho-i
     $   drhob(1,2) )
c -->    dxc-io[dn]
c
c       Have stress functionals, now the fun part of taking integrals
c
c       Move some stress fcnals (dxc-up/dn) to more convenient locations
        call DCOPY( nptr, drhob(1,1),1, rhoa,1 )
        call DCOPY( nptr, drhob(1,2),1, rhob,1 )
c
c       Position the idrh grid density derivatives files
        REWIND( idrhfl0 )
        REWIND( idrhofl )
        REWIND( idrhsfl )
c
c       Construct 1st derivatives of total (up+dn) xc-density
c
c       Retrieve 1st derivatives of reference+core density from idrhfl0
        do  iu=1,ndim
          call READBIG( idrhfl0, nptr, drhoa(1,iu) )
        enddo
c       Retrieve 1st derivatives of total scf delta-density from idrhofl
        do  iu=1,ndim
          call READBIG( idrhofl, nptr, drhob(1,iu) )
        enddo
c       Add d1drho to d1rho0 to get full (up+dn) xc-density derivatives
        call DAXPY( ndim*nptr, one, drhob,1, drhoa,1 )
c
        call DCOPY( 9, strdxc,1, strsav,1 )
c
c       Integrate stress contribution involving total 1st derivatives
c
        call DFTSTR( ndim, strdxc, nptr,weight,
     $   g_dxc, drhoa )
c -->    dxc-i  drho-3i
c
        if( lstout.gt.2 )then
          call DCOPY( 9, strdxc,1, strdel,1 )
          call DAXPY( 9, -1.0d0, strsav,1, strdel,1 )
          write(IWR,9013) 'GGASTR: dftstr-1rh =',(strdel(id,id),id=1,3)
          call DCOPY( 9, strdxc,1, strsav,1 )
        endif
c
c       Construct 1st derivatives of total up/dn-spin xc-densities
c
c       Remove del-density derivs to recover reference xc-density derivs
        call DAXPY( ndim*nptr, -one, drhob,1, drhoa,1 )
c       Now some tight-packed manipulation to get up/dn at same time
        do  iu=1,ndim
c         Make copy of d1rho0[iu]
          call DCOPY( nptr, drhoa(1,iu),1, g_dxc,1 )
c         Retrieve d1drho-up[iu] from idrhsfl
          call READBIG( idrhsfl, nptr, drhoa(1,iu) )
c         Make d1drho-dn[iu] = d1drho[iu] - d1drho-up[iu]
          call DAXPY( nptr, -one, drhoa(1,iu),1, drhob(1,iu),1 )
c         Add half of d1rho0 to d1drho-up/dn to get total up/dn-derivs
          call DAXPY( nptr, half, g_dxc,1, drhoa(1,iu),1 )
          call DAXPY( nptr, half, g_dxc,1, drhob(1,iu),1 )
        enddo
c
c       Integrate stress contribution involving up-spin 1st derivatives
c
        call DFTSTR( ndim, strdxc, nptr,weight,
     $   rhoa, drhoa )
c -->    dxc-i drho-3i
c
        if( lstout.gt.2 )then
          call DCOPY( 9, strdxc,1, strdel,1 )
          call DAXPY( 9, -1.0d0, strsav,1, strdel,1 )
          write(IWR,9013) 'GGASTR: dftstr-1up =',(strdel(id,id),id=1,3)
          call DCOPY( 9, strdxc,1, strsav,1 )
        endif
c
c       Integrate stress contribution involving dn-spin 1st derivatives
c
        call DFTSTR( ndim, strdxc, nptr,weight,
     $   rhob, drhob )
c -->    dxc-i drho-3i
c
        if( lstout.gt.2 )then
          call DCOPY( 9, strdxc,1, strdel,1 )
          call DAXPY( 9, -1.0d0, strsav,1, strdel,1 )
          write(IWR,9013) 'GGASTR: dftstr-1dn =',(strdel(id,id),id=1,3)
          call DCOPY( 9, strdxc,1, strsav,1 )
        endif
c
        if( do_laplac )then
c         Integrate stress contribution involving up/dn 2nd derivatives
c
c         Position idrhfl0,idrhofl,idrhsfl to beginning of 2nd derivs
          if( ndim .lt. 3 )then
c           Step through remaining 1st derivatives in idrh files
            do  id=ndim+1,3
              call READSKP( idrhfl0, nptr )
              call READSKP( idrhofl, nptr )
              call READSKP( idrhsfl, nptr )
            enddo
          endif
c
c         Following assumes idrh files positioned to read 2nd derivs
          call DFTSTR2SP( idrhfl0,idrhofl,idrhsfl,
     $     ndim, strlap, nptr,weight,
     $     g2_dxc2, gg_d2dn,  drhoa(1,1),drhoa(1,2),drhoa(1,3) )
c -->      dxc2up-i dxc2dn-i  ddrho0-s   ddrhoa-s   ddrhob-s
c
          if( lstout.gt.1 )
     $    write(IWR,9013) 'GGASTR: dftstr-2tot=',(strlap(id,id),id=1,3)
        endif
c
        if( lstout.gt.1 )then
          write(IWR,9013) 'GGASTR: dftstr-1tot=',(strdxc(id,id),id=1,3)
        endif
c
c       End spin-GGA stress * * * * * * * * * * * * * * * * * * * * * *
      else
c       Non-spin GGA stress * * * * * * * * * * * * * * * * * * * * * *
c
c       Compute stress functionals dxc(r), dxc2(r) on grid
        call GRIDSTR( xcrhocut, nptr, weight,
     $   rhoa,   g_dxc,    g2_dxc2,   gg_d2dn )
c-->     rho-io  g_dxc-io  g2_dxc2-io gpggp-i
c
c       Position density derivative files
        REWIND( unit=idrhfl0 )
        REWIND( unit=idrhofl )
c
c       Retrieve 1st derivatives of reference+core density from idrhfl0
        do  iu=1,ndim
          call READBIG( idrhfl0, nptr, drhoa(1,iu) )
        enddo
c
c       Retrieve 1st derivatives of scf delta-density from idrhofl
        do  iu=1,ndim
          call READBIG( idrhofl, nptr, drhob(1,1) )
c          ... and combine to get total density derivatives
          do  nr=1,nptr
            drhoa(nr,iu) = drhoa(nr,iu) + drhob(nr,1)
          enddo
        enddo
c
c       Integrate stress contribution involving 1st derivatives
        call DFTSTR( ndim, strdxc, nptr,weight,
     $   g_dxc, drhoa )
c -->    dxc-i  drho-3i
c
        if( do_laplac  )then
c         Integrate stress contribution involving 2nd derivatives
c
c         Position idrhfl0,idrhofl to beginning of 2nd derivs
          if( ndim .lt. 3 )then
c           Step through remaining 1st derivatives in idrh files
            do  id=ndim+1,3
              call READSKP( idrhfl0, nptr )
              call READSKP( idrhofl, nptr )
            enddo
          endif
c
c         Following assumes idrh files positioned to read 2nd derivs
          call DFTSTR2( idrhfl0,idrhofl,idrhsfl,
     $     ndim, strlap, nptr,weight,
     $     g2_dxc2, drhoa(1,1),drhoa(1,2) )
c -->      dxc2-i   ddrho0-s   ddrho-s
c
        endif
c
        if( lstout.gt.1 )then
          write(IWR,9013) 'GGASTR: dftstr-2tot=',(strlap(id,id),id=1,3)
          write(IWR,9013) 'GGASTR: dftstr-1tot=',(strdxc(id,id),id=1,3)
        endif
c
c       End non-spin GGA stress * * * * * * * * * * * * * * * * * * * *
      endif
c
c Finally, load grid integral results into the output stress:
c (note minus sign, given by Eq.24 of Dal Corso and Resta)
c
      do  jd=1,ndim
        do  id=1,ndim
          strgga(id,jd) = strgga(id,jd) - strdxc(id,jd)
     $                  + strlap(id,jd)
        enddo
      enddo
c
c If non-master, drop to here:
  990 continue
c
      if( nprocs .gt. 1 )then
        lenmsg = 9
        call MPBCAST8( master, lenmsg, strgga, icomm )
      endif
      if( lstout.gt.0 )then
        write(IWR,9013) 'GGASTR: ggastress=',(strgga(id,id),id=1,3)
      endif
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GNORM
c
c
      subroutine GNORM( l, n, a, c )
c---------------------------------------------------------------
c Purpose: normalize contracted gaussians
c
c Written: Peter A. Schultz, 27-July-1998, for v2.23 (split basis)
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  a(n),c(n)
c local declarations:
      DATA  one / 1.d0 /
c
      call GOVLP( s, l, n,a,c, n,a,c )
c
      snorm = one/SQRT(s)
      do  i=1,n
        c(i) = snorm*c(i)
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GOVLP
c
c
      subroutine GOVLP( sg, l, n1,a1,c1, n2,a2,c2 )
c---------------------------------------------------------------
c Purpose: compute overlap between pair of contract gaussian orbs
c
c Written: Peter A. Schultz, 27-July-1998, for v2.23 (split basis)
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
      DIMENSION  a1(n1),c1(n1), a2(n2),c2(n2)
c local declarations:
      DATA  zero,two / 0.d0,2.d0  /
c
c >>>> EXECUTABLE CODE:
c
      rtpid2 = rtpi/two
      lp1 = l + 1
c
      s = zero
      do  i2=1,n2
        do  i1=1,n1
          als = a1(i1) + a2(i2)
c 07Dec93-PAS: I choose the following form rather than pure
c   exponentiation of "als" cause this way more likely more accurate
          alsfac = SQRT(als)*als**lp1
          s = s + c1(i1)*c2(i2)/alsfac
        enddo
      enddo
c
      s = rtpid2*s
      do  ll=1,2*l+1,2
        s = s*DBLE(ll)/two
      enddo
c
      sg = s
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRADRHO
c
c
      subroutine GRADRHO( do_spin,
     $ idrhfl0,idrhofl,idrhsfl,igrhofl,
     $ n1r,n2r,n3r, nptr, gprim, ws1,ws2,ws3, ftarray,
     $ rho, rhob, wkr,wkrd )
c---------------------------------------------------------------
c Purpose: compute on grid gradients needed for gga calculation,
c          via analytic reference plus fft residual density
c
c Written: Peter A. Schultz, 13-December-2000, for v2.46 (gga)
c
c Revision history:
c   2Feb08-PAS/2.60e: bug master grho/file
c  27Jun07-PAS/2.60: task-parallel; dist-fftdrho, master-grho
c   1Dec03-PAS/2.58: purge unused argument
c  20Jul01-PAS/2.49: spin-polarized dft
c---------------------------------------------------------------
c
c Notes:
c   I combine all the calls for constructing the (scf) gradients
c   under this rtn for clarity, to make memory mgmt easier, and
c   to make file manipulations easier.
c
c   For spin calculation, it looks like an opportunity to skip
c   gradients if up/dn density empty.  However, need to alter
c   reference calculation to make separate up/dn densities/pots.
c   If empty, why not set to grads zero and ignore other spin?
c   Answer: what about when you have a core density?  Ouch.
c   Hence, a simple skip of gradients is only possible for a
c   very special case: H-atom (or similar core-less single spin).
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( one = 1.d0 )
c Input declarations:
      LOGICAL    do_spin
      DIMENSION  gprim(3,3)
c Input array: (delta-density[up/dn] on grid)
      DIMENSION  rho(nptr)
      DIMENSION  rhob(nptr)
c Scratch array:
      DIMENSION  wkr(nptr,7), wkrd(*)
c fft arrays:
      DIMENSION  ws1(*),ws2(*),ws3(*), ftarray(2,*)
c
c Local declarations:
      DATA  lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
c Get MP info:
      call MPNODES( nprocs )
      call MPNODE0( master )
      call MPNODE( iproc )
c
c  Assign memory slots for grid fields (need seven slots total):
c
c gvec(3r),irhog(2r),idrhog(2r)
      igvec  = 1
      irhog  = 4
      idrhog = 6
c
c grho(1r),g2rho(1r),gpggp(1r), drho(3r), ddrho(1r)
      igrho  = 1
      ig2rho = 2
      igpggp = 3
      idrho  = 4
      iddrho = 7
c
c  Make reciprocal space vectors:
c
      call MKGVEC( n1r,n2r,n3r,nptr, gprim, wkr(1,igvec) )
c -->                                       gvec-3o
c
      if( do_spin )then
c       Combine up and dn spin delta-densities ...
        call DAXPY( nptr, one, rhob,1, rho,1 )
      endif
c
c  Compute 1st and 2nd derivatives of delta-density on grid via fft
c  and save to idrhofl
c
      if( iproc.eq.master ) REWIND( unit=idrhofl )
c
      call FFTDRHO( idrhofl,  n1r,n2r,n3r,nptr,
     $ ws1,ws2,ws3,ftarray,
     $ rho,   wkr(1,igvec), wkr(1,irhog), wkr(1,idrhog) )
c -->  rho-io gvec-3i       rhog-2s       drhog-2s
c
c  And, if we have spin-polarized calculation, we need
c  to construct gradients for up/dn separately ...
c
      if( do_spin )then
c
c       Return to separate up/dn delta-densities ...
        call DAXPY( nptr, -one, rhob,1, rho,1 )
c
        if( iproc.eq.master ) REWIND( unit=idrhsfl )
c
c        ... and compute derivatives for up delta-density:
        call FFTDRHO( idrhsfl,  n1r,n2r,n3r,nptr,
     $   ws1,ws2,ws3,ftarray,
     $   rho,   wkr(1,igvec), wkr(1,irhog), wkr(1,idrhog) )
c -->    rho-io gvec-3i       rhog-2s       drhog-2s
c
      endif
c
      if( lstout.gt.2 ) call TIMER( 'After fftdrho' )
c
c     And now we can go and destroy igvec ...
c
c  Combine derivatives from reference density (saved on idrhfl0),
c  and from total delta-density (saved on idrhofl), to construct
c  total density gradient terms needed for gga, and save to igrhofl:
c
c
c Only the master will generate the gradients
      if( iproc .ne. master ) goto 999
c
      REWIND( unit=idrhfl0 )
      REWIND( unit=idrhofl )
c
      call MKGRHO( idrhfl0,idrhofl,   nptr,
     $ wkr(1,igrho),wkr(1,ig2rho),wkr(1,igpggp),
c -->  grho-1o      g2rho-1o      gpggp-1o
     $ wkr(1,idrho),wkr(1,iddrho) )
c -->  drho-3o      ddrho-1s
c
c Shift to beginning of igrhofl:
      REWIND( unit=igrhofl )
c Save total grho, total g2rho, and total gpggp to igrhofl ...
      call WRITBIG( igrhofl, nptr, wkr(1,igrho) )
      call WRITBIG( igrhofl, nptr, wkr(1,ig2rho) )
      call WRITBIG( igrhofl, nptr, wkr(1,igpggp) )
c
      if( do_spin )then
c
c       Need to get gradient terms for up-spin density ...
c
        REWIND( unit=idrhfl0 )
        REWIND( unit=idrhofl )
        REWIND( unit=idrhsfl )
c
        call MKGRHOA( idrhfl0,idrhofl,idrhsfl,   nptr,
     $   wkr(1,igrho),wkr(1,ig2rho),wkr(1,igpggp),
c -->    grho-1o      g2rho-1o      gpggp-1o
     $   wkr(1,idrho),wkr(1,iddrho), wkrd )
c -->    drho-3o      ddrho-1s       grhob-o
c
c       Save grho-up, grho-dn, g2rho-up, and gpggp-up to igrhofl:
        call WRITBIG( igrhofl, nptr, wkr(1,igrho) )
        call WRITBIG( igrhofl, nptr, wkrd )
        call WRITBIG( igrhofl, nptr, wkr(1,ig2rho) )
        call WRITBIG( igrhofl, nptr, wkr(1,igpggp) )
c
c        ... and gradient terms for dn-spin density ...
c
        REWIND( unit=idrhfl0 )
        REWIND( unit=idrhofl )
        REWIND( unit=idrhsfl )
c
        call MKGRHOB( idrhfl0,idrhofl,idrhsfl,   nptr,
     $   wkr(1,igrho),wkr(1,ig2rho),wkr(1,igpggp),
c -->    grho-1o      g2rho-1o      gpggp-1o
     $   wkr(1,idrho),wkr(1,iddrho), wkrd )
c -->    drho-3o      ddrho-1s       wkrd-1s
c
c       Save grho-dn, g2rho-dn, and gpggp-dn to igrhofl:
        call WRITBIG( igrhofl, nptr, wkr(1,igrho) )
        call WRITBIG( igrhofl, nptr, wkr(1,ig2rho) )
        call WRITBIG( igrhofl, nptr, wkr(1,igpggp) )
c
      endif
c
  999 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRADWF
c
c
      subroutine GRADWF( ibox, ncplx, ndim, iatm,ishl,iorbsh, almin,
     $ nk,nk0,nkloc, natm,ntyp, nshld,nald, nlat,
     $ itypa, numshl,lshel,nala,ala,cala, ratm, rlat, coskr,sinkr,
     $ nrbox, boxrad,boxctr,
     $ rv, rsq, sumg,sum2ag, dpdx,dpdy,dpdz,
     $ dphix,dphiy,dphiz,  dphiuv )
c---------------------------------------------------------------
c Purpose: grid wave function gradients for force calculation
c
c Written: Peter A. Schultz, 28-May-1997, for v2.20 (boxes)
c
c Revision history:
c  23Jan09-PAS/2.63: k-parallel dmat matrices
c   7Mar02-PAS/2.52: ang constants extracted
c  21Dec99-PAS/2.42: cosmetic clean-up
c  27Sep99-PAS/2.40: full three-dimensional stress tensor
c  14Jun99-PAS/2.36: rework grid force memory
c   9Nov98-PAS/2.28: single precision grid orbitals/wf4
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  dphix,dphiy,dphiz,  dphiuv
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  ratm(3,iatm), rlat(3,nlat)
      DIMENSION  coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  boxctr(3), rv(3,nrbox)
c output arrays:
      DIMENSION  dphix(*),dphiy(*),dphiz(*)
      DIMENSION  dphiuv(ndim,ndim,*)
c scratch arrays:
      DIMENSION  rsq(nrbox), sumg(nrbox),sum2ag(nrbox)
      DIMENSION  dpdx(nrbox),dpdy(nrbox),dpdz(nrbox)
c local declarations:
      DIMENSION  ratom(3), rlast(3),rshift(3)
c
      DIMENSION  vnorm(5)
      DATA  zero,one,two, four / 0.d0,1.d0,2.d0, 4.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Get angular normalizations:
      call VNORMS( vnorm)
c
      ityp = itypa(iatm)
c
      lshl = lshel(ishl,ityp)
      nali = nala(ishl,ityp)
c
      vn = vnorm(lshl+1)
      angfac = one
c
      do  jr=1,3
        rlast(jr) = zero
      enddo
c
c    Clear out wave function array:
c
          lenv = ncplx*nkloc*nrbox
          call MKSZERO( lenv, dphix )
          call MKSZERO( lenv, dphiy )
          call MKSZERO( lenv, dphiz )
          if( ndim.ne.0 )then
            call MKSZERO( ndim*ndim*lenv, dphiuv )
          endif
c
          irorb = 0
c
          almins = ala(1,ishl,ityp)
          do  ial=2,nali
            ali = ala(ial,ishl,ityp)
            if( ali.lt.almin ) almins = ali
          enddo
          rngmax = SQRT( cutgrid / (almin +almins) )
c
c  Cycle through lattice vectors:
c
          do 900 ilat=1,nlat
c
            rngbox = zero
            do  jr=1,3
              ratom(jr) = ratm(jr,iatm) + rlat(jr,ilat)
              rngbox = rngbox + (ratom(jr)-boxctr(jr))**2
            enddo
            rngbox = SQRT( rngbox ) - boxrad
            if( rngbox.gt.rngmax ) goto 900
c
            rsqbox = rngbox**2
            if( rngbox.lt.zero ) rsqbox = zero
c
            do  jr=1,3
              rshift(jr) = ratom(jr) - rlast(jr)
            enddo
            do  jr=1,3
              rlast(jr) = ratom(jr)
            enddo
c
c  Shift coordinates to this lattice image:
c
            do  nr=1,nrbox
              rv(1,nr) = rv(1,nr) - rshift(1)
              rv(2,nr) = rv(2,nr) - rshift(2)
              rv(3,nr) = rv(3,nr) - rshift(3)
              rsq(nr) = rv(1,nr)**2 + rv(2,nr)**2 + rv(3,nr)**2
              sumg(nr) = zero
              sum2ag(nr) = zero
            enddo
c
            ndo = 0
            do 70 ial=1,nali
              alf = ala(ial,ishl,ityp)
              twoalc = alf + almin
              rsqcut = cutgrid/twoalc
              if( rsqbox.gt.rsqcut ) goto 70
c
              twoalf = alf + alf
              coef = cala(ial,ishl,ityp)/vn
              ndo = ndo + 1
              do  nr=1,nrbox
                expar2 = coef*EXP( -alf*rsq(nr) )
                sumg(nr) = sumg(nr) + expar2
                sum2ag(nr) = sum2ag(nr) + twoalf*expar2
              enddo
   70       continue
            if( ndo.eq.0 ) goto 900
c
            goto (100,110,120), lshl+1
c
c        -----  s-state  -----
c
  100       continue
c       S-function / iorbsh = 1
            do  nr=1,nrbox
              dpdx(nr) = - rv(1,nr)*sum2ag(nr)
              dpdy(nr) = - rv(2,nr)*sum2ag(nr)
              dpdz(nr) = - rv(3,nr)*sum2ag(nr)
            enddo
            goto 400
c
c        -----  p-state  -----
c
  110       continue
            goto (111,112,113) iorbsh
c
  111       continue
c       X-function / iorbsh = 1
            do  nr=1,nrbox
              p = rv(1,nr)
              dpdx(nr) = sumg(nr) - rv(1,nr)*p*sum2ag(nr)
              dpdy(nr) =          - rv(2,nr)*p*sum2ag(nr)
              dpdz(nr) =          - rv(3,nr)*p*sum2ag(nr)
            enddo
            goto 400
c
  112       continue
c       Y-function / iorbsh = 2
            do  nr=1,nrbox
              p = rv(2,nr)
              dpdx(nr) =          - rv(1,nr)*p*sum2ag(nr)
              dpdy(nr) = sumg(nr) - rv(2,nr)*p*sum2ag(nr)
              dpdz(nr) =          - rv(3,nr)*p*sum2ag(nr)
            enddo
            goto 400
c
  113       continue
c       Z-function / iorbsh = 3
            do  nr=1,nrbox
              p = rv(3,nr)
              dpdx(nr) =          - rv(1,nr)*p*sum2ag(nr)
              dpdy(nr) =          - rv(2,nr)*p*sum2ag(nr)
              dpdz(nr) = sumg(nr) - rv(3,nr)*p*sum2ag(nr)
            enddo
            goto 400
c
c        -----  d-state  -----
c
  120       continue
            goto (121,122,123,124,125) iorbsh
c
  121       continue
c       XY-function / iorbsh = 1
            do  nr=1,nrbox
              x = rv(1,nr)
              y = rv(2,nr)
              z = rv(3,nr)
              dpdx(nr) = y*(sumg(nr) - x*x*sum2ag(nr))
              dpdy(nr) = x*(sumg(nr) - y*y*sum2ag(nr))
              dpdz(nr) =           - x*y*z*sum2ag(nr)
            enddo
            goto 400
c
  122       continue
c       YZ-function / iorbsh = 2
            do  nr=1,nrbox
              x = rv(1,nr)
              y = rv(2,nr)
              z = rv(3,nr)
              dpdx(nr) =           - y*z*x*sum2ag(nr)
              dpdy(nr) = z*(sumg(nr) - y*y*sum2ag(nr))
              dpdz(nr) = y*(sumg(nr) - z*z*sum2ag(nr))
            enddo
            goto 400
c
  123       continue
c       ZX-function / iorbsh = 3
            do  nr=1,nrbox
              x = rv(1,nr)
              y = rv(2,nr)
              z = rv(3,nr)
              dpdx(nr) = z*(sumg(nr) - x*x*sum2ag(nr))
              dpdy(nr) =           - z*x*y*sum2ag(nr)
              dpdz(nr) = x*(sumg(nr) - z*z*sum2ag(nr))
            enddo
            goto 400
c
  124       continue
c       X2-Y2 function / iorbsh = 4
            angfac = vnorm(3)/vnorm(4)
            do  nr=1,nrbox
              x = rv(1,nr)
              y = rv(2,nr)
              z = rv(3,nr)
              d = x*x - y*y
              dpdx(nr) = x*( two*sumg(nr) - d*sum2ag(nr))
              dpdy(nr) = y*(-two*sumg(nr) - d*sum2ag(nr))
              dpdz(nr) =                - z*d*sum2ag(nr)
            enddo
            goto 400
c
  125       continue
c       Z2-(X2+Y2)/2 = 3R2-Z2 function / iorbsh = 5
            angfac = vnorm(3)/vnorm(5)
            do  nr=1,nrbox
              x = rv(1,nr)
              y = rv(2,nr)
              z = rv(3,nr)
              d = two*z*z - x*x - y*y
              dpdx(nr) = x*(-two*sumg(nr) - d*sum2ag(nr))
              dpdy(nr) = y*(-two*sumg(nr) - d*sum2ag(nr))
              dpdz(nr) = z*(four*sumg(nr) - d*sum2ag(nr))
            enddo
            goto 400
c
c  Compute wave-function derivatives
c
  400       continue
c
            if( ncplx.eq.1 )then
c
              ir0 = irorb
              do  nr=1,nrbox
                dphix(ir0+nr) = dphix(ir0+nr) + angfac*dpdx(nr)
                dphiy(ir0+nr) = dphiy(ir0+nr) + angfac*dpdy(nr)
                dphiz(ir0+nr) = dphiz(ir0+nr) + angfac*dpdz(nr)
              enddo
c
              ir0 = irorb
              if( ndim.eq.1 )then
                do  nr=1,nrbox
                  dphiuv(1,1,ir0+nr) = dphiuv(1,1,ir0+nr)
     $             + angfac*dpdx(nr)*rv(1,nr)
                enddo
              elseif( ndim.eq.2 )then
                do  nr=1,nrbox
                  dphiuv(1,1,ir0+nr) = dphiuv(1,1,ir0+nr)
     $             + angfac*dpdx(nr)*rv(1,nr)
                  dphiuv(2,1,ir0+nr) = dphiuv(2,1,ir0+nr)
     $             + angfac*dpdy(nr)*rv(1,nr)
                  dphiuv(1,2,ir0+nr) = dphiuv(1,2,ir0+nr)
     $             + angfac*dpdx(nr)*rv(2,nr)
                  dphiuv(2,2,ir0+nr) = dphiuv(2,2,ir0+nr)
     $             + angfac*dpdy(nr)*rv(2,nr)
                enddo
              elseif( ndim.eq.3 )then
                do  nr=1,nrbox
                  dphiuv(1,1,ir0+nr) = dphiuv(1,1,ir0+nr)
     $             + angfac*dpdx(nr)*rv(1,nr)
                  dphiuv(2,1,ir0+nr) = dphiuv(2,1,ir0+nr)
     $             + angfac*dpdy(nr)*rv(1,nr)
                  dphiuv(3,1,ir0+nr) = dphiuv(3,1,ir0+nr)
     $             + angfac*dpdz(nr)*rv(1,nr)
                  dphiuv(1,2,ir0+nr) = dphiuv(1,2,ir0+nr)
     $             + angfac*dpdx(nr)*rv(2,nr)
                  dphiuv(2,2,ir0+nr) = dphiuv(2,2,ir0+nr)
     $             + angfac*dpdy(nr)*rv(2,nr)
                  dphiuv(3,2,ir0+nr) = dphiuv(3,2,ir0+nr)
     $             + angfac*dpdz(nr)*rv(2,nr)
                  dphiuv(1,3,ir0+nr) = dphiuv(1,3,ir0+nr)
     $             + angfac*dpdx(nr)*rv(3,nr)
                  dphiuv(2,3,ir0+nr) = dphiuv(2,3,ir0+nr)
     $             + angfac*dpdy(nr)*rv(3,nr)
                  dphiuv(3,3,ir0+nr) = dphiuv(3,3,ir0+nr)
     $             + angfac*dpdz(nr)*rv(3,nr)
                enddo
c
              endif
c
            elseif( ncplx.eq.2 )then
c
c First, compute d/dv(phi) terms need for force:
              ir = irorb
              do 450 k=1,nkloc
                ik = nk0 + k
                facr = angfac*coskr(ik,ilat)
                faci = angfac*sinkr(ik,ilat)
                do  nr=1,nrbox
                  dphix(ir+1) = dphix(ir+1) + facr*dpdx(nr)
                  dphix(ir+2) = dphix(ir+2) + faci*dpdx(nr)
                  dphiy(ir+1) = dphiy(ir+1) + facr*dpdy(nr)
                  dphiy(ir+2) = dphiy(ir+2) + faci*dpdy(nr)
                  dphiz(ir+1) = dphiz(ir+1) + facr*dpdz(nr)
                  dphiz(ir+2) = dphiz(ir+2) + faci*dpdz(nr)
                  ir = ir + 2
                enddo
  450         continue
c
c and compute d/dv(phi)*u terms needed for stress calculation
              ir = irorb
              if( ndim.eq.1 )then
                do 451 k=1,nkloc
                  ik = nk0 + k
                  facr = angfac*coskr(ik,ilat)
                  faci = angfac*sinkr(ik,ilat)
                  do  nr=1,nrbox
                    dphiuv(1,1,ir+1) = dphiuv(1,1,ir+1)
     $               + facr*dpdx(nr)*rv(1,nr)
                    dphiuv(1,1,ir+2) = dphiuv(1,1,ir+2)
     $                 + faci*dpdx(nr)*rv(1,nr)
                    ir = ir + 2
                  enddo
  451           continue
              elseif( ndim.eq.2 )then
                do 452 k=1,nkloc
                  ik = nk0 + k
                  facr = angfac*coskr(ik,ilat)
                  faci = angfac*sinkr(ik,ilat)
                  do  nr=1,nrbox
                    dphiuv(1,1,ir+1) = dphiuv(1,1,ir+1)
     $               + facr*dpdx(nr)*rv(1,nr)
                    dphiuv(1,1,ir+2) = dphiuv(1,1,ir+2)
     $                 + faci*dpdx(nr)*rv(1,nr)
                    dphiuv(2,1,ir+1) = dphiuv(2,1,ir+1)
     $               + facr*dpdy(nr)*rv(1,nr)
                    dphiuv(2,1,ir+2) = dphiuv(2,1,ir+2)
     $                 + faci*dpdy(nr)*rv(1,nr)
                    dphiuv(1,2,ir+1) = dphiuv(1,2,ir+1)
     $               + facr*dpdx(nr)*rv(2,nr)
                    dphiuv(1,2,ir+2) = dphiuv(1,2,ir+2)
     $                 + faci*dpdx(nr)*rv(2,nr)
                    dphiuv(2,2,ir+1) = dphiuv(2,2,ir+1)
     $               + facr*dpdy(nr)*rv(2,nr)
                    dphiuv(2,2,ir+2) = dphiuv(2,2,ir+2)
     $                 + faci*dpdy(nr)*rv(2,nr)
                    ir = ir + 2
                  enddo
  452           continue
              elseif( ndim.eq.3 )then
                do 453 k=1,nkloc
                  ik = nk0 + k
                  facr = angfac*coskr(ik,ilat)
                  faci = angfac*sinkr(ik,ilat)
                  do  nr=1,nrbox
                    dphiuv(1,1,ir+1) = dphiuv(1,1,ir+1)
     $               + facr*dpdx(nr)*rv(1,nr)
                    dphiuv(1,1,ir+2) = dphiuv(1,1,ir+2)
     $                 + faci*dpdx(nr)*rv(1,nr)
                    dphiuv(2,1,ir+1) = dphiuv(2,1,ir+1)
     $               + facr*dpdy(nr)*rv(1,nr)
                    dphiuv(2,1,ir+2) = dphiuv(2,1,ir+2)
     $                 + faci*dpdy(nr)*rv(1,nr)
                    dphiuv(3,1,ir+1) = dphiuv(3,1,ir+1)
     $               + facr*dpdz(nr)*rv(1,nr)
                    dphiuv(3,1,ir+2) = dphiuv(3,1,ir+2)
     $                 + faci*dpdz(nr)*rv(1,nr)
                    dphiuv(1,2,ir+1) = dphiuv(1,2,ir+1)
     $               + facr*dpdx(nr)*rv(2,nr)
                    dphiuv(1,2,ir+2) = dphiuv(1,2,ir+2)
     $                 + faci*dpdx(nr)*rv(2,nr)
                    dphiuv(2,2,ir+1) = dphiuv(2,2,ir+1)
     $               + facr*dpdy(nr)*rv(2,nr)
                    dphiuv(2,2,ir+2) = dphiuv(2,2,ir+2)
     $                 + faci*dpdy(nr)*rv(2,nr)
                    dphiuv(3,2,ir+1) = dphiuv(3,2,ir+1)
     $               + facr*dpdz(nr)*rv(2,nr)
                    dphiuv(3,2,ir+2) = dphiuv(3,2,ir+2)
     $                 + faci*dpdz(nr)*rv(2,nr)
                    dphiuv(1,3,ir+1) = dphiuv(1,3,ir+1)
     $               + facr*dpdx(nr)*rv(3,nr)
                    dphiuv(1,3,ir+2) = dphiuv(1,3,ir+2)
     $                 + faci*dpdx(nr)*rv(3,nr)
                    dphiuv(2,3,ir+1) = dphiuv(2,3,ir+1)
     $               + facr*dpdy(nr)*rv(3,nr)
                    dphiuv(2,3,ir+2) = dphiuv(2,3,ir+2)
     $                 + faci*dpdy(nr)*rv(3,nr)
                    dphiuv(3,3,ir+1) = dphiuv(3,3,ir+1)
     $               + facr*dpdz(nr)*rv(3,nr)
                    dphiuv(3,3,ir+2) = dphiuv(3,3,ir+2)
     $                 + faci*dpdz(nr)*rv(3,nr)
                    ir = ir + 2
                  enddo
  453           continue
              endif
c
            endif
c
c    Close lattice loop:
c
  900     continue
c
c    Reconstruct original coordinates:
c
      do  nr=1,nrbox
        rv(1,nr) = rv(1,nr) + rlast(1)
        rv(2,nr) = rv(2,nr) + rlast(2)
        rv(3,nr) = rv(3,nr) + rlast(3)
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRCOFR
c
c
      subroutine GRCOFR( c, r )
c---------------------------------------------------------------
c Purpose: calculates c() matrix for 2nd derivatives in v1ctr
c
c Revision history:
c  19Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION r(3), c(10,3,3)
      DATA  zero,one,two,four / 0.d0,1.d0,2.d0,4.d0 /
c
c >>>> EXECUTABLE CODE:
c
      x = r(1)
      y = r(2)
      z = r(3)
c
      do  l=1,3
        do  ll=1,3
          do  n=1,10
            c(n,l,ll) = zero
          enddo
        enddo
      enddo
c
      c(5,1,2) = one
      c(6,2,3) = one
      c(7,1,3) = one
      c(8,1,1) = one
      c(9,2,2) = one
      c(10,3,3)= one
      c(1,1,2) = x*y
      c(1,2,3) = y*z
      c(1,1,3) = x*z
      c(1,1,1) = x**2
      c(1,2,2) = y**2
      c(1,3,3) = z**2
      c(2,1,2) = -y
      c(3,1,2) = -x
      c(3,2,3) = -z
      c(4,2,3) = -y
      c(2,1,3) = -z
      c(4,1,3) = -x
      c(2,1,1) = -two*x
      c(3,2,2) = -two*y
      c(4,3,3) = -two*z
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRDOVLP
c
c
      subroutine GRDOVLP( ncplx, idwf, near2c, s1atom,orbint,
     $ norb,nk, natm,ntyp, nshld,nald, noad, nlat,
     $ itypa,numshl,lshel,nala,ala,cala,  alamin,norba,
     $ ratm,rlat,coskr,sinkr,  vk, phkdoti,
     $ weight, hh, ndbox,nbox,nrec,inrec,noboxs,inboxs, boxrad,
     $ wvfcns,wf,  wkbox, rmesh,
     $ eikr, otmp )
c---------------------------------------------------------------
c Purpose: compute overlaps on grid of orbitals (for nearby)
c
c Written: Peter A. Schultz,  3-June-1997, for v2.20 (boxes)
c
c Revision history:
c  29Jan10-ACP/2.63 & 6Jul12-PAS: CLeanup
c  17Nov08-PAS/2.63: k-parallel scf matrices
c   4Jan08-PAS/2.61: reduced (dist) memory for grid wvfcns
c   2May01-PAS/2.47: remove disk storage of grid orbitals
c   4Jan00-PAS/2.42: cosmetic clean-up
c   3May99-PAS/2.35: toggle orbint use from flag near2c
c   9Nov98-PAS/2.28: single precision grid orbitals/wf4
c  10Sep98-PAS/2.26: on-the-fly grid orbitals
c---------------------------------------------------------------
c
c Note: orbint&orbofk and sinkr&coskr are in full nk
c       Other arrays (all scratch arrays) are in local nkloc
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c
      REAL  wvfcns,wf
      REAL  ovlpr,ovlpi
c
c Input/Output arrays:
      DIMENSION  s1atom(noad,noad,nk,natm),orbint(2,norb,nk)
c
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), ratm(3,natm), rlat(3,nlat)
      DIMENSION  coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  norba(ntyp),  vk(3,nk)
      DIMENSION  hh(3), ndbox(2,2,3),noboxs(nbox),inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,*),wf(*)
c
c Scratch arrays:
      DIMENSION  wkbox(*)
      DIMENSION  phkdoti(2,*)
c     DIMENSION  phkdoti(2,nkloc)
      DIMENSION  rmesh(3,*),eikr(2,*)
c      needs to match the larger of s1atom() and orbint()
      DIMENSION  otmp(*)
c
c Local declarations:
      DIMENSION  r0box(3),boxctr(3)
c  Criterion of rapidly varying orbital:
      DATA  alfast / 1.2d0 /
      LOGICAL    EVEN
c Statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
c  Get Local MP info
      call MPNODES( nprocl )
      call MPNODE0( masterl )
      call MPNODE( iprocl )
      call MPCOMM( icomml )
c
      call MPNODES_K( nprocs )
      call MPNODE0_K( master )
      call MPNODE_K( iproc )
      call MPCOMM_K( icomm )
c
c  Set up k-parallel
      call KPMINE( nk,nkloc,nk0 )
c
c  Clear out non-master data, so that reduce counts analytics only once
      if( nprocl .gt. 1 )then
        lenvec2 = 2*norb*nk
        lenvec1 = noad*noad*nk*natm
        if( iprocl .ne. masterl )then
c         Multi-proc, and not the master; clear data
          if( near2c .eq. 2 )then
            call MKZERO( lenvec2, orbint )
          endif
          call MKZERO( lenvec1, s1atom )
        endif
Cc       Put a barrier here to make sure master is ready
C        barr = zero
C        lenbarr = 1
C        call MPBCAST8( masterl, lenbarr, barr, icomml )
      endif
c
c     If nkloc=0, bypass loop, because nothing to do ...
      if( nkloc .eq. 0 ) goto 1001
c
      ir00 = 0
      inbox = 0
      jnbox = 0
c
c Loop over boxes of grid points
c
      do 1000 ibox=1,nbox
c
c       Each processor will do every nprocs'th box in this loop
        if( MOD( ibox, nprocs ) .ne. iproc ) goto 1000
c
c       Get basic box data
        call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $   ira0,irb0,irc0, idra,idrb,idrc )
        nrbox = idra*idrb*idrc
c
        nrkbox = nkloc*nrbox
c
c       Get number of orbitals in this box; if none, skip
        nobox = noboxs(ibox)
        if( nobox.le.0 ) goto 1000
c
c       Get grid orbitals:
c
        if( idwf.eq.0 )then
c         Compute orbitals on mesh in this box
c
c         Generate mesh point coordinates
          call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
          call MKRBOX( hh,r0box, idra,idrb,idrc, wkbox )
          ir00 = 0
          iwk1 = 1
          iwk2 = iwk1 + 3*nrbox
          iwk3 = iwk2 + nrbox
          iwk4 = iwk3 + nrbox
          iwk5 = iwk4 + nrbox
          iwk6 = iwk5 + nrbox
          iwk7 = iwk6 + nrbox
          iwk8 = iwk7 + nrbox
c
          call BOXWFN( ibox, ncplx,
     $     nk,nk0,nkloc, natm,ntyp, nshld,nald, nlat,
     $     itypa,numshl,lshel,nala,ala,cala,alamin,
     $     ratm,rlat,coskr,sinkr,
     $     nobox,nrbox,nrec,inrec,inboxs, boxrad,boxctr,
     $     wvfcns(1,ir00+1), wf(ir00+1),
     $     wkbox      ,wkbox(iwk2),wkbox(iwk3),wkbox(iwk4),
     $     wkbox(iwk5),wkbox(iwk6),wkbox(iwk7),wkbox(iwk8) )
c
        endif
c
        if( ncplx.eq.2 .and. near2c.eq.2 )then
          call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
          call MKRBOX( hh,r0box, idra,idrb,idrc, rmesh )
c
          kr0 = 0
          do  ikloc=1,nkloc
            ik = nk0 + ikloc
            xk = vk(1,ik)
            yk = vk(2,ik)
            zk = vk(3,ik)
c           calculate exp(ik.r) for evaluation of slowpot counter-terms
            do  nr=1,nrbox
              rdotk = xk*rmesh(1,nr) + yk*rmesh(2,nr) + zk*rmesh(3,nr)
              eikr(1,kr0+nr) = COS( rdotk )
              eikr(2,kr0+nr) = SIN( rdotk )
            enddo
            kr0 = kr0 + nrbox
          enddo
        endif
c
c       Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        irshl = ir00
        inext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          if( ncplx.eq.2 .and. near2c.eq.2 )then
            do  ikloc=1,nkloc
              ik = nk0 + ikloc
              xk = vk(1,ik)
              yk = vk(2,ik)
              zk = vk(3,ik)
              ridotk = xk*ratm(1,iatm)+yk*ratm(2,iatm)+zk*ratm(3,iatm)
              phkdoti(1,ikloc) = COS( ridotk )
              phkdoti(2,ikloc) = SIN( ridotk )
            enddo
          endif
c
          knbox = inbox
          krec = irec
          katshl = iatshl
          krshl = irshl
          iorbat00 = 0
          do 182 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            iorbat0 = iorbat00
            iorbat00 = iorbat00 + norbshi
            i0 = inext
            inext = i0 + norbshi
            if( EVEN(inbox) ) goto 182
c
            nali = nala(ishl,ityp)
            almaxi = ala(nali,ishl,ityp)
            do  ial=1,nali-1
              ali = ala(ial,ishl,ityp)
              if( ali.gt.almaxi ) almaxi = ali
            enddo
c
c           Take care of 2-center terms first:
c
            if( near2c.eq.2 .and. almaxi.ge.alfast )then
c             This is a fast orbital, do this term
              iorb = i0
              irorb = irshl
              do 170 iorbsh=1,norbshi
                iorb = iorb + 1
                ir0 = irorb
                if( ncplx.eq.1 )then
                  osumr = zero
                  do  nr=1,nrbox
                    osumr = osumr + wf(ir0+nr)
                  enddo
                  orbint(1,iorb,1) = orbint(1,iorb,1) - weight*osumr
                  orbint(2,iorb,1) = zero
                elseif( ncplx.eq.2 )then
                  kr0 = 0
                  do  ikloc=1,nkloc
                    ik = nk0 + ikloc
                    osumr = zero
                    osumi = zero
c                   Need SUM( wvfcn(r)*exp(-ik.r) )
                    do  nr=1,nrbox
C eikr(2,irbox+nrbox*(ikloc-1))  (irbox=1,nrbox; ikloc=1,nkloc)
c wvfcns(1:2,1:nrbox(ibox),1:nkloc,1:norbshi(ishl,itypa(iatm)),1:ishl(iatm),1:natm,1:nbox)
                      osumr = osumr + wvfcns(1,ir0+nr)*eikr(1,kr0+nr)
     $                              + wvfcns(2,ir0+nr)*eikr(2,kr0+nr)
                      osumi = osumi - wvfcns(1,ir0+nr)*eikr(2,kr0+nr)
     $                              + wvfcns(2,ir0+nr)*eikr(1,kr0+nr)
                    enddo
                    ir0 = ir0 + nrbox
                    kr0 = kr0 + nrbox
c
                    coskri = phkdoti(1,ikloc)
                    sinkri = phkdoti(2,ikloc)
                    orbint(1,iorb,ik) = orbint(1,iorb,ik)
     $               - weight*(osumr*coskri-osumi*sinkri)
                    orbint(2,iorb,ik) = orbint(2,iorb,ik)
     $               - weight*(osumr*sinkri+osumi*coskri)
                  enddo
                endif
                irorb = irorb + nrkbox
  170         continue
            endif
c
            jnbox = knbox
            jrec = krec
            jatshl = katshl
            jrshl = krshl
            jorbat00 = 0
            do 181 jshl=1,ishl
              norbshj = 2*lshel(jshl,ityp) + 1
c
              jnbox = jnbox/2
              if( inrec*(jatshl/inrec).eq.jatshl )then
                jrec = jrec + 1
                jnbox = inboxs(jrec,ibox)
              endif
              jatshl = jatshl + 1
              jorbat0 = jorbat00
              jorbat00 = jorbat00 + norbshj
              if( EVEN(jnbox) ) goto 181
c
              joff = 0
              if( jshl.eq.ishl )then
                norbshj = 0
                joff = 1
              endif
c
              nalj = nala(jshl,ityp)
              almaxj = ala(nalj,jshl,ityp)
              do  jal=1,nalj-1
                alj = ala(jal,jshl,ityp)
                if( alj.gt.almaxj ) almaxj = alj
              enddo
c
              if( almaxi.lt.alfast .and. almaxj.lt.alfast )then
c               Both slow shells, skip
                jrshl = jrshl + norbshj*nrkbox
                goto 181
              endif
c
              irorb = irshl
              iorbat = iorbat0
              do 172 iorbsh=1,norbshi
                iorbat = iorbat + 1
c
                norbshj = norbshj + joff
c
                jrorb = jrshl
                jorbat = jorbat0
                do 171 jorbsh=1,norbshj
                  jorbat = jorbat + 1
c
                  ir0 = irorb
                  jr0 = jrorb
c
                  do 60 ikloc=1,nkloc
                    ik = nk0 + ikloc
                    ovlpr = zero
                    ovlpi = zero
                    if( ncplx.eq.1 )then
                      do  nr=1,nrbox
                        ovlpr= ovlpr + wf(ir0+nr)*wf(jr0+nr)
                      enddo
                    elseif( ncplx.eq.2 )then
                      do  nr=1,nrbox
c                       ovlp =+ wvfcns(ir0+nr)*CONJG(wvfcns(jr0+nr))
                        ovlpr= ovlpr + wvfcns(1,ir0+nr)*wvfcns(1,jr0+nr)
     $                               + wvfcns(2,ir0+nr)*wvfcns(2,jr0+nr)
                        ovlpi= ovlpi + wvfcns(2,ir0+nr)*wvfcns(1,jr0+nr)
     $                               - wvfcns(1,ir0+nr)*wvfcns(2,jr0+nr)
                      enddo
                    endif
                    ovlpr = weight*ovlpr
                    ovlpi = weight*ovlpi
c
c                   Subtract grid overlap to form "defect" overlap:
c
                    s1atom(iorbat,jorbat,ik,iatm) =
     $               s1atom(iorbat,jorbat,ik,iatm) - ovlpr
                    if( iorbat.ne.jorbat )then
                      s1atom(jorbat,iorbat,ik,iatm) =
     $                 s1atom(jorbat,iorbat,ik,iatm) - ovlpi
                    endif
c
                    ir0 = ir0 + nrbox
                    jr0 = jr0 + nrbox
   60             continue
c
                  jrorb = jrorb + nrkbox
  171           continue
c
                irorb = irorb + nrkbox
  172         continue
c
              jrshl = jrshl + norbshj*nrkbox
  181       continue
c
            irshl = irshl + norbshi*nrkbox
  182     continue
c
c         Close atom loop:
  200   continue
c
c       Close box loop:
  900   continue
        ir00 = ir00 + nobox*nrkbox
 1000 continue
c     Bypass from nkloc=0:
 1001 continue
c
      if( nprocl .gt. 1 )then
c       Need to sum results over all processors
        if( near2c .eq. 2 )then
          call MPREDUC8( masterl, lenvec2, orbint, otmp, icomml )
          if( iprocl.eq.masterl ) call DCOPY( lenvec2, otmp,1, orbint,1)
          call MPBCAST8( masterl, lenvec2, orbint, icomml )
        endif
        call MPREDUC8( masterl, lenvec1, s1atom, otmp, icomml )
        if( iprocl.eq.masterl ) call DCOPY( lenvec1, otmp,1, s1atom,1 )
        call MPBCAST8( masterl, lenvec1, s1atom, icomml )
      endif
c
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c       Kill those terms where the orbitals are slowly varying
c* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      i0 = 0
      do 1200 iatm=1,natm
        ityp = itypa(iatm)
c
        iorbat00 = 0
        do 1185 ishl=1,numshl(ityp)
          norbshi = 2*lshel(ishl,ityp) + 1
          iorbat0 = iorbat00
          iorbat00 = iorbat00 + norbshi
c
          nali = nala(ishl,ityp)
          almaxi = ala(nali,ishl,ityp)
          do  ial=1,nali-1
            ali = ala(ial,ishl,ityp)
            if( ali.gt.almaxi ) almaxi = ali
          enddo
c
          if( near2c.eq.2 .and. almaxi.lt.alfast )then
c           Slow orbital, blank this term
            do  ik=1,nk
              do  iorb=i0+1,i0+norbshi
                orbint(1,iorb,ik) = zero
                orbint(2,iorb,ik) = zero
              enddo
            enddo
          endif
          i0 = i0 + norbshi
c
          iorbat = iorbat0
          do 1175 iorbsh=1,norbshi
            iorbat = iorbat + 1
c
            jorbat00 = 0
            do 1180 jshl=1,ishl
              norbshj = 2*lshel(jshl,ityp) + 1
              jorbat0 = jorbat00
              jorbat00 = jorbat00 + norbshj
c
              nalj = nala(jshl,ityp)
              almaxj = ala(nalj,jshl,ityp)
              do  jal=1,nalj-1
                alj = ala(jal,jshl,ityp)
                if( alj.gt.almaxj ) almaxj = alj
              enddo
              if( jshl.eq.ishl ) norbshj = iorbsh
c
              if( almaxi.lt.alfast .and. almaxj.lt.alfast )then
c               Both slow orbitals, blank term
                jorbat = jorbat0
                do 1070 jorbsh=1,norbshj
                  jorbat = jorbat + 1
                  if( iorbat.eq.jorbat )then
                    do  ik=1,nk
                      s1atom(iorbat,jorbat,ik,iatm) = zero
                    enddo
                  else
                    do  ik=1,nk
                      s1atom(iorbat,jorbat,ik,iatm) = zero
                      s1atom(jorbat,iorbat,ik,iatm) = zero
                    enddo
                   endif
 1070           continue
                goto 1180
              endif
c
 1180       continue
c
 1175     continue
 1185   continue
c
c    Close atom loop:
c
 1200 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRELAX
c
c
      subroutine GRELAX( IWR, gblend, tstep, engytotl,
     $ igstep,nhistg, nrlxdim, chgmax,
     $ natmg,watmg,nxatm, ratmg,frcg, vatmg,amassg, wk3,wk4,
     $ mxwkb, wkb )
c---------------------------------------------------------------
c Purpose: blend to get new coordinates for next geometry
c
c Written: Peter A. Schultz, 18-May-2001, for v2.47
c
c Revision history:
c  21Jun07-PAS/2.60: BFGS disabled
c   7May04-RPM/2.58: add MD stuff
c  25Apr04-PAS/2.58: purge "igtype" passing
c  11Sep03-PAS/2.57: remove itmaxd-dependence
c  10Jan03-PAS/2.55: added LBFGS, limited-history Broyden
c  19Feb02-PAS/2.54: put step increment into this routine
c   4Feb02-PAS/2.51c: dmd velocity/mass file installed
c   8Dec01-PAS/2.51: file manager/io-units
c  30Oct01-PAS/2.50: modularize relax scheme choice
c   3Oct01-PAS/2.50: damped dynamics relaxation
c  18May01-PAS/2.47: extract from main routine
c---------------------------------------------------------------
c
c Relaxation schemes:
c  ig_type  = choice of geometry scheme from following ...
c  ig_steep = simple steepest descents
c  ig_broy  = modified Broyden (D.D. Johnson)
c  ig_md0   = simple dynamics
c  ig_dmd   = "damped dynamics" a la Jonsson - component-wise
c  ig_dmdat = "damped dynamics" a la Jonsson - atom-by-atom
c  ig_asd   = accelerated steepest descent (modified damped dyn.)
c  ig_lbfgs = limited memory BFGS
c  ig_cg    = conjugate gradient (not yet coded)
c  ig_qmd   = molecular dynamics (RPM)
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /GEOMTYPS/ ig_type, ig_steep,ig_broy,ig_md0,
     $ ig_dmd,ig_dmdat,ig_asd,ig_lbfgs,ig_cg, ig_qmd
c
c Input/Output array (atomic positions, velocities):
      DIMENSION  ratmg(*)
      DIMENSION  vatmg(*), watmg(*)
c Input:
      DIMENSION  frcg(*), amassg(*)
      DIMENSION  nxatm(*)
c Scratch arrays:
      DIMENSION  wk3(*),wk4(*), wkb(*)
c
c Local declarations:
      DATA  one / 1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      igtype = ig_type
      if( igtype .eq. ig_steep )then
c
        write(IWR,*) '>>>>> Simple blend for new geometry'
c
        do  irlx=1,nrlxdim
          ratmg(irlx) = ratmg(irlx) + gblend*frcg(irlx)
        enddo
c
      elseif( igtype .eq. ig_broy )then
c
c       Modified broyden blend to get new vector.
c
        call BROYDDJ( IWR, 'geom', igstep,nhistg, gblend,
     $   chgmax,nrlxdim,
     $   frcg, ratmg,   wk3,   wk4 )
c -->    vv1-i vv2-io   vv3-s  vv4-s
c
      elseif( igtype .eq. ig_dmd .or. igtype .eq. ig_dmdat .or.
     $        igtype .eq. ig_asd .or. igtype .eq. ig_md0   )then
c
c       "Damped dynamics" or PAS accelerated steepest descent relaxation
c
        if( igtype .eq. ig_dmd )then
c         Jonsson damped dynamics - component-wise
          igdmdmod = 1
        elseif( igtype .eq. ig_dmdat )then
c         Jonsson damped dynamics - atom-by-atom
          igdmdmod = 2
        elseif( igtype .eq. ig_asd )then
c         PAS accel. steep. desc. (=modified damped dynamics)
          igdmdmod = 3
        elseif( igtype .eq. ig_md0 )then
c         Simple dynamics
          igdmdmod = 0
        endif
c
        call DMD( IWR, 'geom', igstep, igdmdmod,
     $   nrlxdim, natmg,nxatm, tstep,
     $   amassg, ratmg,vatmg,frcg, watmg )
c
      elseif( igtype .eq. ig_lbfgs )then
c
c       Limited history BFGS method
c
C        call BFGS_STEP( IWR, 'geom', igstep,nhistg,gblend, engytotl,
C     $   nrlxdim, ratmg,  frcg,  wk3  ,   wkb    ,mxwkb )
Cc -->             rvec-io gvec-i rvecx-s  wk_bfgs(lots)-s
         call STOPXERR( 'BFGS disabled/removed' )
c
      elseif( igtype .eq. ig_qmd )then
c
c        Quest molecular dynamics update
c
         call QMDUPDATE( ratmg,frcg )
c
      else
c
        write(IWR,*) '***** ERROR: relaxation scheme unknown:', igtype
        call STOPXERR( 'GRELAX: unknown relaxation type' )
c
      endif
      igstep = igstep + 1
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRHODM1B
c
c
      subroutine GRHODM1B( ibox,
     $ norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox, nobox,inboxs,
     $ wvfcns, rhobox, wkbi,
     $ dmat, dmatbx )
c---------------------------------------------------------------
c Purpose: computes electron density in coordinate space,
c          through a density matrix scheme (real)
c          Version using level-3 blas
c
c Written: Peter A. Schultz,  4-Jun-1999, for v2.36
c          Based on a suggestion from Dave Raczkowski
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Notes:
c  This routine first takes the full dense density matrix in
c  dmat, and packs the part of it used in this box into dmatbx.
c  This packed array is then sent into the level-3 blas routine
c  sgemm for the cpu-heavy arithmetic.
c
c  Tried substituting ssymm, the symmetric form of the level-3
c  blas, for sgemm (note code commented by csym), and the code
c  was slower by 1/3.  Hence, use sgemm instead.  4jun99-pas
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  dmat, dmatbx
      REAL  rhobox
      REAL  r4zero,r4one
csym      REAL  r4half
c
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(nrbox,nobox)
      DIMENSION  dmat(norb,norb)
c output array:
      DIMENSION  rhobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(nrbox,nobox)
      DIMENSION  dmatbx(nobox,nobox)
c local declarations:
      DATA  r4zero,r4one / 0.e0,1.e0 /
csym      DATA  r4half / 0.d0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
      jnbox = 0
c
c Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        inext = 0
        ibnext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            ib0 = ibnext
            ibnext = ibnext + norbshi
c
            jrec = 0
            jatshl = 0
            jnext = 0
            jbnext = 0
            do 100 jatm=1,iatm
              jtyp = itypa(jatm)
              nshlj = numshl(jtyp)
              if( jatm.eq.iatm ) nshlj = ishl
c
              do 80 jshl=1,nshlj
                norbshj = 2*lshel(jshl,jtyp) + 1
c
                jnbox = jnbox/2
                if( inrec*(jatshl/inrec).eq.jatshl )then
                  jrec = jrec + 1
                  jnbox = inboxs(jrec,ibox)
                endif
                jatshl = jatshl + 1
                j0 = jnext
                jnext = jnext + norbshj
                if( EVEN(jnbox) ) goto 80
c
                jb0 = jbnext
                jbnext = jbnext + norbshj
c
                joff = 0
                if( jatm.eq.iatm .and. jshl.eq.ishl )then
                  norbshj = 0
                  joff = 1
                endif
c
                i = i0
                ib = ib0
                do 170 iorbsh=1,norbshi
                  i = i + 1
                  ib = ib + 1
c
                  norbshj = norbshj + joff
c
                  j = j0
                  jb = jb0
                  do 70 jorbsh=1,norbshj
                    j = j + 1
                    jb = jb + 1
c
c Supposed to do triangle, actually do full block
                    dmatbx(jb,ib) = r4zero
                    dmatbx(ib,jb) = dmat(i,j)
csymc
csymc Use symmetric form of blas routine, lower triangle
csym                    if( ib.eq.jb )then
csym                      dmatbx(ib,jb) = dmat(i,j)
csym                    else
csym                      dmatbx(ib,jb) = r4half*dmat(i,j)
csym                    endif
c
   70             continue
  170           continue
c
   80         continue
  100       continue
c
  180     continue
  200   continue
c
c  Now have dmat in this box packed in dmatbx.
c
c Do heavy lifting inside level-3 blas routine:
        call SGEMM( 'n','n', nrbox,nobox,nobox, r4one,
     $   wvfcns,nrbox, dmatbx,nobox, r4zero, wkbi,nrbox )
csymc
csym        call SSYMM( 'r','l', nrbox,nobox, r4one,
csym     $   dmatbx,nobox, wvfcns,nrbox, r4zero, wkbi,nrbox )
c
c Complete density calculation:
        do  ib=1,nobox
          do  nr=1,nrbox
            rhobox(nr) = rhobox(nr)
     $       + wvfcns(nr,ib)*wkbi(nr,ib)
          enddo
        enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRHODM1
c
c
      subroutine GRHODM1( ibox,
     $ norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox, nobox,inboxs,
     $ wvfcns, rhobox, wkbi,
     $ dmat )
c---------------------------------------------------------------
c Purpose: computes electron density in coordinate space,
c          through a density matrix scheme (real)
c
c Written: Peter A. Schultz, 11-May-1999, for v2.35
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  dmat, dmatr
      REAL  rhobox
c
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(nrbox,nobox)
      DIMENSION  dmat(norb,norb)
c output array:
      DIMENSION  rhobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(nrbox,5)
c local declarations:
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
      jnbox = 0
c
c Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        iwvshl = 0
        inext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
c Clear workspace:
            call MKSZERO( norbshi*nrbox, wkbi )
c
            jrec = 0
            jatshl = 0
            jwvshl = 0
            jnext = 0
            do 100 jatm=1,iatm
              jtyp = itypa(jatm)
              nshlj = numshl(jtyp)
              if( jatm.eq.iatm ) nshlj = ishl
c
              do 80 jshl=1,nshlj
                norbshj = 2*lshel(jshl,jtyp) + 1
c
                jnbox = jnbox/2
                if( inrec*(jatshl/inrec).eq.jatshl )then
                  jrec = jrec + 1
                  jnbox = inboxs(jrec,ibox)
                endif
                jatshl = jatshl + 1
                j0 = jnext
                jnext = jnext + norbshj
                if( EVEN(jnbox) ) goto 80
c
                joff = 0
                if( jatm.eq.iatm .and. jshl.eq.ishl )then
                  norbshj = 0
                  joff = 1
                endif
c
                iwvxorb = 0
c                iwvorb = iwvshl
                i = i0
                do 170 iorbsh=1,norbshi
                  i = i + 1
c
                  norbshj = norbshj + joff
c
                  jwvorb = jwvshl
                  j = j0
                  do 70 jorbsh=1,norbshj
                    j = j + 1
c
                    iwvx = iwvxorb + 1
c                    iwv = iwvorb + 1
                    jwv = jwvorb + 1
c
                    dmatr = dmat(i,j)
c
c use blas to substitute for explicit loop ...
                    call SAXPY( nrbox, dmatr, wvfcns(1,jwv),1,
     $               wkbi(1,iwvx),1 )
c
c  ... and this is the reduced op code it replaces:
c                    do  nr=1,nrbox
c                      wkbi(nr,iwvx) = wkbi(nr,iwvx)
c     $                 + dmatr*wvfcns(nr,jwv)
c                    enddo
c  ... and this was the original full code:
c                    do  nr=1,nrbox
c                      rhobox(nr) = rhobox(nr) + dmatr*
c     $                 wvfcns(nr,iwv)*wvfcns(nr,jwv)
c                    enddo
c
                    jwvorb = jwvorb + 1
   70             continue
                  iwvxorb = iwvxorb + 1
c                  iwvorb = iwvorb + 1
  170           continue
c
                jwvshl = jwvshl + norbshj
   80         continue
  100       continue
c
c Now collect all the terms:
            iwvx = 0
            iwv = iwvshl
            do  iorbsh=1,norbshi
              iwvx = iwvx + 1
              iwv = iwv + 1
              do  nr=1,nrbox
                rhobox(nr) = rhobox(nr)
     $           + wvfcns(nr,iwv)*wkbi(nr,iwvx)
              enddo
            enddo
c
            iwvshl = iwvshl + norbshi
  180     continue
  200   continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRHODM2B
c
c
      subroutine GRHODM2B( ibox,
     $ norb,nk, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox, nobox,inboxs,
     $ wvfcns, rhobox, wkbi,
     $ dmat, dmatbx )
c---------------------------------------------------------------
c Purpose: computes electron density in coordinate space,
c          though a density matrix scheme (complex)
c          Version using level-3 blas
c
c Written: Peter A. Schultz,  6-Jun-1999, for v2.36
c          Based on suggestion from Dave Raczkowski
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Notes:
c  This routine first takes the full dense density matrix in
c  dmat, and packs the part of it used in this box into dmatbx.
c  This packed array is then sent into the level-3 blas routine
c  cgemm for the cpu-heavy arithmetic.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  dmat, dmatbx
      REAL  rhobox
      REAL  c4zero,c4one
c
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,nrbox,nk,nobox)
      DIMENSION  dmat(2,nk,norb,norb)
c output array:
      DIMENSION  rhobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(2,nrbox,nobox)
      DIMENSION  dmatbx(2,nobox,nobox,nk)
c local declarations:
      DIMENSION  c4zero(2),c4one(2)
      DATA  c4zero / 0.e0,0.e0 /, c4one / 1.e0,0.e0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
      jnbox = 0
c
      call MKSZERO( 2*nk*nobox*nobox, dmatbx )
c
c Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        inext = 0
        ibnext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            ib0 = ibnext
            ibnext = ibnext + norbshi
c
            jrec = 0
            jatshl = 0
            jnext = 0
            jbnext = 0
            do 100 jatm=1,iatm
              jtyp = itypa(jatm)
              nshlj = numshl(jtyp)
              if( jatm.eq.iatm ) nshlj = ishl
c
              do 80 jshl=1,nshlj
                norbshj = 2*lshel(jshl,jtyp) + 1
c
                jnbox = jnbox/2
                if( inrec*(jatshl/inrec).eq.jatshl )then
                  jrec = jrec + 1
                  jnbox = inboxs(jrec,ibox)
                endif
                jatshl = jatshl + 1
                j0 = jnext
                jnext = jnext + norbshj
                if( EVEN(jnbox) ) goto 80
c
                jb0 = jbnext
                jbnext = jbnext + norbshj
c
                joff = 0
                if( jatm.eq.iatm .and. jshl.eq.ishl )then
                  norbshj = 0
                  joff = 1
                endif
c
                i = i0
                ib = ib0
                do 170 iorbsh=1,norbshi
                  i = i + 1
                  ib = ib + 1
c
                  norbshj = norbshj + joff
c
                  j = j0
                  jb = jb0
                  do 70 jorbsh=1,norbshj
                    j = j + 1
                    jb = jb + 1
c
                    do 60 k=1,nk
c
                      dmatbx(1,ib,jb,k) =  dmat(1,k,i,j)
                      dmatbx(2,ib,jb,k) =  dmat(2,k,i,j)
c
   60               continue
c
   70             continue
  170           continue
c
   80         continue
  100       continue
c
  180     continue
  200   continue
c
c  Now have dmat in this box packed in dmatbx.
c
        do  k=1,nk
c
c Do heavy lifting inside level-3 blas routine, k-by-k:
          call CGEMM( 'n','n', nrbox,nobox,nobox, c4one,
     $     wvfcns(1,1,k,1),nk*nrbox, dmatbx(1,1,1,k),nobox,
     $     c4zero, wkbi,nrbox )
c
c Complete the density calculation:
          do  ib=1,nobox
            do  nr=1,nrbox
              rhobox(nr) = rhobox(nr)
     $         + wvfcns(1,nr,k,ib)*wkbi(1,nr,ib)
     $         + wvfcns(2,nr,k,ib)*wkbi(2,nr,ib)
            enddo
          enddo
c
        enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRHODM2
c
c
      subroutine GRHODM2( ibox,
     $ norb,nk, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox, nobox,inboxs,
     $ wvfcns, rhobox, wkbi,
     $ dmat )
c---------------------------------------------------------------
c Purpose: computes electron density in coordinate space,
c          though a density matrix scheme (complex)
c
c Written: Peter A. Schultz, 11-May-1999, for v2.35
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c  Note that dmat() and wvfcns() are complex quantities, but
c  are represented as double-length (1:2,*) real quantities.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  dmat, dmatr,dmati,dmatv
      COMPLEX  dmatc
      REAL  rhobox
c
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,nrbox,nk*nobox)
      DIMENSION  dmat(2,nk,norb,norb)
c output array:
      DIMENSION  rhobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(2,nrbox,nk*5)
c local declarations:
      DIMENSION  dmatv(2)
      EQUIVALENCE  (dmatv(1),dmatr),(dmatv(2),dmati)
      EQUIVALENCE  (dmatv,dmatc)
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
      jnbox = 0
c
c Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        iwvshl = 0
        inext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
c Clear workspace:
            call MKSZERO( 2*nk*norbshi*nrbox, wkbi )
c
            jrec = 0
            jatshl = 0
            jwvshl = 0
            jnext = 0
            do 100 jatm=1,iatm
              jtyp = itypa(jatm)
              nshlj = numshl(jtyp)
              if( jatm.eq.iatm ) nshlj = ishl
c
              do 80 jshl=1,nshlj
                norbshj = 2*lshel(jshl,jtyp) + 1
c
                jnbox = jnbox/2
                if( inrec*(jatshl/inrec).eq.jatshl )then
                  jrec = jrec + 1
                  jnbox = inboxs(jrec,ibox)
                endif
                jatshl = jatshl + 1
                j0 = jnext
                jnext = jnext + norbshj
                if( EVEN(jnbox) ) goto 80
c
                joff = 0
                if( jatm.eq.iatm .and. jshl.eq.ishl )then
                  norbshj = 0
                  joff = 1
                endif
c
                iwvxorb = 0
c                iwvorb = iwvshl
                i = i0
                do 170 iorbsh=1,norbshi
                  i = i + 1
c
                  norbshj = norbshj + joff
c
                  jwvorb = jwvshl
                  j = j0
                  do 70 jorbsh=1,norbshj
                    j = j + 1
c
                    iwvx = iwvxorb
c                    iwv = iwvorb
                    jwv = jwvorb
c
                    do 60 k=1,nk
                      iwvx = iwvx + 1
c                      iwv = iwv + 1
                      jwv = jwv + 1
                      dmatr =  dmat(1,k,i,j)
                      dmati = -dmat(2,k,i,j)
c
c use blas to substitute for explicit loop ...
                      call CAXPY( nrbox, dmatc, wvfcns(1,1,jwv),1,
     $                 wkbi(1,1,iwvx),1 )
c
c  ... and this is the reduced op code it replaces:
c                      do  nr=1,nrbox
c                        wkbi(1,nr,iwvx) = wkbi(1,nr,iwvx)
c     $                   + dmatr*wvfcns(1,nr,jwv)
c     $                   - dmati*wvfcns(2,nr,jwv)
c                        wkbi(2,nr,iwvx) = wkbi(2,nr,iwvx)
c     $                   + dmatr*wvfcns(2,nr,jwv)
c     $                   + dmati*wvfcns(1,nr,jwv)
c                      enddo
c  ... and this was the original full code:
c                      do  nr=1,nrbox
c                        rhobox(nr) = rhobox(nr) + dmatr*
c     $                   ( wvfcns(1,nr,iwv)*wvfcns(1,nr,jwv)
c     $                   + wvfcns(2,nr,iwv)*wvfcns(2,nr,jwv) )
c                        rhobox(nr) = rhobox(nr) + dmati*
c     $                   ( wvfcns(2,nr,iwv)*wvfcns(1,nr,jwv)
c     $                   - wvfcns(1,nr,iwv)*wvfcns(2,nr,jwv) )
c                      enddo
c
   60               continue
c
                    jwvorb = jwvorb + nk
   70             continue
                  iwvxorb = iwvxorb + nk
c                  iwvorb = iwvorb + nk
  170           continue
c
                jwvshl = jwvshl + nk*norbshj
   80         continue
  100       continue
c
c Now collect all the terms:
            iwvx = 0
            iwv = iwvshl
            do  iorbsh=1,norbshi
              do  k=1,nk
                iwvx = iwvx + 1
                iwv = iwv + 1
                do  nr=1,nrbox
                  rhobox(nr) = rhobox(nr)
     $             + wvfcns(1,nr,iwv)*wkbi(1,nr,iwvx)
     $             + wvfcns(2,nr,iwv)*wkbi(2,nr,iwvx)
                enddo
              enddo
            enddo
c
            iwvshl = iwvshl + nk*norbshi
  180     continue
  200   continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRHOEF1B
c
c
      subroutine GRHOEF1B( ibox, numpop,
     $ norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox, nobox,inboxs,
     $ wvfcns, rhobox, wkbi,
     $ eigvec, evbx )
c---------------------------------------------------------------
c Purpose: computes electron density in coordinate space,
c          via grid eigenfunctions (real)
c          Version using level-3 blas
c
c Written: Peter A. Schultz,  4-Jun-1999, for v2.36
c          Based on a suggestion by Dave Raczkowski
c
c Revision history:
c  23Jul01-PAS/2.49: eigvec indices
c---------------------------------------------------------------
c
c Notes:
c  This routine first takes the full dense eigenvector matrix in
c  eigvec, and packs the part of it used in this box into evbx.
c  This packed array is then sent into the level-3 blas routine
c  sgemm for the cpu-heavy arithmetic.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  eigvec, evbx
      REAL  rhobox
      REAL  r4zero,r4one
c
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(nrbox,nobox)
      DIMENSION  eigvec(numpop,norb)
c output array:
      DIMENSION  rhobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(nrbox,numpop)
      DIMENSION  evbx(numpop,nobox)
c local declarations:
      DATA  r4zero,r4one / 0.e0,1.e0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
c
c  Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        inext = 0
        ibnext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            ib0 = ibnext
            ibnext = ibnext + norbshi
c
            i = i0
            ib = ib0
            do 170 iorbsh=1,norbshi
              i = i + 1
              ib = ib + 1
c
              do 70 n=1,numpop
c
c Pack up box-specific eigenvector array:
                evbx(n,ib) = eigvec(n,i)
c
   70         continue
  170       continue
c
  180     continue
  200   continue
c
c Do heavy lifting inside level-3 blas routine:
        call SGEMM( 'n','t', nrbox,numpop,nobox, r4one,
     $   wvfcns,nrbox, evbx,numpop, r4zero, wkbi,nrbox )
c
c Have occup-weighted eigenfunctions, build density:
        do  n=1,numpop
          do  nr=1,nrbox
            rhobox(nr) = rhobox(nr) + wkbi(nr,n)**2
          enddo
        enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRHOEF1
c
c
      subroutine GRHOEF1( ibox, numpop,
     $ norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox, nobox,inboxs,
     $ wvfcns, rhobox, wkbi,
     $ eigvec )
c---------------------------------------------------------------
c Purpose: computes electron density in coordinate space,
c          via grid eigenfunctions (real)
c
c Written: Peter A. Schultz, 11-May-1999, for v2.35,
c          Based on a suggestion by Dave Raczkowski
c
c Revision history:
c  23Jul01-PAS/2.49: eigvec indices
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  eigvec, cni
      REAL  rhobox
c
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(nrbox,nobox)
      DIMENSION  eigvec(numpop,norb)
c output array:
      DIMENSION  rhobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(nrbox,numpop)
c local declarations:
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
c Clear out grid eigenvector wavefunctions
      call MKSZERO( numpop*nrbox, wkbi )
      inbox = 0
c
c  Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        iwvshl = 0
        inext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            iwvorb = iwvshl
            i = i0
            do 170 iorbsh=1,norbshi
              iwv = iwvorb + 1
              i = i + 1
c
              do 70 n=1,numpop
                cni = eigvec(n,i)
c
c Use blas to build occupation-weighted grid eigenfunctions ...
                call SAXPY( nrbox, cni, wvfcns(1,iwv),1,
     $           wkbi(1,n),1 )
c
   70         continue
c
              iwvorb = iwvorb + 1
  170       continue
c
            iwvshl = iwvshl + norbshi
  180     continue
  200   continue
c
c Have occup-weighted eigenfunctions, build density:
        do  n=1,numpop
          do  nr=1,nrbox
            rhobox(nr) = rhobox(nr) + wkbi(nr,n)**2
          enddo
        enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRHOEF2B
c
c
      subroutine GRHOEF2B( ibox, numpop,
     $ norb,nk, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox, nobox,inboxs,
     $ wvfcns, rhobox, wkbi,
     $ eigvec, evbx )
c---------------------------------------------------------------
c Purpose: computes electron density in coordinate space,
c          via grid eigenfunctions (complex)
c          Version using level-3 blas
c
c Written: Peter A. Schultz,  9-Jun-1999, for v2.36
c          Based on a suggestion by Dave Raczkowski
c
c Revision history:
c  23Jul01-PAS/2.49: eigvec indices
c---------------------------------------------------------------
c
c Notes:
c  This routine first takes the dense complex eigenvector matrix
c  in eigvec, and packs the part of it used in this box into evbx.
c  This packed array is then sent into the level-3 blas routine
c  cgemm for the cpu-heavy arithmetic.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  eigvec, evbx
      REAL  rhobox
      REAL  c4zero,c4one
c
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,nrbox,nk,nobox)
      DIMENSION  eigvec(2,numpop,nk,norb)
c output array:
      DIMENSION  rhobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(2,nrbox,numpop)
      DIMENSION  evbx(2,numpop,nobox,nk)
c local declarations:
      DIMENSION  c4zero(2),c4one(2)
      DATA  c4zero / 0.e0,0.e0 /, c4one / 1.e0,0.e0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
c
c  Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        inext = 0
        ibnext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            ib0 = ibnext
            ibnext = ibnext + norbshi
c
            i = i0
            ib = ib0
            do 170 iorbsh=1,norbshi
              i = i + 1
              ib = ib + 1
c
              do 60 k=1,nk
c
                do 70 n=1,numpop
c Load box-specific eigenvector array:
                  evbx(1,n,ib,k) = eigvec(1,n,k,i)
                  evbx(2,n,ib,k) = eigvec(2,n,k,i)
c
   70           continue
c
   60         continue
c
  170       continue
c
  180     continue
  200   continue
c
c  Do matrix arithmetic k-by-k
c
        do  k=1,nk
c
c Do heavy lifting inside level-3 blas routine, k-by-k:
          call CGEMM( 'n','t', nrbox,numpop,nobox, c4one,
     $     wvfcns(1,1,k,1),nk*nrbox, evbx(1,1,1,k),numpop,
     $     c4zero, wkbi,nrbox )
c
c Have occup-weighted eigenfunctions, build density:
          do  n=1,numpop
            do  nr=1,nrbox
              rhobox(nr) = rhobox(nr) + wkbi(1,nr,n)**2
     $                                + wkbi(2,nr,n)**2
            enddo
          enddo
c
        enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRHOEF2
c
c
      subroutine GRHOEF2( ibox, numpop,
     $ norb,nk, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox, nobox,inboxs,
     $ wvfcns, rhobox, wkbi,
     $ eigvec )
c---------------------------------------------------------------
c Purpose: computes electron density in coordinate space,
c          via grid eigenfunctions (complex)
c
c Written: Peter A. Schultz, 11-May-1999, for v2.35,
c          Based on a suggestion by Dave Raczkowski
c
c Revision history:
c  23Jul01-PAS/2.49: eigvec indices
c---------------------------------------------------------------
c
c  Note that eigvec() and wvfcns() are complex quantities, but
c  are represented as double-length (1:2,*) real quantities.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  eigvec, cni,cnir,cnii
      COMPLEX  cnic
      REAL  rhobox
c
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,nrbox,nk*nobox)
      DIMENSION  eigvec(2,numpop,nk,norb)
c output array:
      DIMENSION  rhobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(2,nrbox,nk*numpop)
c local declarations:
      DIMENSION  cni(2)
      EQUIVALENCE  (cni(1),cnir),(cni(2),cnii)
      EQUIVALENCE  (cni,cnic)
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
c Clear out grid eigenvector wavefunctions
      call MKSZERO( 2*nk*numpop*nrbox, wkbi )
      inbox = 0
c
c  Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        iwvshl = 0
        inext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            iwvorb = iwvshl
            i = i0
            do 170 iorbsh=1,norbshi
              i = i + 1
c
              iwv = iwvorb + 1
              nwv0 = 0
c
              do 60 k=1,nk
c
                nwv = nwv0
                do 70 n=1,numpop
                  nwv = nwv + 1
                  cnir = eigvec(1,n,k,i)
                  cnii = eigvec(2,n,k,i)
c
c Use blas to substitute for explicit loop ...
                  call CAXPY( nrbox, cnic, wvfcns(1,1,iwv),1,
     $             wkbi(1,1,nwv),1 )
c
c  ...and this is the reduced op code it replaces:
c                  do  nr=1,nrbox
c                    wkbi(1,nr,nwv) = wkbi(1,nr,nwv)
c     $               + cnir*wvfcns(1,nr,iwv)
c     $               - cnii*wvfcns(2,nr,iwv)
c                    wkbi(2,nr,nwv) = wkbi(2,nr,nwv)
c     $               + cnir*wvfcns(2,nr,iwv)
c     $               + cnii*wvfcns(1,nr,iwv)
c                  enddo
c
   70           continue
c
                nwv0 = nwv0 + numpop
                iwv = iwv + 1
   60         continue
c
              iwvorb = iwvorb + nk
  170       continue
c
            iwvshl = iwvshl + nk*norbshi
  180     continue
  200   continue
c
c  Have occup-weighted eigenfunctions, build density:
c
        do  nwv=1,nk*numpop
          do  nr=1,nrbox
            rhobox(nr) = rhobox(nr) + wkbi(1,nr,nwv)**2
     $                              + wkbi(2,nr,nwv)**2
          enddo
        enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRID0SET
c
c
      subroutine GRID0SET( IWR, lvlout, igrd0fl,idrhfl0,igrhofl,
     $ do_gga,do_spin, anycore,  xc0val,rhoatom,
     $ xcalcut,xcfac,xcrhocut,  maxwk,maxwkr,mxrb,
     $ natm,ntyp,nshld,nald, nlat, nlat1c, nptr, n1r,n2r,n3r,
     $ itypa, numshl,lshel,nala,ala,cala,
     $        nocc,locc,nalsh,alsh,calsh,  znuc, occsh,
     $ nrd,nrcor,radmsh,corden,
     $ ratm,rlat, nearest, hh, weight,
     $ ndbox,nbox,nrec,inrec,inboxs,boxrad,
     $ wksma,wspl,wkrbx,
     $ wk )
c---------------------------------------------------------------
c Purpose: Do grid part of iteration-independent calculations:
c          reference density, reference xc-potentials, and, if
c          we are doing gga, first and second derivatives of
c          reference density.
c
c Written: Peter A. Schultz, 25-May-2001, for v2.47
c
c Revision history:
c  29Apr14-PAS/2.66: master-only grd0 file
c  19Dec07-PAS/2.61: master-only gga grid files
c  15Oct04-PAS/2.59: pass additional space into grid0xc
c  19Jul01-PAS/2.49: igr0dfl change for spin calculation
c  27May01-PAS/2.48: replace STOPs
c  25May01-PAS/2.47: pushed down from main program
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input/output arrays:
      DIMENSION  xc0val(*)
      DIMENSION  rhoatom(natm,*)
c input declarations:
      LOGICAL    do_gga, do_spin, anycore
      DIMENSION  itypa(natm)
      DIMENSION  numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $  nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  znuc(ntyp), occsh(nshld,ntyp)
      DIMENSION  nrcor(ntyp),radmsh(nrd,ntyp),corden(nrd,ntyp)
      DIMENSION  ratm(3,natm),rlat(3,*), hh(3,3)
      DIMENSION  nearest(3,natm)
      DIMENSION  ndbox(2,2,3), inboxs(*)
c scratch arrays:
      DIMENSION  wksma(natm,*), wspl(nrd,2), wkrbx(maxwkr)
      DIMENSION  wk(maxwk)
c
c local declarations:
      DATA  zero,half,one / 0.d0,0.5d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Carry over the standard output format:
 9020 format(1x,a,3f20.10)
c
c Identify the master processors:
      call MPNODE( iproc )
      call MPNODE0( master )
c
c Space begins at 1st array space in subroutine:
      i01 = 1
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c         Do grid part of iteration-independent calculations
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c Partition space in big work array, and check for sufficiency:
c
c Note that the memory need in "potnr0" cannot be well described
c outside of it, and is not protected in the following statements.
c Normally, there will be plenty of memory, but there is a check
c inside "potnr0" to make sure it stays within bounds, just in case.
      j01 = i01
      j02 = j01 + nptr
      j03 = j02 + nptr
      j04 = j03 + nptr
      j05 = j04 + nptr
      j06 = j05 + nptr
      if( do_gga )then
        j06d = j06
        needwk = j06 - 1 + 9*nptr
      else
c       Set j06d so call to grid0xc (unused) derivs is surely in-bounds:
        j06d = j05
        needwk = j06 - 1
      endif
      if( needwk .gt. maxwk )then
        call STOPXERR( 'gr0set-1/short wk() memory in setup grid' )
      endif
c
c  Compute nearby potential for each reference atom on grid:
c
cspin: need to fix nearby stuff when spin is on ...
      call POTNR0( IWR, do_gga, wksma,
     $ xcalcut,xcfac,xcrhocut,
     $ natm,ntyp,nshld,nald, nlat1c, nptr,
     $ itypa, numshl,lshel,nala,ala,cala,
     $        nocc,locc,nalsh,alsh,calsh,  znuc,occsh,
     $ nrd,nrcor,radmsh,corden, wspl(1,1),wspl(1,2),
     $ ratm,rlat, nearest, hh,
     $ wk(j01), maxwk )
c -->  wkr-8s
c
      if( lvlout.gt.2 ) call TIMER('After potnr0     ')
c
      call MKZERO( nptr, wk(j01) )
      call MKZERO( nptr, wk(j02) )
      call MKZERO( nptr, wk(j03) )
      call MKZERO( nptr, wk(j04) )
c
c  Compute sums of grid densities/xc-potentials for reference atoms:
c
c  Compute space in small scratch workspace:
      mxwkb = maxwkr - 3*mxrb
      if( mxwkb.lt.0 ) call STOPXERR( 'gr0set-2/wkrbx memory' )
c
      call GRID0XC( IWR, do_gga, wksma,wksma(1,5),
     $ xcalcut,xcfac,xcrhocut,
     $ rhotot,cortot,exc0grd,exc0gsl,exc0pt,exc0wt,exccgrd, rhoatom,
     $ natm,ntyp,nshld,nald, nlat1c, nptr,
     $ itypa, numshl,lshel,nala,ala,cala,
     $        nocc,locc,nalsh,alsh,calsh,  znuc,occsh,
     $ nrd,nrcor,radmsh,corden, wspl(1,1),wspl(1,2),
     $ ratm,rlat, hh, weight,
     $ ndbox,nbox,nrec,inrec,inboxs,inboxs(nbox+1),boxrad,
     $ mxwkb, wkrbx,   wkrbx(1+3*mxrb),
c -->         rv(3B)-s wkr(11B)-s
     $ wk(j01), wk(j02), wk(j03), wk(j04), wk(j06d) )
c -->  rho0-o   vxc0-o   exc0-o   rhoc-o   drho-9o
c As configured, using 5*nptr in lda, and (5+9)=14*nptr in gga
c
c Do some processing (remember all grid fields are in boxes):
c
      write(IWR,*)
      corfast = zero
      if( anycore )then
        cortot = weight*DDOT( nptr, one,0, wk(j04),1 )
        corfast = weight*DDOT( nptr, wk(j03),1, wk(j04),1 )
        if( lvlout.gt.2 )then
          write(IWR,9020)'sum of grid-integrated core densities=',cortot
          write(IWR,9020)'grid-integrated core:Exc0 =  ',corfast
        endif
      endif
      if( lvlout.gt.3 )then
        write(IWR,9020)'grid-integrated isolated atom exc =   ',exc0grd
        write(IWR,9020)'atom exc contribution - nearby correct =',exc0pt
        write(IWR,9020)'atom exc contribution - weighted nearby=',exc0wt
      endif
      xc0val(1) = exc0grd
      xc0val(3) = exc0pt
      xc0val(4) = exc0wt
      xc0val(5) = exccgrd
      xc0val(7) = corfast
      xc0val(9) = exc0gsl
      exc0rad = xc0val(2)
      exccrad = xc0val(6)
c
      cor0fix = exccrad - exccgrd
      exc0fix = exc0rad - exc0grd + cor0fix
      if( lvlout.gt.3 )then
       write(IWR,*)
       write(IWR,9020)'sum radial-integrated isolated atom exc=',exc0rad
       write(IWR,9020)'raw exc correction from isolated atoms =',exc0fix
       if( anycore )
     $ write(IWR,9020)'exc core correction from isolated atoms=',cor0fix
      endif
c
      if( nlat1c.lt.nlat .and.lvlout.gt.3 )
     $ write(IWR,*) 'for 1c terms, nlat reduced from',nlat,' to',nlat1c
c     Reset nlat if system totally contained in primary unit cell
      if( nlat1c.eq.1 .and. nlat.ne.1 ) call STOPXERR('bad nlat gr0set')
c
c Save reference atom densities and xc-potentials to grid ...
c
      call DCOPY( nptr, wk(j01),1, wk(j05),1 )
      call FROMBOX( n1r,n2r,n3r, wk(j01), ndbox, wk(j05) )
      call DCOPY( nptr, wk(j02),1, wk(j05),1 )
      call FROMBOX( n1r,n2r,n3r, wk(j02), ndbox, wk(j05) )
      call DCOPY( nptr, wk(j03),1, wk(j05),1 )
      call FROMBOX( n1r,n2r,n3r, wk(j03), ndbox, wk(j05) )
      call DCOPY( nptr, wk(j04),1, wk(j05),1 )
      call FROMBOX( n1r,n2r,n3r, wk(j04), ndbox, wk(j05) )
c
      if( iproc .eq. master )then
        REWIND( unit=igrd0fl )
c   ... sum of isolated atom densities to igrd0fl:
        call WRITBIG( igrd0fl, nptr,  wk(j01) )
c   ... core charge on grid to igrd0fl:
        if( anycore ) call WRITBIG( igrd0fl, nptr, wk(j04) )
c   ... sum of isolated cut-off atom xc-potentials to igrd0fl:
        call WRITBIG( igrd0fl, nptr,  wk(j02) )
c   ... sum of isolated cut-off atom exc-pots to igrd0fl:
        call WRITBIG( igrd0fl, nptr,  wk(j03) )
      endif
c
      if( lvlout.gt.2 ) call TIMER('After grid0xc    ')
c
      if( do_gga .and. ( iproc.eq.master ) )then
c
c       We need to construct initial density gradients
c       from the derivatives of the reference density
c
c       Unbox all 9 derivative fields and write to disk:
c
        REWIND( unit=idrhfl0 )
        jxx = j06
        do  idrh=1,9
          call DCOPY( nptr, wk(jxx),1, wk(j05),1 )
          call FROMBOX( n1r,n2r,n3r, wk(jxx), ndbox, wk(j05) )
          call WRITBIG( idrhfl0, nptr, wk(jxx) )
          jxx = jxx + nptr
        enddo
c
c       Take reference derivatives, and produce gga gradients:
c
        REWIND( unit=idrhfl0 )
        call MKGRHO0( idrhfl0,   nptr,
     $   wk(j01),wk(j02), wk(j03),  wk(j05),wk(j04) )
c -->    grho-1o g2rho-1o gpggp-1o  drho-3s ddrho-1s
c
        REWIND( igrhofl )
c       Save grho-0, g2rho-0, and gpggp-0 to igrhofl:
        call WRITBIG( igrhofl, nptr, wk(j01) )
        call WRITBIG( igrhofl, nptr, wk(j02) )
        call WRITBIG( igrhofl, nptr, wk(j03) )
        if( do_spin )then
c         Need to save up/dn gradients:
          call DSCAL( nptr, half, wk(j01),1 )
          call DSCAL( nptr, half, wk(j02),1 )
          call DSCAL( nptr, half*half, wk(j03),1 )
c         Save grho-0up/dn, g2rho-0up, and gpggp-0up to igrhofl:
          call WRITBIG( igrhofl, nptr, wk(j01) )
          call WRITBIG( igrhofl, nptr, wk(j01) )
          call WRITBIG( igrhofl, nptr, wk(j02) )
          call WRITBIG( igrhofl, nptr, wk(j03) )
c         Save grho-0dn, g2rho-0dn, and gpggp-0dn to igrhofl:
          call WRITBIG( igrhofl, nptr, wk(j01) )
          call WRITBIG( igrhofl, nptr, wk(j02) )
          call WRITBIG( igrhofl, nptr, wk(j03) )
        endif
c
        if( lvlout.gt.2 ) call TIMER('After mkgrho0    ')
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRID0XC
c
c
      subroutine GRID0XC( IWR, do_gga, xcnrat, valatm,
     $ xcalcut,xcfac,xcrhocut,
     $ rhotot,cortot,exc0grd,exc0gsl,exc0pt,exc0wt,exccgrd, rhoatom,
     $ natm,ntyp,nshld,nald, nlat  , nptr,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ znuc,occsh,  nrd,nrcor,radmsh,corden, y2, u,  ratm,rlat,
     $ hh, weight, ndbox,nbox,nrec,inrec,noboxs,inboxs, boxrad,
     $ mxwkr, rv, wkr,
     $ rho0,vxc0,exc0,rhoc, drho )
c---------------------------------------------------------------
c Purpose: compute, on grid, combined isolated atom densities
c      and cutoff (short-range) xc-potentials as 0th reference
c      for iteration phase.  Also compute sum of isolated atom
c      xc-energies, integrated on grid.
c
c Written: Peter A. Schultz, 16-June-1997, for v2.20 (boxes)
c
c Revision history:
c   2Jun08-PAS/2.61e: bugfix: fix the fix
c  17Apr08-PAS/2.61a: bugfix: empty shell vs. nlat1c(wvfcns)
c  20Jun07-PAS/2.60: merge tp and serial
c   6Jul06-APT/2.59: merged task parallel and image parallel
c  17Jul06-PAS/2.59a: bug:"nproc"->"nprocl"
c  15Oct04-PAS/2.59-tp: task-parallelism
c  15Oct04-PAS/2.59: split grid-compute and summary
c   8Nov04-PAS/2.58a: cosmetics to match eslofrc
c  11Jun03-PAS/2.55: change DFTGGA arguments
c   8Apr02-PAS/2.53: gga stress
c   7Mar02-PAS/2.52: explicit constants to d0
c  26Jul01-PAS/2.49: spin-polarized dft
c  21Jun01-PAS/2.48: replace STOPs
c  24Mar01-PAS/2.46a: (gga+cntrch) bugfix
c  15Nov00-PAS/2.46: GGA; nearby split off to "potnr0"
c   4Jan00-PAS/2.42: cosmetic clean-up
c  31Aug99-DBR/2.38: bug fix for cross-shell occupancy cases
c  17Dec98-PAS/2.30: clean force/stress arrays; move force terms
c                    out of setup into new force rtn "eslofrc"
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  16Sep98-PAS/2.27: pseudo-ionic (for xc only) atoms
c  14Aug98-PAS/2.24: cutoffs
c  15Jul98-PAS/2.23: split basis
c  14May98-PAS/2.22: diagnostics/output altered
c  16Jun97-PAS/2.20: rewritten for boxes
c   3Jun97-PAS/2.17: naming conventions, new grid coord rtn,
c                    new exc correct, redo output yet again
c   1May96-PAS/2.15: fix bug in phantom force l=0
c  15Dec95-PAS/2.14: shell-by-shell grid orb ranges
c  28Aug95-PAS/2.13: partial core correction installed
c   7Nov94-PAS/2.11: allow fully non-orthogonal grid vectors
c  15Jun94-PAS/2.10: new cutoff function, install atom Exc
c  31Mar94-PAS: compute ghost xc grid force on isolated atoms
c  vers 2.00: complete rewrite, rename.
c   -installed sterner lattice cutoffs, nearby weighted sample
c---------------------------------------------------------------
c
c Notes:
c  The use of cutoffs in this routine should be compatible
c  with that used in calculating the grid wave functions.
c
c  *** NB **** "grid0xc" is master routine that the routines
c  "potnr0" (to compute nearby potentials for reference atoms),
c  and "eslofrc" must exactly copy in part.  Changes to this
c  this routine should only be done in tandem with corresponding
c  changes in these other routines as well.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
c Input arrays:
      LOGICAL    do_gga
      DIMENSION  xcnrat(4,natm)
      DIMENSION  itypa(natm)
      DIMENSION  numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $  nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  znuc(ntyp)
      DIMENSION  occsh(nshld,ntyp)
      DIMENSION  nrcor(ntyp),radmsh(nrd,*),corden(nrd,*)
      DIMENSION  ratm(3,natm),rlat(3,*), hh(3,3)
      DIMENSION  ndbox(2,2,3),noboxs(nbox),inboxs(nrec,nbox)
c Output arrays:
      DIMENSION  rhoatom(natm,*)
      DIMENSION  rho0(*),vxc0(*),exc0(*),rhoc(*), drho(nptr,*)
c Scratch arrays:
      PARAMETER  ( nvalatm = 11 )
      DIMENSION  valatm(nvalatm,natm)
      DIMENSION  y2(*),u(*)
      DIMENSION  rv(3,*), wkr(*)
c
c Local declarations:
      DIMENSION  ratom(3), r0box(3),boxctr(3)
      LOGICAL  poorho, cntrch, anycntr
      DATA  gdrho / 0.001d0 /, badrho / 0.05d0 /, cutocc / 0.9d-8 /
      DATA  alcutfac / 1.33333333d0 /
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
      DATA  three / 3.d0 /
c flag for additional output 0-none/1-some/2-more/3-full/
      DATA  lstout  / 0 /
c
c Statement function:
      LOGICAL    EVEN
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      fourpi = pi + pi + pi + pi
      argmx = half*cutgaus
c
c Acquire information about parallelism:
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( node0id )
      call MPCOMM( icomm )
c     nprocl: number of processors in this local image
      nprocl = nprocs
c  iprocl0: master/root node of set of processors in this image
      iprocl0 = node0id
      iprocl = iproc - iprocl0
c
c  Initialize sums of atom densities and xc potentials
c
      call MKZERO( 2*natm, rhoatom )
      call MKZERO( nvalatm*natm, valatm )
      rhotot = zero
      cortot = zero
      exc0grd = zero
      exc0gsl = zero
      exccgrd = zero
      exc0pt = zero
      exc0wt = zero
c Clear out derivatives in the event of a GGA calculation:
      if( do_gga )  call MKZERO( 9*nptr, drho )
c
      ipoor = 0
      ibad = 0
      if( lstout.gt.0 )  write(IWR,9010)
 9010 format(/1x,'GRID0XC: analysis on grid of isolated atoms')
c
      nlatmx = 1
c
c >>>>>>>>>> Cycle over atoms:
c
      anycntr = .false.
c  Initialize bitmap index for shell/box occupancy:
      irec00 = 0
      inbox00 = 0
      iatshl00 = 0
c
      do 1000 iatm=1,natm
        ityp = itypa(iatm)
c
        nshli = nocc(ityp)
c
c       Initialize shell/box bitmap index for this atom ...
        irec0 = irec00
        inbox0 = inbox00
        iatshl0 = iatshl00
c        ... and prepare index for the *next* atom:
        do  ishl=1,numshl(ityp)
          inbox00 = 2*inbox00
          if( inrec*(iatshl00/inrec).eq.iatshl00 )then
            irec00 = irec00 + 1
            inbox00 = 1
          endif
          iatshl00 = iatshl00 + 1
        enddo
c
        noccsh = 0
        occatxc = zero
        occatm = zero
        almina = 9.d9
        alminwf = 9.d9
        do 38 ishl=1,nshli
          lshl = locc(ishl,ityp)
          occshl = occsh(ishl,ityp)
          ioccshl = 0
          if( occshl.ne.zero )then
            ioccshl = 1
            occatm = occatm + occshl
            if( occshl.gt.zero ) occatxc = occatxc + occshl
          endif
          noccsh = noccsh + ioccshl
c
          almins = alsh(1,ishl,ityp)
          do  ial=2,nalsh(ishl,ityp)
            ali = alsh(ial,ishl,ityp)
            if( ali.lt.almins ) almins = ali
          enddo
          if( ioccshl.eq.1 .and. almins.lt.almina ) almina = almins
          if( almins.lt.alminwf ) alminwf = almins
   38   continue
c
C        if( noccsh.eq.0 ) goto 1000
c       This skip upon no density cannot be done here because
c       this set of loops used to set nlat1c for *wf* grid orbitals.
c
        rhoatm = zero
        rhoatxc = zero
        coratm = zero
        vxcatm = zero
        vxcfst = zero
        vxcasl = zero
        excatm = zero
        excfst = zero
        excasl = zero
        exccor = zero
        corfst = zero
c
c       Bring out xc slow/fast function parameters
c
        alminxc = two*almina
        if( xcalcut.lt.zero ) alminxc = -xcalcut*almina
        alcutxc = alcutfac*alminxc
        if( xcalcut.gt.zero ) alcutxc = xcalcut
c
        nrsc = nrcor(ityp) + 1
        if( nrsc.ne.1 )then
c         Interpolate core density
          ddy0 = 1.d31
          ddy1 = 1.d31
          call SPLINE(nrsc,radmsh(1,ityp),corden(1,ityp),ddy0,ddy1,y2,u)
        endif
c
        rngatm   = SQRT( cutgrid / (almina +almina ) )
        rngatmwf = SQRT( cutgrid / (alminwf+alminwf) )
c
c       Cycle over boxes:
c
c       Set up task-parallel decomposition over boxes.  Rather than
c       doing MOD( ibox, nprocs ), will do block-wise distribution
c       to simplify gather of big grid vectors.
        nboxpr = nbox / nprocl
        nprocbig = nbox - nprocl*nboxpr
        if( iprocl .lt. nprocbig ) nboxpr = nboxpr + 1
        ibox1 = 1 + iprocl*nboxpr
        if( iprocl .ge. nprocbig ) ibox1 = ibox1 + nprocbig
        iboxn = ibox1 + nboxpr - 1
        ir1proc = 1
        nrproc = 0
c
        irpot = 0
ctp        do 300 ibox=1,nbox
        do 300 ibox=ibox1,iboxn
c
c         Get basic box info
          call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $     ira0,irb0,irc0, idra,idrb,idrc )
          nrbox = idra*idrb*idrc
c
          iv0 = irpot
          irpot = irpot + nrbox
c
          nrproc = nrproc + nrbox
c
          nobox = noboxs(ibox)
          if( nobox.le.0 ) goto 300
c
          call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
          call MKRBOX( hh,r0box, idra,idrb,idrc, rv )
c
c         Set up for scratch space below
          ir0 = 0
          irsq  = ir0
          irngr = ir0 +  1*nrbox
          iatrh = ir0 +  2*nrbox
          icnrh = ir0 +  3*nrbox
          icore = ir0 +  4*nrbox
          idcor = ir0 +  5*nrbox
          ia0e  = icore
          inext = idcor + nrbox
          ia1e  = idcor
          ia2e  = ir0 +  6*nrbox
          idrho = ir0 +  7*nrbox
          iddrh = ir0 +  8*nrbox
          idcrho = ir0 +  9*nrbox
          iddcrh = ir0 + 10*nrbox
          inext = iddcrh + nrbox
c         Check memory sufficiency:
          if( inext.ge.mxwkr ) call STOPXERR( 'xc0-wkrbx' )
c
c         Lattice loop:
c
          do 900 ilat=1,nlat
c
            rngbox = zero
            do  jr=1,3
              ratom(jr) = ratm(jr,iatm) + rlat(jr,ilat)
              rngbox = rngbox + (ratom(jr)-boxctr(jr))**2
            enddo
            rngbox = SQRT( rngbox ) - boxrad
c
c           Downselect lattice vectors using wf range (NOT density range)
            if( rngbox.gt.rngatmwf ) goto 900
            if( ilat.gt.nlatmx ) nlatmx = ilat
            if( noccsh.eq.0 ) goto 900
            if( rngbox.gt.rngatm ) goto 900
c
            rsqbox = rngbox**2
            if( rngbox.lt.zero ) rsqbox = zero
c
c           Generate r**2 on mesh ...
            do  nr=1,nrbox
              wkr(irsq+nr) = ( rv(1,nr) - ratom(1) )**2
     $                     + ( rv(2,nr) - ratom(2) )**2
     $                     + ( rv(3,nr) - ratom(3) )**2
              wkr(iatrh+nr) = zero
              wkr(icnrh+nr) = zero
            enddo
c
            do  nr=1,nrbox
              wkr(irngr+nr) = SQRT( wkr(irsq+nr) )
            enddo
c
            if( do_gga )then
c             Start with having no pseudo-ionic countercharges
              anycntr = .false.
c             Clear atom (xc) and global (es) reference density derivatives
              do  nr=1,nrbox
                wkr(idrho+nr) = zero
                wkr(iddrh+nr) = zero
                wkr(idcrho+nr) = zero
                wkr(iddcrh+nr) = zero
              enddo
            endif
c
c           Shell loop:
c
            irec = irec0
            inbox = inbox0
            iatshl = iatshl0
            do 800 ishl=1,nshli
              lshl = locc(ishl,ityp)
              twol = DBLE( 2*lshl )
c
              occshl = occsh(ishl,ityp)
              if( occshl.eq.zero ) goto 800
c
              cntrch = .false.
              if( occshl.lt.zero ) cntrch = .true.
              if( cntrch ) anycntr = .true.
c
c             Determine if shell occupies box.
c             NB: Box occupancy was set using *basis* shells, not the
c             occupied shells, and must convert to shell occupancy.
c
c             Determine min alpha for this *occupancy* shell
              almins = alsh(1,ishl,ityp)
              do  ial=2,nalsh(ishl,ityp)
                ali = alsh(ial,ishl,ityp)
                if( ali.lt.almins ) almins = ali
              enddo
c
c             Cycle over *basis* shells here, and try to find the
c              basis shell that best matches the occ shell above:
              irec = irec0
              inbox = inbox0
              iatshl = iatshl0
              keybox = 0
              alminl = zero
              do 58 jshl=1,numshl(ityp)
                inbox = 2*inbox
                if( inrec*(iatshl/inrec).eq.iatshl )then
                  irec = irec + 1
                  inbox = 1
                endif
                iatshl = iatshl + 1
                if( lshel(jshl,ityp).eq.lshl )then
c                 Determine min alpha for this *basis* shell
                  alminj = ala(1,jshl,ityp)
                  do  jal=1,nala(jshl,ityp)
                    alj = ala(jal,jshl,ityp)
                    if( alj.lt.alminj ) alminj = alj
                  enddo
                  if( alminj.eq.almins )then
c                   Perfect match, use this box occupancy
                    keybox = inboxs(irec,ibox) / inbox
                    goto 59
                  elseif( alminj.le.almins .and. alminj.gt.alminl )then
c                   Better match, provisionally load this box occupancy
                    keybox = inboxs(irec,ibox) / inbox
cpas: as of 2.58 this was unfortunately left out ... (inserted 2.60)
                    alminl = alminj
                  endif
                endif
c
   58         continue
   59         continue
c
              if( EVEN(keybox) ) goto 800
c
              nali = nalsh(ishl,ityp)
c
              almins = alsh(1,ishl,ityp)
              do  ial=2,nali
                ali = alsh(ial,ishl,ityp)
                if( ali.lt.almins ) almins = ali
              enddo
              almin = almina
              rsqshl = cutgrid / (almin +almins)
              if( rsqbox.gt.rsqshl ) goto 800
c
              call MKZERO( nrbox, wkr(ia0e+1) )
              if( do_gga )then
                do  nr=1,nrbox
C                 wkr(ia0e+nr) = zero
                  wkr(ia1e+nr) = zero
                  wkr(ia2e+nr) = zero
                enddo
              endif
c
              do 190 ial=1,nali
                ali = alsh(ial,ishl,ityp)
                cali = occshl*calsh(ial,ishl,ityp)
                cali0 = cali
c               Just do off-diags once, for Pete's sake:
                do 180 jal=ial,1,-1
                  alj = alsh(jal,ishl,ityp)
                  alsum = ali + alj
                  als2 = alsum*alsum
                  twoals = alsum + alsum
                  coef = cali*calsh(jal,ishl,ityp)/fourpi
c                 Double the off-diags:
                  cali = cali0 + cali0
c                 Looser cutoff used to get quicker convergence
                  algt = ali
                  if( alj.gt.ali ) algt = alj
                  twoalgt = algt + algt
                  twoalc = algt + almin
                  rsqcut = cutgrid/twoalc
c
c                 Skip if alpha is too large
                  if( rsqbox.gt.rsqcut ) goto 180
c
c                 Sums: occ*Ca*Cb*(a+b)**n*exp(-(a+b)r**2); n=0,1,2
                  if( do_gga )then
                    do  nr=1,nrbox
                      gauss = coef*EXP( -alsum*wkr(irsq+nr) )
                      wkr(ia0e+nr) = wkr(ia0e+nr) + gauss
                      wkr(ia1e+nr) = wkr(ia1e+nr) + gauss*alsum
                      wkr(ia2e+nr) = wkr(ia2e+nr) + gauss*als2
                    enddo
                  else
                    do  nr=1,nrbox
                      gauss = coef*EXP( -alsum*wkr(irsq+nr) )
                      wkr(ia0e+nr) = wkr(ia0e+nr) + gauss
                    enddo
                  endif
c
c                 Close alpha loops:
c
  180           continue
  190         continue
c
              if( do_gga )then
c               Assemble density and derivatives for GGA potential:
c
                if( cntrch )then
c                  ... for global (es) reference density
                  iprho  = icnrh
                  ipdrho = idcrho
                  ipddrh = iddcrh
                else
c                  ... atomic (pseudo-ionic) xc reference density
                  iprho  = iatrh
                  ipdrho = idrho
                  ipddrh = iddrh
                endif
c
                call MKSHL2D( lshl, nrbox, wkr(irngr+1), wkr(irsq+1),
     $           wkr(ia0e+1),wkr(ia1e+1),wkr(ia2e+1),
     $           wkr(iprho+1),wkr(ipdrho+1),wkr(ipddrh+1) )
c
              else
c               Just need to assemble density ...
c
                if( cntrch )then
c                  ... to update compensating countercharge for es
                  iprho = icnrh
                else
c                  ... for LDA calculation (no density derivs needed)
                  iprho = iatrh
                endif
c
                call MKSHL( lshl, nrbox, wkr(irsq+1),
     $           wkr(ia0e+1), wkr(iprho+1) )
c
              endif
c
c             Close shell loop:
c
  800       continue
c
c           Check if we have core density to consider
c
            call MKZERO( nrbox, wkr(icore+1) )
            if( nrsc.ne.1 )then
              rsqcut = radmsh(nrsc,ityp)**2
              if( rsqbox.gt.rsqcut ) goto 195
c
              if( do_gga )then
c               Do core 2nd deriv before 1st deriv, and use (idcor)
c               space for scratch  (do not need core 2nd deriv
c               separate from the total rho 2nd deriv).
c               Interpolate to get 2nd deriv. of core density ...
                call SPLIND2( nrsc, radmsh(1,ityp), corden(1,ityp),y2,
     $                        nrbox,wkr(irngr+1),wkr(idcor+1) )
c                ... and put into total 2nd deriv of density for GGA
                do  nr=1,nrbox
                  wkr(iddrh+nr) = wkr(iddrh+nr) + wkr(idcor+nr)
                enddo
c
c               Interpolate to get deriv. of core density ...
                call SPLIND( nrsc, radmsh(1,ityp),corden(1,ityp),y2,
     $                       nrbox,wkr(irngr+1),wkr(idcor+1) )
c                ... and put into density derivative for GGA potential
                do  nr=1,nrbox
                  wkr(idrho+nr) = wkr(idrho+nr) + wkr(idcor+nr)
                enddo
              endif
c
c             Interpolate to get core density on grid ...
              call SPLINT( nrsc, radmsh(1,ityp),corden(1,ityp),y2,
     $                     nrbox,wkr(irngr+1),wkr(icore+1) )
c
            endif
  195       continue
c
c
c         * * * * * * * * * * * * * * * * * * * * * * * * * * *
c             Have total isolated-atom density on this part
c                 of the grid; compute xc-quantities.
c         * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
            do 200 nr=1,nrbox
              rhoxc = wkr(iatrh+nr)
              rhoes = wkr(iatrh+nr) + wkr(icnrh+nr)
              corho = wkr(icore+nr)
              rhopt = rhoxc + corho
c
              if( rhopt.gt.xcrhocut )then
c
                if( do_gga )then
c                 Assemble gradient terms needed for GGA
c
                  rmag = wkr(irngr+nr)
                  if( rmag.gt.1.d-6 )then
c                   For r>0, general Cartesian derivs from radial
c                    ... note dcor already added into drho above
                    drh = wkr(idrho+nr)
c                    ... terms for Cartesian reference derivatives:
                    d1rhdr = drh/rmag
                    d2rh = wkr(iddrh+nr) - d1rhdr
c
c                     ... need gradients for the atomic GGA potential
                    grho = ABS( drh )
                    g2rho = wkr(iddrh+nr) + two*d1rhdr
                    gpggp = grho*wkr(iddrh+nr)
c
                    if( anycntr )then
c                     Need to produce derivatives of (es) reference density
c                     rather than pseudo-ionic reference density used for xc
                      drh = wkr(idrho+nr) + wkr(idcrho+nr)
                      d1rhdr = drh/rmag
                      d2rh = wkr(iddrh+nr) + wkr(iddcrh+nr) - d1rhdr
                    endif
c
                    ux = ( rv(1,nr) - ratom(1) ) / rmag
                    uy = ( rv(2,nr) - ratom(2) ) / rmag
                    uz = ( rv(3,nr) - ratom(3) ) / rmag
                    ir = iv0 + nr
c                    ... first derivs: X,Y,Z
                    drho(ir,1) = drho(ir,1) + ux*drh
                    drho(ir,2) = drho(ir,2) + uy*drh
                    drho(ir,3) = drho(ir,3) + uz*drh
c                    ... second derivs: XX,YY,ZZ, XY,YZ,ZX
                    drho(ir,4) = drho(ir,4) + ux*ux*d2rh + d1rhdr
                    drho(ir,5) = drho(ir,5) + uy*uy*d2rh + d1rhdr
                    drho(ir,6) = drho(ir,6) + uz*uz*d2rh + d1rhdr
                    drho(ir,7) = drho(ir,7) + ux*uy*d2rh
                    drho(ir,8) = drho(ir,8) + uy*uz*d2rh
                    drho(ir,9) = drho(ir,9) + uz*ux*d2rh
                  else
c                   At r=0, dp/du=0, and only d2p/du2 survives limits ...
                    d2rh = wkr(iddrh+nr)
c
                    grho = zero
                    g2rho = three*wkr(iddrh+nr)
                    gpggp = zero
c
                    if( anycntr ) d2rh = wkr(iddrh+nr) + wkr(iddcrh+nr)
c
                    ir = iv0 + nr
                    drho(ir,4) = drho(ir,4) + d2rh
                    drho(ir,5) = drho(ir,5) + d2rh
                    drho(ir,6) = drho(ir,6) + d2rh
                  endif
c
                  call DFTGGA( rhopt, grho,g2rho,gpggp,
     $                         vxcpt,excpt, dxcpt,dxc2pt )
c
c                 End do_gga = .true.
                else
c                 do_gga = .false.
c
                  call DFTLDA( rhopt, vxcpt,excpt )
c
                endif
c
c               Add atom density to sum of atom densities
                rho0(iv0+nr) = rho0(iv0+nr) + rhoes
                rhoc(iv0+nr) = rhoc(iv0+nr) + corho
c
c               Construct "fast" xc-potentials, and update:
                cfac = EXP( -alcutxc*wkr(irsq+nr) )
                fstfcn = cfac / ( (one-xcfac)*cfac + xcfac )
c
                vfast = vxcpt*fstfcn
                vslow = vxcpt - vfast
c
                efast = excpt*fstfcn
                eslow = excpt - efast
c
                vxc0(iv0+nr) = vxc0(iv0+nr) + vfast
                exc0(iv0+nr) = exc0(iv0+nr) + efast
c
c               Integrate atomic electron density and xc-energy on grid
                rhoatm = rhoatm + rhoes
                rhoatxc = rhoatxc + rhoxc
                coratm = coratm + corho
                vxcatm = vxcatm + vxcpt*rhoxc
                vxcfst = vxcfst + vfast*rhoxc
                vxcasl = vxcasl + vslow*rhoxc
                excatm = excatm + excpt*rhoxc
                excfst = excfst + efast*rhoxc
                excasl = excasl + eslow*rhoxc
                exccor = exccor + excpt*corho
                corfst = corfst + efast*corho
c
              endif
c
  200       continue
c
c           Close lattice loop:
c
  900     continue
c
c         Close box loop:
c
  300   continue
c
c       Save isolated atom grid integral quantities:
c
        valatm( 1,iatm) = rhoatm
        valatm( 2,iatm) = rhoatxc
        valatm( 3,iatm) = coratm
        valatm( 4,iatm) = vxcatm
        valatm( 5,iatm) = vxcfst
        valatm( 6,iatm) = vxcasl
        valatm( 7,iatm) = excatm
        valatm( 8,iatm) = excfst
        valatm( 9,iatm) = excasl
        valatm(10,iatm) = exccor
        valatm(11,iatm) = corfst
c
c       Close atom loop:
c
 1000 continue
c
      if( nprocl .gt. 1 )then
c       Reduce all atomic grid integrals to master
c
        nreduc = nvalatm*natm
        call MPREDUC8( iprocl0, nreduc, valatm, wkr, icomm )
C        call MPI_Reduce( valatm, wkr, nreduc,
C     $   MPI_DOUBLE_PRECISION, MPI_SUM,
C     $   iprocl0, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'grid0xc - Reduce ints' )
        call DCOPY( nreduc, wkr,1, valatm,1 )
c
        call MPBCAST8( iprocl0, nreduc, valatm, icomm )
C        call MPI_Bcast( valatm, nreduc, MPI_DOUBLE_PRECISION,
C     $   iprocl0, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'grid0xc - Bcast ints' )
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c   Assemble, analyze, and output final atomic integrals
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      do 2000 iatm=1,natm
        ityp = itypa(iatm)
c
        nshli = nocc(ityp)
        noccsh = 0
        occatm = zero
        occatxc = zero
        do 2038 ishl=1,nshli
          lshl = locc(ishl,ityp)
          occshl = occsh(ishl,ityp)
          if( occshl.eq.zero ) goto 2038
c
          occatm = occatm + occshl
          if( occshl.gt.zero ) occatxc = occatxc + occshl
          noccsh = noccsh + 1
 2038   continue
        if( noccsh.eq.0 ) goto 2000
c
c       Retrieve local density/exc-den for weighted nearby sampling
c
        vxcwtnr = xcnrat(1,iatm)
        excwtnr = xcnrat(2,iatm)
        vxcptnr = xcnrat(3,iatm)
        excptnr = xcnrat(4,iatm)
c
c       Atom-resolved grid integral quantities:
c
        rhoatm  = valatm( 1,iatm)
        rhoatxc = valatm( 2,iatm)
        coratm  = valatm( 3,iatm)
        vxcatm  = valatm( 4,iatm)
        vxcfst  = valatm( 5,iatm)
        vxcasl  = valatm( 6,iatm)
        excatm  = valatm( 7,iatm)
        excfst  = valatm( 8,iatm)
        excasl  = valatm( 9,iatm)
        exccor  = valatm(10,iatm)
        corfst  = valatm(11,iatm)
c
        rhoatm = weight*rhoatm
        rhoatxc = weight*rhoatxc
        coratm = weight*coratm
        vxcatm = weight*vxcatm
        vxcfst = weight*vxcfst
        vxcasl = weight*vxcasl
        excatm = weight*excatm
        excfst = weight*excfst
        excasl = weight*excasl
        exccor = weight*exccor
        corfst = weight*corfst
        vxcatnr = (occatxc-rhoatxc)*vxcptnr
        vxcatwt = (occatxc-rhoatxc)*vxcwtnr
        excatnr = (occatxc-rhoatxc)*excptnr
        excatwt = (occatxc-rhoatxc)*excwtnr
c
        rhoatom(iatm,1) = rhoatm
        rhotot = rhotot + rhoatm
        rhoatom(iatm,2) = coratm
        cortot = cortot + coratm
        exc0grd = exc0grd + excatm
        exc0gsl = exc0gsl + excasl
        exccgrd = exccgrd + exccor
        exc0pt = exc0pt + excatnr
        exc0wt = exc0wt + excatwt
c
        grderr = ABS( rhoatm - znuc(ityp) )
        poorho = grderr .gt. gdrho
        if( poorho ) ipoor = ipoor + 1
        if( grderr .gt. badrho ) ibad = ibad + 1
        if( lstout.gt.1 .or. poorho )then
 9021     format(1x,'Atom',i4,'   Z=',f5.1,'   occ=',f6.2,
     $              '   rho=',f14.10,'   core=',f14.10)
 9022     format( 5x, a, 5(1x,f12.8) )
          write(IWR,9021) iatm,znuc(ityp),occatm,rhoatm,coratm
          if( ABS(rhoatxc-rhoatm).gt.cutocc )
     $    write(IWR,9031)                        rhoatxc
 9031     format(1x,'    ',4x,'     ',5x  ,'       ',5x,
     $              'rho(xc)=',f14.10)
        endif
        if( lstout.gt.3 .or. poorho )then
          write(IWR,9022) 'vxc(afsw): ',vxcatm,vxcfst,vxcasl,vxcatwt
          write(IWR,9022) 'exc(afsw): ',excatm,excfst,excasl,excatwt
          if( nrsc.ne.1 )then
            write(IWR,9022) 'core(af): ',exccor,corfst
            write(IWR,9022) 'ectot',excatm+exccor,excfst+corfst,excasl
          endif
        endif
        if( lstout.gt.4 )then
          write(IWR,9022)  'vxcpt(wp):',vxcwtnr,vxcptnr,vxcatwt,vxcatnr
          write(IWR,9022)  'excpt(wp):',excwtnr,excptnr,excatwt,excatnr
        endif
c
c       Close atom loop:
c
 2000 continue
c
c Set maximum lattice index that was used to limit later grid routines:
c
      if( nprocl .gt. 1 )then
c       A hack to communicate max required nlat:
        call MKZERO( nprocl, wkr )
        wkr(1) = DBLE( nlatmx ) + 0.1
        call MPMERGER8( nprocl, iprocl0, iprocl,
     $       nprocl,1,1, wkr, icomm )
        if( iprocl.eq.iprocl0 )then
          rlatmax = wkr(1)
          do  jpr=2,nprocl
            if( wkr(jpr) .gt. rlatmax ) rlatmax = wkr(jpr)
          enddo
        endif
        call MPBCAST8( iprocl0, 1,rlatmax, icomm )
        nlatmx = rlatmax
        nlat = nlatmx
      endif
      nlat = nlatmx
c
c Add a grid diagnostic message:
c
      if( ibad.gt.0 )then
        call STOPXERR( 'grid0xc-grid is not fine enough' )
      elseif( ipoor.gt.0 )then
        write(IWR,*) '***** CAUTION: grid fineness questionable'
      endif
c
      if( nprocl .gt. 1 )then
c       Gather the full grid fields to the master/root node:
c
cpas:
        call TIMER( 'grid0xc compute' )
c
        call MPMERGER8( nprocl, iprocl0, iprocl,
     $       nptr,ir1proc,nrproc, rho0, icomm )
        call MPMERGER8( nprocl, iprocl0, iprocl,
     $       nptr,ir1proc,nrproc, rhoc, icomm )
        call MPMERGER8( nprocl, iprocl0, iprocl,
     $       nptr,ir1proc,nrproc, vxc0, icomm )
        call MPMERGER8( nprocl, iprocl0, iprocl,
     $       nptr,ir1proc,nrproc, exc0, icomm )
        if( do_gga )then
          do  idrh=1,9
            call MPMERGER8( nprocl, iprocl0, iprocl,
     $       nptr,ir1proc,nrproc, drho(1,idrh), icomm)
          enddo
        endif
cpas:
        call TIMER( 'grid0xc Merge  ' )
c
c       For now, broadcast these to all nodes:
        call MPBCAST8( iprocl0, nptr, rho0, icomm )
        call MPBCAST8( iprocl0, nptr, rhoc, icomm )
        call MPBCAST8( iprocl0, nptr, vxc0, icomm )
        call MPBCAST8( iprocl0, nptr, exc0, icomm )
        if( do_gga )then
          do  idrh=1,9
            call MPBCAST8( iprocl0, nptr, drho(1,idrh), icomm )
          enddo
        endif
cpas:
        call TIMER( 'grid0xc Bcast  ' )
c
c       End tp
      endif
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDAVE
c
c
      subroutine GRIDAVE(IWR,n1,n2,n3,nd,arr,ave,plave,avelbl)
c---------------------------------------------------------------
c Purpose: compute planar averages of quantities on 3D grid
c
c Written: Peter A. Schultz
c
c Revision history:
c  26Jan11-PAS/2.62: cosmetic mods for output
c  22Oct98-PAS/2.27: communicate global averages
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c  Variables:
c   IWR      - output unit number (IWR.le.0 turns output off)
c   n1,n2,n3 - dimensions of grid
c   nd       - dimension of arr(), 1:real ; 2:complex
c   arr()    - input array for which averages are desired
c   ave()    - global averages
c   plave()  - output array of planar averages
c   avelbl   - arbitrary length character string describing average
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  arr(nd,n1*n2,n3), ave(nd),plave(nd,n3)
      CHARACTER*(*)  avelbl
c local declarations:
      LOGICAL  printon
      DATA  zero / 0.d0 /
c
      printon = (IWR.gt.0)
c
      if( printon )  write(IWR,9000)  avelbl
 9000 format(1x,'PLANAR GRID AVERAGE OF ',a)
 9100 format(1x,'Global average:',1pd16.8,
     $       1x,'Planar averages:'
     $       / (1x,1p5d15.7) )
c
      do 1000 id=1,nd
c
        ave(id) = zero
c
        do  i3=1,n3
c
          sum = zero
          do  i12=1,n1*n2
            sum = sum + arr(id,i12,i3)
          enddo
c
          sum = sum/ DBLE(n1*n2)
          plave(id,i3) = sum
          ave(id) = ave(id) + sum
c
        enddo
c
        ave(id) = ave(id)/ DBLE(n3)
c
        if( printon ) write(IWR,9100)  ave(id),(plave(id,i3),i3=1,n3)
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDCGGA
c
c
      subroutine GRIDCGGA( xcrhocut, weight,nptr,
     $ rhuptot, vxcuptot,excuptot,  rhdntot, vxcdntot,excdntot,
     $ rhoup,  g_vxcup, g2_excup, gpggp,
     $ rhodn,  g2u_vxcdn, gd_excdn, grhoup )
c---------------------------------------------------------------
c Purpose: compute spin-polarized GGA correlation fcnals over grid
c
c Written: Peter A. Schultz, 20-July-2001, for 2.49 (spin)
c
c Revision history:
c  10Oct03-AEM+PAS/2.57: accommodate spin stress for GGA
c  26Jun03-AEM/2.56: added g2rhup arg. in DFTCGGA, needed for blypsp.
c  26Jun03-PAS/2.55: restrict rho(up/dn).gt.0, g2rho[up] input
c---------------------------------------------------------------
c
c ***** NOTE: correlation term only, no exchange *****
c
c Note on status of grid arrays _vxc(),_exc():
c  On input to this routine, these arrays contain the density
c  gradients that are inputs to the gga fcns.  Hence, they are
c  initialized here with the values of the correlation part of
c  the gga, and will be updated later with the exchange part.
c
c  Input arrays:
c    rhoup()    - spin-up electron density on grid
c    g_vxcup()  - | grad[rho] | "grho"
c    g2_excup() - grad**2[rho]  "g2rho"
c    gpggp()    - grad[rho] DOT grad | grad[rho] | "gpggp"
c    rhodn()    - spin-down electron density on grid
c    g2u_vxcdn()- grad**2[rhoup]
c    gd_excdn() - | grad[rho-dn] |
c    grhoup()   - | grad[rho-up] |
c  Output arrays [up/dn]:
c    _vxc()  - computed xc-potential on grid (in rydberg)
c    _exc()  - computed xc-energy density on grid
c  Output values [up/dn]:
c    rhotot  - grid integrated total electron density
c    vxctot  - grid integrated Vxc:rho
c    exctot  - grid integrated total xc-energy
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c input/output arrays:
      DIMENSION  rhoup(nptr), grhoup(nptr)
      DIMENSION  g_vxcup(nptr), g2_excup(nptr), gpggp(nptr)
      DIMENSION  rhodn(nptr)
      DIMENSION  g2u_vxcdn(nptr), gd_excdn(nptr)
c
c >>>> EXECUTABLE CODE:
c
      rhuptot = zero
      excuptot = zero
      vxcuptot = zero
      rhdntot = zero
      excdntot = zero
      vxcdntot = zero
c
      do  nr=1,nptr
        rhup = rhoup(nr)
        if( rhup.lt.zero ) rhup = zero
        rhuptot = rhuptot + rhup
        rhdn = rhodn(nr)
        if( rhdn.lt.zero ) rhdn = zero
        rhdntot = rhdntot + rhdn
        rhpt = rhup + rhdn
c
        if( rhpt .gt. xcrhocut )then
          grho = g_vxcup(nr)
          g2rh = g2_excup(nr)
          ggrh = gpggp(nr)
          g2rhup = g2u_vxcdn(nr)
          grhup = grhoup(nr)
          grhdn = gd_excdn(nr)
c
          call DFTCGGA( rhup, grho,g2rh,ggrh, vxcupr,excupr,
     $                  rhdn, grhup,grhdn,g2rhup, vxcdnr,excdnr,
     $                  dcgrho, dcgrhup, dcgrhdn,
     $                  dcg2rhup, dcg2rhdn )
c
          vxcuptot = vxcuptot + vxcupr*rhup
          excuptot = excuptot + excupr*rhup
          g_vxcup(nr) = vxcupr
          g2_excup(nr) = excupr
          vxcdntot = vxcdntot + vxcdnr*rhdn
          excdntot = excdntot + excdnr*rhdn
          g2u_vxcdn(nr) = vxcdnr
          gd_excdn(nr) = excdnr
        else
          g_vxcup(nr) = zero
          g2_excup(nr) = zero
          g2u_vxcdn(nr) = zero
          gd_excdn(nr) = zero
        endif
c
      enddo
c
c  Scale totals by mesh weighting:
c
      rhuptot = weight*rhuptot
      vxcuptot = weight*vxcuptot
      excuptot = weight*excuptot
      rhdntot = weight*rhdntot
      vxcdntot = weight*vxcdntot
      excdntot = weight*excdntot
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDCHG
c
c
      subroutine GRIDCHG( chg,dum,weight,nptr,arr )
c---------------------------------------------------------------
c Purpose: count up movement on grid of grid quantity
c
c Written: Peter A. Schultz, 16-June-1993
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  arr(nptr)
c
      chg = 0.d0
      do  nr=1,nptr
        chg = chg + ABS(arr(nr))
      enddo
      chg = weight*chg
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDCSTR
c
c
      subroutine GRIDCSTR( xcrhocut, nptr, weight,
     $   rhoa,  rhob,  g_dxc,   g2_d2up,   gg_d2dn,
     $   grhoa,     grhob,     g2rhoa,     dxcup,     dxcdn )
c---------------------------------------------------------------
c Purpose: compute extra fcnals for correlation part of
c          spin-dependent GGA stress
c
c Written: Peter A. Schultz and Ann. E. Mattsson
c          10-October-2003, for 2.57
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Variables:
c  Input arrays:
c    rhoa()    - total up-spin xc electron density on grid
c    rhob()    - total dn-spin xc electron density on grid
c    g_dxc()   - | grad[rho] | "grho"
c    g2_d2up() - grad**2[rho]  "g2rho"
c    gg_d2dn() - grad[rho] DOT grad | grad[rho] | "gpggp"
c    grhoa()   - | grad[rho-up] |
c    grhob()   - | grad[rho-dn] |
c    g2rhoa()  - grad**2.[rho-up]
c  Output arrays:
c    g_dxc()   - fcnal for GGA total 1st derivative stress
c    g2_d2up() - fcnal for GGA up-spin Laplacian stress
c    gg_d2dn() - fcnal for GGA dn-spin Laplacian stress
c    dxcup()   - fcnal for GGA up-spin 1st derivative stress
c    dxcdn()   - fcnal for GGA dn-spin 1st derivative stress
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c
c Input:
      DIMENSION  rhoa(nptr),rhob(nptr)
      DIMENSION  grhoa(nptr),grhob(nptr)
      DIMENSION  g2rhoa(nptr)
c Input/output:
      DIMENSION  g_dxc(nptr),g2_d2up(nptr),gg_d2dn(nptr)
c Output:
      DIMENSION  dxcup(nptr),dxcdn(nptr)
c
c >>>> EXECUTABLE CODE:
c
      ectot  = zero
      ectota = zero
      ectotb = zero
      do  nr=1,nptr
        rhup = rhoa(nr)
        if( rhup.lt.zero ) rhup = zero
        rhdn = rhob(nr)
        if( rhdn.lt.zero ) rhdn = zero
        rhpt = rhup + rhdn
c
        if( rhpt .gt. xcrhocut )then
          grh = g_dxc(nr)
          g2rh = g2_d2up(nr)
          ggrh = gg_d2dn(nr)
          g2rhup = g2rhoa(nr)
          grhup = grhoa(nr)
          grhdn = grhob(nr)
c
          call DFTCGGA( rhup, grh,g2rh,ggrh, vxcupr,excupr,
     $                  rhdn, grhup,grhdn,g2rhup, vxcdnr,excdnr,
     $                  dcgrho, dcgrhup, dcgrhdn,
     $                  dcg2rhup, dcg2rhdn )
c
          ectota = ectota + excupr*rhup
          ectotb = ectotb + excdnr*rhdn
c
          g_dxc(nr) = dcgrho
          dxcup(nr) = dcgrhup
          dxcdn(nr) = dcgrhdn
          g2_d2up(nr) = dcg2rhup
          gg_d2dn(nr) = dcg2rhdn
        else
          g_dxc(nr) = zero
          dxcup(nr) = zero
          dxcdn(nr) = zero
          g2_d2up(nr) = zero
          gg_d2dn(nr) = zero
        endif
c
      enddo
      ectota = weight*ectota
      ectotb = weight*ectotb
      ectot = ectota + ectotb
C      write(6,'(a,3f20.10)') 'CSTR: energy ectot,a,b=',
C     $ ectot,ectota,ectotb
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDDFT
c
c
      subroutine GRIDDFT( IWR, igrd0fl,igrhofl,
     $ i1cgrfl, anyxc1c,
     $ anycore, do_gga,do_spin, iter,lvlout,
     $ nptr, weight,xcrhocut, exctot,excslo,corslow,eharris,
     $ rho0,   rhoc,    rhoa,  vxca,  exca,  exc0,
     $                  rhob,  vxcb,  excb,  wksp1, wksp2 )
c---------------------------------------------------------------
c Purpose: evaluate xc-potentials on grid for scf
c
c Written: Peter A. Schultz, 19-July-2001, for 2.49 (spin)
c
c Revision history:
c  29Apr14-PAS/2.66: master-only igrd0fl
c  17Spt08-RJM/2.62:: modified variable passing both spins to AM05SP
c  28Jan08-PAS/2.60e: patch igrhofl rewind to master-only
c  26Jun03-PAS/2.56: pass g2rho[up] into spin-gga corr (blypsp)
c   7Apr03-PAS/2.55: fix rhotot(up,dn) output; extract core
c  19Jul01-PAS/2.49: pushed down from main program
c---------------------------------------------------------------
c
c Notes:
c  The big grid arrays are used multiply as scratch.  The names
c  they are given reflect a compromise between (1) their contents
c  on input to, or output from, this routine, and (2) how they
c  are used in the trickier parts of this routine.  The intent
c  is to be as compact as possible, and still be understandable.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0, half = 0.5d0, one = 1.d0 )
      PARAMETER  ( two = 2.d0 )
c
      LOGICAL  anyxc1c
      LOGICAL  anycore, do_gga,do_spin
c input arrays ...
c  ... reference density
      DIMENSION  rho0(nptr)
c input/output ...
c  ... delta density, up/dn
      DIMENSION  rhoa(nptr), rhob(*)
c output arrays ...
c  ... xc-potentials for up and dn
      DIMENSION  vxca(nptr),exca(nptr),exc0(nptr)
      DIMENSION  vxcb(*),   excb(*)
c scratch space ...
c  ... core density
      DIMENSION  rhoc(*)
      DIMENSION  wksp1(*), wksp2(*)
c
c >>>> EXECUTABLE CODE
c
 9020 format(1x,a,3f20.10)
c
c How much of core/ref density to add?
      spinfac = one
      if( do_spin ) spinfac = half
c
c Add rho-zero reference density into delta (up/dn) density:
      call DAXPY( nptr, spinfac, rho0,1, rhoa,1 )
      if( do_spin ) call DAXPY( nptr, spinfac, rho0,1, rhob,1 )
c
c We are assumeing that rho0 has been read off igrd0fl before here ...
      cortot = zero
      if( anycore )then
c       Recover core density from igrd0fl ...
        call MPBCREADBIG( igrd0fl, nptr, rhoc )
        cortot = weight*DDOT( nptr, one,0, rhoc,1 )
c        ... and add into (up/dn) density for xc-calc
        call DAXPY( nptr, spinfac, rhoc,1, rhoa,1 )
        if( do_spin ) call DAXPY( nptr, spinfac, rhoc,1, rhob,1 )
      endif
c
      if( do_gga )then
c       Retrieve grho, g2rho, and gpggp (gga gradients) from igrhofl:
        call MPBCREWIND( igrhofl )
        call MPBCREADBIG( igrhofl, nptr, vxca )
        call MPBCREADBIG( igrhofl, nptr, exca )
        call MPBCREADBIG( igrhofl, nptr, exc0 )
        if( do_spin )then
c         And retrieve grho[up] and grho[dn] from igrhofl:
          call MPBCREADBIG( igrhofl, nptr, wksp1 )
          call MPBCREADBIG( igrhofl, nptr, excb )
        endif
      endif
c
c Compute xc-functionals on grid:
c
      if( do_spin )then
c
c       Spin-polarized
c
        if( do_gga )then
c
c         Retrieve g2rho-up from igrhofl ...
          call MPBCREADBIG( igrhofl, nptr, wksp2 )
c          ... and put it into vxcb for GRIDCGGA:
          call DCOPY( nptr, wksp2,1, vxcb,1 )
c
c         Compute correlation part of GGA functional ...
          call GRIDCGGA( xcrhocut, weight,nptr,
     $     rhuptot, vcuptot,ecuptot,  rhdntot, vcdntot,ecdntot,
     $     rhoa, vxca,  exca,  exc0,
c -->(i)   rh-up grho   g2rho  gpggp
c <--(o)   rh-up vxc-up exc-up
     $     rhob, vxcb,   excb,   wksp1 )
c -->(i)   rh-dn g2-up   grho-dn grho-up
c <--(o)   rh-dn vxc-dn  exc-dn  grho-up
c
c          ... retrieve gpggp-up from igrhofl:
c             (note grho-up survived from gridcgga, in wksp1,
c              and g2rho-up continued in wksp2)
          call MPBCREADBIG( igrhofl, nptr, exc0 )
c
c          ... compute up-spin GGA exchange:
          call GRIDXGGA( xcrhocut, weight,nptr,
     $     rhuxtot, vxuptot, exuptot,
     $     rhoa,   rhob, wksp1,  wksp2,   exc0,     vxca,    exca )
c -->      rhup-i  grhup-i g2rhup-i gpggpup-i vxcup-io excup-io
c
c          ... retrieve grho-dn, g2rho-dn, and gpggp-dn from igrhofl:
          call MPBCREADBIG( igrhofl, nptr, wksp1 )
          call MPBCREADBIG( igrhofl, nptr, wksp2 )
          call MPBCREADBIG( igrhofl, nptr, exc0 )
c
c          ... compute dn-spin GGA exchange:
          call GRIDXGGA( xcrhocut, weight,nptr,
     $     rhdxtot, vxdntot, exdntot,
     $     rhob,   rhoa, wksp1,  wksp2,   exc0,     vxcb,    excb )
c -->      rhdn-i  grhdn-i g2rhdn-i gpggpdn-i vxcdn-io excdn-io
c
          vctot = vcuptot + vcdntot
          ectot = ecuptot + ecdntot
          vxtot = vxuptot + vxdntot
          extot = exuptot + exdntot
c
          if( lvlout.gt.3 )then
            write(IWR,9020) 'gga up-spin exch energy, vx:rho=',
     $       exuptot,vxuptot
            write(IWR,9020) 'gga dn-spin exch energy, vx:rho=',
     $       exdntot,vxdntot
            write(IWR,9020) 'gga up-spin corr energy, vc:rho=',
     $       ecuptot,vcuptot
            write(IWR,9020) 'gga dn-spin corr energy, vc:rho=',
     $       ecdntot,vcdntot
          endif
c
          vxcuptot = vxuptot + vcuptot
          excuptot = exuptot + ecuptot
          vxcdntot = vxdntot + vcdntot
          excdntot = exdntot + ecdntot
c
        else
c
          call GRIDSLDA( xcrhocut, weight,nptr,
     $     rhuptot, vxcuptot,excuptot,  rhdntot, vxcdntot,excdntot,
     $     rhoa,   vxca,    exca,     rhob,   vxcb,  excb )
c -->      rh-up/i vxc-up/o exc-up/o  rh-dn/i vxc-dn/o exc-dn/o
c
        endif
c
        rhotot = rhuptot + rhdntot
        vxctot = vxcuptot + vxcdntot
        exctot = excuptot + excdntot
c
      else
c
c       Spin-restricted
c
        if( do_gga )then
c
          call GRIDGGA( xcrhocut, weight,nptr,
     $     rhotot, vxctot,exctot,
     $     rhoa, vxca,  exca,   exc0 )
c -->(i)   rho-i grho-i g2rho-i gpggp-i
c <--(o)         vxc-o  exc-o
c
        else
c
          call GRIDLDA( xcrhocut, weight,nptr,
     $     rhotot, vxctot,exctot,
     $     rhoa, vxca,  exca )
c -->      rho-i vxc-o  exc-o
c
        endif
c
        rhuptot = rhotot / two
        rhdntot = rhuptot
c
      endif
c
      rhotot = rhotot - cortot
      rhuptot = rhuptot - cortot/two
      rhdntot = rhdntot - cortot/two
      eharris = exctot - vxctot
c
c  Retrieve Vxc0 from igrd0fl, and remove from Vxc to get del-Vxc ...
      call MPBCREADBIG( igrd0fl, nptr, exc0 )
      call DAXPY( nptr, -one, exc0,1, vxca,1 )
      if( do_spin ) call DAXPY( nptr, -one, exc0,1, vxcb,1 )
c      ... and need core:Vxc0 integral for Harris functional
      if( anycore ) vcorfst = weight*DDOT( nptr, rhoc,1, exc0,1 )
c
c  Retrieve Exc0 from igrd0fl
      call MPBCREADBIG( igrd0fl, nptr, exc0 )
      call DAXPY( nptr, -one, exc0,1, exca,1 )
      exc0rho = weight*DDOT( nptr, rhoa,1, exc0,1 )
      if( do_spin )then
        call DAXPY( nptr, -one, exc0,1, excb,1 )
        exc0rhb = weight*DDOT( nptr, rhob,1, exc0,1 )
        exc0rho = exc0rho + exc0rhb
      endif
      excslo = exctot - exc0rho
c
c  Reconstitute slow-density by taking rho0(+rhoc) out of total:
      if( anycore ) call DAXPY( nptr, one, rhoc,1, rho0,1 )
      call DAXPY( nptr, -spinfac, rho0,1, rhoa,1 )
      if( do_spin ) call DAXPY( nptr, -spinfac, rho0,1, rhob,1 )
c  rho0() is considered destroyed at this point
c
      if( anyxc1c )then
c       Non-standard/non-working code; use rho0() as scratch
c       Retrieve dynamic fast xc grid fields from i1cgrfl ...
        REWIND( i1cgrfl )
c        ... get -vxc1c
        call READBIG( i1cgrfl, nptr, rho0 )
c        ... and remove from grid-vxc to get slow-vxc
        call DAXPY( nptr, one, rho0,1, vxca,1 )
c        ... get -exc1c
        call READBIG( i1cgrfl, nptr, rho0 )
c        ... and remove from grid-exc to get slow-exc
        call DAXPY( nptr, one, rho0,1, exca,1 )
c        ... and add to Exc0 to get "fast" Exc:
        call DAXPY( nptr, -one, rho0,1, exc0,1 )
      endif
c
      if( lvlout.gt.0 )then
        write(IWR,*) ' '
        if( do_spin )then
          write(IWR,9020) 'grid-integrated up-density total =',rhuptot
          write(IWR,9020) 'grid-integrated dn-density total =',rhdntot
        endif
        write(IWR,9020) 'grid-integrated valence-density total =',rhotot
      endif
      if( lvlout.gt.2 )then
        if( do_spin )then
          write(IWR,9020) 'grid-integrated up-spin xc energy=',excuptot
          write(IWR,9020) 'grid-integrated dn-spin xc energy=',excdntot
        endif
        write(IWR,9020) 'grid-integrated total xc-energy =     ', exctot
        write(IWR,9020) 'grid-integrated total slow xc-energy =', excslo
        if( do_spin )then
          write(IWR,9020) 'grid-integrated up-spin vxc energy=',vxcuptot
          write(IWR,9020) 'grid-integrated dn-spin vxc energy=',vxcdntot
        endif
        write(IWR,9020) 'grid-integrated total vxc:rho energy=',vxctot
      endif
      if( anycore )then
        corfast = weight*DDOT( nptr, rhoc,1, exc0,1 )
c
        corslow = spinfac*weight*DDOT( nptr, rhoc,1, exca,1 )
c       Need to pull core:Vxc intergral out of Harris term
        vxccor = vcorfst + spinfac*weight*DDOT( nptr, rhoc,1, vxca,1 )
        if( do_spin )then
          corslob = spinfac*weight*DDOT( nptr, rhoc,1, excb,1 )
          vxccorb = spinfac*weight*DDOT( nptr, rhoc,1, vxcb,1 )
          corslow = corslow + corslob
          vxccor = vxccor + vxccorb
        endif
        coregrd = corfast + corslow
        if( lvlout.gt.1 )then
          write(IWR,9020)     'grid-int core charge  =', cortot
          if( lvlout.gt.2 )then
            write(IWR,9020)   'grid-int core exc total =', coregrd
            if( lvlout.gt.3 )then
              write(IWR,9020) 'grid-int core fast exc  =', corfast
              write(IWR,9020) 'grid-int core slow exc  =', corslow
              write(IWR,9020) 'grid-int core vxc total =', vxccor
            endif
          endif
        endif
        eharris = eharris + vxccor
      endif
c
      if( iter.eq.0 .and.lvlout.gt.1 )
     $ write(IWR,9020) 'Harris Fcnal XC piece=',eharris
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDGGA
c
c
      subroutine GRIDGGA( xcrhocut, weight,nptr,
     $ rhotot, vxctot,exctot,
     $ rho, g_vxc,g2_exc,gpggp )
c---------------------------------------------------------------
c Purpose: compute spin-unpolarized GGA functionals over grid,
c          with derivative term needed for stress
c
c Written: Peter A. Schultz, 20-July-2001, for 2.49 (spin)
c
c Revision history:
c  11Jun03-PAS/2.55: split off stress-specific call
c   5Apr02-PAS/2.53: gga stress
c---------------------------------------------------------------
c
c Variables:
c  Input arrays:
c    rho()    - total electron density on grid
c    g_vxc()  - | grad[rho] | "grho"
c    g2_exc() - grad**2[rho]  "g2rho"
c    gpggp() - grad[rho] DOT grad | grad[rho] | "gpggp"
c  Output arrays:
c    g_vxc()  - computed xc-potential on grid (in rydberg)
c    g2_exc() - computed xc-energy density on grid
c  Output values:
c    rhotot  - grid integrated total electron density
c    vxctot  - grid integrated Vxc:rho
c    exctot  - grid integrated total xc-energy
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c input arrays:
      DIMENSION  rho(nptr)
      DIMENSION  g_vxc(nptr), g2_exc(nptr), gpggp(nptr)
c
c >>>> EXECUTABLE CODE:
c
      rhotot = zero
      vxctot = zero
      exctot = zero
c
      do  nr=1,nptr
        rhpt = rho(nr)
        rhotot = rhotot + rhpt
c
        if( rhpt .gt. xcrhocut )then
          grh  = g_vxc(nr)
          g2rh = g2_exc(nr)
          ggrh = gpggp(nr)
c
          call DFTGGA( rhpt, grh,g2rh,ggrh,
     $                 vxcpt,excpt, dxcpt,dxc2pt )
c
          vxctot = vxctot + vxcpt*rhpt
          exctot = exctot + excpt*rhpt
          g_vxc(nr) = vxcpt
          g2_exc(nr) = excpt
        else
          g_vxc(nr) = zero
          g2_exc(nr) = zero
        endif
c
      enddo
c
c  Scale totals by mesh weighting:
c
      rhotot = weight*rhotot
      vxctot = weight*vxctot
      exctot = weight*exctot
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDLDA
c
c
      subroutine GRIDLDA( xcrhocut,weight,nptr,
     $ rhotot, vxctot,exctot,
     $ rho, vxc,exc )
c---------------------------------------------------------------
c Purpose: compute spin-restricted LDA functionals over grid
c
c Written: Peter A. Schultz, 20-July-2001, for 2.49 (spin)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Variables:
c  Input arrays:
c    rho()   - total electron density on grid
c  Output arrays:
c    vxc()   - computed xc-potential on grid (in rydberg)
c    exc()   - computed xc-energy density on grid
c  Output values:
c    rhotot  - grid integrated total electron density
c    vxctot  - grid integrated Vxc:rho
c    exctot  - grid integrated total xc-energy
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c input/output arrays:
      DIMENSION  rho(nptr),  vxc(nptr),exc(nptr)
c
c >>>> EXECUTABLE CODE:
c
      rhotot = zero
      vxctot = zero
      exctot = zero
c
      do  nr=1,nptr
        rhpt = rho(nr)
        rhotot = rhotot + rhpt
c
        if( rhpt .gt. xcrhocut )then
c
          call DFTLDA( rhpt, vxcpt,excpt )
c
          vxctot = vxctot + vxcpt*rhpt
          exctot = exctot + excpt*rhpt
          vxc(nr) = vxcpt
          exc(nr) = excpt
        else
          vxc(nr) = zero
          exc(nr) = zero
        endif
c
      enddo
c
c  Scale totals by mesh weighting:
c
      rhotot = weight*rhotot
      exctot = weight*exctot
      vxctot = weight*vxctot
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDRHO
c
c
      subroutine GRIDRHO( ivecfl,idmatfl,
     $ irhoopt,ncplx,idwf,doblas3,
     $ nstate,npop,norb, nk,
     $ natm,ntyp, nshld,nald, nlat,
     $ itypa,numshl,lshel,nala,ala,cala, alamin, ratm,rlat,
     $ wtk, coskr,sinkr, eigpop, rtpop,
     $ weight, hh, ndbox,nbox,nrec,inrec,noboxs,inboxs, boxrad,
     $ wvfcns,wf, rhobox, wkbox,wkbi,
     $ dmat,        dmatrd,  rho,  nptr,rho_tp  )
c      R4(nc*nkl*m) R8(mat)  R8(nr)     R8(nr)
c      where nc=ncplx,nkl=nkloc,m=mat=norb^2,nr=nptr
c      dmatrd is dm(mat), ef(nc*nstate*norb)
c---------------------------------------------------------------
c Purpose: computes electron density in coordinate space
c
c Written: Peter A. Schultz,  3-June-1997, for v2.20 (boxes)
c
c Revision history:
c  17Nov08-PAS/2.63: k-parallel scf matrices
c   4Jan08-PAS/2.61: reduced (dist) memory for grid wvfcns; mem pack
c  11Feb07-PAS/2.60: mpi-clean, and use wrapped reduce
c   6Jul06-APT/    : merged task parallel and image parallel
c  30Jul05-PAS/2.59: master-only matrix files
c  25Sep04-PAS/tp0.1: clean-up task-parallel routines
c  24Mar03-DMC: Many changes to make this a parallel version.  I need
c     to distribute files which were only written on processor 0
c     to all processors.  Also, this routine does every n'th element on
c     a processor, and then uses MPI_Reduce and MPI_Bcast to accumulate
c     results on all processors.
c  20Jul01-PAS/2.49: spin-polarized dft, compact dmat, eigfcn
c  21Jun01-PAS/2.48: replace STOPs
c   2May01-PAS/2.47: remove disk storage of grid orbitals
c  10Jun99-PAS/2.36: blas3 installation
c  13May99-PAS/2.35: subcalls to real/cmplx; eigenfcn density
c  15Feb99-PAS/2.31: routine to intercept perhaps too-big i/o
c  13Feb99-PAS/2.31: reduce op ct plus blas of bottom grid code
c   9Nov98-PAS/2.28: single precision grid orbitals/wf4
c  10Sep98-PAS/2.26: on-the-fly grid orbitals
c---------------------------------------------------------------
c
c  Dave Raczkowski suggested the eigenfunction (ef) scheme to
c  compute the density rather than the density matrix (dm) method,
c  faster for certain smaller problems.
c
c  Using subcalls to separate real/complex & dm/ef-based density
c  schemes under the box loop incurs ~5% cost over having that
c  code pulled up into this routine with combined real/cmplx
c  arithmetic/memory indexing.  For the moment, will pay this
c  cost for the purpose of clarity, and perhaps later
c  restructure the work under the ibox loop to get last little
c  bit of speed.  17May99-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      REAL  wvfcns,wf, wkbi
      REAL  dmat
      REAL  rhobox
c
c Input arrays:
      LOGICAL    doblas3
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), ratm(3,natm), rlat(3,nlat)
      DIMENSION  wtk(nk), coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  eigpop(nstate,nk)
      DIMENSION  hh(3,3), ndbox(2,2,3),noboxs(nbox),inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,*),wf(*)
c
c Output array:
c     Note: rho() is initialized to zero before this routine is called
      DIMENSION  rho(*)
c
c Scratch arrays:
      DIMENSION  rtpop(norb)
      DIMENSION  wkbi(*), wkbox(*), rhobox(*)
      DIMENSION  dmat(*)
c                dmat(ncplx*nkloc,norb,norb)
      DIMENSION  dmatrd(*)
c                dmatrd(mat{dm};nc*nst*norb{ef})
c Parallel scratch:
      DIMENSION  rho_tp(*)
c
c Local declarations:
      DIMENSION  r0box(3),boxctr(3)
c
c >>>> EXECUTABLE CODE:
c
c  Get Local MP info
      call MPNODES( nprocl )
      call MPNODE( iprocl )
      call MPNODE0( masterl )
      call MPCOMM( icomml )
c
c  Set up k-parallel
      call MPNODES_K( nprocs )
      call MPNODE_K( iproc )
      call MPNODE0_K( master )
      call MPCOMM_K( icomm )
c
      call KPMINE( nk,nkloc,nk0 )
      if( nkloc .eq. 0 ) goto 1001
c
c  Locate scratch space in dmat
      ipdm2 = ncplx*nkloc*norb*norb + 1
      ipef2 = ncplx*nkloc*norb*npop + 1
c
c  Retrieve dmat/eigvec for DM/EF density scheme
c
      if( irhoopt .eq. 1 )then
c       Density-matrix based grid density, set up dmat(k,i,j)
c
        call RHDMAT( idmatfl, ncplx, norb,
     $   nk,nk0,nkloc,
     $   dmat,          dmatrd )
c -->    r4(nc*NK*N^2)  r8(N^2)
c
      elseif( irhoopt .eq. 2 )then
c       Eigenfunction-based grid density, set up eigvec(nc,n,k,i)
c
        numpop = npop
c
        call RHEIGVEC( ivecfl, ncplx, norb,nstate,numpop,
     $   nk,nk0,nkloc,
     $   wtk,eigpop, rtpop,
     $   dmat,          dmatrd )
c -->    eigvec-o       eigvrd-s
c        r4(rnc*NK*N^2) r8((nc*NST*N)
c
      else
        call STOPXERR( 'irhoopt is corrupted in gridrho' )
      endif
c
c  Initialize location of grid orbitals in big storage
      ir00 = 0
c
      irpot = 0
c
c Cycle over boxes of grid points
c
      do 1000 ibox=1,nbox
c
c       Get basic box data
        call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $   ira0,irb0,irc0, idra,idrb,idrc )
        nrbox = idra*idrb*idrc
c
c       Update location in global mesh density array
        iv0 = irpot
        irpot = irpot + nrbox
c
c       Get number of orbitals in this box; skip if none
        nobox = noboxs(ibox)
        if( nobox.le.0 ) goto 1000
c
c       Each processor will do every nprocs'th box in this loop.
        if( iproc .ne. MOD( ibox, nprocs ) ) goto 1000
c
c       Get grid orbitals:
c
        if( idwf.eq.0 )then
c         Compute orbitals on mesh in this box
c
c         Generate mesh point coordinates
          call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
          call MKRBOX( hh,r0box, idra,idrb,idrc, wkbox )
          ir00 = 0
          iwk1 = 1
          iwk2 = iwk1 + 3*nrbox
          iwk3 = iwk2 + nrbox
          iwk4 = iwk3 + nrbox
          iwk5 = iwk4 + nrbox
          iwk6 = iwk5 + nrbox
          iwk7 = iwk6 + nrbox
          iwk8 = iwk7 + nrbox
c
          call BOXWFN( ibox, ncplx,
     $     nk,nk0,nkloc, natm,ntyp, nshld,nald, nlat,
     $     itypa,numshl,lshel,nala,ala,cala,alamin,
     $     ratm,rlat,coskr,sinkr,
     $     nobox,nrbox,nrec,inrec,inboxs, boxrad,boxctr,
     $     wvfcns(1,ir00+1), wf(ir00+1),
     $     wkbox      ,wkbox(iwk2),wkbox(iwk3),wkbox(iwk4),
     $     wkbox(iwk5),wkbox(iwk6),wkbox(iwk7),wkbox(iwk8) )
c
        endif
c
c       Clear box density:
        call MKSZERO( nrbox, rhobox )
c
c       ***************************************
c       Compute density on mesh in this box:
c       ***************************************
c
        if( irhoopt.eq.1 )then
c
c         **** Density matrix route to compute density ****
c
          if( ncplx.eq.2 )then
c
c           Complex orbitals/DM scheme
c
            if( doblas3 )then
              call GRHODM2B( ibox,
     $         norb,nkloc, natm,ntyp, nshld,  itypa,numshl,lshel,
     $         nbox,nrec,inrec, nrbox, nobox,inboxs,
     $         wvfcns(1,ir00+1), rhobox, wkbi,
     $         dmat,         dmat(ipdm2)      )
c -->          r4(nc*nk*n^2) r4(nc*nk*noboxmax^2)-s
            else
              call GRHODM2( ibox,
     $         norb,nkloc, natm,ntyp, nshld,  itypa,numshl,lshel,
     $         nbox,nrec,inrec, nrbox, nobox,inboxs,
     $         wvfcns(1,ir00+1), rhobox, wkbi,
     $         dmat )
c -->          r4(nc*nk*n^2)
            endif
c
          elseif( ncplx.eq.1 )then
c
c           Real orbitals/DM scheme
c
            if( doblas3 )then
              call GRHODM1B( ibox,
     $         norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $         nbox,nrec,inrec, nrbox, nobox,inboxs,
     $         wf(ir00+1), rhobox, wkbi,
     $         dmat,         dmat(ipdm2)      )
c -->          r4(n^2)       r4(noboxmax^2)-s
            else
              call GRHODM1( ibox,
     $         norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $         nbox,nrec,inrec, nrbox, nobox,inboxs,
     $         wf(ir00+1), rhobox, wkbi,
     $         dmat )
c -->          r4(n^2)
            endif
c
          endif
c
        elseif( irhoopt.eq.2 )then
c
c         **** Eigenfunction route to compute density ****
c
          if( ncplx.eq.2 )then
c
c           Complex orbitals/EF scheme
c
            if( doblas3 )then
              call GRHOEF2B( ibox, numpop,
     $         norb,nkloc, natm,ntyp, nshld,  itypa,numshl,lshel,
     $         nbox,nrec,inrec, nrbox, nobox,inboxs,
     $         wvfcns(1,ir00+1), rhobox, wkbi,
     $         dmat,           dmat(ipef2)      )
c -->          r4(nc*nk*nst*n) r4(nc*nk*nst*noboxmax)-s
            else
              call GRHOEF2( ibox, numpop,
     $         norb,nkloc, natm,ntyp, nshld,  itypa,numshl,lshel,
     $         nbox,nrec,inrec, nrbox, nobox,inboxs,
     $         wvfcns(1,ir00+1), rhobox, wkbi,
     $         dmat )
c -->          r4(nc*nk*nst*n)
            endif
c
          elseif( ncplx.eq.1 )then
c
c           Real orbitals/EF scheme
c
            if( doblas3 )then
              call GRHOEF1B( ibox, numpop,
     $         norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $         nbox,nrec,inrec, nrbox, nobox,inboxs,
     $         wf(ir00+1), rhobox, wkbi,
     $         dmat,     dmat(ipef2)        )
c -->          r4(nst*n) r4(nst*noboxmax)-s
            else
              call GRHOEF1( ibox, numpop,
     $         norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $         nbox,nrec,inrec, nrbox, nobox,inboxs,
     $         wf(ir00+1), rhobox, wkbi,
     $         dmat )
c -->          r4(nst*n)
            endif
c
          endif
c
        endif
c
c       Update total (r8) density with box (r4) density:
        do  nr=1,nrbox
          rho(iv0+nr) = rho(iv0+nr) + rhobox(nr)
        enddo
c
c       Close box loop:
  900   continue
        ir00 = ir00 + nkloc*nobox*nrbox
 1000 continue
c     Bypass from nkloc=0:
 1001 continue
c
      if( nprocl .gt. 1 )then
c       Each local processor now has density for its boxes (and k-pts).
c       Need to sum these into a single array, onto image master.
c       For now, also broadcast total back to all processors.
c
        call MPREDUC8( masterl, nptr, rho, rho_tp, icomml )
C        call MPI_Reduce( rho, rho_tp, nptr, MPI_DOUBLE_PRECISION,
C     $   MPI_SUM, master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pgridrho - Reduce rho' )
        call DCOPY( nptr, rho_tp,1, rho,1 )
c
        call MPBCAST8( masterl, nptr, rho, icomml )
C        call MPI_Bcast( rho, nptr, MPI_DOUBLE_PRECISION,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pgridrho - Bcast rho' )
       endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDSLDA
c
c
      subroutine GRIDSLDA( xcrhocut, weight,nptr,
     $ rhouptot, vxcuptot,excuptot,  rhodntot, vxcdntot,excdntot,
     $ rhoup, vxcup,excup,  rhodn, vxcdn,excdn )
c---------------------------------------------------------------
c Purpose: compute spin-polarized LDA functionals over igrid
c
c Written: Peter A. Schultz, 20-July-2001, for 2.49 (spin)
c
c Revision history:
c  19Apr03-PAS/2.55: restrict rho-up/dn to be non-negative
c---------------------------------------------------------------
c
c Variables: (up/dn)
c  Input arrays:
c    rho()   - total electron density on grid
c  Output arrays:
c    vxc()   - computed xc-potential on grid (in rydberg)
c    exc()   - computed xc-energy density on grid
c  Output values:
c    rhotot  - grid integrated total electron density
c    vxctot  - grid integrated Vxc:rho
c    exctot  - grid integrated total xc-energy
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c input/output arrays:
      DIMENSION  rhoup(nptr),  vxcup(nptr),excup(nptr)
      DIMENSION  rhodn(nptr),  vxcdn(nptr),excdn(nptr)
c
c >>>> EXECUTABLE CODE:
c
      rhouptot = zero
      excuptot = zero
      vxcuptot = zero
      rhodntot = zero
      excdntot = zero
      vxcdntot = zero
c
      do  nr=1,nptr
        rhup = rhoup(nr)
        if( rhup .lt. zero ) rhup = zero
        rhouptot = rhouptot + rhup
        rhdn = rhodn(nr)
        if( rhdn .lt. zero ) rhdn = zero
        rhodntot = rhodntot + rhdn
        rhpt = rhup + rhdn
c
        if( rhpt .gt. xcrhocut )then
c
          call DFTSLDA( rhup, vxcupr,excupr,
     $                  rhdn, vxcdnr,excdnr )
c
          vxcuptot = vxcuptot + vxcupr*rhup
          excuptot = excuptot + excupr*rhup
          vxcup(nr) = vxcupr
          excup(nr) = excupr
          vxcdntot = vxcdntot + vxcdnr*rhdn
          excdntot = excdntot + excdnr*rhdn
          vxcdn(nr) = vxcdnr
          excdn(nr) = excdnr
        else
          vxcup(nr) = zero
          excup(nr) = zero
          vxcdn(nr) = zero
          excdn(nr) = zero
        endif
c
      enddo
c
c  Scale totals by mesh weighting:
c
      rhouptot = weight*rhouptot
      vxcuptot = weight*vxcuptot
      excuptot = weight*excuptot
      rhodntot = weight*rhodntot
      vxcdntot = weight*vxcdntot
      excdntot = weight*excdntot
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDSTR
c
c
      subroutine GRIDSTR( xcrhocut, nptr, weight,
     $ rho, g_dxc,g2_dxc2,gpggp )
c---------------------------------------------------------------
c Purpose: compute extra fcnals for non-spin GGA stress
c
c Written: Peter A. Schultz, 11-JUne-2003, for 2.55
c
c Revision history:
c   9Oct03-PAS/2.57: accomodate spin-dependent stress for GGA
c---------------------------------------------------------------
c
c Variables:
c  Input arrays:
c    rho()     - total electron density on grid
c    g_dxc()   - | grad[rho] | "grho"
c    g2_dxc2() - grad**2[rho]  "g2rho"
c    gpggp()   - grad[rho] DOT grad | grad[rho] | "gpggp"
c  Output arrays:
c    g_dxc()   - fcnal for GGA 1st dervative stress
c    g2_dxc2() - fcnal for GGA Laplacian stress
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c
c Input:
      DIMENSION  rho(nptr)
c Input/output:
      DIMENSION  g_dxc(nptr), g2_dxc2(nptr)
c Output:
      DIMENSION  gpggp(nptr)
c
c >>>> EXECUTABLE CODE:
c
      exctot = zero
      do  nr=1,nptr
        rhpt = rho(nr)
c
        if( rhpt .gt. xcrhocut )then
          grh  = g_dxc(nr)
          g2rh = g2_dxc2(nr)
          ggrh = gpggp(nr)
c
          call DFTGGA( rhpt, grh,g2rh,ggrh,
     $                 vxcpt,excpt, dxcpt,dxc2pt )
c
          exctot = exctot + rhpt*excpt
c
          g_dxc(nr) = dxcpt
          g2_dxc2(nr) = dxc2pt
        else
          g_dxc(nr) = zero
          g2_dxc2(nr) = zero
        endif
c
      enddo
      exctot = weight*exctot
C      write(6,'(a,3f20.10)') 'STR: energy exctot=',exctot
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDWF
c
c
      subroutine GRIDWF( ncplx,idwf,
     $ nk,  natm,ntyp, nshld,nald, nlat,
     $ itypa,numshl,lshel,nala,ala,cala, alamin, ratm,rlat,
     $ coskr,sinkr,
     $ hh, ndbox,nbox,nrec,inrec,noboxs,inboxs, boxrad,
     $ wvfcns,wf,
     $ wkbox )
c---------------------------------------------------------------
c Purpose: generate basis orbitals on regular space grid
c
c Written: Peter A. Schultz,  3-June-1997, for v2.20 (boxes)
c
c Revision history:
c   4Dec08-PAS/2.63: k-parallel scf matrices
c   4Jan08-PAS/2.61: reduced (dist) memory for grid wvfcns
c   2May01-PAS/2.47: remove disk storage of grid orbitals
c   9Nov98-PAS/2.28: single precision grid orbitals/wf4
c  10Sep98-PAS/2.26: cosmetic modification
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wf
c
c Input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), ratm(3,natm), rlat(3,nlat)
      DIMENSION  coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  hh(3,3), ndbox(2,2,3),noboxs(nbox),inboxs(nrec,nbox)
c Output arrays:
      DIMENSION  wvfcns(2,*),wf(*)
c Scratch arrays:
      DIMENSION  wkbox(*)
c
c Local declarations:
      DIMENSION  r0box(3),boxctr(3)
c
c >>>> EXECUTABLE CODE:
c
      if( idwf.eq.0 ) RETURN
c
c  Get Local MP info
      call MPNODES_K( nprocs )
      call MPNODE0_K( master )
      call MPNODE_K( iproc )
      call MPCOMM_K( icomm )
c
c  Set up k-parallel
      call KPMINE( nk,nkloc,nk0 )
c
      ir00 = 0
c
c  Cycle over boxes
c
      do 3000 ibox=1,nbox
c
c       Each processor will do every nprocs'th box in this loop.
        if( MOD( ibox, nprocs ) .ne. iproc ) goto 3000
c
c       Get number of orbitals in this box; skip if none
        nobox = noboxs(ibox)
        if( nobox.le.0 ) goto 3000
c
c       Get basic box info
        call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $   ira0,irb0,irc0, idra,idrb,idrc )
        nrbox = idra*idrb*idrc
c
c       Generate mesh point coordinates
        call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
        call MKRBOX( hh,r0box, idra,idrb,idrc, wkbox )
c
c       Compute orbitals on mesh in this box
c
        iwk1 = 1
        iwk2 = iwk1 + 3*nrbox
        iwk3 = iwk2 + nrbox
        iwk4 = iwk3 + nrbox
        iwk5 = iwk4 + nrbox
        iwk6 = iwk5 + nrbox
        iwk7 = iwk6 + nrbox
        iwk8 = iwk7 + nrbox
c
        call BOXWFN( ibox, ncplx,
     $   nk,nk0,nkloc,  natm,ntyp, nshld,nald, nlat,
     $   itypa,numshl,lshel,nala,ala,cala,alamin,
     $   ratm,rlat,coskr,sinkr,
     $   nobox,nrbox,nrec,inrec,inboxs, boxrad,boxctr,
     $   wvfcns(1,ir00+1), wf(ir00+1),
     $   wkbox      ,wkbox(iwk2),wkbox(iwk3),wkbox(iwk4),
     $   wkbox(iwk5),wkbox(iwk6),wkbox(iwk7),wkbox(iwk8) )
c
c       Close box loop:
 2900   continue
        ir00 = ir00 + nkloc*nobox*nrbox
 3000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:

c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDXGGA
c
c
      subroutine GRIDXGGA( xcrhocut, weight,nptr,
     $ rhtot, vxtot,extot, rho,rop, grho,g2rho,gpggp, vxc,exc )
c---------------------------------------------------------------
c Purpose: compute spin-pol GGA exchange functionals over grid
c
c Written: Peter A. Schultz, 10-August-2001, for 2.49 (spin)
c
c Revision history:
c  17Spt08-RJM/2.62: added opposite spin passing for AM05 spin 
c  10Oct03-AEM+PAS/2.57: accommodate spin stress for GGA
c---------------------------------------------------------------
c
c ***** NOTE: exchange term only, correlation previously *****
c
c Note on spin-dependent exchange:
c   Ex(up,dn) = ( Ex(2*up) + Ex(2*dn) ) / 2
c   where Ex refer to energy (not energy densities)
c   Hence, we want to use *twice* the input density as input
c   to the routines that generate the potentials and energy
c   densities, and gpggp gets doubled twice because it has
c   two factors of density in it.  Once we get the potential
c   and energy density, then we can use the undoubled density
c   to do the integrals, and this takes care of the final
c   division by two.
c
c Note on status of the grid potential and energy-density:
c   We presume that exc and vxc have already been through
c   the correlation gga calculation and on input contain the
c   correlation part of the gga and what we do here is
c   increment exc and vxc with the exchange part of the gga.
c
c Variables:
c  Input arrays:
c    rho()    - total electron density on grid
c    grho()  - | grad[rho] | "grho"
c    g2rho() - grad**2[rho]  "g2rho"
c    gpggp()  - grad[rho] DOT grad | grad[rho] | "gpggp"
c  Input/output arrays:
c    vxc() - computed xc-potential on grid (in rydberg)
c    exc() - computed xc-energy density on grid
c  Output values:
c    rhtot  - grid integrated total electron density
c    vxtot  - grid integrated Vx:rho
c    extot  - grid integrated total Ex-energy
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0, two = 2.d0 )
c input/output arrays:
      DIMENSION  rho(nptr),rop(nptr)
      DIMENSION  grho(nptr), g2rho(nptr), gpggp(nptr)
      DIMENSION  vxc(nptr), exc(nptr)
c
      REAL*8 rhop
c
c >>>> EXECUTABLE CODE:
c
      rhtot = zero
      extot = zero
      vxtot = zero
c
      do  nr=1,nptr
        rh = rho(nr)
        rhop = rop(nr)
        rhtot = rhtot + rh
        rhpt = rh * two
c
        if( rhpt .gt. xcrhocut )then
          grh = grho(nr) * two
          g2rh = g2rho(nr) * two
          ggrh = gpggp(nr) * two * two
c
          call DFTXGGA( rhpt, rhop,grh,g2rh,ggrh, vxr,exr, dexsr )
c
          vxtot = vxtot + vxr*rh
          extot = extot + exr*rh
          vxc(nr) = vxc(nr) + vxr
          exc(nr) = exc(nr) + exr
        endif
c
      enddo
c
c  Scale totals by mesh weighting:
c
      rhtot = weight*rhtot
      vxtot = weight*vxtot
      extot = weight*extot
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GRIDXSTR
c
c
      subroutine GRIDXSTR( xcrhocut, nptr, weight,
     $   rho,   rop,grho,      g2rho,     ggrho,
     $   dxc )
c---------------------------------------------------------------
c Purpose: compute extra fcnal for exchange part of
c          spin-dependent GGA stress
c
c Written: Peter A. Schultz and Ann. E. Mattsson
c          10-October-2003, for 2.57
c
c Revision history:
c  17Spt08-RJM/2.62: added opposite spin (rop) to be passed to AM05 spin
c---------------------------------------------------------------
c
c Variables:
c  Input arrays:
c    rho()    - total spin xc electron density on grid
c    grho()   - | grad[rho] | "grho"
c    g2rho()  - grad**2[rho]  "g2rho"
c    ggrho()  - grad[rho] DOT grad | grad[rho] | "gpggp"
c  Output arrays:
c    dxc()   - fcnal for GGA 1st derivative stress
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0, two = 2.d0 )
c
c Input:
      DIMENSION  rho(nptr),rop(nptr)
      DIMENSION  grho(nptr)
      DIMENSION  g2rho(nptr)
      DIMENSION  ggrho(nptr)
c Output:
      DIMENSION  dxc(nptr)
c
c >>>> EXECUTABLE CODE:
c
      extot = zero
      do  nr=1,nptr
        rh = rho(nr)
        rhop = rop(nr)
        rhpt = rh * two
c
        if( rhpt .gt. xcrhocut )then
          grh = grho(nr) * two
          g2rh = g2rho(nr) * two
          ggrh = ggrho(nr) * two * two
c
          call DFTXGGA( rhpt, rhop, grh, g2rh, ggrh, vxr,exr, dexsr )
c
          extot = extot + exr*rh
          dxc(nr) = dxc(nr) + dexsr
        endif
c
      enddo
      extot = weight*extot
C      write(6,'(a,3f20.10)') 'XSTR: energy extotsp=',extot
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GSELECT
c
c
      subroutine GSELECT( natm, nafrc, iforce, nrlxdim,
     $ nslics,islics,islicats,vslics,
     $ ratmP,frcP,
     $ itypa,atmass, natmg,nxatm,
     $ ratm,frc, ratmg,frcg,amassg )
c---------------------------------------------------------------
c Purpose: select and pack force components of atoms to be
c          relaxed in geometry update
c
c Written: Peter A. Schultz, 18-May-2001, for v2.47
c
c Revision history:
c   1Aug17-PAS/2.68: add bond, unified slics
c  20Feb09-PAS/2.62: refined constraints along vector
c   9Sep08-PAS/2.62: option to freeze atoms along vector
c    Oct06-RMV/2.60: initial SLIC projection
c   3Oct01-PAS/2.50: damped dynamics
c  21Jun01-PAS/2.48: replace STOPs
c  18May01-PAS/2.47: extract from main routine
c  14Jun05-PAS/2.59: File unit
c---------------------------------------------------------------
c
cRMV add in stuff for coordinate de-projection
cRMV needed:  check max 
cRMV                project selected coords cartesian from internal
cRMV                to correct type of internal
cRMV              
c
c Notes:
c  For the moment, we are simply picking frozen and relaxed atoms.
c  This could easily be generalized to enforce internal
c  restrictions on atoms (such as keeping an atom a given plane)
c  by manipulating the forces and coordinates.
c
c On output:
c  natmg   = number of atoms with relaxed coordinates
c  nxatm() = number of degress of freedom per atom
c  nrlxdim = the length of the vector being relaxed
c  ratmg() = packed coordinates of components to be relaxed
c  frcg()  = packed forces of componentes to be relaxed
c  amassg()= packed particle masses for the components to be relaxed
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, one=1.d0 )
c
c Input arrays:
      DIMENSION  iforce(natm)
      DIMENSION  itypa(natm), atmass(*)
      DIMENSION  ratm(3,natm), frc(3,natm)
cRMV constraints/slics
      DIMENSION  islics(4,*), islicats(*), vslics(3,*)
      DIMENSION  ratmP(3,natm), frcP(3,natm)
c Output arrays:
      DIMENSION  nxatm(*)
      DIMENSION  ratmg(*), frcg(*), amassg(*)
c
c Local declarations:
      DIMENSION  ftmp(3)
c Diagnostics/debugging 
      DATA  iprint / 2 /
c
c >>>> EXECUTABLE CODE:
c
      call FLGETIWR( IWR )
      nrlxdim = 3*nafrc
      natmg = 0
c
      if( iprint.gt.1 )
     $write(IWR,*) '>>>>> GSELECT begins, nslics=',nslics
c
c  Set up SLIC options
c
      do  iatm=1,natm
c       Copy raw forces into "projected" forces, as default
        frcP(1,iatm) = frc(1,iatm)
        frcP(2,iatm) = frc(2,iatm)
        frcP(3,iatm) = frc(3,iatm)
      enddo
c
c Take care of preparing Unified SLICS
c
      do 200 islic=1,nslics
        islictyp = islics(1,islic)
        if( iprint.gt.1 )
     $   write(IWR,*) 'GSELECT: islic,islictyp=',islic,islictyp
c
        if( islictyp.eq.1 .or. islictyp.eq.2 )then
c         SLIC projections: 1-fold or 2-fold
          if( iprint.gt.1 )
     $    write(IWR,*) 'SLIC/PROJ: projection type=',islictyp
          iatmproj = islics(2,islic)
          iatmank1 = islics(3,islic)
          iatmank2 = islics(4,islic)
 9201     format(1x,'SLIC/',a,': projected atom, anchors=',3i5)
c****** DEV Should reverse cyl/sph order to 1-fold(sph) and 2-fold (cyl)
          if(     islictyp.eq.2 )then
            if( iprint.gt.1 )
     $      write(IWR,9201) 'SLIC/slsph:',iatmproj,iatmank1,iatmank2
            call SLSPH( IWR,natm, islics,islic,
     $                  ratm,frc, ratmP,frcP )
          elseif( islictyp.eq.1 )then
            if( iprint.gt.1 )
     $      write(IWR,9201) 'SLIC/slcyl:',iatmproj,iatmank1,iatmank2
            call SLCYL( IWR,natm, islics,islic,
     $                  ratm,frc, ratmP,frcP )
          endif
c
        elseif( islictyp.eq.3 )then
c         FRAME
          if( iprint.gt.0 )then
            write(IWR,*) 'SLICS/FRAME; slictyp=',islictyp
          endif
          write(IWR,*) 'DEV/FRAME still done outside of SLICS'
c
        elseif( islictyp.eq.4 )then
c         BONDS
          if( iprint.gt.1 )
     $    write(IWR,*) 'SLICS/BOND - length constrained'
          call SLBONDTO( IWR,islic,islics, ratm,frc, ratmP,frcP )
c
        elseif( islictyp.ge.5 .and. islictyp.le.8 )then
c         VGFIX slictyp
          if( iprint.gt.1 )
     $    write(IWR,*) 'SLICS/VGFIX: slictyp=',islictyp
          nvgfix = islics(2,islic)
          if( nvgfix .gt. 0 )then
            isl1 = islics(3,islic)
            islicv = islics(4,islic)
c
            frcvcm = zero
            do  ivgatm=isl1,isl1+nvgfix-1
              iatm = islicats(ivgatm)
              fdotv = zero
              do  id=1,3
                fdotv = fdotv + vslics(id,islicv)*frc(id,iatm)
              enddo
              frcvcm = frcvcm + fdotv
            enddo
            if( iprint.gt.3 )
     $      write(IWR,*) 'VGFIX: CM force along vector=',frcvcm
c
            do  ivgatm=isl1,isl1+nvgfix-1
              iatm = islicats(ivgatm)
              fdotv = zero
              do  id=1,3
                fdotv = fdotv + vslics(id,islicv)*frc(id,iatm)
              enddo
              if( ivgatm.eq.isl1 .and.
     $          ( islictyp.eq.6 .or. islictyp.eq.8 ) )then
c               Allow CM motion along vector
c               Install CM-vec forces into lead atom, suppress other cm
                fdotv = fdotv - frcvcm
              endif
              do  id=1,3
                ratmP(id,iatm) = fdotv*vslics(id,islicv) 
                if( islictyp.eq. 7 )then
c                 Allow motion along vector, suppress normal
                  frcP(id,iatm) = fdotv*vslics(id,islicv) 
                else
c                 islic=3,4,6 
c                 Allow motion norma to vector, remove along vector
                  frcP(id,iatm)= frc(id,iatm) - fdotv*vslics(id,islicv) 
                endif
              enddo
            enddo
          endif
c
        elseif( islictyp.eq.9 )then
c         SLINKY/LAYERS slictyp
          if( iprint.gt.1 )
     $    write(IWR,*) 'SLICS/SLINKY: slictyp=',islictyp
          call SLINKSEL( IWR, islic, islics,islicats,vslics,
     $      ratm,frc, ratmP,frcP )
c
c         End of all SLICS options
        endif

  200 continue
c
c  Pack the relaxation vectors
c
      irlx = 0
      do 300 iatm=1,natm
c
        if( iforce(iatm) .ne. 0 )then
c         This atom will have some sort of relaxation
c
          ityp = itypa(iatm)
          amass = atmass(ityp)
          natmg = natmg + 1
          nxatm(natmg) = 3
c
          if(     iforce(iatm) .eq. 1 )then
c           Standard cartesian relaxation
            do  id=1,3
              irlx = irlx + 1
              ratmg(irlx) = ratm(id,iatm)
c             Yes, frcP is deliberate here, to enable refining anchors
              frcg(irlx)  = frcP(id,iatm)
              amassg(irlx)= amass
            enddo
c
          elseif( iforce(iatm) .eq. 2 )then
cRMV        SLIC-projected - 1-fold sphere or 2-fold cylinder
            write(IWR,*) 'slic projected atom: ',iatm
            do  id=1,3
c             NB: for new slic1/sphere, will also need frcP on ank1
              irlx = irlx + 1
              ratmg(irlx) = ratmP(id,iatm)
              frcg(irlx)  = frcP(id,iatm)
              if( iprint.gt.4 )then
                write(IWR,'(a,2i6,f14.8)') 'coord ',iatm,id, ratmg(irlx)
                write(IWR,'(a,12x,f14.8)') 'force ',frcg(irlx)
              endif
              amassg(irlx)= amass
            enddo
c
          elseif( iforce(iatm) .eq. 4 )then
c           BOND - length constraint
c
            if( iprint.gt.3 )
     $      write(IWR,*) 'BOND: part of fixed bond, iatm= ',iatm
            do  id=1,3
              irlx = irlx + 1
              ratmg(irlx) = ratmP(id,iatm)
              frcg(irlx) = frcP(id,iatm)
              amassg(irlx)= amass
            enddo
c
          elseif( iforce(iatm) .ge. 5 .and. iforce(iatm) .le. 8 )then
c           VGFIX - Constrain atom along vector
c
            if( iprint.gt.3 )
     $      write(IWR,*) 'VGFIX: vector project force on atom ',iatm
            do  id=1,3
              irlx = irlx + 1
              ratmg(irlx) = ratm(id,iatm)
              frcg(irlx) = frcP(id,iatm)
              amassg(irlx)= amass
            enddo
c
          elseif( iforce(iatm) .ge. 9 )then
c           SLINKY/LAYERS - constraint
c
            if( iprint.gt.3 )
     $      write(IWR,*) 'SLINKY/LAYERS optimization atom ',iatm
            do  id=1,3
              irlx = irlx + 1
              ratmg(irlx) = ratmP(id,iatm)
              frcg(irlx) = frcP(id,iatm)
              amassg(irlx)= amass
            enddo
          endif
c
        endif
c
  300 continue
c
      if( iprint.gt.0 )
     $write(IWR,*) '<<<<< GSELECT ends'
c Idiot-check:
      if( nafrc.ne.natmg )then
        call FLGETIERR( IERRFL )
        write(IERRFL,*) '>>>>> nafrc, sum(iforce)=',nafrc,natmg
        call STOPXERR( 'gselect1/number of relaxed atoms mismatch' )
      elseif( irlx .ne. nrlxdim )then
        call FLGETIERR( IERRFL )
        write(IERRFL,*) '>>>>> nrlxdim,irlx=',nrlxdim,irlx
        call STOPXERR( 'gselect2/dim of relaxation vector mismatch' )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GSTAMP
c
c
      subroutine GSTAMP( IWR, igstep,igeom,igstat,image,
     $ iatmfmt, ntyp,natm, natmnm, itypa, atmnm,typnm, ratm )
c---------------------------------------------------------------
c Purpose: output a complete formatted geometry to a file
c
c Written: Peter A. Schultz, 14-February-2002, for v2.54
c
c Revision history:
c  12Apr15-PAS/2.66: master-pnly write of external file
c   8Nov02-PAS/2.54d: add geom file to output.
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
      DIMENSION  itypa(*)
      CHARACTER*(*)  typnm, atmnm
      DIMENSION  typnm(*), atmnm(*)
      DIMENSION  ratm(3,natm)
c
c Local:
      CHARACTER*10  imgname
c
c >>>> EXECUTABLE CODE:
c
 9430 format(1x,79('#') )
c
      write(IWR,*)
      write(IWR,9430)
c
      call MPNODE( iproc )
      call MPNODE0( master )
c
      if( image.eq.0 )then
c       Standard SCF geometry relaxation
c
        if( igstat.lt.0 )then
          write(IWR,9431) 'INITIAL',igstep,igeom+1
        elseif( igstat.lt.2 )then
          write(IWR,9431) '  NEW',igstep,igeom+1
        elseif( igstat.ge.2 )then
          write(IWR,9431) 'FINAL',igstep,  igeom
        endif
 9431   format(1x,a,' GEOMETRY for step',i4,', of',i4,' total')
c
        if( iproc.eq.master )then
c         Open geom file with default name:
          call FLOPENA( igeomfl, 'geom' )
          REWIND( unit=igeomfl )
c
          write(igeomfl,'(a,i7)') 'atom, type, position;  step#',igstep
          write(IWR    ,'(a,i7)') 'atom, type, position;  step#',igstep
        endif
c
      else
c       Multiple-image (NEB) calculation.
c
        if( igstat.lt.0 )then
          write(IWR,9432) 'INITIAL',image, igstep
        elseif( igstat.lt.2 )then
          write(IWR,9432) '  NEW',image, igstep
        elseif( igstat.ge.2 )then
          write(IWR,9432) 'FINAL',image, igstep
        endif
 9432   format(1x,a,' GEOMETRY for image',i3,', step',i4 )
c
        if( iproc.eq.master )then
c         Open geom file with image-specific geom file name
          call STRNUM( nstr, imgname, image,image )
          call FLOPENA( igeomfl, 'geom'//imgname(1:nstr) )
          REWIND( unit=igeomfl )
c
          write(igeomfl,'(a,i4,1x,i7)')
     $     'atom, type, position; image#',image
          write(IWR    ,'(a,i4,1x,i7)')
     $     'atom, type, position; image#',image
        endif
c
      endif
c
c Write latest geometry to user output listing file:
      call CONFIGWR( IWR    , iatmfmt, natmnm, ntyp,typnm,
     $ natm, atmnm, itypa, ratm )
c
      if( iproc.eq.master )then
c       Write latest geometry to running geometry file:
        call CONFIGWR( igeomfl, iatmfmt, natmnm, ntyp,typnm,
     $   natm, atmnm, itypa, ratm )
c
        call FLCLOSE( igeomfl )
      endif
c
      write(IWR,9430)
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GTYPSET
c
c
      subroutine GTYPSET( glabel )
c---------------------------------------------------------------
c Purpose: set up flags for geometry update method
c
c Written: Peter A. Schultz, 30-October-2001, for v2.50 (dmd)
c
c Revision history:
c  21Jun07-PAS/2.60: bfgs disabled
c   7May04-PAS/2.58: add explicit quantum MD flag
c  19Dec02-PAS/2.55: add LBFGS option
c---------------------------------------------------------------
c
c  Setting ig_type (communicated via common) for a given glabel
c Relaxation schemes:
c  ig_steep = simple steepest descent
c  ig_broy  = modified Broyden (D.D. Johnson).
c  ig_md0   = simple dynamics
c  ig_dmd   = "damped dynamics" a la Jonsson - component-wise
c  ig_dmdat = "damped dynamics" a la Jonsson - atom-by-atom
c  ig_asd   = accelerated steepest descent (modified damped dyn.)
c  ig_lbfgs = limited memory BFGS algorithm
c  ig_cg    = conjugate gradient (not yet coded)
c  ig_qmd   = quantum molecular dynamics (RPM)
c
c  To add new methods, extend COMMON/GEOMTYPS/ with new
c  ig_{labels}, add new unique integer values below, add
c  check for label in if-block here, and add code in
c  routine "GRELAX" to implement the new scheme.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /GEOMTYPS/ ig_type, ig_steep,ig_broy,ig_md0,
     $ ig_dmd,ig_dmdat,ig_asd,ig_lbfgs,ig_cg,ig_qmd
c
c input declarations:
      CHARACTER*(*)  glabel
c local declarations:
      CHARACTER*6  gmeth
c
c >>>> EXECUTABLE CODE:
c
c The following are geometry method id tags.  They must be distinct
c from one another.
      ig_steep =  1
      ig_broy  =  2
      ig_md0   =  3
      ig_dmd   =  4
      ig_dmdat =  5
      ig_asd   =  6
      ig_lbfgs =  7
      ig_cg    =  8
      ig_qmd   =  9
c      ig_gmeth = 10 i.e. extend existing sequence
c
c Now go looking for a matching method:
c
      gmeth = glabel(1:6)
c
      if(     gmeth .eq. 'steepe' .or. gmeth .eq. 'STEEPE' )then
c       Steepest descent
        ig_type = ig_steep
c
      elseif( gmeth .eq. 'broyde' .or. gmeth .eq. 'BROYDE' )then
c       Modified Broyden scheme (D.D. Johnson)
        ig_type = ig_broy
c
      elseif( gmeth .eq. 'mdsimp' .or. gmeth .eq. 'MDSIMP' )then
c       Simple dynamics outside of MD engine
        ig_type = ig_md0
c
      elseif( gmeth .eq. 'dynami' .or. gmeth .eq. 'DYNAMI' )then
c       Simple dynamics
        ig_type = ig_qmd
c
      elseif( gmeth .eq. 'damped' .or. gmeth .eq. 'DAMPED' )then
c       "damped dynamics" a la Jonsson (component-wise)
        ig_type = ig_dmd
c
      elseif( gmeth .eq. 'dmd-at' .or. gmeth .eq. 'DMD-AT' )then
c       "damped dynamics" atom-wise
        ig_type = ig_dmdat
c
      elseif( gmeth .eq. 'asd   ' .or. gmeth .eq. 'ASD   ' )then
c       Accelerated Steepest Descent (PAS-modified damped dyn.)
        ig_type = ig_asd
c
      elseif( gmeth .eq. 'lbfgs ' .or. gmeth .eq. 'LBFGS ' .or.
     $        gmeth .eq. 'bfgs  ' .or. gmeth .eq. 'BFGS  ' )then
c       Limited memory BFGS scheme
        ig_type = ig_lbfgs
c       Write out warning that BFGS installation not clean:
        call FLGETIWR( IWR )
C        call BFGS_WARN( IWR )
        write(IWR,*) 'BFGS disabled - choose different minimization'
        call STOPXERR( 'BFGS disable' )
c
      elseif( gmeth .eq. 'conjug' .or. gmeth .eq. 'CONJUG' .or.
     $        gmeth .eq. 'cg    ' .or. gmeth .eq. 'CG    ' )then
c       Conjugate gradient method
        ig_type = ig_cg
        call STOPXERR( 'conjugate gradient scheme not coded yet' )
c
      elseif( gmeth(1:4) .eq. 'gtyp' .or. gmeth(1:4) .eq. 'GTYP' )then
c       *** development only *** Set igtype directly
        read(gmeth(5:6),'(i2)')  ig_type
c
      else
        call STOPXERR( 'gtypset - unknown geometry update method' )
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GUPDATE
c
c
      subroutine GUPDATE( ierrg, ratm0,
     $ natm, iforce, ndim,nsym,nsyma, rprim, rmatsym, naofsym,
     $ nslics,islics,islicats,vslics,    iatframe,
     $ ratmP,
     $ ratmg, ratmx, dratm0, dratmsy )
c---------------------------------------------------------------
c Purpose: take new geometry, check symmetry, and update the
c          master coordinate vector.
c
c Written: Peter A. Schultz, 18-May-2001, for v2.47
c
c Revision history:
c   1Aug17-PAS/2.68: bonds/slab constraints; unified SLICS
c   5Aug15-PAS/2.67: return error flag rather than stop upon failure
c  20Feb09-PAS/2.62: add options for vgfix atoms along vector
c  14Jun05-PAS/2.59: File units
c  11Feb02-PAS/2.54: install frame-constraint, better documentation
c  30Oct01-PAS/2.50: documentation typo
c  21Jun01-PAS/2.48: replace STOPs
c  18May01-PAS/2.47: extract from main routine
c---------------------------------------------------------------
c
cRRR add in stuff for coordinate de-projection
cRRR needed:  check max allowed angular motions
cRRR                project internal coordinates back to cartesian
cRRR                update cartesian positions in master coord array
c
c Notes:
c  The packed (by relax v. fixed) new coordinates are in ratmg().
c  They are unpacked here, and the difference from the original
c  coordinates computed.  That difference is checked for symmetry,
c  and then used to update the master coordinate array in ratm0().
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero= 0.d0,half=0.5d0 )
c Input/Output array:
      DIMENSION  ratm0(3,natm)
c Input arrays:
      DIMENSION  iforce(natm)
      DIMENSION  rprim(3,3), rmatsym(*), naofsym(*)
      DIMENSION  ratmg(*)
c
      DIMENSION  islics(4,*),islicats(*),vslics(3,*)
      DIMENSION  iatframe(3)
cRMV for slic
      DIMENSION  ratmP(3,natm)
c
c Scratch space:
      DIMENSION  ratmx(3,natm),dratm0(3,natm),dratmsy(3,natm)
c
c Local declarations:
      DIMENSION  dum9(3,3)
      DATA       dum9 / 9*0.d0 /
c Diagnostic level
      DATA  iprint / 2 /
c
c >>>> EXECUTABLE CODE:
c
      call FLGETIWR( IWR )
      ierrg = 0
c
      if( iprint.gt.0 )
     $ write(IWR,*) '>>>>> GUPDATE begins, nslics=', nslics
c
c Expand relaxed coordinates into full vector:
c
      irlx = 0
      do  iatm=1,natm
        if( iforce(iatm) .eq. 0 )then
c         Frozen atoms: Copy in old coordinates for unmodified atoms
          ratmx(1,iatm) = ratm0(1,iatm)
          ratmx(2,iatm) = ratm0(2,iatm)
          ratmx(3,iatm) = ratm0(3,iatm)
        elseif( iforce(iatm) .ne. 0 )then
c         Install new coordinates for relaxed atoms
          do  idf=1,3
            irlx = irlx + 1
            ratmx(idf,iatm) = ratmg(irlx)
          enddo
        endif
      enddo
c
c Compute change vector ...
c
      do 1000 islic=1,nslics
        islictyp = islics(1,islic)
        if( iprint.gt.1 ) 
     $   write(IWR,*) '  islic,islictyp=',islic,islictyp
c
        if(     islictyp.eq.1 .or. islictyp.eq.2 )then
c         SLIC projections - 1-fold sphere, 2-fold cylinder
          iatmproj = islics(2,islic)
          if( iprint.gt.1 ) write(IWR,*) 'SLIC/projection' 
          if( iprint.gt.2 )
     $    write(IWR,*) 'Active update slic-projected atom: ',iatmproj
          if( iprint.gt.3 )then
            write(IWR,*) 'old proj coords ',(ratmP(i,iatmproj),i=1,3)
            write(IWR,*) 'new proj coords ',(ratmx(i,iatmproj),i=1,3)
          endif
c****** DEV Should reverse cyl/sph order to 1-fold(sph) and 2-fold (cyl)
          if( islictyp.eq.2 )then
            write(IWR,*) 'SLIC/slsphb: de-project 1-fold spherical'
            call SLSPHB( IWR,natm, islics,islic,
     $                   ratm0,ratmx,ratmP )
          elseif( islictyp.eq.1 )then
            write(IWR,*) 'SLIC/slcylb: de-project 2-fold cylinder'
            call SLCYLB( IWR,natm, islics,islic,
     $                   ratm0,ratmx,ratmP )
          endif
c
        elseif( islictyp.eq.4 )then
c         BONDS - do "trivial" thing first, simply scale along bond
          if( iprint.gt.1 )  write(IWR,*) 'SLICS/BOND-length'
          call SLBONDFR( IWR, islic,islics,
     $     ratm0,ratmx,ratmP )
c
        elseif( islictyp.ge.5 .and. islictyp.le.8 )then
c       . VGFIX: purify the vector-projected atom geometry update:
          if( iprint.gt.1 ) 
     $     write(IWR,*) 'SLICS/VGFIX: slictyp=',islictyp
          nvgfix = islics(2,islic)
          if( nvgfix .gt. 0 )then
            call FLGETIWR( IWR )
cpas:       (vgfix should ultimately share SLIC data structures)
            isl1 = islics(3,islic)
            iatmvg1 = islicats(isl1)
            islicv = islics(4,islic)
c           Get center of mass motion along vector from lead vgfix atom
            dvec = zero
            do  id=1,3
C              dvec = dvec + vslics(id,islicv)*dratm0(id,iatmvg1)
              dvec = dvec + vslics(id,islicv)*
     $                     (ratmx(id,iatmvg1)-ratm0(id,iatmvg1))
            enddo
            if( iprint.gt.3 )
     $      write(IWR,*) 'VGFIX: purify coordinate update, dvec=',dvec
c
            do  ivgatm=isl1,isl1+nvgfix-1
              iatm = islicats(ivgatm)
              dveci = zero
              do  id=1,3
C                dveci = dveci + vslics(id,islicv)*dratm0(id,iatm)
                dveci = dveci + vslics(id,islicv)*
     $               (ratmx(id,iatm)-ratm0(id,iatm))
              enddo
c
              if( islictyp .eq. 7 )then
c               Constrain geometry change for atom to be along axis
                if( iprint.gt.3 )
     $          write(IWR,*) 'vector project R-update on atom',iatm
c               Geometry change is strictly motion along vector:
                do  id=1,3
C                  dratm0(id,iatm) = dveci*vslics(id,islicv)
                  ratmx(id,iatm) = ratm0(id,iatm) 
     $                           + dveci*vslics(id,islicv)
                enddo
              else
c               Allow motion normal to axis, adjust motion along axis
                if( islictyp .ne. 5 )then
c                 Install center-of-mass motion along vector
c                 Note that lead atom has cm-vec motion already installed,
c                  and that non-lead atom motion along vec had been suppressed.
                  dveci = dveci - dvec
                endif
                do  id=1,3
C                 dratm0(id,iatm) = dratm0(id,iatm)
                 ratmx(id,iatm) = ratmx(id,iatm)
     $                           - dveci*vslics(id,islicv)
                enddo
              endif
            enddo
c
          endif
c
        elseif( islictyp.eq.9 )then
c         SLINKY?LAYERS slab option
          if( iprint.gt.1 ) write(IWR,*) 'SLICS/SLINKY-LAYERS'
            call SLINKUPD( IWR, islic, islics,islicats,vslics,
     $         ratm0,ratmx,ratmP )
c         End SLICS options
        endif
 1000 continue
c
      do  iatm=1,natm
        dratm0(1,iatm) = ratmx(1,iatm) - ratm0(1,iatm)
        dratm0(2,iatm) = ratmx(2,iatm) - ratm0(2,iatm)
        dratm0(3,iatm) = ratmx(3,iatm) - ratm0(3,iatm)
      enddo
c
      do  iatm=1,natm
        dratmsy(1,iatm) = dratm0(1,iatm)
        dratmsy(2,iatm) = dratm0(2,iatm)
        dratmsy(3,iatm) = dratm0(3,iatm)
      enddo
c
c  ... and symmetrize the change vector
c
c (finished with ratmx and ratmg, and can use as scratch here)
      call SYMFRC( 0, 'move at', dum9, dratmsy, ratmx, ratmg,
     $ ndim, natm, nsyma, rprim, rmatsym, naofsym )
c
c Impose fixed-frame constraints on the change vector ...
c
      if( iprint.gt.1 .and. iatframe(1).ne.0 )
     $  write(IWR,*) 'GUPDATE/FRAME constraint applied'
      call FIXFRAME( natm, iatframe,
     $       ratm0,       dratmsy )
c -->        ratm(3a)-io  fatm(3a)-io
c
c  ... and update coordinates with sym'd change for new geometry:
c
      mxrd = 0
      rdmx = zero
      dratmax = zero
      idratmx = 0
      do  iatm=1,natm
c
c       Update coordinates with symmetrized update vectors
        ratm0(1,iatm) = ratm0(1,iatm) + dratmsy(1,iatm)
        ratm0(2,iatm) = ratm0(2,iatm) + dratmsy(2,iatm)
        ratm0(3,iatm) = ratm0(3,iatm) + dratmsy(3,iatm)
        dratmi = dratmsy(1,iatm)**2 + dratmsy(2,iatm)**2
     $         + dratmsy(3,iatm)**2
        if( dratmi .gt. dratmax )then
          dratmax = dratmi
          idratmx = iatm
        endif
c
c       Check deviation of symmetrized from raw update vectors
        rdiff = ( dratmsy(1,iatm) - dratm0(1,iatm) )**2
     $        + ( dratmsy(2,iatm) - dratm0(2,iatm) )**2
     $        + ( dratmsy(3,iatm) - dratm0(3,iatm) )**2
        if( rdiff.gt.rdmx )then
          rdmx = rdiff
          mxrd = iatm
        endif
c
      enddo
      dratmax = SQRT( dratmax )
      write(IWR,'(1x,a,i6,f12.6)')
     $  'GUPDATE: Largest relax: atom#, dr(au)=',idratmx,dratmax
c
      rdmx =  SQRT( rdmx )
      if( rdmx .gt. 0.0001 )then
        call FLGETIERR( IERRFL )
        write(IERRFL,*) '***** ERROR: Geometry update violates symmetry'
        write(IERRFL,*) '>>>>> Atom#, deviation distance:',mxrd,rdmx
        write(IERRFL,'(a/(1x,i4,3f15.8/5x,3f15.8))')
     $   'Change in coordinates, and symmetrized change vector:',
     $   ( iatm, dratm0(1,iatm), dratm0(2,iatm), dratm0(3,iatm),
     $           dratmsy(1,iatm),dratmsy(2,iatm),dratmsy(3,iatm),
     $     iatm=1,natm )
C        call STOPXERR( 'geom-sym/geometry update violates symmetry' )
        ierrg = 2
      endif
c
  999 continue
c
      if( iprint.gt.0 ) write(IWR,*) '<<<<< GUPDATE ends'
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GVECMAG
c
c
      subroutine GVECMAG( n1r,n2r,n3r,nptr,gprim, gvecsq )
c---------------------------------------------------------------
c Purpose: compute magnitudes of recip. lattice squared for use
c      in iteration phase solution of poisson's equation.
c
c Written by: Peter A. Schultz, for v2.00
c
c Revision history:
c  18Nov99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  gprim(3,3),gvecsq(nptr)
c local declarations:
      DIMENSION  g(3),g2(3),g3(3)
c
c >>>> EXECUTABLE CODE:
c
      f1 = DBLE( (n1r+2)/2 )
      f2 = DBLE( (n2r+2)/2 )
      f3 = DBLE( (n3r+2)/2 )
      do  i=1,3
        g3(i) = - f1*gprim(i,1) - f2*gprim(i,2) - f3*gprim(i,3)
      enddo
c
      nr = 0
      do 30 j3=1,n3r
        do  i=1,3
          g3(i) = g3(i) + gprim(i,3)
          g2(i) = g3(i)
        enddo
        do 20 j2=1,n2r
          do  i=1,3
            g2(i) = g2(i) + gprim(i,2)
            g(i)  = g2(i)
          enddo
          do 10 j1=1,n1r
            g(1) = g(1) + gprim(1,1)
            g(2) = g(2) + gprim(2,1)
            g(3) = g(3) + gprim(3,1)
            nr = nr + 1
            gvecsq(nr) = g(1)*g(1) + g(2)*g(2) + g(3)*g(3)
   10     continue
   20   continue
   30 continue
c
c    That's all Folks!
c
      RETURN
      END
c 
c***********************************************************************
c Purpose: Routines to write/read all k-resolved orbital matrices
c***********************************************************************
c
c For single-processor i/o:
c  H0WRIT - write full set of matrixes from processor
c  H0READ - read full set of matrices onto processor
c For k-parallel distrobuted matrices from master i/o:
c  H0WRITKP - write full set of matrices, from k-parallel matrices on k-mastyers
c  H0READKP - read full set of matrices, onto k-parallel matrices on k-mastyers
c  H0WRITKPDIST - write full set of matrices, from k-parallel fully distributed matrices
c  H0READKPDIST - read full set of matrices, onto k-parallel fully distributed matrices
c  KPDMATRD - read full set of matrices, onto k-parallel matrices on k-masters
c
c***********************************************************************
c Notes:
c  KPDMATRD looks redundant with H0READKP, should merge at some point
c  There is also a "KPDMATRD2" embedded in vslofrc, where the matrix needs the extra
c    reorganization into a full complex (rather than compact real/imaginary triangles).
c    The standard routines here cannot be used for vslofrc, but their existence
c    is noted here to prevent perhaps creating another redundancy in the future.
c***********************************************************************
c Revision history:
c   1Mat12-ACP&PAS/2.63: multi-matrix reads purged, k-parallel reads added
c***********************************************************************
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> H0WRIT
c
c
      subroutine H0WRIT( ifile, mat,nk, vij1 )
c---------------------------------------------------------------
c Purpose: write out a single k-resolved matrix to a disk file
c          The k-resolved matrix is resident on a single process
c
c Written: Peter A. Schultz, 3-October-2002
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c Input array:
      DIMENSION  vij1(mat,nk)
c
c >>>> EXECUTABLE CODE:
c
      do  k=1,nk
        call WRITBIG( ifile , mat, vij1(1,k) )
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> H0READ
c
c
      subroutine H0READ( ifile, mat,nk, vij1 )
c---------------------------------------------------------------
c Purpose: read out full k-resolved matrix from file
c          The k-resolved matrix is resident on a single process
c
c Written: Peter A. Schultz, 13-August-2005
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c Output array:
      DIMENSION  vij1(mat,nk)
c
c >>>> EXECUTABLE CODE:
c
      do  k=1,nk
        call READBIG( ifile , mat, vij1(1,k) )
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> H0WRITKP
c
c
      subroutine H0WRITKP( ifile, mat, nk, vij1 , vbuffer )
c---------------------------------------------------------------
c Purpose: Write k-resolved, k-distributed matrix
c          resident on k-point masters to master disk file.
c
c Written: Andrew C. Pineda, Mov. 2009-Mar-2010, for 2.63
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c Input array:
      DIMENSION  vij1(mat,*)
c Scratch array:
      DIMENSION  vbuffer(*)
c -->            vbuffer(mat)
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )

      call MPNODES_K( nprocs_k )
      call MPNODE_K( iproc_k )
      call MPNODE0_K( master_k )
c
c  If processor is not image master or k-point master, skip
      if( iproc .ne. master .and. iproc_k .ne. master_k ) goto 999
c
      ikloc = 1
      do  500 k=1,nk
c       Which processor is k-master, and has matrix for this k-point?
        call KPMASTER( nk, nprocs, k, kmasterpr )

c       If running task-parallel/serial
        if( nprocs .eq. nprocs_k ) kmasterpr = master
c
        if( iproc .eq. master )then
          if( iproc .eq. kmasterpr )then
c           The matrix is local to master, write directly
            call WRITBIG( ifile , mat, vij1(1,ikloc) )
            ikloc = ikloc + 1
          else
c           The master receives matrix from k-master that owns it, using tickets
            call MPSENDTICKET( kmasterpr, icomm )
            call MPRECVR8( kmasterpr, mat, vbuffer, icomm ) 
            call WRITBIG( ifile , mat, vbuffer )
          endif
        else
          if( iproc .eq. kmasterpr )then
c           This k-master sends its matrix to master, waiting for ticker
            call MPRECVTICKET( master, icomm )
            call MPSENDR8( master, mat, vij1(1,ikloc), icomm )
            ikloc = ikloc + 1
          endif
        endif
  500 continue
c
  999 continue
c
c    That's all, Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> H0READKP
c
c
      subroutine H0READKP( ifile, mat, nk, vij1, vbuffer )
c---------------------------------------------------------------
c Purpose: Read k-resolved matrix from master disk file,
c          and distribute to k-masters.
c
c Written: Andrew C. Pineda, Nov 2009-Mar2010, for 2.63
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c Input array:
      DIMENSION  vij1(mat,*)
c Scratch array:
      DIMENSION  vbuffer(*)
c -->            vbuffer(mat)
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
      call MPNODES_K( nprocs_k )
      call MPNODE_K( iproc_k )
      call MPNODE0_K( master_k )
c
c If processor is not image master or k-point master, skip
      if( iproc .ne. master .and. iproc_k .ne. master_k ) goto 999
c
      ikloc = 1
      do 500 k=1,nk
C       Which processor is k-master, and needs matrix for this k-point
        call KPMASTER( nk, nprocs, k, kmasterpr )

c       If running rask-parallel/serial
        if( nprocs .eq. nprocs_k ) kmasterpr = master
c
        if( iproc .eq. master )then
          if( iproc .eq. kmasterpr ) then
c           This matrix belongs on master, read in directly
            call READBIG( ifile, mat, vij1(1,ikloc) )
            ikloc = ikloc + 1
          else
c           The master sends this matrix to k-master that owns it
            call READBIG( ifile, mat, vbuffer )
            call MPSENDTICKET( kmasterpr, icomm )
            call MPSENDR8( kmasterpr, mat, vbuffer, icomm )
          endif
        else
          if( iproc .eq. kmasterpr )then
c           THe k-master receives the matrix it owns from master
            call MPRECVTICKET( master, icomm )
            call MPRECVR8( master, mat, vij1(1,ikloc), icomm )
            ikloc = ikloc + 1
          endif
        endif
  500 continue
c
  999 continue
c
c    That's all, Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> H0WRITKPDIST
c
c
      subroutine H0WRITKPDIST( ifile, mat, nk, vij1 , vbuffer )
c---------------------------------------------------------------
c Purpose: Write k-resolved,  k-distr=ibuted matrix,
c          distributed over each k-parallel group, to master disk file.
c
c Written: Andrew C. Pineda, 13 Nov 2009, for 2.63
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input array:
      DIMENSION  vij1(mat,*)
c Scratch array:
      DIMENSION  vbuffer(*)
c -->            vbuffer(mat)
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
      ikloc = 1
      do 500 k=1,nk
c       What range of processes is matrix(k) distributed over?
        call KPWHERE( nk, k, kproc_min, kproc_max )
c
        do 400  kproc=kproc_min,kproc_max, 1
          if( iproc .eq. master )then
            if( iproc .eq. kproc )then
c             This part of matrix(k) is local to master, write directly
              call WRITBIG( ifile , mat, vij1(1,ikloc) )
              ikloc = ikloc + 1
            else
c             Receive part of matrix(k) owned elsewhere, then write
              call MPSENDTICKET( kproc, icomm )
              call MPRECVR8( kproc, mat, vbuffer, icomm ) 
              call WRITBIG( ifile, mat, vbuffer )
            endif
          else
            if( iproc .eq. kproc )then
c             THis processor sends its part of matrix(k) to master to be written
              call MPRECVTICKET( master, icomm )
              call MPSENDR8( master, mat, vij1(1,ikloc), icomm )
              ikloc = ikloc + 1
            endif
          endif
  400   continue
c
  500 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> H0READKPDIST
c
c
      subroutine H0READKPDIST( ifile, mat, nk, vij1, vbuffer )
c---------------------------------------------------------------
c Purpose: Read k-resolved, k-distr=ibuted matrices from master file,
c          and distribute over all processes in each k-parallel group.
c
c Written: Andrew C. Pineda, 13 Nov 2009, for 2.63
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c Output array:
      DIMENSION  vij1(mat,*)
c Scratch array:
      DIMENSION  vbuffer(*)
c -->            vbuffer(mat)
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )

      ikloc = 1
      do 500  k=1,nk
c       What range of processes is matrix(k) distrobuted over?.
        call KPWHERE( nk, k, kproc_min, kproc_max )
c
        do 400 kproc=kproc_min,kproc_max,1
          if( iproc .eq. master )then
            if( iproc .eq. kproc )then
c             Data is local to master, read in directly
              call READBIG( ifile, mat, vij1(1,ikloc) )
              ikloc = ikloc + 1
            else
c             Send data to processoer that owns it
              call READBIG( ifile, mat, vbuffer )
              call MPSENDTICKET( kproc, icomm )
              call MPSENDR8( kproc, mat, vbuffer, icomm )
            endif
          else
            if( iproc .eq. kproc )then
c             Receive data fr
              call MPRECVTICKET( master, icomm ) 
              call MPRECVR8( master, mat, vij1(1,ikloc), icomm )
              ikloc = ikloc + 1
            endif
          endif
  400   continue
c
  500 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPDMATRD
c
c
      subroutine KPDMATRD( idmatfl, norb, ncplx, nk,nk0,nkloc,
     $ dmatrd,      dmatloc )                   
c ---> R8(mat)      R8(mat,nkloc)
c---------------------------------------------------------------
c Purpose: pack complex dmat from r8 into k-distributed-c8 for atdefct
c
c Written: Peter A. Schultz, 24-January-2009, for v2.62 (k-parallel)
c
c Revision history:
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c Input:
      INTEGER    idmatfl
      INTEGER    norb, ncplx,nk, nkloc,nk0
c Output:
      DOUBLE PRECISION  dmatloc
      DIMENSION  dmatloc(norb*norb,*)
c Scratch:
      DOUBLE PRECISION  dmatrd
      DIMENSION  dmatrd(*)
c
c Local declarations:
      INTEGER    nprocl ,iprocl ,masterl ,icomml
      INTEGER    nproc_k,iproc_k,master_k,icomm_k
      INTEGER    matrd,lenmsg, ik,ikloc, kmasterpr
c
c >>>> EXECUTABLE CODE:
c
c  Get Local MP info
      call MPNODES( nprocl )
      call MPNODE( iprocl )
      call MPNODE0( masterl )
      call MPCOMM( icomml )
c           
      call MPNODES_K( nproc_k )
      call MPNODE_K( iproc_k )
      call MPNODE0_K( master_k )
      call MPCOMM_K( icomm_k )
c       
      matrd = norb*norb
c
      ikloc = 0
      do 100 ik=1,nk
c
        lenmsg = matrd 
        call KPMASTER( nk, nprocl, ik, kmasterpr )
        if( nkloc .eq. nk ) kmasterpr = masterl
c       
        if( iprocl .eq. masterl )then
c         Image/local master reads dmat, and sends it to correct k-master proc
          call READBIG( idmatfl, matrd, dmatrd )
          if( kmasterpr .ne. masterl )then
c           This k-point goes off to kmasterpr
            call MPSENDR8( kmasterpr, lenmsg, dmatrd, icomml )
            goto 100
          endif 
        elseif( iprocl .eq. kmasterpr )then
c         Proc is master of this k-point, get dmatrd from masterl
          call MPRECVR8( masterl, lenmsg, dmatrd, icomml )
        else
c         This proc is not leading this k-point
          goto 100
        endif 
        ikloc = ikloc + 1
c
        if( nk.gt.1 )then
c         Only need to cache this if there is more than 1 k-point
c         (NB: _not_ nkloc.gt.1, master needs this space to store&read
          call DCOPY( matrd, dmatrd,1, dmatloc(1,ikloc),1 )
        endif
c
  100 continue
c
C      if( nproc_k .gt. 1 .and.  nkloc .gt. 0 )then
Cc       Send around each k-group its r8 dmat
C        lenmsg = nkloc*norb*norb
Cc       Actually, this bcast is moot, as only k-masters work in atdefect
C        if( nk.eq.1 )then
C          call MPBCAST8( master_k, lenmsg, dmatrd, icomm_k )
C        else
C          call MPBCAST8( master_k, lenmsg, dmatloc, icomm_k )
C        endif
C      endif
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> INDBOX
c
c
      subroutine INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $ ira0,irb0,irc0, idra,idrb,idrc )
c---------------------------------------------------------------
c Purpose: take box index and break into sub-indices
c
c Written: Peter A. Schultz, 23-April-1997, for v2.20 (boxes)
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  ndbox(2,2,3)
c
c >>>> EXECUTABLE CODE:
c
      nboxa1 = ndbox(1,1,1)
      nboxb1 = ndbox(1,1,2)
      nboxc1 = ndbox(1,1,3)
c The number of boxes in the three dimensions:
      nboxa = ndbox(1,1,1) + ndbox(2,1,1)
      nboxb = ndbox(1,1,2) + ndbox(2,1,2)
      nboxc = ndbox(1,1,3) + ndbox(2,1,3)
c
      iboxbc = (ibox-1)/nboxa
c The box index in the three dimensions, in grid of boxes
      iboxc = iboxbc/nboxb + 1
      iboxb = iboxbc - (iboxc-1)*nboxb + 1
      iboxa = ibox - iboxbc*nboxa
c
c Get box grid sides and corner index on global grid of points
      idra1 = ndbox(1,2,1)
      if( iboxa.le.nboxa1 )then
        idra = idra1
        ira0 = (iboxa-1)*idra1
      else
        idra = idra1 - 1
        ira0 = nboxa1*idra1 + (iboxa-nboxa1-1)*idra
      endif
c
      idrb1 = ndbox(1,2,2)
      if( iboxb.le.nboxb1 )then
        idrb = idrb1
        irb0 = (iboxb-1)*idrb1
      else
        idrb = idrb1 - 1
        irb0 = nboxb1*idrb1 + (iboxb-nboxb1-1)*idrb
      endif
c
      idrc1 = ndbox(1,2,3)
      if( iboxc.le.nboxc1 )then
        idrc = idrc1
        irc0 = (iboxc-1)*idrc1
      else
        idrc = idrc1 - 1
        irc0 = nboxc1*idrc1 + (iboxc-nboxc1-1)*idrc
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> INSETUP
c
c
      subroutine INSETUP( IWR, dokdefct,
     $ natm,ntyp, norb,norbd, nstbulk,nedefct,
     $ elchrg, nocc0k, do_spin,opt_spin,spinpol, nspin,elecno,spinfac,
     $ itypa, ioffa, norba, znuc )
c---------------------------------------------------------------
c Purpose: process some system information
c
c Written: Peter A. Schultz,  9-May-2000, for v2.45
c
c Revision history:
c  22May13-JEM/2.65: fix check of # electrons > zero
c  10Jan08-PAS/2.61: do not pass unused argument (elnumbr); spin-opt
c  15Feb05-PAS/2.59: defect k-sampling
c   8Aug02-PAS/2.53(f): elnum(spin)
c  28Jun02-PAS/2.53: write out number of basis functions
c  21Jun01-PAS/2.48: replace STOPs, clean a little
c   7Jun01-PAS/2.47: strip out nstd dimension check
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER( zero=0.d0, half=0.5d0, one=1.0d0, two=2.d0 )
c
c input/output arrays:
      LOGICAL    dokdefct
      DIMENSION  nstbulk(2), nedefct(2)
      DIMENSION  itypa(natm), ioffa(natm)
      DIMENSION  norba(ntyp)
      DIMENSION  znuc(ntyp)
      LOGICAL    do_spin, opt_spin
      DIMENSION  elecno(2)
c
c >>>> EXECUTABLE CODE:
c
 9020 format(1x,a,3f20.10)
C      any1ctr = .true.
C      anycore = .true.
C      anyxc1c = .true.
      norb = 0
      elnumbr = -elchrg
      do  iatm=1,natm
        ityp = itypa(iatm)
        ioffa(iatm) = norb
        norb = norb + norba(ityp)
        elnumbr = elnumbr + znuc(ityp)
C        if( lmx1ctr(ityp).ge.0 ) any1ctr = .true.
C        if( nrcor(ityp).ne.0 ) anycore = .true.
C        if( nfityp(ityp).gt.0 ) anyxc1c = .true.
      enddo
c
c Check, and set up electron counts
      write(IWR,9020)   '>>>> Total number of electrons=       ',elnumbr
C      if( ABS( elchrg ) .gt. elnumbr ) call STOPXERR( 'charge > # elec')
      if( elnumbr .lt. zero ) call STOPXERR( '# elec < 0')
      if( do_spin )then
        if( spinpol .gt. elnumbr ) call STOPXERR( 'spinpol > # elec' )
        nspin = 2
        spinfac = half
        elecno(1) = ( elnumbr + spinpol ) / two
        elecno(2) = elnumbr - elecno(1)
        elstate = (elecno(1) + 0.9999999d0)
        write(IWR,9020) '>>>> Spin!  Number of up/dn electrons=',elecno
        if( dokdefct )then
          nupstate = elstate
          eldown = (elecno(2) + 0.9999999d0)
          ndnstate = eldown
          nstbulk(1) = nupstate - nedefct(1)
          nstbulk(2) = ndnstate - nedefct(2)
          write(IWR,9020) 'Defect sampling, bulk states, up/dn=',nedefct
        endif
      else
        opt_spin = .false.
        nspin = 1
        spinfac = one
        elecno(1) = elnumbr
        elecno(2) = zero
        elstate = (elnumbr   + 1.9999999d0) / two
        if( dokdefct )then
          nupstate = elstate
          nstbulk(1) = nupstate - nedefct(1)
          write(IWR,9020) 'Defect sampling, bulk states=',nedefct(1)
        endif
      endif
c
c Minimum number of occupied states
      nocc0k = elstate
c
      write(IWR,*) '>>>> Minimum number of occupied states=',nocc0k
      write(IWR,*) '>>>> Number of basis functions, norb=',norb
      if( norb.gt.norbd )then
        write(IWR,*) '***** max norb dimension norbd =',norbd
        call STOPXERR( 'norb2big/norb is larger than dimension' )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> INTOBOX
c
c
      subroutine INTOBOX( n1r,n2r,n3r, vgrid, ndbox, vbox )
c---------------------------------------------------------------
c Purpose: copy grid field into boxes
c
c Written: Peter A. Schultz, 21-April-1997, for v2.20 (boxes)
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  vgrid(n1r,n2r,n3r), vbox(*)
      DIMENSION  ndbox(2,2,3)
c
c >>>> EXECUTABLE CODE:
c
      irbox = 0
c
      nboxa1 = ndbox(1,1,1)
      nboxb1 = ndbox(1,1,2)
      nboxc1 = ndbox(1,1,3)
      nboxa = ndbox(1,1,1) + ndbox(2,1,1)
      nboxb = ndbox(1,1,2) + ndbox(2,1,2)
      nboxc = ndbox(1,1,3) + ndbox(2,1,3)
      idra1 = ndbox(1,2,1)
      idrb1 = ndbox(1,2,2)
      idrc1 = ndbox(1,2,3)
c
      irc0 = 0
      idrc = idrc1
      do 103 iboxc=1,nboxc
        if( iboxc.gt.nboxc1 ) idrc = idrc1 - 1
c
        irb0 = 0
        idrb = idrb1
        do 102 iboxb=1,nboxb
          if( iboxb.gt.nboxb1 ) idrb = idrb1 - 1
c
          ira0 = 0
          idra = idra1
          do 101 iboxa=1,nboxa
            if( iboxa.gt.nboxa1 ) idra = idra1 - 1
c
            do  irc=irc0+1,irc0+idrc
              do  irb=irb0+1,irb0+idrb
                do  ira=ira0+1,ira0+idra
                  irbox = irbox + 1
                  vbox(irbox) = vgrid(ira,irb,irc)
                enddo
              enddo
            enddo
c
            ira0 = ira0 + idra
  101     continue
          irb0 = irb0 + idrb
  102   continue
        irc0 = irc0 + idrc
  103 continue
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FROMBOX
c
c
      ENTRY FROMBOX( n1r,n2r,n3r, vgrid, ndbox, vbox )
c---------------------------------------------------------------
c Purpose: get grid field from boxes
c
c Written: Peter A. Schultz, 21-April-1997, for v2.20
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c---------------------------------------------------------------
c
      irbox = 0
c
      nboxa1 = ndbox(1,1,1)
      nboxb1 = ndbox(1,1,2)
      nboxc1 = ndbox(1,1,3)
      nboxa = ndbox(1,1,1) + ndbox(2,1,1)
      nboxb = ndbox(1,1,2) + ndbox(2,1,2)
      nboxc = ndbox(1,1,3) + ndbox(2,1,3)
      idra1 = ndbox(1,2,1)
      idrb1 = ndbox(1,2,2)
      idrc1 = ndbox(1,2,3)
c
      irc0 = 0
      idrc = idrc1
      do 203 iboxc=1,nboxc
        if( iboxc.gt.nboxc1 ) idrc = idrc1 - 1
c
        irb0 = 0
        idrb = idrb1
        do 202 iboxb=1,nboxb
          if( iboxb.gt.nboxb1 ) idrb = idrb1 - 1
c
          ira0 = 0
          idra = idra1
          do 201 iboxa=1,nboxa
            if( iboxa.gt.nboxa1 ) idra = idra1 - 1
c
            do  irc=irc0+1,irc0+idrc
              do  irb=irb0+1,irb0+idrb
                do  ira=ira0+1,ira0+idra
                  irbox = irbox + 1
                  vgrid(ira,irb,irc) = vbox(irbox)
                enddo
              enddo
            enddo
c
            ira0 = ira0 + idra
  201     continue
          irb0 = irb0 + idrb
  202   continue
        irc0 = irc0 + idrc
  203 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> INTSUM
c
c
      subroutine INTSUM( selem, p,li,lj,ci,cj,alsum )
c---------------------------------------------------------------
c Purpose: computes quintuple sum of symmetry coefficients time
c          times the radial integrals for the overlap matrix
c
c Revision history:
c  10Dec99-PAS/2.42: cosmetic cleanup
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
      DIMENSION  p(3), ci(10),cj(10)
c local declarations:
      EQUIVALENCE  (nq(1),nq1),(nqmn(1),nqmn1),(psq(1),psq1)
      COMMON  /nqs/   nq1,nq2,nq3
      COMMON  /nqmns/ nqmn1,nqmn2,nqmn3
      COMMON  /psqs/  psq1,psq2,psq3
      DIMENSION  nq(3),nqmn(3),psq(3)
c
      LOGICAL    EVEN
      DIMENSION  apn(5),lang(10)
      DATA  lang / 0, 1,1,1, 2,2,2,2,2,2 /
c
      DIMENSION  ns(9),np(10,3),bpq(5,5),nqmin(5)
      DATA  ns / 1, 2,3,4, 5,6,7,9,10 /
      DATA  np / 0, 1,0,0, 1,0,1,2,0,0,
     $           0, 0,1,0, 1,1,0,0,2,0,
     $           0, 0,0,1, 0,1,1,0,0,2 /
      DATA  bpq / 1.d0, 0.d0, 0.d0, 0.d0, 0.d0,
     $            0.d0, 1.d0, 1.d0, 0.d0, 0.d0,
     $            0.d0, 0.d0, 1.d0, 3.d0, 3.d0,
     $            0.d0, 0.d0, 0.d0, 1.d0, 6.d0,
     $            0.d0, 0.d0, 0.d0, 0.d0, 1.d0 /
      DATA  nqmin / 1,2,2,3,3 /
c
      DATA  zero,four / 0.d0,4.d0 /
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      rtpid4 = rtpi/four
      apm = alsum*SQRT(alsum)
C      do  iq=1,lang(li)+lang(lj)+1
      do  iq=1,5
        apn(iq) = rtpid4/apm
        apm = apm*(alsum+alsum)
      enddo
      do  j=1,3
        psq(j) = p(j)*p(j)
      enddo
c
      nsimx = ns(li)
      nsjmx = ns(lj)
c
      selem = zero
      nsjmn = lj
      if( lj.eq.9 ) nsjmn = 8
c
      do 102 nsi=1,nsimx
        if( ci(nsi).eq.zero ) goto 102
c
        do 101 nsj=nsjmn,nsjmx
          if( cj(nsj).eq.zero ) goto 101
c
          pr1 = ci(nsi)*cj(nsj)
          do  j=1,3
            nq(j) = np(nsi,j) + np(nsj,j) + 1
            nqmn(j) = nqmin(nq(j))
            if( EVEN(nq(j)) ) pr1 = pr1*p(j)
          enddo
c     cdir$ novector
          do  iq1=nqmn1,nq1
            pr12 = pr1
            do  iq2=nqmn2,nq2
              pr123 = pr12
              do  iq3=nqmn3,nq3
                selem = selem + apn(iq1+iq2+iq3-2)*pr123*
     $           bpq(nq1,iq1)*bpq(nq2,iq2)*bpq(nq3,iq3)
                pr123 = pr123*psq3
              enddo
              pr12 = pr12*psq2
            enddo
            pr1 = pr1*psq1
          enddo
c     cdir$ vector
  101   continue
  102 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> INVERT
c
c
      subroutine INVERT( a,b,m, td,ad,bd, itmaxd )
c---------------------------------------------------------------
c Purpose: gaussian elimination
c
c Revision history:
c  21Jun01-PAS/2.48: replace STOPs
c  21Dec99-PAS/2.42: comsetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  a(itmaxd,itmaxd),b(itmaxd,itmaxd)
      DIMENSION  td(itmaxd),ad(itmaxd),bd(itmaxd)
c
      DATA  zero,one / 0.d0,1.d0 /
c
      n = m
      if( n.gt.itmaxd )then
        call STOPXERR( 'amat2big/matrix too large in INVERT' )
      endif
c
      do 10 i=1,n
        atmp = a(i,i)
        if( ABS( atmp ) .lt. 1.0d-08 )then
          call STOPXERR( 'inv0diag/zero diag matrix in INVERT' )
        endif
  10  continue
c
      if( n.eq.1 ) goto 300
c
      do 100 i=1,n
c
        do  j=1,n
          td(j) = a(j,i)/a(i,i)
        enddo
        td(i) = zero
c
        do  k=1,n
          bd(k) = b(i,k)
          ad(k) = a(i,k)
        enddo
c
        do  k=1,n
          do  j=1,n
            b(j,k) = b(j,k) - (td(j)*bd(k))
            a(j,k) = a(j,k) - (td(j)*ad(k))
          enddo
        enddo
c
  100 continue
c
      do  i=1,n
        do  j=1,n
          b(j,i) = b(j,i)/a(j,j)
        enddo
      enddo
c
      RETURN
c
  300 continue
      b(1,1) = one/a(1,1)
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> IONGPOT
c
c
      subroutine IONGPOT( ndim, esion, nglm,qlmcc,rchrg,
     $ rprim, n1r,n2r,n3r, hh, weight, ndbox,nbox,
     $ rhion, vion, r )
c---------------------------------------------------------------
c Purpose: Compute densities and potentials on grid from local
c          moment countercharge (LMCC) expressed as an array
c          of spherical gaussians (cluster or periodic).
c
c Written: Peter A. Schultz, 29-March-1999 (for v2.32)
c
c Revision history:
c  30Jun11-PAS/2.62: cosmetics
c   8Mar02-PAS/2.52: clean unused variables/literal constants d0
c---------------------------------------------------------------
c
c notes:
c   nglm    = number of Gaussians in LMCC array
c   qlmcc() = charge in each Gaussian
c   rchrg() = position of each Gaussian
c   esion   = self-energy of Gaussian LMCC array
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c input arrays:
      DIMENSION  rchrg(3,*), qlmcc(*)
c   grid generating primitive vector, and unit cell vectors
      DIMENSION  rprim(3,3), hh(3,3)
      DIMENSION  ndbox(2,2,3)
c input/output arrays:
      DIMENSION  rhion(*),vion(*)
c scratch arrays:
      DIMENSION  r(3,*)
c
c local declarations:
      LOGICAL    ingaus
      DIMENSION  r0box(3),boxctr(3)
      DIMENSION  origlm(3), t(3)
      DIMENSION  gg(3,3), r1(3),r2(3),r3(3),rl(3,27)
      DIMENSION  nro(3),nrx(3)
c
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
      DATA  three,four / 3.d0,4.d0 /
c  Exponent for Gaussian neutralizing charge:
      DATA  alfion / 0.30d0 /
c   Should be small enough to be well integrable on any reasonable
c   grid but large enough to be contained within any viable unit cell.
c
c >>>> EXECUTABLE CODE:
c
      esion = zero
c
c  Get range of this Gaussian on the grid:
      rngalf = SQRT( cutgrid/alfion )
      pi = four*ATAN( one )
      rtalf = SQRT( alfion )
      aldpi = alfion/pi
c
      do 1000 iglm=1,nglm
c
c Specify charge and position of this Gaussian:
        qgaus = qlmcc(iglm)
        do  j=1,3
          origlm(j) = rchrg(j,iglm)
        enddo
c
        gcoef = qgaus*aldpi* SQRT( aldpi )
        vcoef = two*qgaus
        vcoef0 = two*vcoef * SQRT( aldpi )
c
        if( ndim .eq. 0 )then
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c           We have a finite cluster/molecular system
c  I can use the raw parallelpiped unit cell as my local volume
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Find position of coordinate origin on the grid:
          do  j=1,3
            r1(j) = origlm(j)
          enddo
c
          call PROJLV( r1, hh(1,1), hh(1,2), hh(1,3), t )
          do  id=1,3
            nro(id) = ( t(id) + half + one )
          enddo
c
          call CROSS( hh(1,2),hh(1,3), gg(1,1) )
          call CROSS( hh(1,3),hh(1,1), gg(1,2) )
          call CROSS( hh(1,1),hh(1,2), gg(1,3) )
          do  j=1,3
            gmag = SQRT( gg(1,j)**2 + gg(2,j)**2 + gg(3,j)**2 )
            gg(1,j) = gg(1,j)/gmag
            gg(2,j) = gg(2,j)/gmag
            gg(3,j) = gg(3,j)/gmag
          enddo
c
          do  id=1,3
            rhh = ABS( gg(1,id)*hh(1,id) + gg(2,id)*hh(2,id)
     $               + gg(3,id)*hh(3,id) )
            rnx = rngalf/rhh + half
            nrx(id) = rnx
          enddo
c
          ia1 = nro(1) - nrx(1)
          ian = nro(1) + nrx(1)
          ib1 = nro(2) - nrx(2)
          ibn = nro(2) + nrx(2)
          ic1 = nro(3) - nrx(3)
          icn = nro(3) + nrx(3)
          if( ia1.lt.1 ) ia1 = 1
          if( ian.gt.n1r ) ian = n1r
          if( ib1.lt.1 ) ib1 = 1
          if( ibn.gt.n2r ) ibn = n2r
          if( ic1.lt.1 ) ic1 = 1
          if( icn.gt.n3r ) icn = n3r
c
          esiongr = zero
          irpot = 0
          do 200 ibox=1,nbox
c
c  Get basic box info
            call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $       ira0,irb0,irc0, idra,idrb,idrc )
            nrbox = idra*idrb*idrc
c
            iv0 = irpot
            irpot = irpot + nrbox
c
            ingaus = .true.
            if( (ira0+idra).lt.ia1 .or. ian.le.ira0 .or.
     $          (irb0+idrb).lt.ib1 .or. ibn.le.irb0 .or.
     $          (irc0+idrc).lt.ic1 .or. icn.le.irc0 ) ingaus = .false.
c
c  Generate coordinates
c
            call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
            r0box(1) = r0box(1) - origlm(1)
            r0box(2) = r0box(2) - origlm(2)
            r0box(3) = r0box(3) - origlm(3)
            call MKRBOX( hh,r0box, idra,idrb,idrc, r )
c
            if( ingaus )then
c             This box is within the gaussian range
              do 160 nr=1,nrbox
                rsq = r(1,nr)**2 + r(2,nr)**2 + r(3,nr)**2
                rmag = SQRT( rsq )
c
                rhion(iv0+nr) = rhion(iv0+nr) + gcoef*EXP( -alfion*rsq )
                if( rmag .gt. 1.d-4 )then
                  vion(iv0+nr) = vion(iv0+nr)
     $             + vcoef*DERF( rtalf*rmag ) / rmag
                else
                  vion(iv0+nr) = vion(iv0+nr)
     $             + vcoef0*(one-alfion*rsq/three)
                endif
                esiongr = esiongr + vion(iv0+nr)*rhion(iv0+nr)
  160         continue
            else
c             Should replace with asymptotic limit between:
              do 180 nr=1,nrbox
                rsq = r(1,nr)**2 + r(2,nr)**2 + r(3,nr)**2
                rmag = SQRT( rsq )
                vion(iv0+nr) = vion(iv0+nr) + vcoef / rmag
                esiongr = esiongr + vion(iv0+nr)*rhion(iv0+nr)
  180         continue
            endif
c
  200     continue
c
c Finalize grid self-energy term for background charge:
          esiongr = weight*esiongr/two
c
c Compute analytic self-energy term for background charge:
          esiong = qgaus*qgaus* SQRT( two*alfion/pi )
c Since put and take is on grid, use grid integral as self-energy:
c  (for reasonable grids and alpha, should not make a difference)
          esion = esiongr
c
        else
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     We have a system that is periodic in at least one dimension
c   Must use Wigner-Seitz cell as my local volume (in periodic dims)
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c  Note this code would work for ndim=0 cluster as well
c
          nla = 0
          nlb = 0
          nlc = 0
          if( ndim.gt.0 ) nla = 1
          if( ndim.gt.1 ) nlb = 1
          if( ndim.gt.2 ) nlc = 1
c use a nearest neighbor search to find longest range for which you do
c not need to check for residence within wigner-seitz cell
          rngws = 9.9d9
          il = 0
          do 343 kc=-nlc,nlc
            r3(1) = kc*rprim(1,3)
            r3(2) = kc*rprim(2,3)
            r3(3) = kc*rprim(3,3)
            do 342 kb=-nlb,nlb
              r2(1) = r3(1) + kb*rprim(1,2)
              r2(2) = r3(2) + kb*rprim(2,2)
              r2(3) = r3(3) + kb*rprim(3,2)
              do 341 ka=-nla,nla
                il = il + 1
                rl(1,il) = r2(1) + ka*rprim(1,1)
                rl(2,il) = r2(2) + ka*rprim(2,1)
                rl(3,il) = r2(3) + ka*rprim(3,1)
                rsqlat = rl(1,il)**2 + rl(2,il)**2 + rl(3,il)**2
                if( ka.eq.0 .and. kb.eq.0 .and. kc.eq.0 )then
                  ilo = il
                elseif( rsqlat.lt.rngws )then
                  rngws = rsqlat
                endif
  341         continue
  342       continue
  343     continue
          rngws = half*SQRT( rngws )
          rsqws = rngws**2
c
c  Put lattice vector zero to front of lattice vector list:
          nlnn = il
          rl(1,ilo) = rl(1,1)
          rl(2,ilo) = rl(2,1)
          rl(3,ilo) = rl(3,1)
          rl(1,1) = zero
          rl(2,1) = zero
          rl(3,1) = zero
c
          esiongr = zero
          irpot = 0
          do 400 ibox=1,nbox
c
c  Get basic box info
            call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $       ira0,irb0,irc0, idra,idrb,idrc )
            nrbox = idra*idrb*idrc
c
            iv0 = irpot
            irpot = irpot + nrbox
c
c  Generate coordinates
c
            call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
            r0box(1) = r0box(1) - origlm(1)
            r0box(2) = r0box(2) - origlm(2)
            r0box(3) = r0box(3) - origlm(3)
            call MKRBOX( hh,r0box, idra,idrb,idrc, r )
c
            ilmn = 1
c
            do 380 nr=1,nrbox
              rsq = (r(1,nr)+rl(1,ilmn))**2 + (r(2,nr)+rl(2,ilmn))**2
     $            + (r(3,nr)+rl(3,ilmn))**2
c
              if( rsq.gt.rsqws .and. nlnn.gt.1 )then
c               Check if some periodic lattice image of charge is closer
                do 360 il=1,nlnn
                  rsql = (r(1,nr)+rl(1,il))**2 + (r(2,nr)+rl(2,il))**2
     $                 + (r(3,nr)+rl(3,il))**2
                  if( rsql.lt.rsq )then
                    rsq = rsql
                    ilmn = il
                  endif
  360           continue
              endif
              rmag = SQRT( rsq )
c
              if( rmag.lt.rngalf )then
c               This point is within the gaussian countercharge range
                rhion(iv0+nr) = rhion(iv0+nr) + gcoef*EXP( -alfion*rsq )
                if( rmag .gt. 1.d-4 )then
                  vion(iv0+nr) = vion(iv0+nr)
     $             + vcoef*DERF( rtalf*rmag ) / rmag
                else
                  vion(iv0+nr) = vion(iv0+nr)
     $             + vcoef0*(one-alfion*rsq/three)
                endif
              else
c               Outside countercharge range, but still have potential
                vion(iv0+nr) = vion(iv0+nr) + vcoef / rmag
              endif
              esiongr = esiongr + vion(iv0+nr)*rhion(iv0+nr)
c
  380       continue
c
  400     continue
c
          esiongr = weight*esiongr/two
c
c Compute analytic self-energy term for background charge:
          esiong = qgaus*qgaus* SQRT( two*alfion/pi )
c Since put and take is on grid, use grid integral as self-energy:
c  (for reasonable grids and alpha, should not make a difference)
          esion = esiongr
c
        endif
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> IONPOT
c
c
      subroutine IONPOT( ion_opt, elchrg,dipole, ndim, esion, rchrg,
     $ rprim, n1r,n2r,n3r, hh, weight, ndbox,nbox,
     $ rhion, vion, r )
c---------------------------------------------------------------
c Purpose: Compute potential on grid from background charge
c          treating background countercharge as a gaussian, or
c          as a flat jellium countercharge (treating the potential
c          as either flat, or spherical)
c
c Written: Peter A. Schultz, 27-October-1998 (for v2.27)
c
c Revision history:
c  18May11-PAS/2.62: some cosmetics
c  14Jun05-PAS/2.59: File units
c   8Mar02-PAS/2.52: clean unused variables/literal constants d0
c  21Jun01-PAS/2.48: replace STOPs
c   8Feb00-PAS/2.42: bulk charge position bugfix
c  26Jul99-PAS/2.37: fix diagnostic/send out charge position right
c  29Mar99-PAS/2.32: adapt for dipole in non-cluster systems
c  11Jan99-PAS/2.32: charge states for non-cluster systems
c  15Dec98-PAS/2.30: put into boxes
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  (zero=0.d0,half=0.5d0,one=1.d0,two=2.d0)
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
c Input arrays:
      DIMENSION  dipole(3), rchrg(3)
c   grid generating primitive vector, and unit cell vectors
      DIMENSION  rprim(3,3), hh(3,3)
      DIMENSION  ndbox(2,2,3)
c Output arrays:
c   neutralizing density, and associated electrostatic potential:
      DIMENSION  rhion(*),vion(*)
c
c Scratch arrays:
      DIMENSION  r(3,*)
c
c Local declarations:
      DIMENSION  r0box(3),boxctr(3)
      DIMENSION  origlm(3), t(3)
c
      DATA  three,four / 3.d0,4.d0 /
c  Exponent for Gaussian neutralizing charge:
c   Should be small enough to be well integrable on any reasonable
c   grid but large enough to be contained within any viable unit cell.
      DATA  alfion / 0.30d0 /
      DATA  lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
      esion = zero
      nptr = n1r*n2r*n3r
c
c  We have a charged system, with a local point charge,
c  we wish to neutralized for input into the fft Poisson solver
c
      if( elchrg .eq. zero ) RETURN
c
      qgaus = -elchrg
c
c Set up some constants:
      pi = four*ATAN( one )
      fourpi = four*pi
      rtalf = SQRT( alfion )
      aldpi = alfion/pi
c
c Offset origin by enough to cancel the dipole, if requested:
c
c  First, set center of neutralizing charge at center of cell:
      do  j=1,3
        origlm(j) = rchrg(j)
      enddo
c
      dipsq = zero
      do  idim=1,3
        dipsq = dipsq + dipole(idim)**2
      enddo
c     Use a threshhold to skip dipole due to numerical noise
      if( ion_opt.gt.0 .and. dipsq.gt. 4.d-4 )then
c       Note you have to be careful of qgaus sign
        do  idim=1,3
          origlm(idim) = origlm(idim) + dipole(idim) / qgaus
        enddo
      endif
c
c  Branch to chosen method for Poisson solver for charge
c
      if( ion_opt.eq.0 )then
c
c       * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c             Jellium neutralizing charge, flat potential
c       * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c       I do not know how to explicitly evaluate the jellium self-energy
c       integral (need Madelung term, Ewald summations, etc), but I have
c       an empirically derived expression that converges to the correct
c       result.  Since this branch is superceded by the more rigorous
c       gaussian local moment countercharge scheme, no better is needed.
c       Someone who cares more about this can refine this in the future.
c
        call CROSS( rprim(1,2),rprim(1,3), t )
        vol = ABS( rprim(1,1)*t(1) + rprim(2,1)*t(2) + rprim(3,1)*t(3) )
        arg = 9*pi / (two*vol)
c
        essph = 0.8d0*qgaus*qgaus*arg**(one/three)
        esion = 0.925368d0 * essph
        sigma = qgaus/vol
c       Make potential so that grid integral matches self-energy term:
        vsigma = two*esion / qgaus
c
        esions = zero
        do  nr=1,nptr
          rhion(nr) = sigma
          vion(nr) = vsigma
          esions = esions + rhion(nr)*vion(nr)
        enddo
        esiongr = nptr*half*weight*sigma*vsigma
c
        esions = half*weight*esions
        rhoion = nptr*weight*sigma
        if( lstout .gt. 0 )then
          call FLGETIWR( IWR )
          write(IWR,'(a,4i10)')  'IONPOT: n1r,n2r,n3r=',n1r,n2r,n3r
          write(IWR,'(a,f20.8)') 'IONPOT: flat charge =',rhoion
          write(IWR,'(a,f20.8)') 'IONPOT: flat esion  =',esion
          write(IWR,'(a,f20.8)') 'IONPOT: flat esions =',esions
          write(IWR,'(a,f20.8)') 'IONPOT: flat esiongr=',esiongr
        endif
c
      elseif( IABS( ion_opt ) .eq. 1 )then
c
c       * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c           Flat background charge, sphere-shaped potential
c       * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c       Our unit cell is a parallelpiped.  To simplify the arithmetic,
c       assume the potential follows the functional form of a sphere.
c       Further, for computing the grid potential, I'm going to assume
c       that functional form for the potential is the functional form
c       for the inside of the sphere, even for points lying outside the
c       sphere radius (rather than the Z/r proper outside a sphere).
c       This is a cheaper calculation (no branching) and I can get away
c       with it because in a local Gaussian basis, the orbitals have no
c       amplitude there, which, further, explains why I do not care
c       about discontinuities in the potential at the boundaries.
c
        call CROSS( rprim(1,2),rprim(1,3), t )
        vol = ABS( rprim(1,1)*t(1) + rprim(2,1)*t(2) + rprim(3,1)*t(3) )
        arg = 9*pi / (two*vol)
c
c  For the self-energy correction, I use the functional form for a
c  sphere, and scale with an empirically derived factor to get the
c  proper energy correction for a cube unit cell.
        essph = 0.8d0*qgaus*qgaus*arg**(one/three)
        esion = 0.925368 * essph
c  Get sphere radius matching unit cell volume, density of background:
        rad = ( (three*vol) / (fourpi) ) ** (one/three)
        radsq = rad*rad
        sigma = qgaus/vol
c
c  Compute potential (Ry) based on distance from sphere origin:
        fac = fourpi*sigma
c
        irpot = 0
        do 150 ibox=1,nbox
c
c  Get basic box info
          call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $     ira0,irb0,irc0, idra,idrb,idrc )
          nrbox = idra*idrb*idrc
c
          iv0 = irpot
          irpot = irpot + nrbox
c
c  Generate coordinates
c
          call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
          r0box(1) = r0box(1) - origlm(1)
          r0box(2) = r0box(2) - origlm(2)
          r0box(3) = r0box(3) - origlm(3)
          call MKRBOX( hh,r0box, idra,idrb,idrc, r )
c
          do 140 nr=1,nrbox
            rsq = r(1,nr)**2 + r(2,nr)**2 + r(3,nr)**2
c
c  Flat neutralizing charge, and associated potential (sphere):
            rhion(iv0+nr) = sigma
            vion(iv0+nr) = fac*( radsq - rsq/three )
  140     continue
c
  150   continue
c
      elseif( IABS( ion_opt ) .eq. 2 )then
c
c       * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c               LMCC - 0D point charge - Gaussians
c       * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
CC Following  check doesn't work anymore with new conventions.
Cc  Find position of Gaussian LMCC origin on the grid:
C        do id=1,3
C          r1(id) = origlm(id)
C        enddo
Cc
C        call PROJLV( r1, hh(1,1), hh(1,2), hh(1,3), t )
C        do 160 id=1,3
C          if( t(id).lt.zero .and. id.gt.ndim )then
C            call STOPXERR( 'LMCC-ion/Gaussian ctr outside cell' )
C          endif
C  160   continue
c
c  Go ahead and compute single Gaussian LMCC:
c
        call IONGPOT( ndim, esion, 1,qgaus,origlm,
     $   rprim, n1r,n2r,n3r, hh, weight, ndbox,nbox,
     $   rhion, vion, r )
c
      else
c
c       * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                Not a valid charge treatment option
c       * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
        call STOPXERR( 'ionopt-x/bad ion treatment option/IONPOT' )
c
      endif
c
c  Send out new position of charge:
      do  j=1,3
        rchrg(j) = origlm(j)
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KCART
c
c
      subroutine KCART( ndim, rprim, nk,veckg,veck )
c---------------------------------------------------------------
c Purpose: convert k-vectors to Cartesian(KCART)/lattice(KLATT)
c
c Written: Peter A. Schultz, 6-August-2003, for v2.55a
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c
c Input: real space primitive vectors
      DIMENSION  rprim(3,3)
c
c Input<->Output: k-vectors: Cartesian and lattice units
      DIMENSION  veck(3,*),veckg(3,*)
c
c Local: k-point cell primitive vectors
      DIMENSION  gvec(3,3)
c
c >>>> EXECUTABLE CODE:
c
c If molecular, or just the gamma point, load zeroes:
      if( ndim.eq.0 .or.
     $    nk.eq.1 .and. veckg(1,1).eq.zero .and. veckg(2,1).eq.zero
     $            .and. veckg(3,1).eq.zero )then
        veck(1,1) = zero
        veck(2,1) = zero
        veck(3,1) = zero
        RETURN
      endif
c
c Generate reciprocal space primitive vectors:
      call KCELL( ndim, rprim, gvec )
c
c Expand Cartesian k-vectors from lattice-unit k-vectors:
      do  ik=1,nk
        call LVXPND( gvec, veck(1,ik), veckg(1,ik) )
      enddo
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KLATT
c
c
      entry KLATT( ndim, rprim, nk,veck,veckg )
c
c If molecular, or just the gamma point, load zeroes:
      if( ndim.eq.0 .or.
     $    nk.eq.1 .and. veck(1,1).eq.zero .and. veck(2,1).eq.zero
     $            .and. veck(3,1).eq.zero )then
        veckg(1,1) = zero
        veckg(2,1) = zero
        veckg(3,1) = zero
        RETURN
      endif
c
c Generate reciprocal space primitive vectors:
      call KCELL( ndim, rprim, gvec )
c
c Project Cartesian k-vectors onto primitive k-vectors lattice:
      do  ik=1,nk
        call LVPROJ( gvec, veck(1,ik), veckg(1,ik) )
      enddo
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KCELL
c
c
      subroutine KCELL( kdim, rprim, gprim )
c---------------------------------------------------------------
c Purpose: produce BZ cell vectors appropriate to dimensionality
c
c Written: Peter A. Schultz, 5-August-2003, for v2.55a
c
c Revision history:
c   4Sep08-PAS/2.61g: once more fix handedness of gprim vectors
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
c Input: real-space primitive vectors
      DIMENSION  rprim(3,3)
c Output: reciprocal space primitive vectors
      DIMENSION  gprim(3,3)
c Local:
      DIMENSION  rvec(3,3),gvec(3,3)
c
c >>>> EXECUTABLE CODE:
c
c Copy over the primitive vectors:
      do  jd=1,3
        do  i=1,3
          rvec(i,jd) = rprim(i,jd)
        enddo
      enddo
c
c Project out bad stuff from r-vectors:
      if( kdim.lt.3 )then
        do  idk=1,kdim
          dotkk = rvec(1,idk)*rvec(1,idk) + rvec(2,idk)*rvec(2,idk)
     $          + rvec(3,idk)*rvec(3,idk)
          do  idx=kdim+1,3
            fac = ( rvec(1,idk)*rvec(1,idx) + rvec(2,idk)*rvec(2,idx)
     $            + rvec(3,idk)*rvec(3,idx) ) / dotkk
            rvec(1,idx) = rvec(1,idx) - fac*rvec(1,idk)
          enddo
        enddo
      endif
c
c Produce reduced primitive reciprocal vectors:
      call CROSS( rvec(1,2),rvec(1,3), gvec(1,1) )
      call CROSS( rvec(1,3),rvec(1,1), gvec(1,2) )
      call CROSS( rvec(1,1),rvec(1,2), gvec(1,3) )
      vol = rvec(1,1)*gvec(1,1) + rvec(2,1)*gvec(2,1) +
     $      rvec(3,1)*gvec(3,1)
c
c Transfer the results to the output g-prim:
      twopi = pi + pi
      scfac = twopi / vol
      do  jd=1,3
        do  i=1,3
          gprim(i,jd) = scfac*gvec(i,jd)
        enddo
      enddo
      vol = ABS( vol )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KGRID
c
c
      subroutine KGRID( ndim, rprim,
     $ iktype, nka,nkb,nkc, nkfull, veck )
c---------------------------------------------------------------
c Purpose: produce a regular grid of k-points in full BZ
c
c Written: Peter A. Schultz, 19-October-1999, for v2.40
c
c Revision history:
c  14Jun05-PAS/2.59: File units
c  18Feb05-PAS/2.59: changes needed for closeshl or defect sampling
c  23Jul03-PAS/2.56: add special hexagonal offset grids
c   2Jul01-PAS/2.48: replace STOPs
c---------------------------------------------------------------
c
c This gets a little messy and makes bunches of assumptions that
c would be easy to violate, because it tries to take care of all
c sorts of special cases simultaneously.  It should work for all
c common cases and might fail if the user gets really cute.
c
c Variables:
c   ndim    - periodic dimensionality
c   rprim() - primitve lattice vectors
c   iktype  - type of kgrid
c           = 0,1,2,3 number of 0-offsets (rather than 1/2 offset)
c           = 20 1x1 hex grid offset to triangle center
c   nkU     - dimension of k-grid in dimensions
c   nkfull  - total number of k-points in grid
c   veck(3,*) - resulting k-point grid
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
c Input: primitive lattice vectors
      DIMENSION  rprim(3,3)
c Output: k-vectors
      DIMENSION  veck(3,*)
c Local declarations:
      DIMENSION  nkx(3), nkt(3)
      DIMENSION  rvec(3,3), gvec(3,3)
      DIMENSION  vk0(3), dk(3,3)
      DATA  zero,one,two,three / 0.d0,1.d0,2.d0,3.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Determine type of k-grid to generate:
      if( iktype.ge.0 .and. iktype.le.3 )then
c       Number of offsets to set to 0 ( rather than 1/2 )
        n0k = iktype
      elseif( iktype.eq.20 )then
c       Hex grid, offset of 1/3 (center of triangle)
        n0k = 2
      else
c       Default: offset to body-center ( all 1/2 )
        n0k = 0
      endif
c
c Load k-dimensions, setting non-periodic directions to gamma:
      nkx(1) = nka
      nkx(2) = nkb
      nkx(3) = nkc
      do  jd=ndim+1,3
        nkx(jd) = 0
      enddo
c
c Check for gamma point calculation:
      if( nka.eq.0 .and. nkb.eq.0 .and. nkc.eq.0 )then
c       Trivial gamma, point, load and exit
        nkfull = 1
        veck(1,1) = zero
        veck(2,1) = zero
        veck(3,1) = zero
        RETURN
      endif
c
c Determine k-space dimensionality (number of non-zero dims)
c   kdim = number of non-zero dimensions
c   mdim = index of last non-zero dimension
      kdim = 0
      do  jd=1,3
        nkt(jd) = nkx(jd)
        if( nkx(jd).ne.0 )then
          kdim = kdim + 1
          mdim = jd
        endif
      enddo
c
c At this point have:
c  ndim = dimension of problem (molecule=0, ... , 3=bulk)
c  kdim = number of non-zero dimensions of k-grid
c  mdim = dimension index of last non-zero dimension of grid
c
c We have choices how to generate the k-grid, corresponding to:
c  First, how to set the effective dimension of the problem.
c   (1) Choose the actual problem dimension: ndim
c       -straightforward
c   (2) Choose the default k-space dimension: mdim
c       - also straightforward, leaving the problem in the
c         "standard" state of periodic dimension first, simply
c         reducing the k-grid dimension from the r-space dimension
c   (3) Choose the number of non-zero k-dims: kdim
c       - perhaps the "true" dimension of the grid and is likely
c         the closest thing to an "ideal" sample.  However, since
c         it is not standard order (mixed periodic/non-periodic)
c         it requires reordering and careful bookkeeping.
c  Second, how to use the reduced dimension:
c   (a) Use full 3-dimensional R-vectors to get G-vec
c       - straightforward
c   (b) Use reduced dimension space, i.e., assuming
c       non-periodic dimension are normal to periodic dimensions.
c       - some modest effort to created "reduced" R-vectors.
c
c We will choose (1)(b). (Specified by setting kdim=ndim)
        kdim = ndim
c   We choose (b), because non-periodic directions should NOT
c   be used in generating the reciprocal space.  Note this only
c   has an effect if non-periodic R-vectors are not orthogonal
c   to periodic vectors, which should not usually happen.
c   We choose (1) because otherwise we run into problems in
c   other places in the code, i.e. cell-optimization, which
c   must do transformations of the G-vectors, but will not
c   have knowledge of the reduced dimension and thereby
c   cause errors unless this information (kdim,mdim) is
c   propagated.  Sending this information around is prone
c   to coding errors and therefore we will skip it. <sigh>
c
c Standard usage:
      call DCOPY( 9, rprim,1, rvec,1 )
c
      if( mdim.gt.kdim )then
c       Have non-periodics between/before periodics, reorder vecs
        if( n0k .ne. 0 )then
          call STOPXERR( 'kgrid dims and offsets incompatible' )
        endif
        jdk = 0
        jdx = kdim
        do  jd=1,3
          if( nkt(jd).ne.0 )then
            jdk = jdk + 1
            kd = jdk
          else
            jdx = jdx + 1
            kd = jdx
          endif
          nkx(kd) = nkt(jd)
          rvec(1,kd) = rprim(1,jd)
          rvec(2,kd) = rprim(2,jd)
          rvec(3,kd) = rprim(3,jd)
        enddo
      endif
c
c Produce reduced primitive reciprocal lattice vectors:
      call KCELL( kdim, rvec, gvec )
c
c Define k-point intervals:
      do  jd=1,3
        if( nkx(jd).ne.0 )then
          nkt(jd) = nkx(jd)
        else
          nkt(jd) = 1
        endif
        do  i=1,3
          dk(i,jd) = gvec(i,jd)/ DBLE( nkt(jd) )
        enddo
      enddo
c
c Define k-grid offset:
      vk0(1) = zero
      vk0(2) = zero
      vk0(3) = zero
      if( iktype.ge.0 .and. iktype.lt.3 )then
c       Simple 1/2 (body-center) offset
        do  jd=1,kdim
          if( jd.gt.n0k .and. nkx(jd).ne.0 )then
            do  i=1,3
              vk0(i) = vk0(i) + dk(i,jd)/two
            enddo
          endif
        enddo
      elseif( iktype.eq.20 )then
c       2D Hex 1/3 offset
c       First, another idiot check:
        aklen = SQRT( dk(1,1)**2 + dk(2,1)**2 + dk(3,1)**2 )
        bklen = SQRT( dk(1,2)**2 + dk(2,2)**2 + dk(3,2)**2 )
        adotb = dk(1,1)*dk(1,2) + dk(2,1)*dk(2,2) + dk(3,1)*dk(3,2)
        diflen = ABS( one - bklen/aklen )
        difdot = ABS( one - two*ABS( adotb ) / (aklen*bklen) )
        if( diflen.gt.(1.d-6) .or. difdot.gt.(1.d-6) )then
          call FLGETIERR( IERRFL )
          write(IERRFL,'(a,3f16.8)') 'dkA=',(dk(i,1),i=1,3)
          write(IERRFL,'(a,3f16.8)') 'dkB=',(dk(i,2),i=1,3)
          write(IERRFL,'(a,3f16.8)') 'A,B,A.B=',aklen,bklen,adotb
          write(IERRFL,'(a,3f16.8)') 'scaled=',one,bklen/aklen,
     $     adotb/(aklen*bklen)
          write(IERRFL,'(a,3f16.8)') 'diflen,difdot=',diflen,difdot
          call STOPXERR( 'KGRID: hex k-grid vectors are not hex' )
        endif
        bsign = one
        if( adotb.lt.zero ) bsign = -one
        do  i=1,3
          vk0(i) = ( dk(i,1) + bsign*dk(i,2) ) / three
        enddo
        jd = 3
        if(  jd.gt.n0k .and. nkx(jd).ne.0 )then
          do  i=1,3
            vk0(i) = vk0(i) + dk(i,3)/two
          enddo
        endif
      endif
c
c Generate resulting k-grid:
      nkfull = nkt(1)*nkt(2)*nkt(3)
      call MKRBOX( dk, vk0, nkt(1),nkt(2),nkt(3), veck )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KGAMMA
c
c
      subroutine KGAMMA( IWR, ikgamma, nk,nkd,wtk, veck,veckg )
c---------------------------------------------------------------
c Purpose: if missing, add the gamma-pt to the k-sample
c Written: P.A. Schultz, 14Feb05, for 2.59/defect k-sampling
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, one=1.d0 )
c
c Input/Output: k-vectors
      DIMENSION  wtk(*)
      DIMENSION  veck(3,*), veckg(3,*)
c
c >>>> EXECUTABLE CODE:
c
c First, try to find the gamma pt in the list:
      do 100 ik=1,nk
        veckmag = veck(1,ik)**2 + veck(2,ik)**2 + veck(3,ik)**3
        if( veckmag .eq. zero )then
          ikgamma = ik
          if( IWR.gt.0 )
     $    write(IWR,*) 'KGAMMA: found gamma-pt at k=',ikgam
          goto 900
        endif
  100 continue
c
      if( IWR.gt.0 )
     $write(IWR,*) 'KGAMMA: will add gamma-pt to k-sample'
      nk = nk + 1
      if( nk .gt. nkd ) call STOPXERR( 'too many kpts' )
c
c Load zero-weighted gamma pt at end of list
      ikgam = nk
c     Denote special point outsider status by sending
c      defect k-point as negative
      ikgamma = -ikgam
      wtk(ikgam) = one
      do  i=1,3
        veck(i,ikgam) = zero
        veckg(i,ikgam) = zero
      enddo
c
  900 continue
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KWRITE
c
c
      subroutine KWRITE( IWR, ndim, rprim, nk,nk0,wtk,wtkscal,veckg )
c---------------------------------------------------------------
c Purpose: write out k-vectors to output file
c
c Written: Peter A. Schultz, 6-August-2003, for v2.55a
c
c Revision history:
c   8Aug03-PAS/2.56: use LVPROJ instead of PROJLV
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input: real space primitive vectors; k-point weights, vectors
      DIMENSION  rprim(3,3)
      DIMENSION  wtk(*), veckg(3,*)
c Local:
      DIMENSION  gvec(3,3), vkr(3),vkg(3)
      DATA  zero / 0.d0 /
      DATA  lstout / 2 /
c
c >>>> EXECUTABLE CODE:
c
c If molecular, or just the gamma point, skip this:
      if( ndim.eq.0 ) RETURN
      if( nk.eq.1 .and. veckg(1,1).eq.zero .and. veckg(2,1).eq.zero
     $            .and. veckg(3,1).eq.zero ) RETURN
c
      if( IWR.le.0 ) RETURN
c
      if( lstout.gt.0 )then
c       Get reciprocal space primitive vectors:
        call KCELL( ndim, rprim, gvec )
c
c       Summarize output k-point set:
        write(IWR,*) 'IBZ Bloch vectors, total=',nk,nk0
        write(IWR,9101)
 9101   format(1x,'  K# ',2x,4x,'wt',4x,2x,9x,'k-vector:(r);(g)')
 9102   format(1x,  i5,   2x,  f10.6,   2x, 3f10.6, 2x,3f8.4 )
        if( lstout.gt.1 )then
          do  k=1,nk
            vkg(1) = veckg(1,k)
            vkg(2) = veckg(2,k)
            vkg(3) = veckg(3,k)
            call LVXPND( gvec, vkr, vkg )
            write(IWR,9102)  k, wtkscal*wtk(k), vkr, vkg
          enddo
        endif
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LATVEC
c
c
      subroutine LATVEC( ndim, nlatd,nlat,nlat1c,nlat2c,
     $ natm,ntyp,nshld,nald, itypa, numshl,nala,ala,
     $ ratm,rprim, rlat, rl1c,rl2c )
c---------------------------------------------------------------
c Purpose: computes lattice vectors so hamiltonian is converged
c     to degree specified by "cutgwfn", given longest gaussians
c
c Written: Peter A. Schultz, 8-November-1994, based on PJF's
c  code, which in turn was based on appelbaum/hamann lcao code
c
c Revision history:
c  14Jun05-PAS/2.59: File units, with a fix
c  21Jun01-PAS/2.48: replace STOPs
c  27Mar00-PAS/2.43: separate out calculations of Bloch phases
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  24Apr97-PAS/2.17: naming conventions
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp)
      DIMENSION  ratm(3,natm),rprim(3,3)
c output array:
      DIMENSION  rlat(3,*)
c scratch arrays:
      DIMENSION  rl1c(*), rl2c(*)
c local declarations:
      DIMENSION  g(3,3),rl(3),rcm(3),ruc(3), nnp(3),rt(3),rt1c(3)
      LOGICAL    sorted
      DATA  zero,half / 0.d0,0.5d0 /
      DATA  lstout / 1 /
c
c >>>> EXECUTABLE CODE:
c
      almin = ala(1,1,1)
      do  ityp=1,ntyp
        do  ishl=1,numshl(ityp)
          do  ial=1,nala(ishl,ityp)
            if( ala(ial,ishl,ityp).lt.almin ) almin = ala(ial,ishl,ityp)
          enddo
        enddo
      enddo
c
c Compute linear independent length of each primitive lattice vector
c   (consider the effect of reduced dimensionality)
c
      call CROSS( rprim(1,1),rprim(1,2), g(1,3) )
      call CROSS( rprim(1,3),rprim(1,1), g(1,2) )
      call CROSS( rprim(1,2),rprim(1,3), g(1,1) )
      if( ndim.lt.3 )then
        call CROSS( g(1,3),rprim(1,1), g(1,2) )
        call CROSS( rprim(1,2),g(1,3), g(1,1) )
        if( ndim.lt.2 ) call CROSS( g(1,2),g(1,3), g(1,1) )
      endif
      do  idim=1,3
        gmag = SQRT(g(1,idim)**2+g(2,idim)**2+g(3,idim)**2)
        g(1,idim) = g(1,idim)/gmag
        g(2,idim) = g(2,idim)/gmag
        g(3,idim) = g(3,idim)/gmag
        rl(idim) = g(1,idim)*rprim(1,idim) + g(2,idim)*rprim(2,idim)
     $           + g(3,idim)*rprim(3,idim)
        rl(idim) = ABS(rl(idim))
      enddo
c
c Get center-of-"existence" of center coordinates:
      atmn = DBLE(natm)
      do  j=1,3
        ruc(j) = half*( rprim(j,1) + rprim(j,2) + rprim(j,3) )
        rcm(j) = zero
        do  iatm=1,natm
          rcm(j) = rcm(j) + ratm(j,iatm)
        enddo
        rcm(j) = rcm(j)/atmn
      enddo
c Get radius of a sphere/circle/line sure to contain all atoms:
      radatm = zero
      do  iatm=1,natm
        rt(1) = rcm(1) - ratm(1,iatm)
        rt(2) = rcm(2) - ratm(2,iatm)
        rt(3) = rcm(3) - ratm(3,iatm)
        do  idim=ndim+1,3
          cg = g(1,idim)*rt(1) + g(2,idim)*rt(2) + g(3,idim)*rt(3)
          rt(1) = rt(1) - cg*g(1,idim)
          rt(2) = rt(2) - cg*g(2,idim)
          rt(3) = rt(3) - cg*g(3,idim)
        enddo
        rmag = SQRT( rt(1)**2 + rt(2)**2 + rt(3)**2 )
        if( rmag.gt.radatm ) radatm = rmag
      enddo
c Bias center-of-mass:
      do  idim=1,ndim
        do  j=1,3
          rcm(j) = rcm(j) - 0.001*rprim(j,idim)
        enddo
      enddo
c
c find longest diagonal within unit cell
      raduc = zero
      if( ndim.eq.1 )then
        raduc = half*SQRT(rprim(1,1)**2+rprim(2,1)**2+rprim(3,1)**2)
      elseif( ndim.eq.2 )then
        rlp = SQRT( (rprim(1,1)+rprim(1,2))**2 +
     $   (rprim(2,1)+rprim(2,2))**2 + (rprim(3,1)+rprim(3,2))**2 )
        rlm = SQRT( (rprim(1,1)-rprim(1,2))**2 +
     $   (rprim(2,1)-rprim(2,2))**2 + (rprim(3,1)-rprim(3,2))**2 )
        raduc = half* MAX( rlp, rlm )
      elseif( ndim.eq.3 )then
        rt(1) = half*( rprim(1,1) + rprim(1,2) + rprim(1,3) )
        rt(2) = half*( rprim(2,1) + rprim(2,2) + rprim(2,3) )
        rt(3) = half*( rprim(3,1) + rprim(3,2) + rprim(3,3) )
        sqpp = zero
        sqpm = zero
        sqmp = zero
        sqmm = zero
        do  j=1,3
          sqpp = sqpp +   rt(j)**2
          sqpm = sqpm + ( rt(j) - rprim(j,3) )**2
          sqmp = sqmp + ( rt(j) - rprim(j,2) )**2
          sqmm = sqmm + ( rt(j) - rprim(j,2) - rprim(j,3) )**2
        enddo
        raduc = MAX( sqpp, sqpm, sqmp, sqmm )
        raduc = SQRT(raduc)
      endif
c
      rang1c = SQRT( cutgrid / (almin+almin) )
      rang2c = 2*SQRT( cutslow / (almin+almin) )
      r1cut = rang1c + radatm + raduc
      r2cut = rang2c + radatm + radatm
      l1 = 0
      l2 = 0
      l3 = 0
      goto (70,71,72,73), ndim+1
   73 l3 = (rang2c/rl(3)) + 1
   72 l2 = (rang2c/rl(2)) + 1
   71 l1 = (rang2c/rl(1)) + 1
   70 continue
c
c  Form trial linear combinations of primitive vectors
c
      ilat = 0
      do 103 i3=-l3,l3
        nnp(3) = i3
        do 102 i2=-l2,l2
          nnp(2) = i2
          do 101 i1=-l1,l1
            nnp(1) = i1
c
            do  j=1,3
              rt(j) = zero
            enddo
            do  j=1,3
              do  i=1,ndim
                rt(j) = rt(j) + rprim(j,i)* DBLE(nnp(i))
              enddo
            enddo
c bias results by center-of-mass for 1c range
            do  j=1,3
              rt1c(j) = rt(j) + rcm(j) - ruc(j)
            enddo
c
            r2c = SQRT(rt(1)**2+rt(2)**2+rt(3)**2)
            r1c = SQRT(rt1c(1)**2+rt1c(2)**2+rt1c(3)**2)
c this will force primary unit cell to the front
            if( i1.eq.0 .and. i2.eq.0 .and. i3.eq.0 ) r1c = -1.
            if( r1c.gt.r1cut .and. r2c.gt.r2cut ) goto 101
c
            ilat = ilat + 1
            if( ilat.gt.nlatd )then
c too many vectors, find out how many total before stopping
              call FLGETIERR( IERRFL )
              write(IERRFL,9100)  ilat,r2c,r2cut
 9100         format(' r2c(',i4,')=',f13.6,' while r2cut=',f13.6)
            else
c "rl1c" holds 1c rlat magnitudes, "rl2c" 2c mags:
              rl1c(ilat) = r1c
              rl2c(ilat) = r2c
              rlat(1,ilat) = rt(1)
              rlat(2,ilat) = rt(2)
              rlat(3,ilat) = rt(3)
            endif
c
  101     continue
  102   continue
  103 continue
      if( ilat.gt.nlatd )then
        write(IERRFL,*)'LATVEC: nlat= ',ilat,' exceeds max nlatd=',nlatd
        call STOPXERR( 'nlat-dim/exceeded max num of lattice vectors' )
      endif
      nlat = ilat
      nlat2c = nlat
c
c  Order lattice vectors wrt magnitude
c
      nlat1c = 0
  200 sorted = .true.
      do 220 ilat=nlat1c+1,nlat-1
        if( rl1c(ilat).le.rl1c(ilat+1) ) goto 220
c
        x = rl1c(ilat)
        rl1c(ilat) = rl1c(ilat+1)
        rl1c(ilat+1) = x
        x = rl2c(ilat)
        rl2c(ilat) = rl2c(ilat+1)
        rl2c(ilat+1) = x
        do  j=1,3
          rt(j) = rlat(j,ilat)
          rlat(j,ilat) = rlat(j,ilat+1)
          rlat(j,ilat+1) = rt(j)
        enddo
        sorted = .false.
  220 continue
      if( .not. sorted ) goto 200
c
      if( nlat1c.eq.0 )then
c       sort again, this time over 2c ranges
        do  ilat=1,nlat
          if( rl1c(ilat).le.r1cut ) nlat1c = ilat
          x = rl1c(ilat)
          rl1c(ilat) = rl2c(ilat)
          rl2c(ilat) = x
        enddo
        goto 200
      endif
c
      if( lstout.gt.0 )then
        call FLGETIWR( IWR )
        write(IWR,*) ' '
        write(IWR,*) 'LATVEC: nlat1c,nlat2c,nlat =',nlat1c,nlat2c,nlat
        if( lstout.gt.1 )then
          nlatprt = MIN( 160, nlat )
          write(IWR,9260)
 9260     format(2x,'ilat',10x,'rlat length',23x,'( lattice vector )')
 9261     format(1x,  i4,  2x,      2f12.6,5x,'('  ,3(f12.6,1x),    ')')
          do  ilat=1,nlatprt
            write(IWR,9261)  ilat, rl1c(ilat),rl2c(ilat),
     $       (rlat(i,ilat),i=1,3)
          enddo
          if( nlat.gt.nlatprt )then
            write(IWR,9261)  nlat, rl1c(ilat),rl2c(ilat),
     $       (rlat(i,ilat),i=1,3)
          endif
        endif
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LMCC
c
c
      subroutine LMCC( IWR, igrdref,  lvlout, lmcc_on, ion_opt,
     $ esion,vacplus, eslmref, elchrg, ndim,nsym,
     $ dolvatm, rprim,rscale, orig,rsym,origws,rchrg, rmatsym,
     $ n1r,n2r,n3r,nptr, hh,weight, ndbox,nbox,
     $ wk1,wk2,wk3,wk4,wk5 )
c---------------------------------------------------------------
c Purpose: generate grid densities and potentials for the
c          local moment countercharge (LMCC) treatment of
c          supercell electrostatics.
c
c Written: Peter A. Schultz, 17-May-2001 for v2.47
c
c Revision history:
c  13May11-PAS/2.62: prepping inserting of 2D slab charges
c  15Feb11-PAS/2.62: extract slab dipole vacuum potential
c  10Sep05-PAS/2.59: chemical potential perspective diagnostics
c   4Oct03-PAS/2.57: set/require reference be non-spin; cosmetics
c   5May03-PAS/2.55: fix LMCC + spin bug (up+dn delrho)
c---------------------------------------------------------------
c
c Notes:
c  Implements the method for treating supercell moments described
c  in:  P.A. Schultz,  PRB 60, 1551 (1999);  PRL 84, 1942 (2000).
c
c on input
c   wk1 contains the electron density (with moments) on the grid
c       and is destroyed
c on output
c   wk2 contains the lmcc density on grid
c   wk3 contains the lmcc potential on grid
c Grid fields are presumed sorted into boxes, and returned boxed
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, half=0.5d0 )
c Input arrays:
      LOGICAL    lmcc_on, dolvatm
      DIMENSION  rprim(3,3),rscale(*)
      DIMENSION  orig(3),rsym(3),origws(3),rchrg(*)
      DIMENSION  rmatsym(*)
      DIMENSION  hh(3,3), ndbox(2,2,3)
c
c big arrays:
      DIMENSION  wk1(nptr),wk2(nptr),wk3(nptr),wk4(nptr),wk5(nptr)
c
c Local declarations:
      DIMENSION  dipole(3), rdipole(3)
      DIMENSION  dipref(3), rdipref(3)
      DIMENSION  vect(3), vec0(3)
      DIMENSION  zchrglm(3), zchrgcc(3)
cxxx
      LOGICAL    debugdl
c
      DATA  vec0 / 0.d0,0.d0,0.d0 /
      DATA  toev / 13.605805d0 /
c
c >>>> EXECUTABLE CODE:
c
cxxx:
      debugdl = .false.
      if( debugdl )then
        write(IWR,*) 'DBG/LMCC: esion, dble-layer self-energy - clean'
      endif
      lmcc_on = .false.
      esion = zero
      vacplus = zero
      eslmref = zero
c  Format for diagnostics:
 9020 format(1x,a,3f20.10)
cxxx:
 9013 format(1x,a,6f15.6)
c
c Start by taking moment of total density
c
      call MOMENT( IWR, elchrg, dipole,rdipole, ndim,
     $ origws, rprim, n1r,n2r,n3r, hh, weight, ndbox,nbox,
     $ wk1,    wk4 )
cxxx:start
      if( debugdl )then
        qgrid = zero
        do  i=1,nptr
          qgrid = qgrid + wk1(i)
        enddo
        qgrid = weight*qgrid
        write(IWR,9020) 'DBG/LMCC: delta-rho net charge=',qgrid
      endif
cxxx:end
c -->  rho-io  r-3bs
c
      call SYMVEC( 1, dipole, vec0, nsym, rmatsym )
      call SYMVEC( 1,rdipole, rsym, nsym, rmatsym )
cxxx:
      if( debugdl )then
        write(IWR,9013) 'DBG/LMCC: delrho dipole=',dipole
        write(IWR,9013) 'DBG/LMCC: delrho rdipole=',rdipole
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c  If have reference density, retrieve and compute dipoles.
c  I will want two dipoles when I come out of the next section.
c  The first is a "defect" dipole for which a local spherical gaussian
c  countercharge array will be used, and the second is a "vacuum"
c  dipole with boundaries in, of course, vacuum.  Note that molecules
c  can be classed in either because they have boundaries in vacuum,
c  but they also use spherical gaussian countercharges.  Here, I class
c  them with the defect terms.  The defect dipole gets put into
c  the vector dipole(), while the vacuum dipole (now the only one
c  we consider is the slab dipole) gets put into dipref().
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if( igrdref .gt. 0 )then
c
        write(IWR,*)
        if( lvlout.gt.1 )then
c         Report dipole moment from full delta-density of this system:
          call REXTRNL( ndim,  1 , dolvatm, rprim,orig,rscale,
     $     vect, rdipole )
          write(IWR,9020) 'full dipole moment(z*bohr)=',dipole
          write(IWR,9020) 'full dipole center: rdipole=',vect
        endif
c
c       Retrieve reference delta-density, and put into boxes:
        REWIND( unit=igrdref )
        call READBIG( igrdref, nptr, wk4 )
        call INTOBOX( n1r,n2r,n3r, wk4, ndbox, wk5 )
c
c       Compute moments from reference system density
c
        call MOMENT( IWR, elchrg, dipref,rdipref, ndim,
     $   origws, rprim, n1r,n2r,n3r, hh, weight, ndbox,nbox,
     $   wk5,    wk4 )
c -->    rho-io  r-3bs
c
        call SYMVEC( 1, dipref, vec0, nsym, rmatsym )
        call SYMVEC( 1,rdipref, rsym, nsym, rmatsym )
c
        if( lvlout.gt.1 )then
c         Report dipole from reference system density
          call REXTRNL( ndim,  1 , dolvatm, rprim,orig,rscale,
     $     vect, rdipref )
          write(IWR,9020) 'reference dipole(z*bohr)=',dipref
          write(IWR,9020) 'reference rdipole=',vect
        endif
c
c       Take difference of current density from reference:
        do  nr=1,nptr
          wk3(nr) = wk1(nr) - wk5(nr)
        enddo
c
c       Take moment of difference of density from reference:
c
        call MOMENT( IWR, elchrg, dipole,rdipole, ndim,
     $   origws, rprim, n1r,n2r,n3r, hh, weight, ndbox,nbox,
     $   wk3,    wk4 )
c -->    rho-io  r-3bs
c
        call SYMVEC( 1, dipole, vec0, nsym, rmatsym )
        call SYMVEC( 1,rdipole, rsym, nsym, rmatsym )
c
        if( lvlout.gt.1 )then
c         Report lmcc defect dipole:
          call REXTRNL( ndim,  1 , dolvatm, rprim,orig,rscale,
     $     vect, rdipole )
          write(IWR,9020) 'net dipole(z*bohr)=',dipole
          write(IWR,9020) 'net mom: rdipole=',vect
        endif
c
      else
c
        if( lvlout.gt.4 )then
c         Report full dipole from this system:
          call REXTRNL( ndim,  1 , dolvatm, rprim,orig,rscale,
     $     vect, rdipole )
          write(IWR,9020) 'full dipole moment(z*bohr)=',dipole
          write(IWR,9020) 'full dipole center: rdipole=',vect
        endif
c
c       Clear out undefined parts of dipole
        do  idim=1,ndim
          dipole(idim) = zero
          rdipole(idim) = zero
        enddo
c
c       In case have slab calculation, save moment in reference variables
        do  idim=1,3
          dipref(idim) = dipole(idim)
          rdipref(idim) = rdipole(idim)
        enddo
c
        if( ndim.eq.0 )then
c
c         Symmetrize net dipole
          call SYMVEC( 1, dipole, vec0, nsym, rmatsym )
          call SYMVEC( 1,rdipole, rsym, nsym, rmatsym )
          if( nsym.gt.1 .and. lvlout.gt.1 )then
            call REXTRNL( ndim,  1 , dolvatm, rprim,orig,rscale,
     $       vect, rdipole )
            write(IWR,*)
            write(IWR,9020) 'net dipole(z*bohr)=',dipole
            write(IWR,9020) 'net mom: rdipole=',vect
          endif
c
        else
c
c         Clear out defect lmcc moment for non-molecules
c         (This compels skip of elchrg=0, point dipole LMCC)
          do  idim=1,3
            dipole(idim) = zero
            rdipole(idim) = zero
          enddo
        endif
c
      endif
c
c  Compute magnitude of lmcc "defect" dipole moment:
      dipsq = zero
      do  idim=1,3
        dipsq = dipsq + dipole(idim)**2
      enddo
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c      We have all the dipole moments, now go and generate the
c      LMCC charge density and LMCC potential for defect LMCC
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Clear out local moment counter-charge density and potential
      call MKZERO( nptr, wk2 )
      call MKZERO( nptr, wk3 )
c
      if( elchrg .ne. zero )then
c       Charged system (point charge): compute LMCC density and potential
c
        if( ion_opt .eq. 2 )then
c         Initialize charge position to WS (dipole) origin
          do  i=1,3
            rchrg(i) = origws(i)
          enddo
        endif
c
        if( IABS( ion_opt ) .ne. 3 )then
c         (Shunt slab 2D planar charge, ion_opt=3, to later in routine)
          call IONPOT( ion_opt,elchrg,dipole,ndim,esion,rchrg,
     $     rprim, n1r,n2r,n3r,  hh,weight, ndbox,nbox,
     $     wk2,    wk3,    wk1 )
c -->      rhion-o vion-o  r-3bs
c
          if( lvlout.gt.0 .and. ion_opt.gt.0 )then
            call REXTRNL( ndim,  1 , dolvatm, rprim,orig,rscale,
     $       vect  ,rchrg )
            write(IWR,*)
            write(IWR,9020) 'Location of LMCC charge=',vect
          endif
c
          lmcc_on = .true.
        endif
c
      elseif( dipsq .gt. 4.d-4 .and. ion_opt.gt.0 )then
c       Neutral system, with dipole: compute counter-moment charge density:
c       NB: Do not know how to specify dipole for point-dipole in bulk.
c
        if( ndim.eq.0 .or. ndim.eq.3 )then
c         (Shunt slab planar dipole treatment to later in routine)
          call DIPPOT( ion_opt, dipole,rdipole, ndim, esion,
     $     rprim, n1r,n2r,n3r,  hh,weight, ndbox,nbox,
     $     wk2,    wk3,    wk1 )
c -->      rhion-o vion-o  r-3bs
c
          if( lvlout.gt.0 )then
            write(IWR,*)
            write(IWR,9020) 'LMCC local dipole, |dip|=', SQRT( dipsq )
          endif
          lmcc_on = .true.
        endif
c
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c  Compute excluded volume reference term via fft/local b.c. exchange:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if( igrdref.gt.0 .and. lmcc_on )then
c
c       Retrieve reference delta electrostatic potl; put into boxes:
        call READBIG( igrdref, nptr, wk1 )
        call INTOBOX( n1r,n2r,n3r, wk1, ndbox, wk4 )
c
c       First, a simple diagnostic check, v(ref):rho(ref)
        esnsref = half*weight*DDOT( nptr, wk4,1, wk5,1 )
        write(IWR,9020) 'Reference system esns(Ry)=',esnsref
c
c       Take G=0 net charge error out of reference delta density:
        rhave = zero
        do  nr=1,nptr
          rhave = rhave + wk5(nr)
        enddo
        rhave = rhave / DBLE( nptr )
        do  nr=1,nptr
          wk5(nr) = wk5(nr) - rhave
        enddo
c
c       Take pbc reference LMCC integral over all space: rho(ion):v(ref)
        epionvref = weight*DDOT( nptr, wk2,1, wk4,1 )
c
c       Take local reference LMCC integral over WS cell: v(ion)*rho(ref)
        evionpref = weight*DDOT( nptr, wk3,1, wk5,1 )
        eslmref = epionvref - evionpref
        eslmxev = toev*eslmref
        if( lvlout.gt.1 )then
          write(IWR,9020) 'LMCC reference int(Ry): pivx(pbc)=',
     $     epionvref
          write(IWR,9020) 'LMCC reference int(Ry): vipx(loc)=',
     $     evionpref
          write(IWR,9020) 'LMCC total reference int(Ry,eV): pivx-vipx=',
     $     eslmref,eslmxev
        endif
c
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c    Treat slab 2D planar dipole or charge via vacuum LMCC
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      esionsl = zero
      if( ndim.eq.2 .and. ion_opt .ne. 0 )then
c       Slab with 2D electrostatic corrections (i.e., planar, not point)
c
c       Compute magnitude of slab (normal) dipole:
        diprefsq = zero
        do  idim=ndim+1,3
          diprefsq = diprefsq + dipref(idim)**2
        enddo
c
        if( elchrg.eq.zero .and. diprefsq .gt. 4.d-4 )then
c         Neutral slab, with a planar dipole
c
          call DIPSLAB( ion_opt, ndim,
     $     dipref,rdipref,  esionsl,vacplus,
     $     rprim, n1r,n2r,n3r,  hh,weight, ndbox,nbox,
     $     wk2,     wk3,     wk1 )
c -->      rhlmcc-o vlmcc-o  r-3b
c
c         Let user know slab correction is on:
          if( ion_opt.eq.2 )then
            write(IWR,*) 'Slab dipole removed using vacuum LMCC'
            write(IWR,*) 'Vacuum level[Ry]@z(+),z(-)=',vacplus,-vacplus
c           **** NB ****
c           Combined ion/dipole defect and slab vacuum LMCC suspect
            esion = esionsl
            lmcc_on = .true.
          endif
c
c         End neutral slab dipole branch
c
        elseif( elchrg.ne.zero .and. IABS( ion_opt ) .eq. 3 )then
c
c         Charged slab, with implicit planar Gaussian countercharge in vacuum
c
c         Put counter-charge plane at specific location (stored in second half of rchrg)
c         This will ultimately come from an external source (fluids-DFT, MD, etc)
          do  i=1,3
            zchrglm(i) = rchrg(i)
            zchrgcc(i) = rchrg(3+i)
          enddo
          call SLABCHRG( ion_opt,ndim,
     $     elchrg, origws,zchrglm,zchrgcc,
     $     dipref,rdipref,  esionsl,vacplus,
     $     rprim, n1r,n2r,n3r,  hh,weight, ndbox,nbox,
     $     wk2,     wk3,     wk1 )
c -->      rhlmcc-o vlmcc-o  r-3b
c
           esion = esionsl
           write(IWR,9020) 'Planar charge dble-layer energy=',esionsl
cxxx:`
      write(IWR,*) 'DBG/LMCC Charged plane SLABCHRG not fully vetted'
c
cxxx:start - compute moment of countercharge
      call MOMENT( IWR, elchrg, dipole,rdipole, ndim,
     $ origws, rprim, n1r,n2r,n3r, hh, weight, ndbox,nbox,
     $ wk2,    wk4 )
c
      qgrid = zero
      do  i=1,nptr
        qgrid = qgrid + wk2(i)
      enddo
      qgrid = weight*qgrid
      write(IWR,9013) 'DBG/LMCC: rho_lmcc net charge=',qgrid
      call SYMVEC( 1, dipole, vec0, nsym, rmatsym )
      call SYMVEC( 1,rdipole, rsym, nsym, rmatsym )
cxxx:
      write(IWR,9013) 'DBG/LMCC: rho_lmcc dipole=',dipole
      write(IWR,9013) 'DBG/LMCC: rho_lmcc rdipole=',rdipole
cxxx:end
c 
c         Record location of slab planar charge into rchrg()
          do  i=1,3
            rchrg(i) = zchrglm(i)
          enddo
cxxx
          write(IWR,9013)'DBG/LMCC: z_lm(internal)=',zchrglm
          write(IWR,9013)'DBG/LMCC: z_cc(internal)=',zchrgcc
c
          lmcc_on = .true.
c
c         Close double-layer LMCC branch ...
c
        endif
c
c       Close slab (ndim=2) LMCC treatments
      endif
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LMCCINT
c
c
      subroutine LMCCINT( IWR, igrdref,  lvlout, lmcc_on,
     $ esnsgr, esion,eslmref,  ndim, nptr, weight,
     $ rhoslo, vesslo, rholmcc, veslmcc, delrho )
c---------------------------------------------------------------
c Purpose: evaluate integrals needed to compute contributions
c          to LMCC energy.
c
c Written: Peter A. Schultz, 30-May-2001 for v2.47
c
c Revision history:
c  22May11-PAS/2.62: cosmetics, so far
c  10Sep05-PAS/2.59: chemical potential perspective diagnostics
c  30May01-PAS/2.47: pushed down from main program
c---------------------------------------------------------------
c
c Notes:
c  Implements the method for treating supercell moments described
c  in:  P.A. Schultz,  PRB 60, 1551 (1999);  PRL 84, 1942 (2000).
c
c on input
c   rhoslo()  = fft density
c   vesslo()  = fft es potential
c   rholmcc() = lmcc density
c   veslmcc() = lmcc es potential
c   delrho()  = delta-rho [rho - rho0(ref atoms)]
c on output
c   rhoslo()  = full slow density (fft+lmcc)
c   vesslo()  = full slow es potential (fft+lmcc)
c This routine does not care whether grid fields come boxed or
c not, as long as all the fields are the same way.
c
c Want to evaluate convolution INT[delrho:slorho] where
c   delrho = del = fast + fft + ion
c   slorho = slo = fft + ion
c and want to evaluate all ion:X terms using X density and
c ion potentials, and use a special evaluation for the ion:ion
c term in case it is provided.  The way I do this is:
c (density left, potential right)
c
c    del:slo = (fast+fft+ion):(fft+ion) "esdelslo"
c        - ion:fft + fft:ion - ion:ion(grid) + ion:ion(spec)
c        "epionvslo" "evionpslo"  "esiongr"     "esion"
c        + ion:fft[ref] [reference system lmcc integrals ell]
c     Note: esion was computed previously in "ionpot" or "dippot"
c I also would like to compute the "chemical potential" shift,
c which is the LMCC grounding of the energy to crystal reference
c electron reservoir:
c    esulmcc = - rho_lm:ves_def + v_lm:rho_def
c              + rho_lm:ves_ref - v_lm:rho_ref
c The reference terms were done earlier, and sum is passed
c in "eslmref", while the defect terms are evaluated here.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, half=0.5d0, one=1.d0 )
c
c Input arrays:
      LOGICAL    lmcc_on
c
c Input/Output arrays:
      DIMENSION  rhoslo(nptr),vesslo(nptr),  delrho(nptr)
c Input arrays:
      DIMENSION  rholmcc(nptr),veslmcc(nptr)
c
c Local declarations:
      DATA  toev / 13.605805d0 /
cxxx      DATA  lvldbg / 0 /
      DATA  lvldbg / 0 /
c
c >>>> EXECUTABLE CODE:
c
 9020 format(1x,a,3f20.10)
      lvllst = MAX( lvlout, lvldbg )
cxxx:
      write(6,*) 'DBG/LMCCINT, esns diagnostics redone'
c
      epionvslo = half*weight*DDOT( nptr, rholmcc,1, vesslo ,1 )
      evionpslo = half*weight*DDOT( nptr, rhoslo ,1, veslmcc,1 )
      eslmdef = -epionvslo + evionpslo
      esulmcc = eslmdef + eslmref
      esiongr  = half*weight*DDOT( nptr, rholmcc,1, veslmcc,1 )
c
c  Combine lmcc into slow densities, and potentials:
      call DAXPY( nptr, one, rholmcc,1, rhoslo,1 )
      call DAXPY( nptr, one, veslmcc,1, vesslo,1 )
c
c  Take the last integral I need ...
      esdelslo = half*weight*DDOT( nptr, delrho ,1, vesslo ,1 )
c
c  And put it all together ...
      esnsgr = esdelslo + esulmcc - esiongr + esion
c
      if( lvllst .gt. 3 )then
        write(IWR,'(1x,a)') 'LMCCINT energy breakdown:'
        write(IWR,9020) '  epionvslo(pivd)  = ',-epionvslo
        write(IWR,9020) '  evionpslo(vipd)  = ', evionpslo
        write(IWR,9020) '  esdelslo(pdvd)   = ', esdelslo
        write(IWR,9020) '  grid ion self-energy esiongr   =',-esiongr
        write(IWR,9020) '  grid ion self-energy(analytic)`=', esion
        write(IWR,9020) '  total grid es energy=',esnsgr
      endif
      eslmdev = toev*eslmdef
      if( lvlout.gt.2 )then
        write(IWR,9020) 'LMCC defect int(Ry): pivd(pbc)=',
     $   epionvslo
        write(IWR,9020) 'LMCC defect int(Ry): vipd(loc)=',
     $   evionpslo
        write(IWR,9020) 'LMCC total defect int(Ry,eV): -pivd+vipd=',
     $   eslmdef,eslmdev
      endif
      if( ndim.gt.0 )then
        if( igrdref.gt.0 )then
          if( lvlout.gt.1 )then
            write(IWR,9020) 'LMCC total reference int(Ry)=', eslmref
          endif
        else
          write(IWR,*) '***** Warning: No reference term in LMCC'
        endif
      endif
      esulmev = toev*esulmcc
      if( lvlout.gt.0 )then
        write(IWR,9020) 'LMCC chemical potential shift(Ry,eV)=',
     $   esulmcc,esulmev
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LVPROJ
c
c
      subroutine LVPROJ( a, r, v )
c---------------------------------------------------------------
c Purpose: project vector r() onto primitive vectors; and v.v.
c
c Written: Peter A. Schultz, 7-Jul-2000, for v2.45
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c  Uses Cramer's Rule to do projections.
c   a() are the input primitive vectors
c   r() is a vector in Cartesian space
c   v() is projection onto the primitive vectors
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  a(3,3), r(3)
c output arrays:
      DIMENSION  v(3)
c
c >>>> EXECUTABLE CODE:
c
      denom =  a(1,1)*( a(2,2)*a(3,3) - a(3,2)*a(2,3) ) +
     $         a(1,2)*( a(2,3)*a(3,1) - a(3,3)*a(2,1) ) +
     $         a(1,3)*( a(2,1)*a(3,2) - a(3,1)*a(2,2) )
c
      v(1) = ( r(1)  *( a(2,2)*a(3,3) - a(3,2)*a(2,3) ) +
     $         a(1,2)*( a(2,3)*r(3)   - a(3,3)*r(2)   ) +
     $         a(1,3)*( r(2)  *a(3,2) - r(3)  *a(2,2) ) ) / denom
      v(2) = ( a(1,1)*( r(2)  *a(3,3) - r(3)  *a(2,3) ) +
     $         r(1)  *( a(2,3)*a(3,1) - a(3,3)*a(2,1) ) +
     $         a(1,3)*( a(2,1)*r(3)   - a(3,1)*r(2)   ) ) / denom
      v(3) = ( a(1,1)*( a(2,2)*r(3)   - a(3,2)*r(2)   ) +
     $         a(1,2)*( r(2)  *a(3,1) - r(3)  *a(2,1) ) +
     $         r(1)  *( a(2,1)*a(3,2) - a(3,1)*a(2,2) ) ) / denom
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LVXPND
c
c
      entry      LVXPND( a, r, v )
c
c >>>> EXECUTABLE CODE:
c
      r(1) = v(1)*a(1,1) + v(2)*a(1,2) + v(3)*a(1,3)
      r(2) = v(1)*a(2,1) + v(2)*a(2,2) + v(3)*a(2,3)
      r(3) = v(1)*a(3,1) + v(2)*a(3,2) + v(3)*a(3,3)
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MAT0FRC
c
c
      subroutine MAT0FRC( IWR,IWRF, idmatfl,idmatsfl,iematfl,iematsfl,
     $ lvlout, nspinf,ndim, dolocxc,
     $ mat,nmat, convs,convsl,convii,
     $ nafrc,iforce, frctot,strtot,fdefct, frc1,frc2,frc3, str1,str2,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, noad, nlat,nlat2c,nlat3c,
     $ itypa, numshl,lshel,nala,ala,cala,
     $ nocc,locc,nalsh,alsh,calsh, occsh,occij,
     $ alamin, norba, occ,znuc, lmxnlp1,almnnl,
     $ nrd, nrad,nrps,radmsh,radwt,
     $ vpsrad, vatrad,vesrad,vxcrad,excrad, wkrad,
     $ ratm, rlat, coskr,sinkr, nsyma,rprim,rmatsym,naofsym,
     $ wksm , naldsq, gntcomb, maxwk,mxang,
     $ dmat )
c---------------------------------------------------------------
c Purpose: compute contributions from force due to
c          (semi-)analytic matrix elements.
c
c Written: Peter A. Schultz, 21-May-2001 for v2.47
c
c Revision history:
c    Jan12-ACO/2.63: install reduced-memory k-parallel dmat distribtino
c  15Oct08-PAS/2.62: stripe-parallel
c  20Jun07-PAS/2.60: merge serial and tp
c  12May07-PAS/2.60: add scratch arroy, for tp-serial consistency
c  25Sep04-PAS/tp0.1: clean-up task-parallel routines
c   6May03-DMC:  Added scratch array, to pass to NLOCFFRC and VLOCFRC
c  23Jul01-PAS/2.49: compact dmat
c  21May01-PAS/2.47: pushed down from main program
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0, one = 1.d0 )
c
c Input/Output:
      DIMENSION  frctot(3,natm),strtot(3,3),fdefct(3)
c Input arrays:
      LOGICAL    dolocxc
      DIMENSION  convs(*)
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $ nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  occsh(nshld,ntyp),occij(nshld,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp),occ(nshld,ntyp),znuc(ntyp)
      DIMENSION  lmxnlp1(ntyp),almnnl(ntyp)
      DIMENSION  nrad(ntyp),nrps(ntyp),radmsh(nrd,ntyp),radwt(nrd,ntyp)
      DIMENSION  vpsrad(nrd,4,ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat), coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  rprim(3,3), rmatsym(*),naofsym(natm,*)
      DIMENSION  vatrad(*),vesrad(*),vxcrad(*),excrad(*)
c Scratch arrays:
      DIMENSION  frc1(3,natm),frc2(3,natm),frc3(3,natm)
      DIMENSION  str1(3,3),str2(3,3)
      DIMENSION  wkrad(nrd,*), wksm(naldsq,46)
      DOUBLE COMPLEX    gntcomb(9,5,5,2,9)
c
c Big scratch array:
      DIMENSION  dmat(*)
c
c  dmat() total memory requirement:
c    Using dm0fetch, all-k full striped matrices
c      Spin/k=1: nmatpr + max(mat,ncplx*matstr=nmatstr) + mat
c      else:     nmatpr + nmatstr + nspin*mat
c    Using dm0fetchkp, k-parallel reduced memory fetches
c      nmatpr + nmatpr + mat + max( ncplx*matstr, (nspin-1)*mat )
c    Later:
c      nmatpr + max( mxangf, 3*natm )
c
c    Where mxangf is not recorded, but it looks like (not checked):
c      5x5x7x3x9x9 + 25x25 + 2 x 4(25x9x3x3)
c      42525 + 625 + 2x8100 = 59350
c      Exact usage doesn't matter ... this has entire end of arena free
c
c Local declaration;
      LOGICAL    USE_KPSTORE
c
c >>>> EXECUTABLE CODE:
c
      USE_KPSTORE = .true.
c     For nk=1, old scheme is smaller by nmatpr:
      if( nk .eq. 1 ) USE_KPSTORE = .false.
      write(IWR,*) 'mat0frc: stripe-parallel, KPSTORE=',USE_KPSTORE
c
 9020 format(1x,a,3f20.10)
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c      Set up parallelism for the atom-centered force calculations
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
c Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmatstr = ncplx*nk*matstr
c
c Figure out how much belongs on local processor:
      call MATLOCSTR( iproc,nprocs,nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmatpr = mymatpr*ncplx*nk
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c         Get the density matrices and put into usable form
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c 
      n1dm = nmatstr
      n2dm = mat
      if( .not. USE_KPSTORE )then
c       Using original all-k striped matrices retrieve
        if( nspinf .eq. 2 )then
          if( nk .eq. 1 )then
c           Use the target as temporary storage for up/dn spin retrieve
            n1dm = MAX( n1dm, mat )
          else
c           Need to use extra mat buffer to read both up/dn dmat:
            n2dm = mat + mat
          endif
        endif
        n3dm = 0
      else
c       Using reduced memory single-k-by-k striped matrix retrieve
        n1dm = nmatpr
        n3dm = ncplx*matstr
        if( nspinf .eq. 2 ) n3dm = MAX( n3dm, mat )
      endif
c
c  Load up dmat/emat fetching pointers:
      i1dm = 1
      i2dm = i1dm + n1dm
      i3dm = i2dm + n2dm
c
      i1em = i1dm + nmatpr
      i2em = i1em + n1dm
      i3em = i2em + n2dm
c
c     Determine total required storage for dmat/emat:
      memdm = i3em + n3dm - 1
      if( memdm .gt. maxwk )then
c       We do not have enough space for this ...
        call FLGETIERR( IERR )
        write(IERR,*) 'FORCES/MAT0FRC: memory inadequate'
        write(IERR,*) 'Needed, available memory=',memdm,maxwk
        call STOPXERR( 'MAT0FRC memory shortage' )
      endif
c
c  Fetch and distribute density matrix dmat from idmatfl
c    and then
c  Fetch and distribute energy-weighted density matrix emat from iematfl
c
      if( .not. USE_KPSTORE )then
c       Use all-k striped intermediate
        call DM0FETCH( idmatfl,idmatsfl, nspinf,
     $   norb,nk,ncplx, natm,ntyp,itypa,norba,
     $   dmat(i1dm),                 dmat(i2dm) )
c -->    dmatstr(nmatpr-o)           dmatij(mat)[2mat if spin.and.k>1]
c -->    nmatstr|mat(spin&k=1)-s     mat-s (2mat if spin&k>1)
        call DM0FETCH( iematfl,iematsfl, nspinf,
     $   norb,nk,ncplx, natm,ntyp,itypa,norba,
     $   dmat(i1em),                 dmat(i2em) )
      else
c       Do reduced-memory single-k striped intermediates
        call DM0FETCHKP( idmatfl,idmatsfl, nspinf,
     $   norb,nk,ncplx, natm,ntyp,itypa,norba,
     $   dmat(i1dm),        dmat(i2dm),   dmat(i3dm) )
c -->    dmatstr(nmatpr)-o  dmatij(mat)-s dmatbuf(nc*matstr|mat[spin])-s
        call DM0FETCHKP( iematfl,iematsfl, nspinf,
     $   norb,nk,ncplx, natm,ntyp,itypa,norba,
     $   dmat(i1em),        dmat(i2em),   dmat(i3em) )
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c   Compute force contribution from two-center part of Hamiltonian
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Set up cutoffs for 2-center (overlap&kinetic) force calculation:
      call MKCUTS( convs(5), convsl, convii )
c
      call FRC2CTR( ndim,
     $ nafrc,iforce, frc1,frc2, str1,str2,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba,
     $ ratm, rlat,coskr,sinkr,
     $ dmat(i1dm), dmat(i1em),  wksm )
c -->  dmat-io     emat-i       frctp-s(3a)
c
      call SYMFRC( IWRF, 'overlap', str1, frc1, frc3, fdefct,
     $ ndim, natm, nsyma, rprim, rmatsym, naofsym )
c
      call DAXPY( 3*natm, one, frc1,1, frctot,1 )
      do  jd=1,ndim
        do  id=1,ndim
          strtot(id,jd) = strtot(id,jd) + str1(id,jd)
        enddo
      enddo
c
      call SYMFRC( IWRF, 'kinetic energy', str2, frc2, frc3, fdefct,
     $ ndim, natm, nsyma, rprim, rmatsym, naofsym )
c
      call DAXPY( 3*natm, one, frc2,1, frctot,1 )
      do  jd=1,ndim
        do  id=1,ndim
          strtot(id,jd) = strtot(id,jd) + str2(id,jd)
        enddo
      enddo
c
      if( lvlout.gt.2 ) call TIMER('After frc2ctr    ')
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c      Compute forces due to non-local part of pseudopotential
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Set up cutoffs for non-local potential force calculation:
      call MKCUTS( convs(7), convsl, convii )
c
      call NLOCFRC( nafrc,iforce, ndim, frc1,str1,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat,  nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba, znuc,
     $ lmxnlp1,almnnl,  ratm, rlat,coskr,sinkr,
     $ nrd,nrps, radmsh,vpsrad, wkrad,
     $ dmat(i1dm), gntcomb, dmat(i1em),    wksm )
c -->  dmat-io              angsav-s       frctp-s(3a)
c
      call SYMFRC( IWRF, 'nlocfrc', str1, frc1, frc3, fdefct,
     $ ndim, natm, nsyma, rprim, rmatsym, naofsym )
c
      call DAXPY( 3*natm, one, frc1,1, frctot,1 )
      do  jd=1,ndim
        do  id=1,ndim
          strtot(id,jd) = strtot(id,jd) + str1(id,jd)
        enddo
      enddo
c
      if( lvlout.gt.2 ) call TIMER('After nlocfrc    ')
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c    Compute force from local (spherical) part of atom potentials
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Set up cutoffs for local potential force calculation:
      call MKCUTS( convs(8), convsl, convii )
c
      call VLOCFRC( nafrc,iforce, ndim, frc1,str1,
     $ dolocxc, norb,nk,ncplx, natm,ntyp,nshld,nald, nlat,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ alamin, norba, znuc,occsh,occij,
     $ lmxnlp1, ratm, rlat,coskr,sinkr,
     $ nrd,nrad, radmsh,radwt, vpsrad, vatrad,vesrad, wkrad,
     $ naldsq, wksm(1,1),wksm(1,7),wksm(1,13),
     $  wksm(1,19),wksm(1,20),wksm(1,21), wksm(1,22),  wksm(1,25),
     $ dmat(i1dm), dmat(i1em) )
c -->  dmat-io     frctp-s(3a)
c
      call SYMFRC( IWRF, 'vlocfrc', str1, frc1, frc3, fdefct,
     $ ndim, natm, nsyma, rprim, rmatsym, naofsym )
c
      call DAXPY( 3*natm, one, frc1,1, frctot,1 )
      do  jd=1,ndim
        do  id=1,ndim
          strtot(id,jd) = strtot(id,jd) + str1(id,jd)
        enddo
      enddo
c
      if( lvlout.gt.2 ) call TIMER('After vlocfrc    ')
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MAT0SET
c
c
      subroutine MAT0SET( IWR, lvlout,
     $ iovlpfl,iham0fl,ivxc0fl,iexc0fl,ih0tfl,ih0nlfl,
     $ atm0engy, mat, nmat, convs,convsl,convii,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, noad, nlat,nlat2c,nlat3c,
     $ itypa, numshl,lshel,nala,ala,cala,
     $ nocc,locc,nalsh,alsh,calsh, occsh,occij,
     $ alamin, norba, occ,znuc, lmxnlp1,almnnl,
     $ nrd, nrad,nrps,radmsh,radwt,
     $ vpsrad, vatrad,vesrad,vxcrad,excrad, wkrad, wspl,
     $ ratm, rlat, coskr,sinkr, s1atom,
     $ wksm, gntcomb, maxwk,mxang,
     $ wkmat )
c---------------------------------------------------------------
c Purpose: compute iteration-independent, (semi-)analytic matrix
c          elements over reference atoms: standard dense matrices.
c
c Written: Peter A. Schultz, 21-May-2001 for v2.47
c
c Revision history:
c  24Nov09-ACP/2.63: reduced footprint stripe-distributed parallelism
c  10Oct08-PAS/2.62: stripe-distributed parallelism
c  20Jun07-PAS/2.60: merge tp and serial
c  30Jul05-PAS/2.59-tp: master-only Ham writes
c  15Oct04-PAS/2.59-tp: clean-up task-parallel routines, purge
c    scratch mem (by again reordering calls).
c  15Oct04-PAS/2.59: reorder orbital mat routines
c  16Apr03-DMC: add scratch array to call.  Will be passed on to
c    nlocmat and vlocmat, to allow parallelization.
c   3Oct02-PAS/2.54: repack memory and i/o for big ham matrices
c   2Oct02-PAS/2.54: opt of non-local - purge killed variables
c  21Jun01-PAS/2.48: replace STOPs
c  21May01-PAS/2.47: extracted from main routine
c---------------------------------------------------------------
c  Memory footprint
c   USING STANDARD H0STORE
c     2*nmatpr + nmatstr + max(norb*norb, 3*norb*norbat)
c   USING H0STOREKP
c     2*nmatpr + max(nmatpr,mxang) + matstr*ncplx+max(norb*norb, 3*norb*maxnorba)
c   where
c     mat     = norb*norb
c     matstr  = slightly bigger than mat (atom-block striped storage)
c     nmat    = nk*norb*norb      
c     nmatstr = nk*matstr*ncplx
c     nmatpr  = O(nmatstr / nprocstr)
c     maxnorba = max( norba(1:natm) ), i.e. most bf/atom
c---------------------------------------------------------------
c
c The distributed parallelism is done via atom-stripes along the
c upper triangle of the diagonal blocks, and done in such a way as
c to distribute the memory requirements roughly equally.
c Each processor gets a single contiguous sequence of atoms as its own,
c with early processors getting fewer atoms with longer lengths and
c later atoms getting more atoms with shorter lengths.
c
c Using H0STORE, the distributed striped matrices are all-k merged
c onto the master proc into full striped matrices, using nk*matstr space.
c The master reorders these into a square i-j order matrix (size mat),
c k-by-k, one matrix(k) at a time, and writes it out for later use.
c  
c Using H0STOREKP, the distributed striped matrix pieces are merged
c onto the master proc one full striped mat[k] (size matstr) at a time.
c The master reorders this into a square i-j order matrix (size mat),
c and writes each out for later use.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input arrays:
      DIMENSION  convs(*)
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $ nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  occsh(nshld,ntyp),occij(nshld,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp), occ(nshld,ntyp), znuc(ntyp)
      DIMENSION  lmxnlp1(ntyp),almnnl(ntyp)
      DIMENSION  nrad(ntyp),nrps(ntyp),radmsh(nrd,ntyp),radwt(nrd,ntyp)
      DIMENSION  vpsrad(nrd,4,ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat), coskr(nk,nlat),sinkr(nk,nlat)
c Output arrays:
      DIMENSION  s1atom(noad,noad,nk,natm)
      DIMENSION  vatrad(*),vesrad(*),vxcrad(*),excrad(*)
c Scratch arrays:
      DIMENSION  wkrad(nrd,*), wspl(nrd,2), wksm(nk,*)
      DOUBLE COMPLEX    gntcomb(9,5,5,2,9)
c Big scratch array:
      DIMENSION  wkmat(*)
c
c Local declarations:
      DATA  zero,one / 0.d0,1.d0 /
      LOGICAL    USE_KPSTORE
c     USE_KPSTORE = .true. use reduced footprint scheme
c     USE_KPSTORE = .false. use original scheme
c
c >>>> EXECUTABLE CODE:
c
      USE_KPSTORE=.true.
c     For nk=1, old scheme is smaller by nmatpr:
      if( nk .eq. 1 ) USE_KPSTORE = .false.
      write(IWR,*) 'mat0set: stripe-parallel, KPSTORE=', USE_KPSTORE
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                 Determine work/memory allocations
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc ) 
      call MPNODE0( master )
      call MPCOMM( icomm )
c
c Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb, nk, ncplx, natm, ntyp, itypa, norba )
c
      nmatstr = ncplx*nk*matstr
c Need maximum value of norba for memory allocation.
      maxnorba = norba(1)
      do  ityp=2,ntyp
        maxnorba = MAX( maxnorba, norba(ityp) )
      enddo
c           
c Figure out how much belongs on local processor:
c
      call MATLOCSTR( iproc, nprocs, nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb, nk, ncplx, natm, ntyp, itypa, norba )
c
      nmatpr = mymatpr*ncplx*nk
c
c   NB: nmatpr = O( nmatstr / nprocstr )
c
c
c Partition memory in big workspace:
c
      if( .not. USE_KPSTORE )then
c       Simple all-k merge onto master, needs:
c        i01(nmatpr),i02(nmatpr),
c        i03(nmatstr) [full all-k striped matrices]
c        i04(mat)
c
        i01 = 1
        i02 = i01 + nmatpr
        i03 = i02 + nmatpr
        i04 = i03 + nmatstr
        i0end = i04 + mat
      else
c       Reduced memory, k-by-k merge onto master, needs:
c        i01(nmatpr),i02(nmatpr)
c        i03(nmatpr) [distributed all-k striped matrices]
c         (NB: angsav can safely overlap thru i04 to end of full arena)
c        i04(matstr*ncplx,3*norb*maxnorba),
c        i05(mat)
c
C        nlocmat_angsav_dim = 5*5*5*5*3*81
        nlocmat_angsav_dim = mxang
        i01 = 1
        i02 = i01 + nmatpr
        i03 = i02 + nmatpr
        i04 = i03 + nmatpr
        i05 = i04 + MAX( matstr*ncplx, 3*norb*maxnorba )
        i0end = i05 + mat
      endif
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      nlat2c = nlat
      nlat3c = nlat
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                   Overlap matrix
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Set up cutoffs for overlap calculation:
c
      call MKCUTS( convs(1), convsl, convii )
c
      call SIJ( norb,nk,ncplx, natm,ntyp,nshld,nald, nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba,
     $ ratm, rlat,coskr,sinkr, wksm,
     $ wkmat(i01) )
c -->  smat-o
c -->  nmatpr 
      if( lvlout.gt.2 ) call TIMER('After sij        ')
c
      if( nlat2c.lt.nlat .and. lvlout.gt.3 )
     $ write(IWR,*) 'for 2c terms, nlat reduced from', nlat,
     $                                          ' to', nlat2c
c
c  Extract 1-center overlaps from distributed  matrix for grid-analytic corrections
c
      call MKS1STR( s1atom,
     $ norb,nk,ncplx, natm,ntyp, noad, itypa, norba,
     $ myj0,myatm1,myatm2,
     $ nprocstr, master,iproc,icomm,
     $ wkmat(i01) )
c -->  smat-io
c -->  nmatpr 
c
c  Store overlap matrix:
c
      if( .not. USE_KPSTORE )then
        call H0STORE( iovlpfl , nprocstr, master,iproc,icomm,
     $   nmatstr,nmatpr, mat,
     $   norb,nk,ncplx, natm,ntyp,itypa, norba,
     $   wkmat(i01),        wkmat(i04) )
c -->    hmatstr-is         hmatijk-s
c -->    nmatpr-i/nmatstr-s mat
      else
        call H0STOREKP( iovlpfl , nprocstr, master, iproc, icomm,
     $   nmatstr, nmatpr, mymatpr, mat,
     $   norb, nk, ncplx, natm, ntyp, itypa, norba,
     $   wkmat(i01), wkmat(i05), matstr, wkmat(i04) )
c -->    hmatstr-i   hmatijk-s           hmatkbuf-s
c -->    nmatpr      mat                 matstr*ncplx 
      endif
c
      if( lvlout.gt.2 ) call TIMER('After sij/store  ')
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                Initialize total Hamiltonian
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Will accumulate total Hamiltonian in wkmat(i01), clear it here:
c
      call MKZERO( nmatpr, wkmat(i01) )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c       Matrix elements of local atomic reference potentials
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  "vlocmat" computes matrix elements of local 1-ctr potentials, ie.,
c  sum of coulomb interaction of nuclei, electrostatic and xc potentials
c  due to spherical electron density distributions of reference atoms.
c  Initialize "atm0engy", the calculation of the difference between
c  the system total energy and the sum of the one-electron energies
c  The 2-ctr terms (N:II) are done in "vlocmii".
c
      call MKZERO( nmatpr, wkmat(i02) )
      call MKZERO( nmatpr, wkmat(i03) )
c
c  Set up cutoffs for local potential calculation:
c
      call MKCUTS( convs(4), convsl, convii )
c
      call VLOCMAT( IWR,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat3c,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ alamin, norba, znuc,occsh,
     $ ratm, rlat,coskr,sinkr,
     $ nrd,nrad, radmsh,radwt, vatrad, vesrad,vxcrad,excrad, wkrad,
     $ wkmat(i01), wkmat(i02), wkmat(i03), wkmat(i04) )
c -->  vloc0-o     vxc0-o      exc0-o      vtmp-s/tp
c -->  nmatpr      nmatpr      nmatpr    0(Lmatreduce=false)/nmat(Lmatreduce=true)
c
      if( lvlout.gt.2 ) call TIMER('After vlocmat    ')
c
      atm0engy = zero
c
      call VLOCMII( IWR, atm0engy,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat3c,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ alamin, norba, znuc,occsh,occij,
     $ ratm, rlat,coskr,sinkr,
     $ nrd,nrad, radmsh,radwt, vatrad, vesrad,vxcrad,excrad, wkrad,
     $ wkmat(i01), wkmat(i02), wkmat(i03), wkmat(i04) )
c -->  vloc0-io    vxc0-io     exc0-io     vtmp-s
c -->  nmatpr      nmatpr      nmatpr     3*norb*maxnorba
c
      if( lvlout.gt.2 )then
        write(IWR,*) ' '
        write(IWR,9020) ' from vlocmii, atm0engy=',atm0engy
 9020   format(1x,a,3f20.10)
      endif
c
      if( lvlout.gt.2 ) call TIMER('After vlocmii    ')
c
c Pack up contributions to Hamiltonians from local nuc potentials
c We are sorting into (i,j,k) from (k,ij) here
c
c Start from rear, i03=Exc0, so that full merge does not wipe other matrices
c
c  Store Exc0 matrix:
c
      if( .not. USE_KPSTORE )then
        call H0STORE( iexc0fl , nprocstr, master,iproc,icomm,
     $   nmatstr,nmatpr, mat,
     $   norb,nk,ncplx, natm,ntyp,itypa, norba,
     $   wkmat(i03),        wkmat(i04) )
c -->    hmatstr-is         hmatijk-s
c -->    nmatpr-i/nmatstr-s mat
      else
        call H0STOREKP( iexc0fl , nprocstr, master, iproc, icomm,
     $   nmatstr, nmatpr, mymatpr, mat,
     $   norb,nk,ncplx, natm,ntyp,itypa, norba,
     $   wkmat(i03), wkmat(i05), matstr, wkmat(i04))
c -->    hmatstr-i   hmatijk-s           hmatkbuf-s
c -->    nmatpr      mat                 matstr*ncplx
      endif
c
      if( lvlout.gt.2 .and. nprocstr.gt.1 )
     $ call TIMER('  vlocmat/store-E')
c
c  Store Vxc0 matrix:
c
      if( .not. USE_KPSTORE )then
        call H0STORE( ivxc0fl , nprocstr, master,iproc,icomm,
     $   nmatstr,nmatpr, mat,
     $   norb,nk,ncplx, natm,ntyp,itypa, norba,
     $   wkmat(i02),        wkmat(i04) )
c -->    hmatstr-is         hmatijk-s
c -->    nmatpr-i/nmatstr-s mat
      else
        call H0STOREKP( ivxc0fl , nprocstr, master,iproc,icomm,
     $   nmatstr,nmatpr, mymatpr, mat,
     $   norb,nk,ncplx, natm,ntyp,itypa, norba,
     $   wkmat(i02), wkmat(i05), matstr, wkmat(i04) )
c -->    hmatstr-i   hmatijk-s           hmatkbuf-s
c -->    nmatpr      mat                 matstr*ncplx
      endif
c
      if( lvlout.gt.2 .and. nprocstr.gt.1 )
     $ call TIMER('  vlocmat/store-V')
c
      if( lvlout.gt.2 ) call TIMER('After vloc stores')
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c           Matrix elements of non-local atomic potentials
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  In "nlocmat" compute matrix elements of non-local pseudopotentials,
c  i.e. angular-momentum-dependent contributions of nuclear potential
c  at short distances from each nucleus.
c
c  Assemble some needed angular integrals
      call MKGAUNT( gntcomb, wksm )
c
c  Set up cutoffs for non-local potential calculation:
      call MKCUTS( convs(3), convsl, convii )
c
c  Check memory sufficiency:
      maxuse1 = i0end - 1
      maxuse2 = i03 - 1 + mxang
      maxuse = MAX( maxuse1, maxuse2 )
      if( maxuse .gt. maxwk )then
        call STOPXERR( 'mem-mat0/ memory err in mat0set/nlocmat' )
      endif
c
      call MKZERO( nmatpr, wkmat(i02) )
c
c     NLOCMAT works with the matrix in stripe-distributed fashion. 
c
      call NLOCMAT( IWR,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat3c,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba, znuc,
     $ lmxnlp1,almnnl, ratm, rlat,coskr,sinkr, gntcomb,
     $ nrd,nrps, radmsh,vpsrad, wkrad,
     $ wksm(1,1), wksm(1,2),
c -->  vnlr(k)-s  vnli(k)-s
     $ wkmat(i02), wkmat(i03),     wkmat(i03) )
c -->  vnlij-o     angsav(mxang)-s vnltp-s/tp
c -->  nmatpr      mxang           0(Lmatreduce=false)/nmat(Lmatreduce=true)
c
c  Accumulate total Hamiltonian in i01, add non-local PP:
c
      call DAXPY( nmatpr, one, wkmat(i02),1, wkmat(i01),1 )
c
c  Store non-local pseudopotential matrix:
c
      if( .not. USE_KPSTORE )then
        call H0STORE( ih0nlfl , nprocstr, master,iproc,icomm,
     $   nmatstr,nmatpr, mat,
     $   norb,nk,ncplx, natm,ntyp,itypa, norba,
     $   wkmat(i02),        wkmat(i04) )
c -->    hmatstr-is         hmatijk-s
c -->    nmatpr-i/nmatstr-s mat
      else
        call H0STOREKP( ih0nlfl, nprocstr, master, iproc, icomm,
     $   nmatstr, nmatpr, mymatpr, mat,
     $   norb, nk, ncplx, natm, ntyp, itypa, norba,
     $   wkmat(i02), wkmat(i05), matstr, wkmat(i04) )
c -->    hmatstr-i   hmatijk-s           hmatkbuf-s
c -->    nmatpr      mat                 matstr*ncplx
      endif
c
      if( lvlout.gt.2 ) call TIMER('After nlocmat    ')
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                   Kinetic matrix elements
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Set up cutoffs for kinetic calculation:
c
      call MKCUTS( convs(2), convsl, convii )
c
      call TIJ( norb,nk,ncplx, natm,ntyp,nshld,nald, nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba,
     $ ratm, rlat,coskr,sinkr, wksm,
     $ wkmat(i02) )
c -->  tmat-o
c -->  nmatpr
      if( lvlout.gt.2 ) call TIMER('  tij compute    ')
c
c  Accumulate total Hamiltonian in i01, add kinetic matrix:
c
      call DAXPY( nmatpr, one, wkmat(i02),1, wkmat(i01),1 )
c
c  Store kinetic energy matrix:
c
      if( .not. USE_KPSTORE )then
        call H0STORE( ih0tfl , nprocstr, master,iproc,icomm,
     $   nmatstr,nmatpr, mat,
     $   norb,nk,ncplx, natm,ntyp,itypa, norba,
     $   wkmat(i02),        wkmat(i04) )
c -->    hmatstr-is         hmatijk-s
c -->    nmatpr-i/nmatstr-s mat
      else
        call H0STOREKP( ih0tfl , nprocstr, master,iproc,icomm,
     $   nmatstr,nmatpr, mymatpr, mat,
     $   norb,nk,ncplx, natm,ntyp,itypa, norba,
     $   wkmat(i02), wkmat(i05), matstr, wkmat(i04) )
c -->    hmatstr-i   hmatijk-s           hmatkbuf-s
c -->    nmatpr      mat                 matstr*ncplx
      endif
c
      if( lvlout.gt.2 ) call TIMER('After tij        ')
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c              Save total reference Hamiltonian
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if( .not. USE_KPSTORE )then
        call H0STORE( iham0fl, nprocstr, master,iproc,icomm,
     $   nmatstr,nmatpr, mat,
     $   norb,nk,ncplx, natm,ntyp,itypa, norba,
     $   wkmat(i01),        wkmat(i04) )
c -->    hmatstr-is         hmatijk-s
c -->    nmatpr-i/nmatstr-s mat
      else
        call H0STOREKP( iham0fl, nprocstr, master, iproc, icomm,
     $   nmatstr,nmatpr, mymatpr, mat,
     $   norb,nk,ncplx, natm,ntyp,itypa, norba,
     $   wkmat(i01), wkmat(i05), matstr, wkmat(i04) )
c -->    hmatstr-i   hmatijk-s           hmatkbuf-s
c -->    nmatpr      mat                 matstr*ncplx
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MAT0SET1
c
c
      subroutine MAT0SET1( IWR, lvlout,
     $ iovlpfl,iham0fl,ivxc0fl,iexc0fl,ih0tfl,ih0nlfl,
     $ atm0engy, mat,nmat, convs,convsl,convii,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, noad, nlat,nlat2c,nlat3c,
     $ itypa, numshl,lshel,nala,ala,cala,
     $ nocc,locc,nalsh,alsh,calsh, occsh,occij,
     $ alamin, norba, occ,znuc, lmxnlp1,almnnl,
     $ nrd, nrad,nrps,radmsh,radwt,
     $ vpsrad, vatrad,vesrad,vxcrad,excrad, wkrad, wspl,
     $ ratm, rlat, coskr,sinkr, s1atom,
     $ wksm, gntcomb, maxwk,mxang,
     $ wkmat )
c---------------------------------------------------------------
c Purpose: compute iteration-independent, (semi-)analytic matrix
c          elements over reference atoms: standard dense matrices.
c
c Written: Peter A. Schultz, 21-May-2001 for v2.47
c
c Revision history:
c  25Sep08-PAS/2.62: pass ncplx through mat0set
c  20Jun07-PAS/2.60: merge tp and serial
c  30Jul05-PAS/2.59-tp: master-only Ham writes
c  15Oct04-PAS/2.59-tp: clean-up task-parallel routines, purge
c    scratch mem (by again reordering calls).
c  15Oct04-PAS/2.59: reorder orbital mat routines
c  16Apr03-DMC: add scratch array to call.  Will be passed on to
c    nlocmat and vlocmat, to allow parallelization.
c   3Oct02-PAS/2.54: repack memory and i/o for big ham matrices
c   2Oct02-PAS/2.54: opt of non-local - purge killed variables
c  21Jun01-PAS/2.48: replace STOPs
c  21May01-PAS/2.47: extracted from main routine
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input arrays:
      DIMENSION  convs(*)
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $ nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  occsh(nshld,ntyp),occij(nshld,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp), occ(nshld,ntyp), znuc(ntyp)
      DIMENSION  lmxnlp1(ntyp),almnnl(ntyp)
      DIMENSION  nrad(ntyp),nrps(ntyp),radmsh(nrd,ntyp),radwt(nrd,ntyp)
      DIMENSION  vpsrad(nrd,4,ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat), coskr(nk,nlat),sinkr(nk,nlat)
c Output arrays:
      DIMENSION  s1atom(noad,noad,nk,natm)
      DIMENSION  vatrad(*),vesrad(*),vxcrad(*),excrad(*)
c Scratch arrays:
      DIMENSION  wkrad(nrd,*), wspl(nrd,2), wksm(nk,*)
      DOUBLE COMPLEX    gntcomb(9,5,5,2,9)
c Big scratch array:
      DIMENSION  wkmat(*)
c
c Local declarations:
      DATA  zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      write(IWR,*) 'mat0set1: standard ijkmat'
c Find out who is master:
      call MPNODE0( master )
      call MPNODE( iproc )
c
c Partition memory in big workspace:
      i01 = 1
      i02 = i01 + nmat
      i03 = i02 + nmat
      i04 = i03 + nmat
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
      nlat2c = nlat
      nlat3c = nlat
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                   Overlap matrix
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Set up cutoffs for overlap calculation:
      call MKCUTS( convs(1), convsl, convii )
c
      call SIJ1( norb,nk,ncplx, natm,ntyp,nshld,nald, nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba,
     $ ratm, rlat,coskr,sinkr,
     $ wkmat(i01) )
c -->  smat-o
c -->  nmat
c
      if( nlat2c.lt.nlat .and. lvlout.gt.3 )
     $ write(IWR,*) 'for 2c terms, nlat reduced from', nlat,
     $                                          ' to', nlat2c
c
      call TIMER('  Before mks1atm')
      call MKS1ATM( s1atom,
c -->               noad*noad*nk*natm
     $ norb,nk,ncplx, natm,ntyp, noad, itypa, norba,
     $ wkmat(i01) )
c -->  smat-io
c -->  nmat
c
      if( lvlout.gt.2 ) call TIMER('After sij        ')
c
      if( iproc .eq. master )then
c       Save overlap matrix to disk file iovlpfl:
        REWIND( unit=iovlpfl )
        call H0WRIT( iovlpfl, mat,nk, wkmat(i01) )
c
        if( lvlout.gt.2 ) call TIMER('After sij/write  ')
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                Initialize total Hamiltonian
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Will accumulate total Hamiltonian in wkmat(i01), clear it here:
      call MKZERO( nmat, wkmat(i01) )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c       Matrix elements of local atomic reference potentials
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  "vlocmat" computes matrix elements of local 1-ctr potentials, ie.,
c  sum of coulomb interaction of nuclei, electrostatic and xc potentials
c  due to spherical electron density distributions of reference atoms.
c  Initialize "atm0engy", the calculation of the difference between
c  the system total energy and the sum of the one-electron energies
c  The 2-ctr terms (N:II) are done in "vlocmii".
c
      call MKZERO( nmat, wkmat(i02) )
      call MKZERO( nmat, wkmat(i03) )
      call MKZERO( nmat, wkmat(i04) )
c
c  Set up cutoffs for local potential calculation:
c
      call MKCUTS( convs(4), convsl, convii )
c
      call VLOCMAT1( IWR,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat3c,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ alamin, norba, znuc,occsh,
     $ ratm, rlat,coskr,sinkr,
     $ nrd,nrad, radmsh,radwt, vatrad, vesrad,vxcrad,excrad, wkrad,
     $ wkmat(i01), wkmat(i02), wkmat(i03), wkmat(i04) )
c -->  vloc0-o     vxc0-o      exc0-o      vtmp-s/tp(nmat)
c -->  nmat        nmat        nmat
c
      if( lvlout.gt.2 ) call TIMER('After vlocmat    ')
c
      atm0engy = zero
      call VLOCMII1( IWR, atm0engy,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat3c,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ alamin, norba, znuc,occsh,occij,
     $ ratm, rlat,coskr,sinkr,
     $ nrd,nrad, radmsh,radwt, vatrad, vesrad,vxcrad,excrad, wkrad,
     $ wkmat(i01), wkmat(i02), wkmat(i03), wkmat(i04) )
c -->  vloc0-io    vxc0-io     exc0-io     vtmp-s(3*norb*norbat)
c -->  nmat        nmat        nmat
c
      if( lvlout.gt.2 )then
        write(IWR,*) ' '
        write(IWR,9020) ' from vlocmii, atm0engy=',atm0engy
 9020   format(1x,a,3f20.10)
      endif
c
      if( lvlout.gt.2 ) call TIMER('After vlocmii    ')
c
c Pack up contributions to Hamiltonians from local nuc potentials
c We are sorting into (i,j,k) from (k,i,j) here
c
      if( iproc .eq. master )then
c       Save Exc0 matrix to iexc0fl:
        call VLWRIT( iexc0fl, norb,nk, wkmat(i03),  wkmat(i04) )
c -->                                  vkij(nmat)-i vij(mat)-s
c       Save Vxc0 matrix to ivxc0fl:
        call VLWRIT( ivxc0fl, norb,nk, wkmat(i02),  wkmat(i04) )
c -->                                  vkij(nmat)-i vij(mat)-s
      endif
c
      call VLSORT( norb,nk, wkmat(i01), wkmat(i02) )
c -->                       vkijfrom-i  vijkto-o
      call DCOPY( nmat, wkmat(i02),1, wkmat(i01),1 )
c
      if( iproc .eq. master )then
        if( lvlout.gt.2 ) call TIMER('After vloc/write ')
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c           Matrix elements of non-local atomic potentials
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  In "nlocmat" compute matrix elements of non-local pseudopotentials,
c  i.e. angular-momentum-dependent contributions of nuclear potential
c  at short distances from each nucleus.
c
c  Assemble some needed angular integrals
      call MKGAUNT( gntcomb, wksm )
c
c  Set up cutoffs for non-local potential calculation:
      call MKCUTS( convs(3), convsl, convii )
c
c  Check memory sufficiency:
      maxuse = i04 - 1 + mxang
      if( maxuse .gt. maxwk )then
        call STOPXERR( 'mem-mat0/ memory err in mat0set/nlocmat' )
      endif
c
      call MKZERO( nmat, wkmat(i02) )
c
      call NLOCMAT1( IWR,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat3c,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba, znuc,
     $ lmxnlp1,almnnl, ratm, rlat,coskr,sinkr, gntcomb,
     $ nrd,nrps, radmsh,vpsrad, wkrad,
     $ wksm(1,1), wksm(1,2),
c -->  vnlr(k)-s  vnli(k)-s
     $ wkmat(i02), wkmat(i03),     wkmat(i03) )
c -->  vnlij-o     angsav(mxang)-s vnltp-s/tp(nmat)
c
c  Accumulate total Hamiltonian in wk01, add non-local PP:
      if( iproc .eq. master )then
        call DAXPY( nmat, one, wkmat(i02),1, wkmat(i01),1 )
      endif
c
      if( iproc .eq. master )then
c       Save non-local pseudopotential matrix to ih0nlfl:
        REWIND( unit=ih0nlfl )
        call H0WRIT( ih0nlfl, mat,nk, wkmat(i02) )
      endif
c
      if( lvlout.gt.2 ) call TIMER('After nlocmat    ')
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                   Kinetic matrix elements
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Set up cutoffs for kinetic calculation:
      call MKCUTS( convs(2), convsl, convii )
c
      call TIJ1( norb,nk,ncplx, natm,ntyp,nshld,nald, nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba,
     $ ratm, rlat,coskr,sinkr,
     $ wkmat(i02) )
c -->  tmat-o
c
c  Accumulate total Hamiltonian in wk01, add kinetic matrix:
      if( iproc .eq. master )then
        call DAXPY( nmat, one, wkmat(i02),1, wkmat(i01),1 )
      endif
c
      if( iproc .eq. master )then
c       Save kinetic energy matrix to ih0tfl:
        REWIND( unit=ih0tfl )
        call H0WRIT( ih0tfl, mat,nk, wkmat(i02) )
      endif
c
      if( lvlout.gt.2 ) call TIMER('After tij        ')
c
      if( iproc .eq. master )then
c       Save total reference Hamiltonian "h0" to iham0fl:
        REWIND( unit=iham0fl )
        call H0WRIT( iham0fl, mat,nk, wkmat(i01) )
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLSORT
c
c
      subroutine VLSORT( norb,nk, vkijfrom, vijkto )
c---------------------------------------------------------------
c Purpose: copy matrices from k-first to k-last form
c          Not very efficient, but I do not care.
c
c Written: Peter A. Schultz, 15-September-1999, for v2.39
c
c Revision History:
c  27Mar00-PAS/2.43: rename "enjisrt" to "vljisrt"
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Output array:
      DIMENSION  vijkto(norb,norb,nk)
c Input array:
      DIMENSION  vkijfrom(nk,norb,norb)
c
c >>>> EXECUTABLE CODE:
c     
      do  k=1,nk
c
        do  j=1,norb
          do  i=1,norb
            vijkto(i,j,k) = vkijfrom(k,i,j)
          enddo
        enddo
c
      enddo
c
c    That's all Folks!
c     
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLWRIT
c
c
      subroutine VLWRIT( imatfile, norb,nk, vkij, vij )
c---------------------------------------------------------------
c Purpose: copy matrices from k-first to k-last form
c          Not very efficient, but I do not care.
c
c Written: Peter A. Schultz, 15-September-1999, for v2.39
c
c Revision History:
c  27Mar00-PAS/2.43: rename "enjisrt" to "vljisrt"
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input array:
      DIMENSION  vkij(nk,norb,norb)
c Scratch array:
      DIMENSION  vij(norb,norb)
c
c >>>> EXECUTABLE CODE:
c     
      REWIND( unit=imatfile )
c
      ik = 0
  100 continue
      ik = ik + 1
c
      k = ik
      do  j=1,norb
        do  i=1,norb
          vij(i,j) = vkij(k,i,j)
        enddo
      enddo
c
      mat = norb*norb
      call H0WRIT( imatfile, mat, 1, vij )
c
      if( ik .lt. nk ) goto 100
c
c    That's all Folks!
c     
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MESH
c
c
      subroutine MESH( n1r,n2r,n3r,rprim, weight,hh, gprim )
c---------------------------------------------------------------
c Purpose: setup grid intervals, compute recip. lattice vecs
c
c Revision history:
c   8Aug03-PAS/2.56: use KCELL to generate fft cell
c  27Aug02-PAS/2.53g: sign error in rt-hand cell to gprim
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
c Input: real space primitive lattice vectors:
      DIMENSION  rprim(3,3)
c Output: real space integration grid primitive vectors
      DIMENSION  hh(3,3)
c         reciprocal space primitive cell for fft:
      DIMENSION  gprim(3,3)
c
c Local:
      DIMENSION  tvec(3)
c
c >>>> EXECUTABLE CODE:
c
c Generate fft reciprocal space vectors (i.e. full 3-D)
      kdim = 3
      call KCELL( kdim, rprim, gprim )
c
      r1n = DBLE( n1r )
      r2n = DBLE( n2r )
      r3n = DBLE( n3r )
      do  i=1,3
        hh(i,1) = rprim(i,1) / r1n
        hh(i,2) = rprim(i,2) / r2n
        hh(i,3) = rprim(i,3) / r3n
      enddo
c
      call CROSS( hh(1,2), hh(1,3), tvec )
      vol = ABS( hh(1,1)*tvec(1)+hh(2,1)*tvec(2)+hh(3,1)*tvec(3) )
      weight = vol
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKCUTS
c
c
      subroutine MKCUTS( convgf, convsl, convii )
c---------------------------------------------------------------
c Purpose: construct cutoffs from convergence parameters
c
c Written: Peter A. Schultz, 13-August-1998, for v2.24
c
c Revision history:
c  21Jun01-PAS/2.48: replaces STOPs
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c  I take the input convergence parameters, translate them into
c  exponent cutoffs, and communicate those cutoffs via common
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      cutgwfn = -LOG(convgf)
      cutslow = cutgwfn - LOG(convsl)
      cutii   = cutgwfn - LOG(convii)
      if( cutgwfn.lt.zero .or. cutslow.lt.zero .or.
     $ cutii.lt.zero ) call STOPXERR( 'bad-cuts/bad conv params' )
c
c    That's all, Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKEIKL
c
c
      subroutine MKEIKL( nk,nlat, vk,rlat,  coskr,sinkr )
c---------------------------------------------------------------
c Purpose: computes Bloch phase factors for lattice vectors
c
c Written: Peter A. Schultz, 27-March-2000, for v2.43
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  vk(3,nk), rlat(3,nlat)
c output arrays:
      DIMENSION  coskr(nk,nlat),sinkr(nk,nlat)
c local declarations:
      DATA  zero,one / 0.d0,1.d0 /
      cutoff = 1d-12
c
c >>>> EXECUTABLE CODE:
c
      do  ilat=1,nlat
c
        do  k=1,nk
c
          dot = vk(1,k)*rlat(1,ilat) + vk(2,k)*rlat(2,ilat)
     $        + vk(3,k)*rlat(3,ilat)
c
          if( dot .eq. zero )then
            coskr(k,ilat) = one
            sinkr(k,ilat) = zero
          else
            coskr(k,ilat) = COS( dot )
            sinkr(k,ilat) = SIN( dot )
          endif
c     RPM put in cutoff to make sure small values don't mess up
c     the floating point math:
          if (abs(coskr(k,ilat)) .lt. cutoff)
     $         coskr(k,ilat) = zero
          if (abs(sinkr(k,ilat)) .lt. cutoff)
     $         sinkr(k,ilat) = zero
c     
c
        enddo
c
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKGAUNT
c
c
      subroutine MKGAUNT( gntcomb,gaunt )
c---------------------------------------------------------------
c Purpose: compute linear combinations of gaunt coefficients
c          needed because of the use of real spherical harmonics
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c   8Aug94-PAS/2.11: routine still a mess even after makeover
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DOUBLE COMPLEX    gntcomb(9,5,5,2,9)
      DIMENSION  gaunt(9,25,3)
c local declarations:
      DOUBLE COMPLEX    zone,fre,fim,fac1,fc1,fac2,fc2
      DIMENSION  l(9),m(9),irl(9)
      DATA  l   / 0, 1,1,1, 2,2,2,2,2 /
      DATA  m   / 0, 1,1,0, 2,1,1,2,0 /
      DATA  irl / 1, 1,2,1, 2,2,1,1,1 /
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /
      LOGICAL  ODD
c statement function:
      ODD(int) = (AND(int,1).eq.1)
c
c create gaunt coefficients:
c
      do  ll1=1,3
        l1 = ll1 - 1
        do  mm1=1,2*l1+1
          m1 = mm1 - 1 - l1
          lm1 = l1**2 + mm1
          do  ll2=1,5
            l2 = ll2 - 1
            do  mm2=1,2*l2+1
              m2 = mm2 - 1 - l2
              lm2 = l2**2+mm2
              do 10 kk=1,3
                k = kk - 1
                if( IABS(l1-l2).gt.k .or. (l1+l2).lt.k .or.
     $              IABS(m1-m2).gt.k ) goto 10
                gaunt(lm1,lm2,kk) = CEE( l1,m1,l2,m2,k )
   10         continue
            enddo
          enddo
        enddo
      enddo
c
c clear array of stored values:
c
      do  lmp1=1,9
       do  ll2=1,5
        do  mm2=1,5
         do  i2=1,2
          do  km=1,9
           gntcomb(lmp1,ll2,mm2,i2,km) = (0.,0.)
          enddo
         enddo
        enddo
       enddo
      enddo
c
      do 500 lmp1=1,9
      l1 = l(lmp1)
      m1 = m(lmp1)
      i1 = irl(lmp1)
c
      do 430 mm2=1,5
      m2 = mm2 - 1
      do 420 ll2=mm2,5
      l2 = ll2 - 1
      do 410 i2=1,2
c
      do 300 k1=1,3
        k = k1 - 1
c
c  triangle inequality
        if( k.gt.(l1+l2) .or. k.lt.IABS(l1-l2) ) goto 300
c
        zone = DCMPLX( one, zero )
        rt2 = one/SQRT(two)
        fre = DCMPLX( rt2, zero )
        fim = DCMPLX( zero, rt2 )
c
        do 200 im1=1,2
          if( m1.eq.0 )then
            if( im1.eq.2 ) goto 200
            fac1 = zone
            mc1 = 0
          else
            if( i1.eq.2 )then
              fc1 = fim
            else
              fc1 = fre
            endif
            if( im1.eq.2 )then
              fac1 = fc1
              if( ODD(i1-1) ) fac1 = -fac1
              mc1 = -m1
            else
              fac1 = fc1
              if( ODD(m1) ) fac1 = -fac1
              mc1 = m1
            endif
          endif
c
          do 100 im2=1,2
            if( m2.eq.0 )then
              if( im2.eq.2 ) goto 100
              fac2 = zone
              mc2 = 0
            else
              if( i2.eq.2 )then
                fc2 = fim
              else
                fc2 = fre
              endif
              if( im2.eq.2 )then
                fac2 = fc2
                if( ODD(m2+i2-1) ) fac2 = - fac2
                mc2 = -m2
              else
                fac2 = fc2
                mc2 = m2
              endif
            endif
            msubk = mc1 + mc2
            if( IABS(msubk).gt.k ) goto 100
c
c      compute m-sub-k index
c
            km = k**2 + k + msubk + 1
            gntcomb(lmp1,ll2,mm2,i2,km) = gntcomb(lmp1,ll2,mm2,i2,km) +
     $       fac1*fac2* gaunt( l1**2+l1-mc1+1, l2**2+l2+mc2+1, k+1 )
c
  100     continue
  200   continue
  300 continue
c
  410 continue
  420 continue
  430 continue
  500 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKGRHO
c
c
      subroutine MKGRHO( idrhfl0,idrhofl,   nptr,
     $ grho,g2rho,gpggp,  drho,ddrho )
c---------------------------------------------------------------
c Purpose: compute, on grid, density gradients needed for gga
c          calculation from density derivatives on grid.
c
c Written: Peter A. Schultz, 11-December-2000, for v2.46 (gga)
c
c Revision history:
c  20Jul01-PAS/2.49: spin-polarized dft. mv idrhofl rewind up
c---------------------------------------------------------------
c
c Notes:
c  We need three quantities:
c   (1) grho  = | grad[rho] |
c   (2) g2rho = grad**2 [rho]
c   (3) gpggp = grad[rho] DOT grad[ | grad[rho] | ]
c  On disk(s) we have all first and second derivatives of rho:
c    d/dx,d/dy,d/dz
c    d2/dxdx, d2/dydy, d2/dzdz, d2/dxdy, d2/dydz, d2/dzdx
c  Need to accumulate:
c    grho  = SQRT( (dp/dx)**2 + (dp/dy)**2 + (dp/dz)**2 )
c    g2rho = d2p/dxdx + d2p/dydy + d2p/dzdz
c    gpggp = SUM[ du*dv*duv ] / grho
c  For vectorization, I accumulate du*dv*duv without regard
c  for grho=0, and take care of this at the end where I do the
c  final zero-checking and division by grho.
c  I need only a single second derivative field in memory
c  at any one time (plus a scratch work field to get the
c  reference + scf second derivatives), and accumulate
c  needed sums and discard. I compute grho late, so that
c  I can use it as temp scratch for this purpose.
c
c Variables:
c    idrhfl0 - file with derivatives from reference density
c    idrhofl - file with derivatives from delta (scf) density
c    nptr    - size of grid field
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0, half = 0.5d0, two = 2.d0 )
c output arrays: (gga gradients)
      DIMENSION  grho(nptr),g2rho(nptr),gpggp(nptr)
      DIMENSION  wkrd(*)
c scratch arrays: (1st derivs, 2nd deriv)
      DIMENSION  drho(nptr,3)
      DIMENSION  ddrho(nptr)
c local declarations:
c     This defines threshhold for what is considered a "zero" gradient
      DATA  vsmall / 1.d-8 /
c
c >>>> EXECUTABLE CODE:
c
c Clear out gradient terms:
      call MKZERO( nptr, grho )
      call MKZERO( nptr, g2rho )
      call MKZERO( nptr, gpggp )
c
c Retrieve first derivatives of reference atom density:
      do  iu=1,3
        call READBIG( idrhfl0, nptr, drho(1,iu) )
      enddo
c
c Retrieve first derivatives of scf delta-density ...
      do  iu=1,3
        call READBIG( idrhofl, nptr, grho )
c        ... and combine to get total density derivatives
        do  nr=1,nptr
          drho(nr,iu) = drho(nr,iu) + grho(nr)
        enddo
      enddo
c
c Retrieve double (XX,YY,ZZ) derivs of reference and scf density ...
      do  iu=1,3
        call READBIG( idrhfl0, nptr, ddrho )
        call READBIG( idrhofl, nptr, grho )
c        ... combine
        do  nr=1,nptr
          ddrho(nr) = ddrho(nr) + grho(nr)
        enddo
c        ... and accumulate gga gradient terms:
        do  nr=1,nptr
          g2rho(nr) = g2rho(nr) + ddrho(nr)
          gpggp(nr) = gpggp(nr) + drho(nr,iu)*drho(nr,iu)*ddrho(nr)
        enddo
      enddo
c
c Retrieve 2nd (XY,YZ,ZX) derivs of reference and scf density ...
      do  iu=1,3
        iv = iu + 1
        if( iv.eq.4 ) iv = 1
        call READBIG( idrhfl0, nptr, ddrho )
        call READBIG( idrhofl, nptr, grho )
c        ... combine
        do  nr=1,nptr
          ddrho(nr) = ddrho(nr) + grho(nr)
        enddo
c        ... and accumulate gga gradient terms:
        do  nr=1,nptr
          gpggp(nr) = gpggp(nr) + two*drho(nr,iu)*drho(nr,iv)*ddrho(nr)
        enddo
      enddo
c
c Assemble | grad[rho] | term in grho(), now that scratch work done:
      do  nr=1,nptr
        grho(nr) = SQRT( drho(nr,1)**2 + drho(nr,2)**2 + drho(nr,3)**2 )
      enddo
c
c And finish the gpggp term, with conditional division by grho:
      do  nr=1,nptr
        if( grho(nr).gt.vsmall )then
          gpggp(nr) = gpggp(nr) / grho(nr)
        else
          gpggp(nr) = zero
        endif
      enddo
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKGRHO0
c
c
      entry MKGRHO0( idrhfl0,   nptr,
     $ grho,g2rho,gpggp,  drho,ddrho )
c---------------------------------------------------------------
c Purpose: compute, on grid, density gradients needed for gga
c          calculation from density derivatives on grid for
c          reference density.
c---------------------------------------------------------------
c
c >>>> EXECUTABLE CODE:
c
c Clear out gradient terms:
      call MKZERO( nptr, grho )
      call MKZERO( nptr, g2rho )
      call MKZERO( nptr, gpggp )
c
c Retrieve first derivatives of reference atom density:
      do  iu=1,3
        call READBIG( idrhfl0, nptr, drho(1,iu) )
      enddo
c
c Retrieve double (XX,YY,ZZ) derivs of reference atom density ...
      do  iu=1,3
        call READBIG( idrhfl0, nptr, ddrho )
c        ... and accumulate gga gradient terms:
        do  nr=1,nptr
          g2rho(nr) = g2rho(nr) + ddrho(nr)
          gpggp(nr) = gpggp(nr) + drho(nr,iu)*drho(nr,iu)*ddrho(nr)
        enddo
      enddo
c
c Retrieve 2nd (XY,YZ,ZX) derivs of reference atom density ...
      do  iu=1,3
        iv = iu + 1
        if( iv.eq.4 ) iv = 1
        call READBIG( idrhfl0, nptr, ddrho )
c        ... and accumulate gga gradient terms:
        do  nr=1,nptr
          gpggp(nr) = gpggp(nr) + two*drho(nr,iu)*drho(nr,iv)*ddrho(nr)
        enddo
      enddo
c
c Assemble | grad[rho] | term in grho(), now that scratch work done:
      do  nr=1,nptr
        grho(nr) = SQRT( drho(nr,1)**2 + drho(nr,2)**2 + drho(nr,3)**2 )
      enddo
c
c And finish the gpggp term, with conditional division by grho:
      do  nr=1,nptr
        if( grho(nr).gt.vsmall )then
          gpggp(nr) = gpggp(nr) / grho(nr)
        else
          gpggp(nr) = zero
        endif
      enddo
c
c    That's all Folks!
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKGRHOA
c
c
      entry MKGRHOA( idrhfl0,idrhofl,idrhsfl,   nptr,
     $ grho,g2rho,gpggp,  drho,ddrho, wkrd )
c---------------------------------------------------------------
c Purpose: compute, on grid, up-spin density gradients for gga
c          calculation from density derivatives on grid.
c
c Written: Peter A. Schultz, 11-August-2001, for v2.49 (gga)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Notes:
c  We need three quantities:
c   (1) grho  = | grad[rho] |
c   (2) g2rho = grad**2 [rho]
c   (3) gpggp = grad[rho] DOT grad[ | grad[rho] | ]
c  On disk(s) we have all first and second derivatives of rho:
c    d/dx,d/dy,d/dz
c    d2/dxdx, d2/dydy, d2/dzdz, d2/dxdy, d2/dydz, d2/dzdx
c  Need to accumulate:
c    grho  = SQRT( (dp/dx)**2 + (dp/dy)**2 + (dp/dz)**2 )
c    g2rho = d2p/dxdx + d2p/dydy + d2p/dzdz
c    gpggp = SUM[ du*dv*duv ] / grho
c  For vectorization, I accumulate du*dv*duv without regard
c  for grho=0, and take care of this at the end where I do the
c  final zero-checking and division by grho.
c  I need only a single second derivative field in memory
c  at any one time (plus a scratch work field to get the
c  reference + scf second derivatives), and accumulate
c  needed sums and discard. I compute grho late, so that
c  I can use it as temp scratch for this purpose.
c
c Variables:
c    idrhfl0 - file with derivatives from reference density
c    idrhofl - file with derivatives from total delta (scf) density
c    idrhsfl - file with derivatives from up delta (scf) density
c    nptr    - size of grid field
c
c >>>> EXECUTABLE CODE:
c
c Clear out gradient terms:
      call MKZERO( nptr, grho )
      call MKZERO( nptr, g2rho )
      call MKZERO( nptr, gpggp )
c
c Retrieve first derivatives of reference density ...
      do  iu=1,3
        call READBIG( idrhfl0, nptr, drho(1,iu) )
c        ... and divide by two to get up-spin part:
        call DSCAL( nptr, half, drho(1,iu),1 )
      enddo
c
c Retrieve first derivatives of total scf delta-density ...
      do  iu=1,3
        call READBIG( idrhsfl, nptr, grho )
        call READBIG( idrhofl, nptr, wkrd )
c        ... accumulate dn-spin gradient:
        do  nr=1,nptr
          g2rho(nr) = g2rho(nr) +
     $     ( drho(nr,iu) + wkrd(nr) - grho(nr) )**2
        enddo
c        ... and combine to get total up-spin first derivatives
        do  nr=1,nptr
          drho(nr,iu) = drho(nr,iu) + grho(nr)
        enddo
      enddo
c
c Complete *dn*-spin gradient, and reinitialize borrowed array:
      do  nr=1,nptr
        wkrd(nr) = SQRT( g2rho(nr) )
      enddo
      call MKZERO( nptr, g2rho )
c
c Retrieve double (XX,YY,ZZ) derivs of reference and scf density ...
      do  iu=1,3
        call READBIG( idrhfl0, nptr, ddrho )
        call READBIG( idrhsfl, nptr, grho )
c        ... combine
        do  nr=1,nptr
          ddrho(nr) = ddrho(nr)/two + grho(nr)
        enddo
c        ... and accumulate gga gradient terms:
        do  nr=1,nptr
          g2rho(nr) = g2rho(nr) + ddrho(nr)
          gpggp(nr) = gpggp(nr) + drho(nr,iu)*drho(nr,iu)*ddrho(nr)
        enddo
      enddo
c
c Retrieve 2nd (XY,YZ,ZX) derivs of reference and scf density ...
      do  iu=1,3
        iv = iu + 1
        if( iv.eq.4 ) iv = 1
        call READBIG( idrhfl0, nptr, ddrho )
        call READBIG( idrhsfl, nptr, grho )
c        ... combine
        do  nr=1,nptr
          ddrho(nr) = ddrho(nr)/two + grho(nr)
        enddo
c        ... and accumulate gga gradient terms:
        do  nr=1,nptr
          gpggp(nr) = gpggp(nr) + two*drho(nr,iu)*drho(nr,iv)*ddrho(nr)
        enddo
      enddo
c
c Assemble | grad[rho] | term in grho(), now that scratch work done:
      do  nr=1,nptr
        grho(nr) = SQRT( drho(nr,1)**2 + drho(nr,2)**2 + drho(nr,3)**2 )
      enddo
c
c And finish the gpggp term, with conditional division by grho:
      do  nr=1,nptr
        if( grho(nr).gt.vsmall )then
          gpggp(nr) = gpggp(nr) / grho(nr)
        else
          gpggp(nr) = zero
        endif
      enddo
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKGRHOB
c
c
      entry MKGRHOB( idrhfl0,idrhofl,idrhsfl,  nptr,
     $ grho,g2rho,gpggp,  drho,ddrho, wkrd )
c---------------------------------------------------------------
c Purpose: compute, on grid, dn-spin density gradients for gga
c          calculation from density derivatives on grid.
c
c Written: Peter A. Schultz, 11-August-2001, for v2.49 (gga)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Notes:
c  We need three quantities:
c   (1) grho  = | grad[rho] |
c   (2) g2rho = grad**2 [rho]
c   (3) gpggp = grad[rho] DOT grad[ | grad[rho] | ]
c  On disk(s) we have all first and second derivatives of rho:
c    d/dx,d/dy,d/dz
c    d2/dxdx, d2/dydy, d2/dzdz, d2/dxdy, d2/dydz, d2/dzdx
c  Need to accumulate:
c    grho  = SQRT( (dp/dx)**2 + (dp/dy)**2 + (dp/dz)**2 )
c    g2rho = d2p/dxdx + d2p/dydy + d2p/dzdz
c    gpggp = SUM[ du*dv*duv ] / grho
c  For vectorization, I accumulate du*dv*duv without regard
c  for grho=0, and take care of this at the end where I do the
c  final zero-checking and division by grho.
c  I need only a single second derivative field in memory
c  at any one time (plus a scratch work field to get the
c  reference + scf second derivatives), and accumulate
c  needed sums and discard. I compute grho late, so that
c  I can use it as temp scratch for this purpose.
c
c Variables:
c    idrhfl0 - file with derivatives from reference density
c    idrhofl - file with derivatives from total delta (scf) density
c    idrhsfl - file with derivatives from up delta (scf) density
c    nptr    - size of grid field
c
c >>>> EXECUTABLE CODE:
c
c Clear out gradient terms:
      call MKZERO( nptr, grho )
      call MKZERO( nptr, g2rho )
      call MKZERO( nptr, gpggp )
c
c Retrieve first derivatives of reference density ...
      do  iu=1,3
        call READBIG( idrhfl0, nptr, drho(1,iu) )
c        ... and divide by two to get dn-spin part:
        call DSCAL( nptr, half, drho(1,iu),1 )
      enddo
c
c Retrieve first derivatives of ...
      do  iu=1,3
c        ... total delta-density:
        call READBIG( idrhofl, nptr, wkrd )
c        ... and up-spin delta-density:
        call READBIG( idrhsfl, nptr, grho )
c        ... and combine to get total dn-spin first derivatives:
        do  nr=1,nptr
          drho(nr,iu) = drho(nr,iu) + wkrd(nr) - grho(nr)
        enddo
      enddo
c
c Retrieve double (XX,YY,ZZ) derivs of reference and scf density ...
      do  iu=1,3
        call READBIG( idrhfl0, nptr, ddrho )
        call READBIG( idrhofl, nptr, wkrd )
        call READBIG( idrhsfl, nptr, grho )
c        ... combine
        do  nr=1,nptr
          ddrho(nr) = ddrho(nr)/two + wkrd(nr) - grho(nr)
        enddo
c        ... and accumulate gga gradient terms:
        do  nr=1,nptr
          g2rho(nr) = g2rho(nr) + ddrho(nr)
          gpggp(nr) = gpggp(nr) + drho(nr,iu)*drho(nr,iu)*ddrho(nr)
        enddo
      enddo
c
c Retrieve 2nd (XY,YZ,ZX) derivs of reference and scf density ...
      do  iu=1,3
        iv = iu + 1
        if( iv.eq.4 ) iv = 1
        call READBIG( idrhfl0, nptr, ddrho )
        call READBIG( idrhofl, nptr, wkrd )
        call READBIG( idrhsfl, nptr, grho )
c        ... combine
        do  nr=1,nptr
          ddrho(nr) = ddrho(nr)/two + wkrd(nr) - grho(nr)
        enddo
c        ... and accumulate gga gradient terms:
        do  nr=1,nptr
          gpggp(nr) = gpggp(nr) + two*drho(nr,iu)*drho(nr,iv)*ddrho(nr)
        enddo
      enddo
c
c Assemble | grad[rho] | term in grho(), now that scratch work done:
      do  nr=1,nptr
        grho(nr) = SQRT( drho(nr,1)**2 + drho(nr,2)**2 + drho(nr,3)**2 )
      enddo
c
c And finish the gpggp term, with conditional division by grho:
      do  nr=1,nptr
        if( grho(nr).gt.vsmall )then
          gpggp(nr) = gpggp(nr) / grho(nr)
        else
          gpggp(nr) = zero
        endif
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKGVEC
c
c
      subroutine MKGVEC( n1r,n2r,n3r,nptr, gprim, gvec )
c---------------------------------------------------------------
c Purpose: compute reciprocal lattice vectors for fft code to do
c          density derivatives
c
c Written by: Peter A. Schultz, 10-November-2000 for v2.46 (gga)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays: (recip space primitive vectors)
      DIMENSION  gprim(3,3)
c output array: (reciprocal space vectors for fft)
      DIMENSION  gvec(3,nptr)
c local declarations:
      DIMENSION  g(3),g2(3),g3(3)
c
c >>>> EXECUTABLE CODE:
c
      f1 = DBLE( (n1r+2)/2 )
      f2 = DBLE( (n2r+2)/2 )
      f3 = DBLE( (n3r+2)/2 )
      do  i=1,3
        g3(i) = - f1*gprim(i,1) - f2*gprim(i,2) - f3*gprim(i,3)
      enddo
c
      nr = 0
      do 30 j3=1,n3r
        do  i=1,3
          g3(i) = g3(i) + gprim(i,3)
          g2(i) = g3(i)
        enddo
        do 20 j2=1,n2r
          do  i=1,3
            g2(i) = g2(i) + gprim(i,2)
            g(i)  = g2(i)
          enddo
          do 10 j1=1,n1r
            g(1) = g(1) + gprim(1,1)
            g(2) = g(2) + gprim(2,1)
            g(3) = g(3) + gprim(3,1)
            nr = nr + 1
            gvec(1,nr) = g(1)
            gvec(2,nr) = g(2)
            gvec(3,nr) = g(3)
   10     continue
   20   continue
   30 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKNRWT
c
c
      subroutine MKNRWT( alf, wtsum, orig, hh, n1,n2,n3, wtwk )
c---------------------------------------------------------------
c Purpose: construct grid weighting function for "nearby" value
c
c Written: Peter A. Schultz, 3-September-1993
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  orig(3), hh(3,3)
      DIMENSION  wtwk(*)
c local declarations:
      DIMENSION  r1(3),r2(3),r3(3)
c
c >>>> EXECUTABLE CODE:
c
      do  i=1,3
        r3(i) = orig(i) - hh(i,1) - hh(i,2) - hh(i,3)
      enddo
c
      ir = 0
      do 33 j3=1,n3
        do  i=1,3
          r3(i) = r3(i) + hh(i,3)
          r2(i) = r3(i)
        enddo
        do 32 j2=1,n2
          do  i=1,3
            r2(i) = r2(i) + hh(i,2)
            r1(i) = r2(i)
          enddo
          do 31 j1=1,n1
            r1(1) = r1(1) + hh(1,1)
            r1(2) = r1(2) + hh(2,1)
            r1(3) = r1(3) + hh(3,1)
            ir = ir + 1
            wtwk(ir) = r1(1)**2 + r1(2)**2 + r1(3)**2
   31     continue
   32   continue
   33 continue
c
      do  ir=1,n1*n2*n3
        wtwk(ir) = EXP(-alf*wtwk(ir))
        wtsum = wtsum + wtwk(ir)
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKRBOX
c
c
      subroutine MKRBOX( hh,r0, nra,nrb,nrc, r )
c---------------------------------------------------------------
c Purpose: construct coordinates of regular grid from mesh
c          primitive vectors, with offset
c
c Written:  Peter A. Schultz, 1-May-1997, for v2.17
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c Not very optimized as not particularly expensive
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input array: (mesh definition vectors, r-offset)
      DIMENSION  hh(3,3), r0(3)
c output array: (output coordinates of grid points)
      DIMENSION  r(3,*)
c local declarations:
      DIMENSION  r1(3),r2(3),r3(3)
c
c >>>> EXECUTABLE CODE:
c
      do  i=1,3
c       offset initial vector
        r3(i) = r0(i)
      enddo
c
      ir = 0
      do 300 irc=1,nrc
        do  i=1,3
          r2(i) = r3(i)
          r3(i) = r3(i) + hh(i,3)
        enddo
c
        do 200 irb=1,nrb
          do  i=1,3
            r1(i) = r2(i)
            r2(i) = r2(i) + hh(i,2)
          enddo
c
          do 100 ira=1,nra
            ir = ir + 1
c           record coordinates of this grid pt.
            r(1,ir) = r1(1)
            r(2,ir) = r1(2)
            r(3,ir) = r1(3)
            r1(1) = r1(1) + hh(1,1)
            r1(2) = r1(2) + hh(2,1)
            r1(3) = r1(3) + hh(3,1)
  100     continue
  200   continue
  300 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKS1ATM
c
c
      subroutine MKS1ATM( s1atom,
     $ norb,nk,ncplx, natm,ntyp, noad, itypa, norba,
     $ smat )
c---------------------------------------------------------------
c Purpose: distill single atom overlaps from total overlap matrix
c
c Written: P.A. Schultz, 15-May-2001 for v2.47
c
c Revision history:
c  10Sep08-PAS/2.62: clean and adapt for striped-matrices
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input arrays:
      DIMENSION  itypa(natm), norba(ntyp)
      DIMENSION  smat(norb,norb,nk)
c Output array:
      DIMENSION  s1atom(noad,noad,nk,natm)
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'SDEV/mks1atm: ijkmat'
      jnext = 0
      do 1000 jatm=1,natm
        jtyp = itypa(jatm)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        j0 = jstart
c
        do  k=1,nk
c
          do  jorbat=1,norbatj
            do  iorbat=1,norbatj
              s1atom(iorbat,jorbat,k,jatm) = smat(j0+iorbat,j0+jorbat,k)
            enddo
          enddo
c
        enddo
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKS1STR
c
c
      subroutine MKS1STR( s1atom,
     $ norb,nk,ncplx, natm,ntyp, noad, itypa, norba,
     $ myj0,myatm1,myatm2,
     $ nprocstr, master,iproc,icomm,
     $ smat )
c---------------------------------------------------------------
c Purpose: distill single atom overlaps from total overlap matrix
c
c Written: P.A. Schultz, 15-May-2001 for v2.47
c          based on P.J. Feibelman's original
c
c Revision history:
c  25Sep08-PAS/2.62: pass ncplx into this routine
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  itypa(natm), norba(ntyp)
      DIMENSION  smat(nk,*)
c output array:
      DIMENSION  s1atom(noad,noad,nk,natm)
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'SDEV/mks1str: stripe-parallel'
      myatm = 0
      jjnext = 0
      jnext = myj0
      do 1000 jatm=myatm1,myatm2
        myatm = myatm + 1
        jtyp = itypa(jatm)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        matij = norbatj*norbatj
        njstripe = norb - jstart
        matjstr = norbatj*njstripe
        jjstart = jjnext
        jjnext = jjstart + matjstr*ncplx
c
        j0 = jstart
c
        ij0 = jjstart
        ij0 = ij0 - norbatj
        ijc0 = ij0 + matij
c
        do 420 jorbat=1,norbatj
c
          if( ncplx.eq.2 .and. jorbat.gt.1 )then
c           Need to flip i-j counting in stripe to pick up complex
            ijc = ijc0 + jorbat
            do 412 iorbat=1,jorbat-1
              ijc = ijc + norbatj
              do  k=1,nk
                s1atom(iorbat,jorbat,k,myatm) = smat(k,ijc)
              enddo
 412        continue
          endif
c
          ij0 = ij0 + norbatj
          do 410 iorbat=jorbat,norbatj
            ij = ij0 + iorbat
            do  k=1,nk
              s1atom(iorbat,jorbat,k,myatm) = smat(k,ij)
            enddo
  410     continue
c
  420   continue
c
c       Close Atom i loop:
 1000 continue
c
      if( nprocstr.gt.1 )then
        nvatm = noad*noad*nk
        nvtotl = nvatm*natm
        nvlocl = nvatm*myatm
        call STRMERGE( nprocstr, master,iproc,icomm, nvtotl,nvlocl,
     $   s1atom )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKSHL2D
c
c
      subroutine MKSHL2D( lshl, nrs, rngr,rsq, a0e,a1e,a2e,
     $ rho,drho,ddrh )
c---------------------------------------------------------------
c Purpose: produce radial derivatives of reference shells
c          from sums of Occ*Ca*Cb*(a+b)**N*exp(-(a+b)*r**2)
c
c Written: Peter A. Schultz, 11-January-2001, for v2.46 (gga)
c
c Revision history:
c  21Jun01-PAS/2.48: replace STOPs
c---------------------------------------------------------------
c
c  We have accumulated these sums over the gaussians of a shell:
c   aNe(r) = SUM[a;b] [ Occ*Ca*Cb * (a+b)**N * exp(-(a+b)*r**2) ]
c  for N=0,1,2.  Want to assemble density and derivatives from
c  these sums, for a shell of angular momentum l=lshl.
c
c  rho(r)      = r**(2l) * a0e(r)
c  d(rho)/dr   = [l=0] -2*r*a1e(r)
c              = [l>0] -2*r**(2l+1)*a1e(r) + 2l*r**(2l-1)*a0e(r)
c              = r**(2l-1) * ( -2*r2*a1e(r) + 2l*a0e(r) )
c  d2(rho)/dr2 = [l=0] 4*r2*a2e(r) - 2*a1e(r)
c              = [l>0] 4*r**(2l+2)*a2e(r) - (8l+2)*r**2l*a1e(r)
c                    + (2l)*(2l-1)*a0e(r)
c              = r**(2l-2) * ( 4*r4*a2e(r) - (8l+2)*r2*a1e(r) +
c                              (2l)*(2l-1)*a0e )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c input arrays: (r,r2, sums)
      DIMENSION  rngr(nrs), rsq(nrs)
      DIMENSION  a0e(nrs), a1e(nrs), a2e(nrs)
c output arrays:
      DIMENSION  rho(nrs), drho(nrs), ddrh(nrs)
c
c local declarations:
      PARAMETER ( zero=0.d0, one=1.d0, two=2.d0, four=4.d0 )
c
c >>>> EXECUTABLE CODE:
c
      twol = DBLE( 2*lshl )
c
      twolm1 = twol - one
      cab0 = twol*twolm1
      cab1 = two*( two*twol + one )
c
      if( lshl.eq.0 )then
        do  nr=1,nrs
          rho(nr) = rho(nr) + a0e(nr)
          drho(nr) = drho(nr)
     $     - a1e(nr)*two*rngr(nr)
          ddrh(nr) = ddrh(nr) +
     $     a2e(nr)*four*rsq(nr) - a1e(nr)*two
        enddo
      elseif( lshl.eq.1 )then
        do  nr=1,nrs
          r = rngr(nr)
          r2 = rsq(nr)
          rho(nr) = rho(nr) + a0e(nr)*r2
          drho(nr) = drho(nr) + r*
     $     ( a0e(nr)*twol - a1e(nr)*two*r2 )
          ddrh(nr) = ddrh(nr) +
     $     ( a2e(nr)*four*r2*r2 - a1e(nr)*cab1*r2 + a0e(nr)*cab0 )
         enddo
      elseif( lshl.eq.2 )then
        do  nr=1,nrs
          r = rngr(nr)
          r2 = rsq(nr)
          rho(nr) = rho(nr) + a0e(nr)*r2*r2
          drho(nr) = drho(nr) + r*r2*
     $     ( a0e(nr)*twol - a1e(nr)*two*r2 )
          ddrh(nr) = ddrh(nr) + r2*
     $     ( a2e(nr)*four*r2*r2 - a1e(nr)*cab1*r2 + a0e(nr)*cab0 )
        enddo
      elseif( lshl.gt.2 )then
        do  nr=1,nrs
          r = rngr(nr)
          r2 = rsq(nr)
          r2lm2 = r2**(lshl-1)
          rho(nr) = rho(nr) + a0e(nr)*r2*r2lm2
          drho(nr) = drho(nr) + r*r2lm2*
     $     ( a0e(nr)*twol - a1e(nr)*two*r2 )
          ddrh(nr) = ddrh(nr) + r2lm2*
     $     ( a2e(nr)*four*r2*r2 - a1e(nr)*cab1*r2 + a0e(nr)*cab0 )
        enddo
      else
c       This should never happen but test is free.
        call STOPXERR( 'SH2-lshl/ bad lshl in MKSHL2D' )
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKSHL1D
c
c
      entry MKSHL1D( lshl, nrs, rngr,rsq, a0e,a1e,
     $ rho,drho )
c---------------------------------------------------------------
c Purpose: shell density and first derivative only.
c---------------------------------------------------------------
c
c >>>> EXECUTABLE CODE:
c
      twol = DBLE( 2*lshl )
c
      if( lshl.eq.0 )then
        do  nr=1,nrs
          rho(nr) = rho(nr) + a0e(nr)
          drho(nr) = drho(nr)
     $     - a1e(nr)*two*rngr(nr)
        enddo
      elseif( lshl.eq.1 )then
        do  nr=1,nrs
          r = rngr(nr)
          r2 = rsq(nr)
          rho(nr) = rho(nr) + a0e(nr)*r2
          drho(nr) = drho(nr) + r*
     $     ( a0e(nr)*twol - a1e(nr)*two*r2 )
         enddo
      elseif( lshl.eq.2 )then
        do  nr=1,nrs
          r = rngr(nr)
          r2 = rsq(nr)
          rho(nr) = rho(nr) + a0e(nr)*r2*r2
          drho(nr) = drho(nr) + r*r2*
     $     ( a0e(nr)*twol - a1e(nr)*two*r2 )
         enddo
      elseif( lshl.gt.2 )then
        do  nr=1,nrs
          r = rngr(nr)
          r2 = rsq(nr)
          r2lm2 = r2**(lshl-1)
          rho(nr) = rho(nr) + a0e(nr)*r2*r2lm2
          drho(nr) = drho(nr) + r*r2lm2*
     $     ( a0e(nr)*twol - a1e(nr)*two*r2 )
        enddo
      else
c       This should never happen but test is free.
        call STOPXERR( 'SH1-lshl/ bad lshl in MKSHL1D' )
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MKSHL
c
c
      entry MKSHL( lshl, nrs, rsq, a0e, rho )
c---------------------------------------------------------------
c Purpose: shell density only, no derivatives.
c---------------------------------------------------------------
c
c >>>> EXECUTABLE CODE:
c
      if( lshl.eq.0 )then
        do  nr=1,nrs
          rho(nr) = rho(nr) + a0e(nr)
        enddo
      elseif( lshl.eq.1 )then
        do  nr=1,nrs
          rho(nr) = rho(nr) + a0e(nr) * rsq(nr)
        enddo
      elseif( lshl.eq.2 )then
        do  nr=1,nrs
          rho(nr) = rho(nr) + a0e(nr) * rsq(nr)*rsq(nr)
       enddo
      elseif( lshl.gt.2 )then
        do  nr=1,nrs
          rho(nr) = rho(nr) + a0e(nr) * rsq(nr)**lshl
        enddo
      else
c       This should never happen but test is free.
        call STOPXERR( 'SHL-lshl/ bad lshl in MKSHL' )
      endif
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MOMENT
c
c
      subroutine MOMENT( IWR, elchrg,dipole,rdipole, ndim,
     $ origws, rprim, n1r,n2r,n3r, hh, weight, ndbox,nbox,
     $ rho, r )
c---------------------------------------------------------------
c Purpose: compute the dipole moment of a charge distribution
c          known on the grid
c
c Written: Peter A. Schultz, 28-October-1998, for v2.27 (ions)
c
c Revision history:
c  14Jun00-PAS/2.45: deal with grid defect charge and dipoles
c  12Jun00-PAS/2.44: bias latvec/ws to make slab match bulk
c   9Mar99-PAS/2.32: boxed wigner-seitz periodic supercell dipole
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  10Nov98-PAS/2.27: compute and send position of cluster dipole
c---------------------------------------------------------------
c
c Input variables:
c  origws() = center of the wigner-seitz (WS) cell
c  rprim()  = primitive lattice vectors
c  hh()     = primitive vectors of grid
c  n1r,n2r,n3r = dimension of grid in three dimensions
c  ndbox()  = defines box-wise breakup of grid
c  rho()    = input electron density on grid, sorted into boxes
c
c Output variables:
c  dipole() = computed dipole moment
c  rdipole() = computed dipole position
c
c Notes:
c  This code has a zero bias, i.e., points on/near the boundary
c  contribute only to the cell with that point on the zero side
c  of the cell.  However, this "point" represents a *volume*,
c  which should be shared among the cells it overlaps.  Here, I
c  assume that the supercell approximation is sound, and that
c  the delta density at this boundary is zero.  This should be
c  dealt with properly - this ideal is never truly achieved
c  in charged systems as the density polarizes due to the charge.
c
c  Ouch.  Because of grid-inaccuracies, the density on the grid
c  does not exactly integrate to the correct number of electrons.
c  Need to address this here explicitly somehow as calculation
c  is affected by this: computed dipole depends on frame of
c  reference with net q.  The ad hoc solution here is to take the
c  defect charge off its charge centroid and compute dipole from
c  that.  Increasing vacuum region and changing reference point
c  then yields the same computed dipole.  14Jun00-PAS/2.44
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  origws(3)
c   grid generating primitive vector, and unit cell vectors
      DIMENSION  rprim(3,3), hh(3,3)
      DIMENSION  ndbox(2,2,3)
      DIMENSION  rho(*)
c output arrays:
      DIMENSION  dipole(3), rdipole(3)
c scratch arrays:
      DIMENSION  r(3,*)
c local declarations:
      DIMENSION  ctrpos(3),ctrneg(3)
      DIMENSION  r0box(3),boxctr(3)
      DIMENSION  orig(3), r1(3),r2(3),r3(3),rl(3,27)
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
c vsmall is diff between R**2's considered to be equal.
      DATA  vsmall / 0.9d-6 /
      DATA  lstout / 1 /
c
c >>>> EXECUTABLE CODE:
c
      nla = 1
      nlb = 1
      nlc = 1
      if( ndim.gt.0 ) nla = 3
      if( ndim.gt.1 ) nlb = 3
      if( ndim.gt.2 ) nlc = 3
c use a nearest neighbor search to find longest range for which you do
c not need to check for residence within wigner-seitz cell
      rngws = 9.9d9
      il = 0
c
      isc = 1
      kc = 0
      do 343 ilc=1,nlc
        r3(1) = kc*rprim(1,3)
        r3(2) = kc*rprim(2,3)
        r3(3) = kc*rprim(3,3)
        kc = kc + isc*ilc
        isc = -isc
c
        isb = 1
        kb = 0
        do 342 ilb=1,nlb
          r2(1) = r3(1) + kb*rprim(1,2)
          r2(2) = r3(2) + kb*rprim(2,2)
          r2(3) = r3(3) + kb*rprim(3,2)
          kb = kb + isb*ilb
          isb = -isb
c
          isa = 1
          ka = 0
          do 341 ila=1,nla
            il = il + 1
            rl(1,il) = r2(1) + ka*rprim(1,1)
            rl(2,il) = r2(2) + ka*rprim(2,1)
            rl(3,il) = r2(3) + ka*rprim(3,1)
            ka = ka + isa*ila
            isa = -isa
            rsqlat = rl(1,il)**2 + rl(2,il)**2 + rl(3,il)**2
            if( il.ne.1 .and. rsqlat.lt.rngws )then
              rngws = rsqlat
            endif
  341     continue
  342   continue
  343 continue
      rngws = half*SQRT( rngws )
      rsqws = rngws**2
c
c  Note: origin is at front of lattice vector list:
      nlnn = il
      rl(1,1) = zero
      rl(2,1) = zero
      rl(3,1) = zero
c
      sumrho = zero
      sumdif = zero
      sumpos = zero
      sumneg = zero
      do  j=1,3
        dipole(j) = zero
        ctrpos(j) = zero
        ctrneg(j) = zero
c Center calculation about center of WS cell:
        orig(j) = -origws(j)
      enddo
c
      irpot = 0
      do 380 ibox=1,nbox
c
c  Get basic box info
        call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $   ira0,irb0,irc0, idra,idrb,idrc )
        nrbox = idra*idrb*idrc
c
        iv0 = irpot
        irpot = irpot + nrbox
c
c  Generate coordinates
c
        call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
        r0box(1) = r0box(1) + orig(1)
        r0box(2) = r0box(2) + orig(2)
        r0box(3) = r0box(3) + orig(3)
        call MKRBOX( hh,r0box, idra,idrb,idrc, r )
c
        if( ndim.eq.0 )then
c         Cluster: WS cell same as unit cell
          do 350 nr=1,nrbox
            r1(1) = r(1,nr)
            r1(2) = r(2,nr)
            r1(3) = r(3,nr)
c
            rh = rho(iv0+nr)
            sumrho = sumrho + rh
            dipole(1) = dipole(1) + rh*r1(1)
            dipole(2) = dipole(2) + rh*r1(2)
            dipole(3) = dipole(3) + rh*r1(3)
c
            sumdif = sumdif + ABS(rh)
            if( rh.lt.zero )then
              sumneg = sumneg - rh
              ctrneg(1) = ctrneg(1) - rh*r1(1)
              ctrneg(2) = ctrneg(2) - rh*r1(2)
              ctrneg(3) = ctrneg(3) - rh*r1(3)
            else
              sumpos = sumpos + rh
              ctrpos(1) = ctrpos(1) + rh*r1(1)
              ctrpos(2) = ctrpos(2) + rh*r1(2)
              ctrpos(3) = ctrpos(3) + rh*r1(3)
            endif
  350     continue
c
        else
c         Periodic: WS not same as unit cell
          ilmn = 1
          do 370 nr=1,nrbox
            rsq = (r(1,nr)+rl(1,ilmn))**2 + (r(2,nr)+rl(2,ilmn))**2
     $          + (r(3,nr)+rl(3,ilmn))**2
c
            if( rsq.gt.rsqws .and. nlnn.gt.1 )then
c             Check if some periodic lattice image of charge is closer
              do 360 il=1,nlnn
                rsql = (r(1,nr)+rl(1,il))**2 + (r(2,nr)+rl(2,il))**2
     $               + (r(3,nr)+rl(3,il))**2
                if( ABS( rsql - rsq ) .lt. vsmall )then
c                 Should deal with points on/near boundaries better.
c                 This hack at least should make slab and bulk results
c                 match by biasing boundaries toward earlier latvecs.
                elseif( rsql.lt.rsq )then
                  rsq = rsql
                  ilmn = il
                endif
  360         continue
            endif
c
            r1(1) = r(1,nr) + rl(1,ilmn)
            r1(2) = r(2,nr) + rl(2,ilmn)
            r1(3) = r(3,nr) + rl(3,ilmn)
c
            rh = rho(iv0+nr)
            sumrho = sumrho + rh
            dipole(1) = dipole(1) + rh*r1(1)
            dipole(2) = dipole(2) + rh*r1(2)
            dipole(3) = dipole(3) + rh*r1(3)
c
            sumdif = sumdif + ABS(rh)
            if( rh.lt.zero )then
              sumneg = sumneg - rh
              ctrneg(1) = ctrneg(1) - rh*r1(1)
              ctrneg(2) = ctrneg(2) - rh*r1(2)
              ctrneg(3) = ctrneg(3) - rh*r1(3)
            else
              sumpos = sumpos + rh
              ctrpos(1) = ctrpos(1) + rh*r1(1)
              ctrpos(2) = ctrpos(2) + rh*r1(2)
              ctrpos(3) = ctrpos(3) + rh*r1(3)
            endif
  370     continue
c
        endif
c
c    Close up box loop:
c
  380 continue
c
      if( sumpos.ne.zero )then
        do  j=1,3
          ctrpos(j) = ctrpos(j)/sumpos
        enddo
      endif
      if( sumneg.ne.zero )then
        do  j=1,3
          ctrneg(j) = ctrneg(j)/sumneg
        enddo
      endif
c
c  Install grid weighting factors to get final result:
      sumrho = weight*sumrho
      dipole(1) = weight*dipole(1)
      dipole(2) = weight*dipole(2)
      dipole(3) = weight*dipole(3)
c
      sumdif = weight*sumdif
      sumpos = weight*sumpos
      sumneg = weight*sumneg
c
c  Take defect charge out of dipole calculation:
      qdefct = sumrho + elchrg
      if( qdefct.gt.zero )then
        dipole(1) = dipole(1) - qdefct*ctrpos(1)
        dipole(2) = dipole(2) - qdefct*ctrpos(2)
        dipole(3) = dipole(3) - qdefct*ctrpos(3)
      else
        dipole(1) = dipole(1) - qdefct*ctrneg(1)
        dipole(2) = dipole(2) - qdefct*ctrneg(2)
        dipole(3) = dipole(3) - qdefct*ctrneg(3)
      endif
c
      dipsq = zero
      do  idim=1,3
        dipsq = dipsq + dipole(idim)**2
      enddo
c
c
c Complete calculation of dipole location, and offset by the
c origin "origws()" of the dipole computation
      do  j=1,3
        rdipole(j) = ( ctrpos(j) + ctrneg(j) ) / two
     $   + origws(j)
      enddo
c
 9020 format(1x,a,2f20.10)
 9030 format(1x,a,3f15.8)
      if( lstout.gt.1 .and. dipsq.gt. 1.d-4 )then
        write(IWR,9020) 'MOM: ########### dipole analysis ###########'
        write(IWR,9020) 'MOM:  grid charge=',sumrho,qdefct
        write(IWR,9030) 'MOM:  grid dipole=', dipole
        write(IWR,9030) 'MOM:  dipole origin=',rdipole
        if( lstout.gt.3 )then
          write(IWR,9020) 'MOM:  grid charge movement=',sumdif
          write(IWR,9020) 'MOM:  grid positive charge=',sumpos
          write(IWR,9030) 'MOM:  positive centroid=',ctrpos
          write(IWR,9020) 'MOM:  grid negative charge=',sumneg
          write(IWR,9030) 'MOM:  negative centroid=',ctrneg
        endif
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEARBY
c
c
      subroutine NEARBY( nearest, natm, itypa, norba,
     $  ratm, rprim,hh,n1r,n2r,n3r,nptr, mngr3,mxgr3,ngr,
     $  r,  rsq )
c---------------------------------------------------------------
c Purpose: find mesh point nearest each atom
c
c Written: Peter A. Schultz, 30-August-1993
c
c Revision history:
c  15Feb08-PAS/2.60f: fix nearby indexing error; skip brute force
c  14Jun05-PAS/2.59: File units
c  21Jun01-PAS/2.48: replace print statements
c  21Dec99-PAS/2.42: comsetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c   1May97-PAS/2.17: naming conventions, new grid coord rtn
c  15Dec95-PAS/2.14: shell-by-shell grid ranges
c---------------------------------------------------------------
c
c  Original pjf scheme to find the grid point nearest an atom is
c  brute force search of all grid points within the primary unit
c  cell.  I translate each atom to put it into the primary unit
c  cell to guarantee accuracy (in all but pathological cases).
c
c  In new algorithm to find grid point nearest an atom, begin by
c  finding the coordinates of atom in terms of the grid-defining
c  vectors (solving a 3X3 system of equations), round to integers,
c  perform a very local search, and bring the resulting nearby
c  points (if necessary) back into the primary unit cell by a
c  translation.  This works only with "well-behaved" sets of mesh
c  definition vectors.  Sufficient but not necessary conditions:
c    1. vec3 normal to plane of vec1/vec2 and and projections of
c       vec1 and vec2 onto each other does not exceed the other
c OR 2. all vecs project onto one another < 1/2 and projection of
c       each vector onto the plane defined by the other two falls
c       the primary parallelpiped.
c  These conditions could be satisfied by transforming input grid
c  vectors into a more suitable set, something I do not attempt
c  here.  Instead, I just check simple stringent test, and default
c  to pjf brute force scheme if vectors fail (they usually pass).
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input arrays:
      DIMENSION  itypa(*),norba(*)
      DIMENSION  ratm(3,natm),hh(3,3),rprim(3,3)
      DIMENSION  mngr3(*),mxgr3(*),ngr(*)
c Output array:
      DIMENSION  nearest(3,natm)
c Scratch arrays:
      DIMENSION  r(3,nptr),rsq(nptr)
c
c Local declarations:
      DIMENSION  r0(3),nprim(3),v(3),rat(3),rnr(3),rv(3),gg(3,3)
      DATA  zero,half,one / 0.0d0,0.5d0,1.0d0 /
      DATA  del / 0.49999999d0 /
      DATA  lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
c First, check if unprepared projection scheme will work
c Actually, we will do "smart" scheme, do basic check, and then
c  revert to brute force (nrmeth=0) only if simple check actually
c  other than just assume smart scheme fails at the outset.
      h11 = hh(1,1)*hh(1,1) + hh(2,1)*hh(2,1) + hh(3,1)*hh(3,1)
      h22 = hh(1,2)*hh(1,2) + hh(2,2)*hh(2,2) + hh(3,2)*hh(3,2)
      h33 = hh(1,3)*hh(1,3) + hh(2,3)*hh(2,3) + hh(3,3)*hh(3,3)
      h12 = hh(1,1)*hh(1,2) + hh(2,1)*hh(2,2) + hh(3,1)*hh(3,2)
      h23 = hh(1,2)*hh(1,3) + hh(2,2)*hh(2,3) + hh(3,2)*hh(3,3)
      h13 = hh(1,3)*hh(1,1) + hh(2,3)*hh(2,1) + hh(3,3)*hh(3,1)
      nrmeth = 1
      if( h13.eq.zero .and. h23.eq.zero )then
        if( ABS(h12).gt.h11 .or. ABS(h12).gt.h22 )then
          nrmeth = 0
        endif
      else
        if( ABS(h12).gt.half*h11 .or. ABS(h12).gt.half*h22 )then
          nrmeth = 0
        endif
c       There are other conditions necessary to guarantee
        nrmeth = 0
      endif
c
c Set up ranges for test to see if we got it right:
      call CROSS( hh(1,1),hh(1,2), gg(1,3) )
      call CROSS( hh(1,2),hh(1,3), gg(1,1) )
      call CROSS( hh(1,3),hh(1,1), gg(1,2) )
      g1mag = SQRT( gg(1,1)**2 + gg(2,1)**2 + gg(3,1)**2 )
      g2mag = SQRT( gg(1,2)**2 + gg(2,2)**2 + gg(3,2)**2 )
      g3mag = SQRT( gg(1,3)**2 + gg(2,3)**2 + gg(3,3)**2 )
      do  ir=1,3
        gg(ir,1) = gg(ir,1)/g1mag
        gg(ir,2) = gg(ir,2)/g2mag
        gg(ir,3) = gg(ir,3)/g3mag
      enddo
      r1eff = ABS( hh(1,1)*gg(1,1) + hh(2,1)*gg(2,1) + hh(3,1)*gg(3,1) )
      r2eff = ABS( hh(1,2)*gg(1,2) + hh(2,2)*gg(2,2) + hh(3,2)*gg(3,2) )
      r3eff = ABS( hh(1,3)*gg(1,3) + hh(2,3)*gg(2,3) + hh(3,3)*gg(3,3) )
c     Set up length along long diagonal from center of box to corner
c      as approximate maximum distance from atom to nearest grid point:
      ratnrmax = SQRT( r1eff**2+r2eff**2+r3eff**2 ) / 1.99d0
c
      nprim(1) = n1r
      nprim(2) = n2r
      nprim(3) = n3r
c
      iorb = 0
      do 1000 iatm=1,natm
c
c       Project atom position onto grid vectors
        call PROJLV( ratm(1,iatm), hh(1,1),hh(1,2),hh(1,3), v )
        do  iprim=1,3
          iv = 0
          if( v(iprim).gt.-del )then
            iv = (v(iprim) + del)
          else
            iv = -ABS(v(iprim)-half)
          endif
          nearest(iprim,iatm) = iv
        enddo
c
        do  i=1,3
          rat(i) = ratm(i,iatm)
        enddo
        do  iprim=1,3
          nv = 0
          if( nearest(iprim,iatm).lt.0 )then
            nv = -nearest(iprim,iatm) + nprim(iprim) - 1
            nv = nv/nprim(iprim)
          elseif( nearest(iprim,iatm).ge.nprim(iprim) )then
            nv = -( nearest(iprim,iatm)/nprim(iprim) )
          endif
          nearest(iprim,iatm) = nearest(iprim,iatm) + nv*nprim(iprim) +1
c         Translate atom coordinates into primary unit cell:
          do  i=1,3
            rat(i) = rat(i) + DBLE(nv)*rprim(i,iprim)
          enddo
        enddo
c
        rsqmin = zero
        do  i=1,3
          rnr(i) = zero
          do  iprim=1,3
            rnr(i) = rnr(i) + DBLE(nearest(iprim,iatm)-1)*hh(i,iprim)
          enddo
          rv(i) = rnr(i) - rat(i)
          rsqmin = rsqmin + rv(i)*rv(i)
        enddo
c       Perform a local search about this point:
        nr1 = nearest(1,iatm)
        nr2 = nearest(2,iatm)
        nr3 = nearest(3,iatm)
        do 163 idif3= -1,1
          do 162 idif2= -1,1
            do 161 idif1= -1,1
              rsqdif = 0
              do  i=1,3
                v(i) = DBLE(idif1)*hh(i,1) + DBLE(idif2)*hh(i,2)
     $               + DBLE(idif3)*hh(i,3)
                rsqdif = rsqdif + (rv(i)+v(i))**2
              enddo
              if( rsqdif.lt.rsqmin )then
                rsqmin = rsqdif
                nearest(1,iatm) = nr1 + idif1
                nearest(2,iatm) = nr2 + idif2
                nearest(3,iatm) = nr3 + idif3
                rnr(1) = rat(1) + rv(1) + v(1)
                rnr(2) = rat(2) + rv(2) + v(2)
                rnr(3) = rat(3) + rv(3) + v(3)
              endif
  161       continue
  162     continue
  163   continue
        if( nearest(1,iatm).ne.nr1 .or. nearest(2,iatm).ne.nr2 .or.
     $      nearest(3,iatm).ne.nr3 )then
c         Check to see that have not inadvertantly left unit cell
          do  iprim=1,3
            if( nearest(iprim,iatm).lt.1 )then
              nearest(iprim,iatm) = nearest(iprim,iatm) + nprim(iprim)
            elseif( nearest(iprim,iatm).gt.nprim(iprim) )then
              nearest(iprim,iatm) = nearest(iprim,iatm) - nprim(iprim)
            endif
          enddo
        endif
c
        if( lstout.gt.0 )then
          call FLGETIWR( IWR )
          write(IWR,*) ' '
          write(IWR,*) 'NEARBY: results'
          write(IWR,*) 'Atom Posn ',iatm,-1,-1,-1,(ratm(i,iatm),i=1,3)
          write(IWR,*) 'Atom shft ',iatm,-2,-2,-2,(rat(i),i=1,3)
          write(IWR,*) 'Atom near ',iatm,(nearest(i,iatm),i=1,3),
     $                  (rnr(i),i=1,3)
        endif
c
        ratnr = (rat(1)-rnr(1))**2 + (rat(2)-rnr(2))**2
     $        + (rat(3)-rnr(3))**2
        ratnr = SQRT( ratnr )
c
        if( ratnr .gt. ratnrmax )then
C        if( nrmeth.eq.0 )then
c
c          PJF BRUTE FORCE SCHEME, MUCH REVISED:
c
          r0(1) = zero
          r0(2) = zero
          r0(3) = zero
          call MKRBOX( hh,r0, n1r,n2r,n3r, r )
c
          imin3 = mngr3(iorb+1)
          imax3 = mxgr3(iorb+1)
          do  iorbat=1,norba(itypa(iatm))
            iorb = iorb + 1
            if( mngr3(iorb).gt.imin3 ) imin3 = mngr3(iorb)
            if( mxgr3(iorb).lt.imax3 ) imax3 = mxgr3(iorb)
          enddo
          nrii = n1r*n2r*(imax3-imin3+1)
          nr0 = n1r*n2r*(imin3-1)
c
c         Compute r**2 at each point within range of atom
          do  nr=nr0+1,nr0+nrii
            rsq(nr) = (r(1,nr)-rat(1))**2 + (r(2,nr)-rat(2))**2 +
     $                (r(3,nr)-rat(3))**2
          enddo
c
          nearpt = n1r*n2r*(nearest(3,iatm)-1) +
     $             n1r*(nearest(2,iatm)-1) + nearest(1,iatm)
          rsqmin = rsq(nearpt)
          do  nr=nr0+1,nr0+nrii
            if( rsq(nr).lt.rsqmin )then
              rsqmin = rsq(nr)
              nearpt = nr
            endif
          enddo
c
          nearm1 = nearpt - 1
          n3a =  nearm1 / (n1r*n2r)
          n2a = (nearm1 - n1r*n2r*n3a) / n1r
          n1a =  nearm1 - n1r*n2r*n3a - n1r*n2a
c
          nearest(1,iatm) = n1a + 1
          nearest(2,iatm) = n2a + 1
          nearest(3,iatm) = n3a + 1
c
          if( lstout.gt.0 )then
           do  i=1,3
             rnr(i) = zero
             do  iprim=1,3
               rnr(i) = rnr(i) + DBLE(nearest(iprim,iatm)-1)*hh(i,iprim)
             enddo
           enddo
C           print*,'Atmnrpjf',iatm,(nearest(i,iatm),i=1,3),(rnr(i),i=1,3)
          endif
c
        endif
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBASSGN
c
c
      subroutine NEBASSGN( IWR, image,neb_step, ierror,
     $ node,neb_master,nodes,
     $ nimg_neb, natm,imgstat, ratm,
     $ ratm_neb,  ntmp, tmp, igrouplist, ngroup, icomm )
c---------------------------------------------------------------
c Purpose: assign NEB images to nodes
c
c Written: Peter A. Schultz, 21-January-2002, for v2.54
c
c Revision history:
c   6Jul06-APT/    : merged task parallel and image parallel
c  10Feb05-PAS/2.58b: fix NEBASTOP/neb_step misuse
c  11Nov02-PAS/2.54d: better stop
c---------------------------------------------------------------
c
c At this point, I have coordinates and completion status
c - in imgstat() - for each image in the NEB.  This routine
c assigns images to groups of nodes, sending each node in 
c each group the coordinates (and identity) for the image 
c it is assigned.
c Must anticipate the following possibilities:
c (0) This documentation was blindly extended to from nodes 
c     to groups of nodes. It may no longer be correct.     
c (1) Status is: all images complete (ie. with E and forces)
c     Noone has any work to do ... must update geometries.
c     This should have been done elsewhere -> error if happens
c (2) Each group gets an image to work on (the default).
c     Easy.
c (3) Some groups are busy through an NEB step ...
c     Easy.
c (4)  ... and some idle groups never get work to do.
c     This is non-trivial, because some nodes will get stopped
c     in the nebsetup while others will get through to the
c     nebupdate phase.  They will need to be made to sync up,
c     either to start the next NEB step, or at finish of NEB.
c
c     The available groups of nodes are stored in the array
c     igrouplist, giving the global node id of the first node
c     in each group. ngroup is the number of groups. nroup is
c     assumed to never exceed the number of images, although
c     there may be reasons to want to allow this.
c
c 
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Output (coordinates for scf calculation)
      DIMENSION  ratm(3,natm)
c Input quantities
      DIMENSION  ratm_neb(3,natm,*)
      DIMENSION  imgstat(*)
c Input: List of first node id in each group of nodes.
      DIMENSION igrouplist(*)
c Scratch space:
      DIMENSION  tmp(*)
c
c >>>> EXECUTABLE CODE:
c
      ierror = 0
c
      if( node.eq.neb_master )then
c
        image = 0
        if( nodes.eq.1 )then
c         Serial calculation
c
c         Find next undone image:
          do 100 img=1,nimg_neb
            if( imgstat(img).eq.1 )then
c             Found free image ...
              image = img
c              ... and transfer coordinates into work coords:
              call DCOPY( 3*natm, ratm_neb(1,1,image),1, ratm,1 )
              goto 190
            endif
  100     continue
          ierror = 1
          call STOPXERR( 'NEBASSGN: no unfinished images to assign' )
c
  190     write(IWR,*) '>>>>> Working on NEB image#',image
c
c         End branch #nodes=1
        else
c         Non-Idiot-parallel NEB, #nodes>1 -> assign images to groups of nodes
c
          img0 = 0
          do 300 igroup = 1,ngroup
c
c           Find next undone image:
            do 200 img=img0+1,nimg_neb
              if( imgstat(img).eq.1 )then
                imgtodo = img
                goto 210
              endif
  200       continue
c           Did not find an image needing work for nodei
            goto 301
c
  210       img0 = imgtodo
c
            do nodei = igrouplist(igroup),igrouplist(igroup+1)-1
            if( nodei.eq.neb_master )then
c             This image assignment stays on neb_master node
              image = imgtodo
              call DCOPY( 3*natm, ratm_neb(1,1,imgtodo),1, ratm,1 )
            else
c             Pack and ship off image {image,R[image]} to nodei
              call ASSGNPUT( node, nodei, neb_master, imgtodo,neb_step,
     $         3*natm, ratm_neb(1,1,imgtodo), ntmp, tmp, icomm )
            endif
c
            write(IWR,'(a,i4,a,i6)')
     $       '>>>>> NEB image#',imgtodo,' assigned to node#',nodei
            end do
c
  300     continue
  301     continue
c
c         End branch of #nodes>1.
        endif
c
c       End branch node=neb_master
      else
c       node.ne.neb_master (and, by implication, #nodes>1)
c
c       Receive and unpack assignment {image,R[image]} from neb_master
        call ASSGNGET( node, neb_master, neb_master, image,neb_step,
     $   3*natm, ratm, ntmp, tmp, icomm )
c
c       If this node got a null assignment, signal to stop:
        if( image.eq.0 )then
          write(IWR,*) '>>>>> Null NEB assignment at node#',node
          call STOPXOK( 'end NEB' )
        endif
c
        write(IWR,'(a,i4,a,i6)')
     $   '>>>>> NEB image#',image  ,' assigned to this node#',node
c
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBASTOP
c
c
      entry      NEBASTOP( IWR, node,neb_master,nodes, ntmp, tmp, 
     $     igrouplist, ngroup, icomm )
c---------------------------------------------------------------
c Purpose: send null assignments to nodes to terminate NEB
c
c Written: Peter A. Schultz, 29-January-2002, for v2.54
c
c Revision history:
c  10Feb05-PAS/2.58b: fix NEBASTOP/neb_step misuse
c---------------------------------------------------------------
c
      if( node.eq.neb_master )then
c
        write(IWR,*) '>>>> Terminating NEB'
        if( nodes.eq.1 )then
c         Serial calculation: #nodes=1 -> do nothing
c
c         End branch #nodes=1
        else
c         Idiot-parallel NEB: #nodes>1 -> send null assignments
c
          i_data = 1
          n_data = 1
          i_tmp2 = i_data + n_data
          ntmp2 = ntmp - n_data
          lendata = 0
c
          do 600 igroup=1,ngroup
            do nodei = igrouplist(igroup),igrouplist(igroup+1)-1
               node_to = nodei
c     **** using "node_to=0,nodes-1" loop triggers a compiler
c     **** error (seg-fault).  Using an intermediate variable
c     **** prevent compiler mistake.  6Oct02-PAS
               imgtodo = 0
               neb_stop = 0
               if( node_to.ne.node )then
c     Pack up and ship off null assignment
                  call ASSGNPUT( node,node_to,neb_master, 
     $                 imgtodo,neb_stop,
     $                 lendata, tmp(i_data), ntmp, tmp(i_tmp2), icomm )
               endif
            end do
 600     continue
c
c         End #nodes>1
        endif
c
c       End node=neb_master
      else
c       node.ne.neb_master -> not allowed here.
        call STOPXERR( 'NEBASTOP: node.ne.neb_master' )
      endif
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBDAT
c
c
      subroutine NEBDAT( IWR,IDAT,
     $ neb_step, nimg_neb, nimg_max, ea_neb,eb_neb, spring_neb,
C     $ dt_neb,nsteps_neb,
     $ Lantikink_neb,Loptall_neb, 
     $ Lclimb_neb, Lnoninteract, Lrestart_neb,
     $ natm, imgstat, ratma,ratmb, ratm_neb )
c---------------------------------------------------------------
c Purpose: read definition of nudged elastic band
c
c Written: Aidan Thompson, Art Edwards, and Peter A. Schultz
c          December-2001
c
c Revision history:
c   9Apr15-PAS/2.66: lnwrite lines
c  11May05-RMV/2.59: add flags: climb-NEB, noninteracting images
c  20Jan03-PAS/2.54e: change keywords to set NEB flag options
c  10Jan02-PAS/2.54: adapted for lcao production code
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      LOGICAL    Lantikink_neb, Loptall_neb
      LOGICAL    Lclimb_neb, Lnoninteract
      LOGICAL    Lrestart_neb
c  coordinates for initial, final, and intermediate NEB images
      DIMENSION  ratma(3,natm),ratmb(3,natm), ratm_neb(3,natm,*)
      DIMENSION  imgstat(*)
c local declarations:
      PARAMETER  ( nline = 128 )
      CHARACTER    label*(nline), readlbl*6, wantlbl*6
      EQUIVALENCE  (label,readlbl)
c
c >>>> EXECUTABLE CODE:
c
 8000 format(a128)
 9000 format(1x,a)
 9010 format(1x,3f20.8)
c
c We use setdata input as initial start-point:
      img0stat = 1
c  ... and we do not yet have a final end-product:
      imgnstat = 0
c
c >>>> Required data for NEB run:
c
c Header for NEB section:
      wantlbl = 'neb da'
      read(IDAT,8000,err=1300,end=1300)  label
      call LNWRIT( IWR, label, nline )
c
      if( readlbl.ne.wantlbl )then
        write(IWR,*) '>>>>> looking for neb data section'
        write(IWR,*) '>>>>> incorrect label'
        write(IWR,*) '>>>>> looking for: >neb data<'
        goto 1301
      endif
c
      wantlbl = 'images'
      read(IDAT,8000,err=1300,end=1300)  label
      call LNWRIT( IWR, label, nline )
c
c The number of this NEB step
c (optional)
      wantlbl = 'neb st'
      if( readlbl.eq.wantlbl )then
        read(IDAT,*)  neb_step
        write(IWR,'(1x,i6)')  neb_step
        if( neb_step.lt.0 ) call STOPXERR( 'NEB restart: bad step' )
c
        wantlbl = 'images'
        read(IDAT,8000,err=1300,end=1300)  label
        call LNWRIT( IWR, label, nline )
      endif
c
c Number of images (and possibly atoms - ignored):
c (required)
      wantlbl = 'images'
      if( readlbl.eq.wantlbl )then
        read(IDAT,*)  nimg_neb
        write(IWR,'(1x,i6)')  nimg_neb
c
        if( nimg_neb.gt.nimg_max )then
          write(IWR,*) '>>>>> max number of neb images=',nimg_max
          call STOPXERR( 'nebdat - too many neb images' )
        endif
      else
        write(IWR,*) 'images - number of NEB images?'
        goto 1301
      endif
c
c
c Total energy of initial start-point
c (required)
      wantlbl = 'einiti'
      read(IDAT,8000,err=1300,end=1300)  label
      call LNWRIT( IWR, label, nline )
c
      if( readlbl.eq.wantlbl )then
        read(IDAT,*)  ea_neb
        write(IWR,9010)  ea_neb
      else
        write(IWR,*) 'einitial - energy of initial image for NEB?'
        goto 1301
      endif
c
c Start-point coordinates:
c (optional - defaults to setdata input)
      wantlbl = 'coordi'
      read(IDAT,8000,err=1300,end=1300)  label
      call LNWRIT( IWR, label, nline )
c
      call ATFMTIN( jatmfmt, label )
      if( jatmfmt.ge.0 )then
        call COORDRD( IDAT, jatmfmt, natm, ratma )
        call COORDWR( IWR ,          natm, ratma )
        img0stat = 1
c
        wantlbl = 'efinal'
        read(IDAT,8000,err=1300,end=1300)  label
        call LNWRIT( IWR, label, nline )
C     else
C       write(IWR,*) 'coordinates (x y z)?'
C       call STOPXERR( 'NEB restart: start-pt coords missing' )
      endif
c
c Total energy of end-product
c (required)
      wantlbl = 'efinal'
      if( readlbl.eq.wantlbl )then
        read(IDAT,*)  eb_neb
        write(IWR,9010)  eb_neb
      else
        write(IWR,*) 'efinal - energy of final image for NEB?'
        goto 1302
      endif
c
c End-product coordinates
c (required)
      wantlbl = 'coordi'
      read(IDAT,8000,err=1300,end=1300)  label
      call LNWRIT( IWR, label, nline )
c
      call ATFMTIN( jatmfmt, label )
      if( jatmfmt.ge.0 )then
c       Get atomic coordinates for end-product:
        call COORDRD( IDAT, jatmfmt, natm, ratmb )
        call COORDWR( IWR ,          natm, ratmb )
        imgnstat = 1
      else
        write(IWR,*) 'atom, type, coordinates for endpoint of NEB?'
        goto 1302
      endif
c
c  ... and then parse *optional* inputs
c (required: an "end neb data" to signal end of neb data)
c
  100 continue
      wantlbl = 'end_ne'
      read(IDAT,8000,err=1301,end=1301)  label
      call LNWRIT( IWR, label, nline )
c
  101 continue
      if    ( readlbl.eq. 'end ne' .or.
     $        readlbl.eq. 'end_ne' )then
c       End of neb parameter input
        goto 990
c
C      elseif( readlbl.eq. 'timest' )then
Cc       Timestep size for nudged elastic band damped dynamics
C        read(IDAT,*)  dt_neb
C        write(IWR,'(1x,f15.8)')  dt_neb
Cc
C      elseif( readlbl.eq. 'nsteps' )then
Cc       Number of steps for nudged elastic band damped dynamics
C        read(IDAT,*)  nsteps_neb
C        write(IWR,'(1x,i8)')  nsteps_neb
Cc
      elseif( readlbl.eq. 'nebspr' )then
c       Spring constant for nudged elastic band
        read(IDAT,*)  spring_neb
        write(IWR,'(1x,f15.8)')  spring_neb
c
      elseif( readlbl.eq. 'antiki' )then
c       Flag to use anti-kink method (uphill-only tangent)
cpas:
        write(IWR,*) 'Antikink turned ON, to turn off use: no_antikink'
        Lantikink_neb = .true.
      elseif( readlbl.eq. 'no_ant' )then
c       Flag to turn off anti-kink method
        Lantikink_neb = .false.
c
cpas: note change of keyword structure for NEB
      elseif( readlbl.eq. 'optall' )then
c       Flag to drive minimal/maximal points downhill/uphill
        write(IWR,*) 'optall keyword changed, use: extreme|no_extreme'
        call STOPXERR( 'change optall => extreme|no_extreme' )
c
      elseif( readlbl.eq. 'extrem' )then
c       Push nearest images to minimum/maximum points along band
        Loptall_neb = .true.
      elseif( readlbl.eq. 'no_ext' )then
c       Do not push images to minimum/maximum points along band
        Loptall_neb = .false.
c
      elseif( readlbl.eq.'climb ' )then
c       Push high images to maxima (climbing image NEB)
        Lclimb_neb = .true.
c      elseif( readlbl.eq.'climbn' )then
c         Do not push high images to maxima
c         Lclimb_neb = .false.
c
      elseif( readlbl.eq.'nointer' )then
c       Non-interacting images
         Lnoninteract = .true.
c
      elseif( readlbl.eq. 'restar' )then
c       Use restrart of nudged elastic band
        Lrestart_neb = .true.
cpas:
        write(IWR,*) 'Restart turned ON, to turn off use: no_restart'
      elseif( readlbl.eq. 'no_res' )then
c       Prevent restart of nudged elastic band
        Lrestart_neb = .false.
c
      elseif( readlbl(1:5).eq. 'image' )then
c       Get geometry of one of the NEB images
        if( readlbl(6:6).eq. ' ' .or.
     $      readlbl(6:6).eq. 'I' )then
c         Coordinates for an intermediate image, which one?
          read(IDAT,*)  image
          write(IWR,'(1x,i4)')  image
          if( image.lt.1 .or. image.gt.nimg_neb )then
c           Number of image is outside the number in the NEB
            call STOPXERR( 'NEBDAT: image# is out-of-bounds' )
          endif
c
c       Following are non-standard, included only for completeness
        elseif( readlbl(6:6).eq. '0' )then
          image = 0
        elseif( readlbl(6:6).eq. 'N' )then
          image = -1
        else
          wantlbl = 'image '
          goto 1301
        endif
c
c       Find out format type of atom input line ...
        wantlbl = 'coordi'
        read(IDAT,8000)  label
        call LNWRIT( IWR, label, nline )
        call ATFMTIN( jatmfmt, label )
        if( jatmfmt.lt.0 )then
          write(IWR,9000) 'coordinates ( x y z )?'
          goto 1301
        endif
c
c        ... and extract coordinates from input:
        if( image.gt.0 .and. image.le.nimg_neb )then
c         Intermediate image
          call COORDRD( IDAT, jatmfmt, natm, ratm_neb(1,1,image) )
          call COORDWR( IWR ,          natm, ratm_neb(1,1,image) )
          imgstat(image) = 1
        elseif( image.eq.0 )then
c         Initial-reactant positions
          call COORDRD( IDAT, jatmfmt, natm, ratma )
          call COORDWR( IWR ,          natm, ratma )
          img0stat = 1
        elseif( image.lt.0 )then
c         End-product positions
          call COORDRD( IDAT, jatmfmt, natm, ratmb )
          call COORDWR( IWR ,          natm, ratmb )
          imgnstat = 1
        endif
c
      else
        call STOPXERR( 'NEBDAT - unknown command' )
c
      endif
c
      goto 100
c
c >>>> Provide summary of NEB data:
c
  990 continue
      write(IWR,9991)  nimg_neb,  ea_neb,eb_neb,spring_neb,
C     $ dt_neb,nsteps_neb,
     $ Lantikink_neb,Loptall_neb,Lclimb_neb,Lrestart_neb
 9991 format(/1x,'NEB parameter summary:',
     $    ' Nimage, Estart, Eend, spring',
C     $    ', dt, nsteps',
     $ /   1x,i3,  3(1x,f15.8),
C     $     1x,f15.8,1x,i3,
     $ /   1x,'NEB options: antikink, optall, climb, restart=',
     $     4(1x,l8) / )
c
c Check for noninteracting image calculation
      if( Lnoninteract )then
         write(IWR,*)  '>>>> CAUTION: Noninteracting images selected.'
      endif
c Check status of endpoints:
      if( img0stat.eq.0 .or. imgnstat.eq.0 )
     $ call STOPXERR( 'NEB: either initial or final end-point missing' )
c
      RETURN
c
c >>>> ERROR handling
c
 1300 continue
      write(IWR,*)  'neb data: error/end reading neb data'
 1301 continue
      write(IWR,*) '>>>>> Want label >',wantlbl,'<, found >',readlbl,'<'
 1302 continue
      call STOPXERR( 'NEBDAT: format error in input file' )
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBFILL
c
c
      subroutine NEBFILL( IWR, natm, nimg_neb,imgstat,
     $ ratma,ratmb, ratm_neb, ratmx )
c---------------------------------------------------------------
c Purpose: fill in missing NEB images
c
c Written: Peter Schultz, 14-January-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c The current code uses linear interpolation to fill in missing
c images in the NEB.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input/output declarations ...
c  ... coordinates for initial, final, and intermediate NEB images
      DIMENSION  ratma(3,natm),ratmb(3,natm), ratm_neb(3,natm,*)
c  ... existence of coordinates for given image
      DIMENSION  imgstat(*)
c Scratch:
      DIMENSION  ratmx(3,natm,2)
c Local:
      DATA       zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Initialize lead point coordinates with initial start-point:
      do  iatm=1,natm
        ratmx(1,iatm,1) = ratma(1,iatm)
        ratmx(2,iatm,1) = ratma(2,iatm)
        ratmx(3,iatm,1) = ratma(3,iatm)
      enddo
      imglast = 0
c
  100 continue
c
c Find the first empty image:
c (and, thereby, the filled image "img0" at start of open interval)
c
      do 150 img=imglast+1,nimg_neb
        if( imgstat(img).eq.0 )then
          img0 = img - 1
          goto 200
        endif
  150 continue
c     All images already determined - done.
      goto 900
c
  200 continue
      if( img0.gt.0 )then
c       Transfer coordinates of filled image at start of open interval:
        do  iatm=1,natm
          ratmx(1,iatm,1) = ratm_neb(1,iatm,img0)
          ratmx(2,iatm,1) = ratm_neb(2,iatm,img0)
          ratmx(3,iatm,1) = ratm_neb(3,iatm,img0)
        enddo
      endif
c
c Find filled image "imgn" at end of open interval:
c
      do 250 img=img0+1,nimg_neb
        if( imgstat(img).gt.0 )then
c         Found filled image at end of open interval
          imgn = img
c         Transfer coords of filled image
          do  iatm=1,natm
            ratmx(1,iatm,2) = ratm_neb(1,iatm,imgn)
            ratmx(2,iatm,2) = ratm_neb(2,iatm,imgn)
            ratmx(3,iatm,2) = ratm_neb(3,iatm,imgn)
          enddo
          goto 300
        endif
  250 continue
c     Did not find filled final image in band, use final end-product:
      imgn = nimg_neb + 1
      do  iatm=1,natm
        ratmx(1,iatm,2) = ratmb(1,iatm)
        ratmx(2,iatm,2) = ratmb(2,iatm)
        ratmx(3,iatm,2) = ratmb(3,iatm)
      enddo
c
  300 continue
c
c Fill in the empty images in the band (linear interpolation):
c
      nebgap = imgn - img0
      gapint = one / DBLE( nebgap )
      gapneb = zero
c
      do  img=img0+1,imgn-1
        imgstat(img) = 1
        gapneb = gapneb + gapint
        do  iatm=1,natm
          ratm_neb(1,iatm,img) = ratmx(1,iatm,1) +
     $     gapneb*( ratmx(1,iatm,2) - ratmx(1,iatm,1) )
          ratm_neb(2,iatm,img) = ratmx(2,iatm,1) +
     $     gapneb*( ratmx(2,iatm,2) - ratmx(2,iatm,1) )
          ratm_neb(3,iatm,img) = ratmx(3,iatm,1) +
     $     gapneb*( ratmx(3,iatm,2) - ratmx(3,iatm,1) )
        enddo
      enddo
c
      imglast = imgn
c Go back and try to find other open intervals in the band:
      if( imglast.lt.nimg_neb ) goto 100
c
  900 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBFORCE
c
c
      subroutine NEBFORCE( IWRNEB,  Lantikink, Loptall,
     $ Lclimb, Lnoninteract,
     $ nimg_neb, spring_neb,
     $ natm, imgstat, engyneb, ea_neb, eb_neb,
     $ fatm_neb, ratm_neb, ratma, ratmb,
     $ rilo, rihi, tmpa, pathout ) 
c---------------------------------------------------------------
c Purpose: generate band forces for NEB calculation
c
c Written: Peter A. Schultz, 13-February-2002, for v2.54
c          Based on original code by Aidan Thompson (SNL)
c
c Revision history:
c  14Jun05-PAS/2.59: File units
c  11May05-RMV/2.59: add climb, noninteracting, analysis
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
c   Option flags for NEB:
      LOGICAL    Lantikink, Loptall, Lclimb
      LOGICAL    Lnoninteract
c   Status and energies for images
      DIMENSION  imgstat(*), engyneb(*)
c   Coordinates for the initial-point, and end-product
      DIMENSION  ratma(3,natm),ratmb(3,natm)
c   Coordinates and forces for all images
      DIMENSION  ratm_neb(3,natm,nimg_neb)
c   Energy, distance and force projections for each image
      DIMENSION pathout(5,nimg_neb)
c
c Input/Output:
c   Forces over all images
      DIMENSION  fatm_neb(3,natm,nimg_neb)
c
c Scratch space:
      DIMENSION  rilo(3,natm),rihi(3,natm)
      DIMENSION  tmpa(natm,*)
c
c Local declarations:
      LOGICAL    Lnoenergy
      LOGICAL    Loptalltmp,Lantikinktmp,Lclimbtmp
      REAL*8 pathlength
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Set up the various NEB options flags:
c
      Lnoenergy = .false.
c
      if( .not.Loptall )then
        Loptalltmp = .false.
      elseif( Lnoenergy )then
        Loptalltmp = .false.
      else
        Loptalltmp = .true.
      endif
c
      if( .not.Lclimb )then
        Lclimbtmp = .false.
      elseif( Lnoenergy )then
        Lclimbtmp = .false.
      else
        Lclimbtmp = .true.
      endif
c
      if( .not.Lantikink )then
        Lantikinktmp = .false.
      elseif( Lnoenergy )then
        Lantikinktmp = .false.
      else
        Lantikinktmp = .true.
      endif
c
c Cycle over all the images:
c
c     Set initial total path distance to zero
      pathlength = zero
      do 1000 img=1,nimg_neb
c
        engyimg = engyneb(img)
c
c       Get front and back-end coordinates:
c
        if( img.eq.1 )then
c         Load initial-state into down-chain coords
          do  iatm=1,natm
            rilo(1,iatm) = ratma(1,iatm)
            rilo(2,iatm) = ratma(2,iatm)
            rilo(3,iatm) = ratma(3,iatm)
          enddo
          engylo = ea_neb
        else
c         Load next lower image into down-chain coords
          imglo = img - 1
          do  iatm=1,natm
            rilo(1,iatm) = ratm_neb(1,iatm,imglo)
            rilo(2,iatm) = ratm_neb(2,iatm,imglo)
            rilo(3,iatm) = ratm_neb(3,iatm,imglo)
          enddo
          engylo = engyneb(imglo)
        endif
c
        if( img.eq.nimg_neb )then
c         Load final-state into up-chain coords
          do  iatm=1,natm
            rihi(1,iatm) = ratmb(1,iatm)
            rihi(2,iatm) = ratmb(2,iatm)
            rihi(3,iatm) = ratmb(3,iatm)
          enddo
          engyhi = eb_neb
        else
c         Load next higher image into up-chain coords
          imghi = img + 1
          do  iatm=1,natm
            rihi(1,iatm) = ratm_neb(1,iatm,imghi)
            rihi(2,iatm) = ratm_neb(2,iatm,imghi)
            rihi(3,iatm) = ratm_neb(3,iatm,imghi)
          enddo
          engyhi = engyneb(imghi)
        endif
c     
c       Non-interacting image option can just return from here
        if( Lnoninteract ) goto 1000
c
c       Apply the band force for this image along the band:
c
        call FORCE_NEB( IWRNEB,
     $     natm, rilo, ratm_neb(1,1,img),
     $     rihi, fatm_neb(1,1,img),
     $     tmpa(1,1), tmpa(1,4),     tmpa(1,7),
c -->      ti(3a)-s   driminus(3a)-s driplus(3a)-s
     $     spring_neb,
     $     engylo,engyimg,engyhi,   drsqplus,drsqminus,
     $     fpt,fpn,fet,
     $     Lantikinktmp,Loptalltmp,Lclimbtmp,
     $      fdottan,dprev,dnext)
c
c       Load array of projected force,dprev,dnext,
c        and cumulative path distance (RMV)
        pathlength = pathlength + dprev
        pathout( 1,img ) = pathlength
        pathout( 2,img ) = engyimg
        pathout( 3,img ) = fdottan
        pathout( 4,img ) = dprev
        pathout( 5,img ) = dnext
c
c       End loop over images
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBRGET
c
c
      subroutine NEBRGET( IWR,IDAT,
     $ neb_step, nimg_neb, ea_neb,eb_neb,
     $ natm, imgstat, ratma,ratmb, ratm_neb )
c---------------------------------------------------------------
c Purpose: get geometries out of NEB configuration file
c
c Written: Aidan Thompson and Art Edwards, Dec-2001
c
c Revision history:
c  14Jun05-PAS/2.59: IERR changes
c  10Jul03-PAS/2.56: modify some output formats/labels
c  10Jan02-PAS/2.54: adapted for SeqQuest production code
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c  coordinates for initial, final, and intermediate NEB images
      DIMENSION  ratma(3,natm),ratmb(3,natm), ratm_neb(3,natm,*)
      DIMENSION  imgstat(*)
c
c local declarations:
      CHARACTER    label*72, readlbl*6, wantlbl*6
      EQUIVALENCE  (label,readlbl)
      LOGICAL      printon
      DATA         lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
 8000 format(a72)
 9000 format(a)
 9030 format(1x,3f20.8)
c
      printon = .false.
      if( IWR.ge.0 .and. lstout.gt.1 ) printon = .true.
c
      if( printon ) write(IWR,*) '>>>> READ NEB GEOMETRY FILE'
c Initialize to empty NEB images:
      do  img=1,nimg_neb
        imgstat(img) = 0
      enddo
c
      REWIND( IDAT )
c
c Header for NEB section
      wantlbl = 'neb da'
      read(IDAT,8000,err=1300,end=1300)  label
      if( printon ) write(IWR,9000)  label
c
      if( readlbl.ne.wantlbl )then
        goto 1301
      endif
c
c The number of this NEB step
      wantlbl = 'neb st'
      read(IDAT,8000,err=1300,end=1300)  label
      if( printon ) write(IWR,9000)  label
      if( readlbl.eq.wantlbl )then
c
        read(IDAT,*) neb_step
        if( printon ) write(IWR,'(2(1x,i6))') neb_step
        if( neb_step.lt.0 ) call STOPXERR( 'NEB restart: bad step' )
c
        wantlbl = 'images'
        read(IDAT,8000,err=1300,end=1300)  label
        if( printon ) write(IWR,9000)  label
      endif
c
c Number of images and atoms
      wantlbl = 'images'
      if( readlbl.eq.wantlbl )then
        read(IDAT,*)  nimgx, natmx
        if( printon ) write(IWR,'(2(1x,i6))') nimgx,natmx
c       Check these numbers against this calculation
        if( nimgx.ne.nimg_neb .or. natmx.ne.natm )
     $   call STOPXERR( 'NEB restart: # of images or atoms is wrong' )
      else
        goto 1301
      endif
c
c Total energy of initial start-point
      wantlbl = 'einiti'
      read(IDAT,8000,err=1300,end=1300)  label
      if( printon ) write(IWR,9000)  label
      if( readlbl.eq.wantlbl )then
        read(IDAT,*)  ea_neb
        if( printon ) write(IWR,9030)  ea_neb
      else
        goto 1301
      endif
c
c Start-point coordinates
      wantlbl = 'coordi'
      read(IDAT,8000,err=1300,end=1300)  label
      if( printon ) write(IWR,9000)  label
c
      call ATFMTIN( jatmfmt, label )
      if( jatmfmt.ge.0 )then
        call COORDRD( IDAT, jatmfmt, natm, ratma )
        if( printon ) call COORDWR( IWR, natm, ratma )
c
        wantlbl = 'efinal'
        read(IDAT,8000,err=1300,end=1300)  label
        if( printon ) write(IWR,9000)  label
      else
        goto 1301
      endif
c
c Total energy of final end-product
      wantlbl = 'efinal'
      if( readlbl.eq.wantlbl )then
        read(IDAT,*)  eb_neb
        if( printon ) write(IWR,9030)  eb_neb
      else
        goto 1301
      endif
c
c End-product coordinates
      wantlbl = 'coordi'
      read(IDAT,8000,err=1300,end=1300)  label
      if( printon ) write(IWR,9000)  label
c
      call ATFMTIN( jatmfmt, label )
      if( jatmfmt.ge.0 )then
        call COORDRD( IDAT, jatmfmt, natm, ratmb )
        if( printon ) call COORDWR( IWR, natm, ratmb )
        imgnstat = 1
      else
        goto 1301
      endif
c
c Coordinates for *all* intermediate images
c
      do 200 img=1,nimg_neb
c
        wantlbl = 'image '
        read(IDAT,8000,err=990,end=990)  label
        if( printon ) write(IWR,9000)  label
        if( readlbl.ne.wantlbl ) goto 1301
c
c       Which intermediate image (do *not* assume images are in order)?
        read(IDAT,*)  image
        if( printon ) write(IWR,'(1x,i6)')  image
        if( image.lt.1 .or. image.gt.nimg_neb )then
c         Index of image is outside the number in the NEB
          call STOPXERR( 'NEB restart: # of image is out-of-bounds' )
        endif
c
c       Determine format type of atom input line ...
        wantlbl = 'coordi'
        read(IDAT,8000)  label
        if( printon ) write(IWR,9000)  label
        call ATFMTIN( jatmfmt, label )
        if( jatmfmt.lt.0 ) goto 1301
c
c        ... and extract coordinates from input:
        call COORDRD( IDAT, jatmfmt, natm, ratm_neb(1,1,image) )
        if( printon ) call COORDWR( IWR, natm, ratm_neb(1,1,image) )
        imgstat(image) = 1
c
  200 continue
c
  990 continue
c Check that picked up all the images:
      do  img=1,nimg_neb
        if( imgstat(img).ne.1 )
     $   call STOPXERR( 'NEB restart: bad image set' )
      enddo
c
      RETURN
c
c >>>> ERROR handling
c
 1300 continue
      call FLGETIERR( IERRFL )
      write(IERRFL,*) '>>>>> error/end reading neb restart'
 1301 continue
      call FLGETIERR( IERRFL )
      write(IERRFL,*) '>>>>> Want label >',wantlbl,'<,
     $                            found >',readlbl,'<'
 1302 continue
      call STOPXERR( 'NEB restart: format error in input file' )
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBRSAV
c
c
      entry NEBRSAV( IDAT,
     $ neb_step, nimg_neb, ea_neb,eb_neb,
     $ natm, imgstat, ratma,ratmb, ratm_neb )
c---------------------------------------------------------------
c Purpose: write geometries to NEB configuration file
c
c Written: Peter Schultz, 16-January-2002, for v2.54
c
c Revision history:
c  16Jan02-PAS/2.54: adapted from Aidan Thompson original code
c---------------------------------------------------------------
c
c Header for NEB section
      write(IDAT,9000)  'neb data:'
c
c The sequence number for this step:
      write(IDAT,9000)  'neb step number'
      write(IDAT,'(2(1x,i6))')  neb_step
c
c Number of images and atoms
      write(IDAT,9000)  'images, and number of atoms'
      write(IDAT,'(2(1x,i6))') nimg_neb, natm
c
c Total energy of initial start-point
      write(IDAT,9000)  'einitial - energy for start-point'
      write(IDAT,9030)  ea_neb
c
c Start-point coordinates
      write(IDAT,9000)  'coordinates for start-point'
      call COORDWR( IDAT, natm, ratma )
c
c Total energy of final end-product
      write(IDAT,9000)  'efinal - energy for end-product'
      write(IDAT,9030)  eb_neb
c
c End-product coordinates
      write(IDAT,9000)  'coordinates for end-product'
      call COORDWR( IDAT, natm, ratmb )
c
c Coordinates for *all* intermediate images:
c
      do 1200 img=1,nimg_neb
        image = img
c
        write(IDAT,9000)  'image number in NEB'
        write(IDAT,'(1x,i6)')  image
c
        write(IDAT,9000)  'coordinates for this image'
        call COORDWR( IDAT, natm, ratm_neb(1,1,image) )
c
 1200 continue
c
c Mark the end of this file to this point
      write(IDAT,9000)  'end neb data'
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBFGET
c
c
      subroutine NEBFGET( IWR, IDAT, nimg_neb,
     $ natm, imgstat, engyneb,
     $ fatmx, fatm_neb )
c---------------------------------------------------------------
c Purpose: retrieve NEB images energies and (raw) forces
c
c Written: Peter Schultz, 18-January-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c status of images:
      DIMENSION  imgstat(*)
c total energies of images:
      DIMENSION  engyneb(*)
c forces for everybody:
      DIMENSION  fatm_neb(3,natm,*)
c scratch declaration:
      DIMENSION  fatmx(3,natm)
c
c >>>> EXECUTABLE CODE:
c
c Count up the number of images we should have:
      nimg_f = 0
      do  img=1,nimg_neb
        if( imgstat(img).eq.2 ) nimg_f = nimg_f + 1
      enddo
c
c Get the images:
      do  img=1,nimg_f
        call NEBGETF( IWR,IDAT, image, eimage, natm, fatmx, ierror )
        if( ierror.ne.0 ) goto 1301
        if( imgstat(image).ne.2 ) goto 1302
c
c       Take in the energy and the forces:
        engyneb(image) = eimage
        do  iatm=1,natm
          fatm_neb(1,iatm,image) = fatmx(1,iatm)
          fatm_neb(2,iatm,image) = fatmx(2,iatm)
          fatm_neb(3,iatm,image) = fatmx(3,iatm)
        enddo
c
      enddo
c
      RETURN
c
 1301 call STOPXERR( 'NEBFGET: error reading force file' )
 1302 call STOPXERR( 'NEBFGET: image force from image without force' )
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBFPUT
c
c
      entry NEBFPUT( IDAT, nimg_neb,
     $ natm, img_stat, engyneb,
     $ fatm_neb )
c---------------------------------------------------------------
c Purpose: Write out all image forces.
c
c Written: Peter A. Schultz,  8-February-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      do  img=1,nimg_neb
        image = img
        eimage = engyneb(img)
        call NEBPUTF( IDAT, image,eimage, natm, fatm_neb(1,1,image) )
      enddo
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBFWIPE
c
c
      entry NEBFWIPE( IDAT )
c---------------------------------------------------------------
c Purpose: Reset NEB energy/force file to null
c
c Written: Peter A. Schultz,  8-February-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      REWIND( unit=IDAT )
      write(IDAT,'(a)') 'no image results yet for this NEB step'
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBFSTAT
c
c
      entry NEBFSTAT( IWR, IDAT, nimg_neb,  natm, imgstat,
     $ fatmx )
c---------------------------------------------------------------
c Purpose: find number of complete images (forces) in NEB restart
c
c Written: Peter Schultz, 18-January-2002, for v2.54
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      REWIND( IDAT )
c
C     nimgf_neb = 0
      do  img=1,nimg_neb
        call NEBGETF( IWR,IDAT, image, eimage, natm, fatmx, ierror )
        if( ierror.ne.0 ) goto 900
c
C       nimgf_neb = nimgf_neb + 1
        imgstat(image) = 2
      enddo
c
  900 continue
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBGETF
c
c
      subroutine NEBGETF( IWR,IDAT, image, eimage, natm, fatm, ierror )
c---------------------------------------------------------------
c Purpose: read energy/force of image to NEB configuration file
c
c Written: Peter Schultz, 16-January-2002, for v2.54
c
c Revision history:
c  10Jul03-PAS/2.55a: fix an output format
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c  coordinates for initial, final, and intermediate NEB images
      DIMENSION  fatm(3,natm)
c
c local declarations:
      CHARACTER    label*72, readlbl*6, wantlbl*6
      EQUIVALENCE  (label,readlbl)
      LOGICAL      printon
      DATA         lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
 8000 format(a72)
 9000 format(a)
 9011 format(1x,f20.8,a,i5)
 9030 format(1x,3f20.8)
c
      ierror = 0
      printon = .false.
      if( IWR.ge.0 .and. lstout.gt.0 ) printon = .true.
c
c Image number
      wantlbl = 'imagef'
      read(IDAT,8000,err=1310,end=1310)  label
      if( printon ) write(IWR,9000)  label
      if( readlbl.eq.wantlbl )then
        read(IDAT,*)  image
        if( printon ) write(IWR,'(1x,i6)')  image
      else
        call STOPXERR( 'NEB restart: imagef' )
      endif
c
c Energy of image
      wantlbl = 'eimage'
      read(IDAT,8000)  label
      if( printon ) write(IWR,9000)  label
      if( readlbl.eq.wantlbl )then
        read(IDAT,*)  eimage
        if( printon ) write(IWR,9030)  eimage
      else
        call STOPXERR( 'NEB restart: eimage' )
      endif
c
c Forces for all atoms in image
      wantlbl = 'forcei'
      read(IDAT,8000)  label
      if( printon ) write(IWR,9000)  label
      if( readlbl.eq.wantlbl )then
        jatmfmt = 0
        call COORDRD( IDAT, jatmfmt, natm, fatm )
        if( printon ) call COORDWR( IWR, natm, fatm )
      else
        call STOPXERR( 'NEB restart: forcei' )
      endif
c
      RETURN
c
c >>>> ERROR handling
c
 1310 ierror = 1
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBPUTF
c
c
      entry NEBPUTF( IDAT, image, eimage, natm, fatm )
c---------------------------------------------------------------
c Purpose: write energy/force of image to NEB configuration file
c
c Written: Peter Schultz, 16-January-2002, for v2.54
c
c Revision history:
c  10Jul03-PAS/2.55a: add grep-able string to output image energy
c---------------------------------------------------------------
c
c Image number
      write(IDAT,9000)  'imagef - image number for E/F output'
      write(IDAT,'(1x,i6)')  image
c
c Energy of image
      write(IDAT,9000)  'eimage - energy of image (Ry)'
      write(IDAT,9011) eimage,' Ry = CONVERGED ENERGY, NEB image#',image
c
c Forces for all atoms in image
      write(IDAT,9000)  'forcei - forces (Ry/bohr) on atoms'
      call COORDWR( IDAT, natm, fatm )
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBNTRNL
c
c
      subroutine NEBNTRNL( ndim,natm,dolvatm,rprim,orig,rscale,
     $ nimg_neb, imgstat,  ratma,ratmb,
     $ ratm_neb,  ratm,ratm0 )
c---------------------------------------------------------------
c Purpose: scale neb images between internal/external coordinates
c
c Written: Peter A. Schultz, 6-February-2002, for v2.54
c
c Revision history:
c  20Jan03-PAS/2.54e: NEBXTRNL bug
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
      LOGICAL  dolvatm
      DIMENSION  rprim(3,4),orig(3),rscale(3)
      DIMENSION  imgstat(*)
c Input/Output:
      DIMENSION  ratma(3,natm),ratmb(3,natm)
      DIMENSION  ratm_neb(3,natm,*)
c Scratch:
      DIMENSION  ratm(3,natm),ratm0(3,natm)
c
c >>>> EXECUTABLE CODE:
c
      nvec = 3*natm
c
c Convert start-point coordinates:
c      ... copy coords into temp work space
      call DCOPY( nvec, ratma,1, ratm,1 )
c      ... take external coords in ratm(), convert to internal ratm0()
      call RINTRNL( ndim,natm, dolvatm, rprim,orig,rscale,
     $ ratm,ratm0 )
c      ... and move converted coordinates back into right place:
      call DCOPY( nvec, ratm0,1, ratma,1 )
c
c Convert end-point coordinates:
      call DCOPY( nvec, ratmb,1, ratm,1 )
      call RINTRNL( ndim,natm, dolvatm, rprim,orig,rscale,
     $ ratm,ratm0 )
      call DCOPY( nvec, ratm0,1, ratmb,1 )
c
c Convert all initialized images:
      do  img=1,nimg_neb
        if( imgstat(img).gt.0 )then
          call DCOPY( nvec, ratm_neb(1,1,img),1, ratm,1 )
          call RINTRNL( ndim,natm, dolvatm, rprim,orig,rscale,
     $     ratm,ratm0 )
          call DCOPY( nvec, ratm0,1, ratm_neb(1,1,img),1 )
        endif
      enddo
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBXTRNL
c
c
      entry      NEBXTRNL( ndim,natm,dolvatm,rprim,orig,rscale,
     $ nimg_neb, imgstat,  ratma,ratmb,
     $ ratm_neb,  ratm,ratm0 )
c---------------------------------------------------------------
c
      nvec = 3*natm
c
c Convert start-point coordinates:
c      ... copy coords into temp work space
      call DCOPY( nvec, ratma,1, ratm0,1 )
c      ... take internal coords in ratm(), convert to external ratm0()
      call REXTRNL( ndim,natm, dolvatm, rprim,orig,rscale,
     $ ratm,ratm0 )
c      ... and move converted coordinates back into right place:
      call DCOPY( nvec, ratm,1, ratma,1 )
c
c Convert end-point coordinates:
      call DCOPY( nvec, ratmb,1, ratm0,1 )
      call REXTRNL( ndim,natm, dolvatm, rprim,orig,rscale,
     $ ratm,ratm0 )
      call DCOPY( nvec, ratm,1, ratmb,1 )
c
c Convert all initialized images:
      do  img=1,nimg_neb
        if( imgstat(img).gt.0 )then
          call DCOPY( nvec, ratm_neb(1,1,img),1, ratm0,1 )
          call REXTRNL( ndim,natm, dolvatm, rprim,orig,rscale,
     $     ratm,ratm0 )
          call DCOPY( nvec, ratm,1, ratm_neb(1,1,img),1 )
        endif
      enddo
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBOUT
c
c
      subroutine NEBOUT( iflpath,ea_neb,eb_neb,nimg_neb, pathout )
c---------------------------------------------------------------
c Purpose: output NEB data for post-processing
c
c Written: Renee M. Van Ginhoven, 11-May-2005, for 2.59
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Declare variables
      INTEGER iflpath,nimg_neb,img
      REAL*8 ea_neb, eb_neb
      REAL*8 totlen
c
      DIMENSION pathout(5,nimg_neb)
c
c Local declarations
      DATA zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      write(iflpath,*)'# Img, distance, energy, fdottan,'
      write(iflpath,3000) INT(zero), zero, ea_neb, zero
c
      do img = 1,nimg_neb
         write(iflpath,3000) img, 
     $        pathout(1,img), pathout(2,img), pathout(3,img),
     $        pathout(4,img), pathout(5,img)
      enddo
c
c Compute total path length
      totlen = pathout(1,nimg_neb) + pathout(4,nimg_neb)
      write(iflpath,3000)  nimg_neb+1, totlen, eb_neb, zero
 3000 FORMAT(i2,2x,f10.6,2x,f20.8,2x,3(f10.6,2x))
c
c
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBREAP
c
c
      subroutine NEBREAP( IWR   , iflnebf, image, engytotl, ierror,
     $ node,neb_master,nodes,
     $ nimg_neb, natm,imgstat, engyneb, fatm,
     $ fatm_neb,  ntmp, tmp, igrouplist, ngroup, icomm )
c---------------------------------------------------------------
c Purpose: collect results from NEB images
c
c Written: Peter A. Schultz, 28-January-2002, for v2.54
c
c Revision history:
c  10Apr15-PAS/2.66: nebstat propagated for scf fail in image
c   6Jul06-APT/    : merged task parallel and image parallel
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Output quantities
      DIMENSION  imgstat(*)
      DIMENSION  engyneb(*)
      DIMENSION  fatm(3,natm)
c Scratch space:
      DIMENSION  fatm_neb(3,natm,*)
      DIMENSION  tmp(*)
c Local:
c    status value for image with completed force
c Input: List of first node id in each group of nodes.
      DIMENSION igrouplist(*)
c
      DATA  imgstdone / 2 /
c
c >>>> EXECUTABLE CODE:
c
      ierror = 0
c
      if( node.eq.neb_master )then
        ineberr = 0
c
        if( nodes.eq.1 )then
c         Serial calculation
c
c         Find next undone image:
          do 100 img=1,nimg_neb
            if( imgstat(img).eq.1 )then
c             Found unfinished image, check against input ...
              if( img.ne.image )then
                write(IWR,*) 'Completed image number =',image
                write(IWR,*) 'Apparent assigned number=',img
                write(IWR,'(a,20i2)') 'imgstat=',
     $           (imgstat(i),i=1,nimg_neb)
                call STOPXERR( 'NEBREAP: image.ne.image_neb' )
              endif
              eimage = engytotl
c              ... save to NEB status file, and to NEB output:
              call NEBPUTF( IWR    ,  image,eimage,  natm, fatm )
              call NEBPUTF( iflnebf,  image,eimage,  natm, fatm )
c              ... and transfer coordinates into work coords:
              engyneb(image) = eimage
              call DCOPY( 3*natm, fatm,1, fatm_neb(1,1,image),1 )
              goto 190
            endif
  100     continue
          ierror = -1
          call STOPXERR( 'NEBREAP: no unfinished images to reap' )
c
  190     continue
          write(IWR   ,*) '>>>>> Collected NEB image#',image
          imgstat(image) = imgstdone
c
c         End branch #nodes=1
        else
c         #nodes>1
c         Idiot-parallel NEB -> retrieve image results from nodes
c
          img0 = 0
          do 300 igroup=1,ngroup
c
c           Find next undone image:
            do 200 img=img0+1,nimg_neb
              if( imgstat(img).eq.1 )then
                imgtodo = img
                goto 210
              endif
  200       continue
c           Did not find an image needing work for this node
            goto 301
c
  210       continue
            img0 = imgtodo
c
            nodei = igrouplist(igroup)
            if( nodei.eq.neb_master )then
c             This image stayed on master NEB node
c
              if( image.ne.imgtodo )
     $         call STOPXERR( 'NEBREAP/neb_master: image.ne.imgtodo' )
              imgi = image
              eimage = engytotl
              call DCOPY( 3*natm, fatm,1, fatm_neb(1,1,imgi),1 )
c
            else
c             This image was done elsewhere ...
c
c             Receive/unpack assignment {image,E[img],F[img]} results
              call NEBSTAT( nodei, image, ierr, icomm )
              if( ierr .ne. 0 )then
c               This image failed for some reason, report error
                write(IWR,*)'***** ERROR: remote image failed=',img0
                write(IWR,*)'>>>>> Error code reported=',ierr,' (scf)'
                ineberr = ineberr + 1
c               Skip rest of processing this image
                goto 300
              endif
              call REAPGET( nodei, imgi, eimage,
     $         3*natm, fatm_neb(1,1,imgtodo), ntmp, tmp, icomm )
c
              if( imgi.ne.imgtodo )then
 9020           format(a,2i6)
                write(IWR   ,9020) 'Image assigned and image returned',
     $           ' disagree on node#',nodei
                write(IWR   ,9020) 'Image sent, returned=',imgtodo,imgi
                call STOPXERR( 'NEBREAP: image.ne.image_neb from nodei')
              endif
c
            endif
            write(IWR   ,'(a,i4,a,i6)')
     $       '>>>>> NEB image#',imgi,' results from node#',nodei
            imgstat(imgi) = imgstdone
c
            engyneb(imgi) = eimage
            call NEBPUTF( IWR    , imgi,eimage,natm,fatm_neb(1,1,imgi) )
            call NEBPUTF( iflnebf, imgi,eimage,natm,fatm_neb(1,1,imgi) )
  300     continue
  301     continue
c
c         End branch of #nodes>1.
        endif
c
        ierror = ineberr
c       End branch node=neb_master
      else
c       node.ne.nebmaster (and, by implication, #nodes>1)
c
c     Check if this node is the root node for the group
         call MPNODE( iproc )
         call MPNODE0( master )
         if( iproc.eq.master )then
c
c       Pack/send image result {image,E[image],F[image]} to NEB master
            call NEBSTATOK( neb_master, image, icomm )
            call REAPPUT( neb_master, image, engytotl,
     $           3*natm, fatm, ntmp, tmp, icomm )
         endif
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBRUN
c
c
      subroutine NEBRUN( IWR,IWRNEB, inebstat, ierrg,
     $ do_neb, image,engytotl,
     $ igstep,igstop,nhistg, gconv,gblend, tstep,
     $ nimg_neb, nimg_max, ea_neb,eb_neb, spring_neb,
     $ Lantikink_neb,Loptall_neb,Lclimb_neb,Lnoninteract,
     $ itypa,atmass, nafrc, iforce,
     $ nslics,islics,islicats,vslics,    iatframe,
     $ ndim, dolvatm, rprim,orig,rscale, nsym,nsyma, rmatsym, naofsym,
     $ natm, imgstat, engyneb, fatm, ratm,ratma,ratmb, wksma,
     $ ntmp, tmp, igrouplist, ngroup )
c---------------------------------------------------------------
c Purpose: manage a NEB run
c
c Written: Peter A. Schultz, 28-January-2002, for v2.54
c          Based on original code by Aidan Thompson (SNL)
c
c Revision history:
c  30Mar20-PAS/2.68e: error write upon geom fail
c  31Jul17-PAS/2.68: unified slics, added slinky layers; 68d fix update
c   5Aug15-PAS/2.67: handle error in geom updates
c  11Apr15-PAS/2.66: handle errors in images
c  20Feb09-PAS/2.62: pass through vgfix option
c   6Jul06-APT/2.60: merged task parallel and image parallel
c  11May05-RMV/2.59: climb/noninteracting/post-analysis data; patched
c  10Feb05-PAS/2.58b: fix status for non-masters
c  25Apr04-PAS/2.58: purge "igtype" passing
c  11Sep03-PAS/2.57: remove itmaxd-dependence; neb+broy bugfix
c  10Jan03-PAS/2.55: l-BFGS into GRELAX
c  16Oct02-PAS/2.54c: fix g77 problem (cxg77)
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
c   Option flags for NEB:
      LOGICAL    Lantikink_neb, Loptall_neb
      LOGICAL    Lclimb_neb, Lnoninteract
c   Atomic info: type of each atom, mass for each type
      DIMENSION  itypa(natm), atmass(*)
c   Info about lattice, for internal/external coord converts
      LOGICAL    dolvatm
      DIMENSION  rprim(3,4),orig(3),rscale(3)
c   Info defining relaxation/frame constraints; and symmetry
      DIMENSION  iforce(natm)
cRMV SLIC: projected coordinate variables and arrays
      DIMENSION  islics(4,*),islicats(*),vslics(3,*)
      DIMENSION  iatframe(3)
c
      DIMENSION  rmatsym(*), naofsym(*)
c   Status and energies for images
      DIMENSION  imgstat(*), engyneb(*)
c   Forces, coords for this local image calculation
      DIMENSION  fatm(3,natm), ratm(3,natm)
c   Coordinates for the initial-point, and end-product
      DIMENSION  ratma(3,natm),ratmb(3,natm)
c   List of first node id in each group of nodes.
      DIMENSION  igrouplist(*)
c
c Scratch space:
      DIMENSION  wksma(natm,*)
      DIMENSION  tmp(ntmp)
c
c Local declarations:
      LOGICAL    set_done
      DATA       zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Find out who is what:
      call MPNODES_G( nodes )
      call MPNODE0_G( neb_master )
      call MPNODE_G( node )
      call MPCOMM_G( icomm )
c
c Carve out memory to be used:
      if( node.eq.neb_master )then
        nebatm =   natm*nimg_neb
      else
        nebatm =   natm
      endif
      i_ratm = 1
      i_fatm = i_ratm + nebatm*3
      i_tmp2 = i_fatm + nebatm*3
      ntmp2  = ntmp - 2*nebatm*3
      if( node.eq.neb_master )then
c       Carve out more temp memory
        i_nx    = i_tmp2
        i_wrlx  = i_nx    + nebatm
        i_grlx  = i_wrlx  + nebatm
        i_frlx  = i_grlx  + nebatm*3
        i_vrlx  = i_frlx  + nebatm*3
        i_mrlx  = i_vrlx  + nebatm*3
        i_trlx1 = i_mrlx  + nebatm*3
        i_trlx2 = i_trlx1 + nebatm*3
        i_tmp3  = i_trlx2 + nebatm*3
        ntmp3 = ntmp - i_tmp3 + 1
      endif
c
      if( node.eq.neb_master )then
c       Retrieve R for all, and F for finished, images
c
c       Turn off writing to output files:
        IWRX = -1
c
c       Retrieve coords from saved file
c
        write(IWRNEB,*) '>>>>> retrieve all image coords',
     $                   ' from neb_geom'
        call FLOPENA( iflnebg, 'neb_geom' )
c
        call NEBRGET( IWRX  ,iflnebg,
     $   neb_step, nimg_neb, ea_neb,eb_neb,
cxg77     $   natm, tmp(i_fatm),   ratma,ratmb,
     $   natm, imgstat(nimg_neb+1),   ratma,ratmb,
c -->          imgstat(nimg_neb) - do not stomp true imgstat (1)
     $   tmp(i_ratm) )
c -->    ratm_neb(3an)-o
c
c       Retrieve forces from saved file, if they exist
c        (also points code to right place in file to append new frc's).
c
        write(IWRNEB,*) '>>>>> retrieve previous NEB image results',
     $                   ' from neb_efrc'
        call FLOPENA( iflnebf, 'neb_efrc' )
        REWIND( unit=iflnebf )
c
        call NEBFGET( IWRX  , iflnebf, nimg_neb,
     $   natm, imgstat, engyneb,
     $   wksma,       tmp(i_fatm) )
c -->    fatmx(3a)-s, fatm_neb(3an)-o
c
      endif
c
c Collect image results from nodes (and save to file):
c
      write(IWR,*) '>>>>> collect image results at master NEB node'
      if( node.eq.neb_master )
     $write(IWRNEB,*) '>>>>> collect image results at master NEB node'
      call NEBREAP( IWRNEB, iflnebf, image, engytotl, ierror,
     $ node,neb_master,nodes,
     $ nimg_neb, natm,imgstat, engyneb, fatm,
     $ tmp(i_fatm),  ntmp2, tmp(i_tmp2), 
     $         igrouplist, ngroup, icomm )
c -->  fatm-neb(3an)-io     tmp-s
c
       if( node .eq. neb_master .and. ierror .ne. 0 )then
c        We have a problem - one of the images (at least) went bad
c        It is a job problem, because this job has to die, and we don't
c        really have a clean way to tell everyone without a hang because
c        the bad image may not be responsive.
         write(IWR   ,*)'***** ERROR: scf fail in image, NEB terminated'
         write(IWRNEB,*)'***** ERROR: scf fail in image, NEB terminated'
         call FLUSH( IWR )
         call FLUSH( IWRNEB )
         call MPBCASTI( neb_master, 1, ierror, icomm )
         call STOPXERR( 'ERROR in NEB images' )
       else
c        This is everyone (neb_master detected no error) inc. neb_mr
c         .OR. neb_mr detected error above and tells everyone else here
c              (everyone except failed image(s), which must be caught
c               in nebstat routines that notified neb_master of problem.
         call MPBCASTI( neb_master, 1, ierror, icomm )
         if( ierror .ne. 0 )then
c          Error detected, stop the job
           call STOPXERR( 'ERROR in NEB images' )
         endif
c
       endif
c NEB Master node manages and works the results:
c
c Set default completion status to "continue"
c NEB Master will evaluate status, and terminate processes.
      inebstat = 0
      if( node.eq.neb_master )then
c
c       Find if all image forces done:
        set_done = .true.
        do  img=1,nimg_neb
          if( imgstat(img).lt.2 ) set_done = .false.
        enddo
c
c       inebstat=0(continue),1(out_of_steps),2(converged)
        if( set_done )then
          write(IWRNEB,*) '***** All NEB image forces done *****'
c
c         Retrieve all image coordinates (already have the forces):
          IWRX = -1
c
c         Convert input images into internal cartesian bohr coords
          call NEBNTRNL( ndim,natm,dolvatm,rprim,orig,rscale,
     $     nimg_neb, imgstat,  ratma, ratmb,
     $     tmp(i_ratm),      wksma(1, 1),wksma(1, 4) )
c -->      ratm_neb(3an)-io  ratm(3a)-s  ratm0(3a)-s
c
c         Modify computed forces with NEB forces
          write(IWRNEB,*) '>>>>> Apply NEB forces to images'
          call NEBFORCE( IWRNEB,  Lantikink_neb, Loptall_neb,
     $     Lclimb_neb, Lnoninteract,
     $     nimg_neb, spring_neb,
     $     natm, imgstat, engyneb, ea_neb, eb_neb,
     $     tmp(i_fatm), tmp(i_ratm), ratma, ratmb,
c -->      fatm_neb(3an)-io ratm_neb(3an)-i
     $     wksma(1,1), wksma(1,4), wksma(1,7), tmp(i_tmp2) )
c -->      rilo(3a)-s  rihi(3a)-s  tmpa(9a)-s  pathout-o
c          RMV: pathdat(5,nimg) gets path info for post-process
c          (ndat=5)
c
c         Write record of NEB-modified forces to NEB output file
c
          write(IWRNEB,*) '********** NEB modified forces **********'
          call NEBFPUT( IWRNEB, nimg_neb,
     $     natm, img_stat, engyneb,
     $     tmp(i_fatm) )
c -->      fatm_neb(3an)-io
          write(IWRNEB,*)
c
c         Write to post-NEB file (RMV): fsystem dot tangent, and
c          distance to previous and next images (contents of pathdat)
c
          call FLOPENA( iflpath, 'neb_post' )
          REWIND( unit = iflpath )
          write(iflpath,*)  '#write out path data for post-processing'
          call NEBOUT( iflpath,ea_neb,eb_neb,nimg_neb,
     $     tmp(i_tmp2) )
c -->      pathout(5,nimg)-i
          call FLCLOSE( iflpath )  
c
c         Apply the various constraints on the system forces
c
          write(IWRNEB,*) '>>>>> Apply constraints to NEB forces'
          n3atm = 3*natm
          img_off = 0
          nx_off = 0
          nrlx_off = 0
          nrlxdim = 0
          do 200 img=1,nimg_neb
c
c           Load full coordinates and forces into temporary locations
            call DCOPY( n3atm, tmp(i_ratm+img_off),1, wksma(1,10),1 )
            call DCOPY( n3atm, tmp(i_fatm+img_off),1, wksma(1,13),1 )
            img_off = img_off + n3atm
c
c           Fix frame of reference - project out frame-violating forces
            call FIXFRAME( natm, iatframe,
     $       wksma(1,10), wksma(1,13) )
c -->        ratm(3a)-io  fatm(3a)-io
c
c           Select out atoms to be relaxed
            call GSELECT( natm, nafrc, iforce, nrlxg,
     $       nslics,islics,islicats,vslics,
     $       wksma(1,19),wksma(1,22),
c -->        ratmP(3a)-o ratmP(3a)-s
     $       itypa, atmass,  natmg,wksma(1,16),
c -->                              nxatm(a)-o
     $       wksma(1,10),wksma(1,13),
c -->        ratm0(3a)-i frc(3a)-i
     $       wksma(1, 1), wksma(1, 4), wksma(1, 7) )
c -->        ratmg(3a)-o  frcg(3a)-o   amassg(3a)-o
c
c           Load the various arrays into the right places ...
c            ... number of free components
c                Be careful: packing ints, from real into real space!
            call ICOPYOFF( natmg, wksma(1,16),0, tmp(i_nx),nx_off )
            nx_off = nx_off + natmg
            natmrlx = nx_off
c            ... coords, forces, and masses for each degree of freedom
            call DCOPY( nrlxg, wksma(1, 1),1, tmp(i_grlx+nrlx_off),1 )
            call DCOPY( nrlxg, wksma(1, 4),1, tmp(i_frlx+nrlx_off),1 )
            call DCOPY( nrlxg, wksma(1, 7),1, tmp(i_mrlx+nrlx_off),1 )
            nrlx_off = nrlx_off + nrlxg
            nrlxdim = nrlx_off
  200     continue
c
c         Check convergence over entire set of images simultaneously
          call CONVCHK( IWRNEB, 'nebfrc', igstat, igstep,igstop, gconv,
     $     chgmax,chgrms,  3,natmrlx, tmp(i_frlx) )
c -->                                 frcg(3an)-io
          inebstat = igstat
c
          if( inebstat.ne.2 )then
c           Not converged, propagate geoms for next NEB step
c
c           Propagate new configurations for next NEB step:
c
            write(IWRNEB,*) '>>>>> Blend to get new image coordinates'
            engypass = zero
            call GRELAX( IWRNEB, gblend, tstep, engypass,
     $       igstep,nhistg, nrlxdim, chgmax,
     $       natmrlx,tmp(i_wrlx),  tmp(i_nx),
c -->                watmg(an)-io  nxatm(an)-i
     $       tmp(i_grlx),  tmp(i_frlx), tmp(i_vrlx), tmp(i_mrlx),
c -->        ratmg(3an)-io frcg(3an)-i  vatmg(3an)-s amassg(3an)-i
     $       tmp(i_trlx1), tmp(i_trlx2), ntmp3,tmp(i_tmp3) )
c -->        wk3(3an)-s    wk4(3an)-s
c
c           Update master coordinate vectors, impose/check constraints
c
            write(IWRNEB,*)'>>>>> Update image coords for next NEB step'
            nrlx_off = 0
            img_off = 0
            do  img=1,nimg_neb
              call DCOPY( nrlxg, tmp(i_grlx+nrlx_off),1, wksma(1, 1),1 )
              call DCOPY( n3atm, tmp(i_ratm+img_off) ,1, wksma(1,13),1 )
c
              call GUPDATE( ierrg, wksma(1,13),
c -->                              ratm0(3a)-io
     $         natm, iforce, ndim,nsym,nsyma, rprim, rmatsym, naofsym,
     $         nslics,islics,islicats,vslics,  iatframe,
     $         wksma(1,19),
c -->          ratmP(3a)-i
     $         wksma(1, 1), wksma(1, 4),wksma(1, 7), wksma(1,10) )
c -->          ratmg(3a)-is ratmx(3a)-s dratm0(3a)-s dratmsy(3a)-s
c
c             Put updated coordinates into master coordinate vector
              call DCOPY( n3atm, wksma(1,13),1, tmp(i_ratm+img_off),1 )
              nrlx_off = nrlx_off + nrlxg
              img_off = img_off + n3atm
c
              if( ierrg .ne. 0 )then
                inebstat = -1
                goto 313
              endif
              imgstat(img) = 1
            enddo
c
c           Convert images into external user frame
            call NEBXTRNL( ndim,natm,dolvatm,rprim,orig,rscale,
     $       nimg_neb, imgstat,  ratma, ratmb,
     $       tmp(i_ratm),      wksma(1, 1),wksma(1, 4) )
c -->        ratm_neb(3an)-io  ratm(3a)-s  ratm0(3a)-s
c
c           Reset force file to null results to reflect the new step
            call NEBFWIPE( iflnebf )
c
            write(IWRNEB,*) '>>>>> record new image coords to file'
            neb_step = igstep
c
c           Record new coords to NEB status file ...
            REWIND( unit=iflnebg )
            call NEBRSAV( iflnebg,
     $       neb_step, nimg_neb, ea_neb,eb_neb,
     $       natm, imgstat, ratma,ratmb,
     $       tmp(i_ratm) )
c -->        ratm_neb(3an)-io
c
c            ... and write new band coords to the NEB output file:
            call NEBRSAV( IWRNEB,
     $       neb_step, nimg_neb, ea_neb,eb_neb,
     $       natm, imgstat, ratma,ratmb,
     $       tmp(i_ratm) )
c -->        ratm_neb(3an)-io
c
c           End NEB set-done, propagated new images for next NEB step
          endif
c
c         End NEB set-done
        else
          write(IWRNEB,*) '>>>>> NEB step not done, do more images'
        endif
c
  313   continue
        call FLCLOSE( iflnebg )
        call FLCLOSE( iflnebf )
c
cxxx    Should have a status/sync here?
        if( inebstat.eq.0 )then
c         Send new image assignments
c
          write(IWRNEB,*) '>>>>> Assign NEB image(s)'
          call NEBASSGN( IWRNEB, image,neb_step, ierror,
     $     node,neb_master,nodes,
     $     nimg_neb, natm,imgstat, ratm,
     $     tmp(i_ratm),  ntmp2, tmp(i_tmp2), 
     $         igrouplist, ngroup, icomm )
c-->       ratm_neb(3an)-io     tmp-s
c
        else
          if( inebstat .lt. 0 )then
             write(IWR,*)    ' ***** ERROR in NEB geoms'
             write(IWRNEB,*) ' ***** ERROR in NEB geoms'
          endif
c         Send null assignments to terminate processes
c
          write(IWRNEB,*) '>>>>> Terminate NEB, null assignments'
          call NEBASTOP( IWRNEB, node,neb_master,nodes,
     $     ntmp2,tmp(i_tmp2), 
     $         igrouplist, ngroup, icomm )
c
        endif
c
c       End node.eq.neb_master branch
      else
c       Start node.ne.neb_master (implying nodes>1)
c
cxxx    Should have status/sync here?
c       Receive new image assignments
        call NEBASSGN( IWR, image,neb_step, ierror,
     $   node,neb_master,nodes,
     $   nimg_neb, natm,imgstat, ratm,
     $   tmp(i_ratm),  ntmp2, tmp(i_tmp2), 
     $        igrouplist, ngroup, icomm )
c-->     ratm_neb(3an)-io     tmp-s
c
c       Set step number to neb step number:
        igstep = neb_step
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBSETUP
c
c
      subroutine NEBSETUP( IDAT,IWR, IWRNEB,
     $ do_neb, image, neb_step,
     $ nimg_neb, nimg_max, ea_neb,eb_neb, spring_neb,
     $ Lantikink_neb,Loptall_neb,Lclimb_neb,Lnoninteract,
     $ ndim, dolvatm, rprim,orig,rscale,
     $ natm, imgstat, engyneb, ratm,ratma,ratmb, wksma,
     $ ntmp, tmp, igrouplist, ngroup )
c---------------------------------------------------------------
c Purpose: Initialize and set up a Nudged Elastic Band (NEB)
c          series of calculations.
c
c Written: Peter A. Schultz, 17-January-2002, for v2.54
c
c Revision history:
c  19Nov08-PAS/2.62: mpi-comm rework to accommodate k-parallel
c  16Nov07-PAS/2.60b: bugfix - mprecvi lenmsg argument
c  13Jun07-PAS/2.60: rename MP calls
c   6Jul06-APT/2.60: merged task parallel and image parallel
c  11May05-RMV/2.59: add flags: climb, noninteract
c  10Jul03-PAS/2.56: change master NEB write to IWRNEB
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Identify version/revision status for this NEB
      CHARACTER  version*5,         lastup*11
      DATA       version /'1.10 '/, lastup/'19Nov08-PAS'/
c
      LOGICAL    do_neb
c
c Output: option flags for NEB
      LOGICAL    Lantikink_neb, Loptall_neb
      LOGICAL    Lclimb_neb, Lnoninteract
c
c Input: info about lattice, for internal/external coord converts
      LOGICAL    dolvatm
      DIMENSION  rprim(3,4),orig(3),rscale(3)
c Output: coords for local calculation; initial, final images
      DIMENSION  ratm(3,natm)
      DIMENSION  ratma(3,natm),ratmb(3,natm)
c         status of each image, and computed energy for each
      DIMENSION  imgstat(*), engyneb(*)
c Output: List of first node id in each group of nodes.
c Array dimension is ngroup+1, where igrouplist(ngroup+1) 
c is set to number of nodes for convenience.
      DIMENSION igrouplist(*)
c
c Scratch:
      DIMENSION  wksma(natm,*)
      DIMENSION  tmp(ntmp)
      DIMENSION  itmpbuf(2)
c
c Local declarations:
      LOGICAL    Lrestart_neb
      CHARACTER    label*72, readlbl*6, wantlbl*6
      EQUIVALENCE  (label,readlbl)
c
c >>>> EXECUTABLE CODE:
c
 9000 format(
     $  / 4x,'Program SEQQUEST: LCAO-PS-DFT electronic structure code'
     $  / 4x,'Written by Peter A. Schultz' / )
 9001 format( 1x,72('-')
     $  / 4x,'***** NEB module for transition state finding *****'
     $  / 4x,'Written by Aidan Thompson, adapted by PAS for SeqQuest'
     $  / 4x,'Based on the NEB method of Hannes Jonnson'
     $ // 4x,'NEB Version: ',a,'        Last revised: ',a
     $  / 4x,'Maximum number of NEB images =',i6
     $  / 1x,72('-') / )
c
c Assign workspace in tmp()
      i_ratm = 1
c
c Find out who is what:
      call MPNODES_G( nodes )
      call MPNODE0_G( neb_master )
      call MPNODE_G( node )
      call MPCOMM_G( icomm_g )
c
      if( node.eq.neb_master )then
c
c       >>> Open NEB output file, and give some vitals:
c
        write(IWR,*) '***** NEB Module invoked *****'
        write(IWR,9001)  version,lastup,nimg_max
c
        write(IWR,*) 'This node is the NEB master'
        write(IWR,*) 'NEB output file= neb_out'
        call FLOPENA( IWRNEB, 'neb_out' )
        if( IWRNEB.ne.IWR )then
          write(IWRNEB,9000)
        endif
        write(IWRNEB,9001)  version,lastup,   nimg_max
c
c       >>> Initialize NEB parameters:
c
        call DAT0NEB( nimg_neb, nimg_max,
     $   ea_neb,eb_neb, spring_neb,
     $   Lantikink_neb,Loptall_neb, 
     $   Lclimb_neb, Lnoninteract, Lrestart_neb,
     $   imgstat, natm, ratm, ratma )
c
c       >>> Input data to define this NEB calculation:
c
        write(IWR,*) '>>>>> reading NEB input data'
c
        call NEBDAT( IWRNEB,IDAT,
     $   neb_step, nimg_neb, nimg_max, ea_neb,eb_neb, spring_neb,
     $   Lantikink_neb,Loptall_neb,
     $   Lclimb_neb, Lnoninteract, Lrestart_neb,
     $   natm, imgstat, ratma,ratmb,
     $   tmp(i_ratm) )
c-->     ratm_neb(3*natm*nimg_neb)-o
c
        n_ratm = 3*natm*nimg_neb
        i_tmp2 = i_ratm + n_ratm
        ntmp2 = ntmp - n_ratm
c
c       >>> If restart, recover coordinates
c       >>> and recover energy/forces for previously completed images
cpas:       I should consider making NEB restart automatic
c
        if( Lrestart_neb )then
c
c         Load preexisting image geometries from NEB configuration file
c
          write(IWRNEB,*) '>>>>> get restart coords from neb_geom'
          call FLOPENA( iflnebg, 'neb_geom' )
          call NEBRGET( IWRNEB,iflnebg,
     $     neb_step, nimg_neb, ea_neb,eb_neb,
     $     natm, imgstat, ratma,ratmb,
     $     tmp(i_ratm) )
c -->      ratm_neb(3an)-io
          call FLCLOSE( iflnebg )
c
c         Identify and load energies/forces for previously done images
c
          write(IWRNEB,*) '>>>>> restart image E/F from neb_efrc'
          call FLOPENA( iflnebf, 'neb_efrc' )
          call NEBFSTAT( IWRNEB, iflnebf, nimg_neb,
     $     natm, imgstat,
     $     wksma )
c -->      fatmx(3a)-s
          call FLCLOSE( iflnebf )
c
        endif
c
c       Convert input images into internal cartesian bohr coords
        call NEBNTRNL( ndim,natm,dolvatm,rprim,orig,rscale,
     $   nimg_neb, imgstat,  ratma, ratmb,
     $   tmp(i_ratm),      wksma(1,1),wksma(1,4) )
c -->    ratm_neb(3an)-io  ratm(3a)-s ratm0(3a)-s
c
c       Fill in coordinates for empty images in the band:
        write(IWRNEB,*) '>>>>> fill in empty images in band'
        call NEBFILL( IWRNEB,
     $   natm, nimg_neb, imgstat, ratma,ratmb,
     $   tmp(i_ratm),      wksma )
c-->     ratm_neb(3an)-io  ratmx(6*natm)-s
c
c       Convert all images back to external user coordinates
        call NEBXTRNL( ndim,natm,dolvatm,rprim,orig,rscale,
     $   nimg_neb, imgstat,  ratma, ratmb,
     $   tmp(i_ratm),      wksma(1,1),wksma(1,4) )
c -->    ratm_neb(3an)-io  ratm(3a)-s ratm0(3a)-s
c
        if( .not.  Lrestart_neb )then
c         Save record of all image coordinates to NEB restart file
          call FLOPENA( iflnebg, 'neb_geom' )
          REWIND( unit=iflnebg )
          call NEBRSAV( iflnebg,
     $     neb_step, nimg_neb, ea_neb,eb_neb,
     $     natm, imgstat, ratma,ratmb,
     $     tmp(i_ratm) )
          call FLCLOSE( iflnebg )
        endif
c
c       Write record of all image coordinates to NEB output file
        call NEBRSAV( IWRNEB,
     $   neb_step, nimg_neb, ea_neb,eb_neb,
     $   natm, imgstat, ratma,ratmb,
     $   tmp(i_ratm) )
c
        write(IWRNEB,*) '>>>>> NEBSETUP: Assign images to nodes'
c
        IWRX = IWRNEB
c       End node=neb_master branch
      else
c       Not node=neb_master, receive assignments (image#, coords).
c
c       Assign memory (i_ratm not used, but to be safe):
        n_ratm = 3*natm
        i_tmp2 = i_ratm + n_ratm
        ntmp2 = ntmp - n_ratm
        IWRX = IWR
c
      endif
c
c     Set up partitioning of nodes into image-specific communicators
c      and record in igrouplist()
c
c     There may be a fancier way to assign processors,
c     to get better Scalapack performance.
c
      if( node .eq. neb_master )then
c
        if( nodes .ge. nimg_neb )then
c         More nodes than images: group nodes for each image  
          ngroup = nimg_neb
          nper = nodes / ngroup
          nremain = nodes - nper*ngroup
          inode = 0
          do  igroup=1,ngroup
            igrouplist(igroup) = inode
            if( igroup .le. nremain )then
              inode = inode + nper + 1
            else
              inode = inode + nper
            endif
          enddo
          igrouplist(ngroup+1) = nodes
        else
c         More images than nodes, then make each node into its own group
          ngroup = nodes
          do  igroup=1,ngroup
            igrouplist(igroup) = igroup - 1
          enddo
          igrouplist(ngroup+1) = nodes
        endif
c
c       Tell each node which group it belongs to
c
        do  igroup=1,ngroup
          do  nodei=igrouplist(igroup),igrouplist(igroup+1)-1
            if( nodei .eq. neb_master )then
              mygroup = igroup
            else
              itmpbuf(1) = igroup
              lenmsg = 1
              call MPSENDI( nodei, lenmsg, itmpbuf, icomm_g )
            endif
          enddo
        enddo
c
      else
c
c       Each node receives its group assignment from the neb_master
c
        lenmsg = 1
        call MPRECVI( neb_master, lenmsg, itmpbuf, icomm_g )
        mygroup = itmpbuf(1)
c
      endif
c     
c Split processors up into local communicators:
c
      call MPSPLITGCOMM( mygroup )
      write(IWR,'(1x,a,i4,a)') 
     $     'MPINFO::: NEB Group = ',mygroup  ,'           :::'
c
c At this point, I have coordinates and completion status
c for every image in the band.  Now cycle over groups of 
c nodes and assign images (with coordinates) to groups.
c
cxxx  I should probably put a status/sync step here.
      call NEBASSGN( IWRX, image,neb_step, ierror,
     $ node,neb_master,nodes,
     $ nimg_neb, natm,imgstat, ratm,
     $ tmp(i_ratm), ntmp2, tmp(i_tmp2) ,
     $ igrouplist, ngroup, icomm_g )
c-->   ratm_neb(3an)-io    tmp-s
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NLANG
c
c
      subroutine NLANG( lmi,lmj,limxp1,ljmxp1,lmxp1,rimag,rjmag,
     $ ylmi,gntcomb,angsav,gntci,cgntcj )
c---------------------------------------------------------------
c Purpose: compute sums of three-j , for non-local integrals
c
c Revision history:
c   6Mar00-PAS/2.43: rename "angset" to "nlang"
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c   5Jun89-PAS: extracted ANGSET from orbital loops
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c input arrays:
      DIMENSION  ylmi(2,25)
      DOUBLE COMPLEX    gntcomb(9,5,5,2,9)
c output array:
      DIMENSION  angsav(limxp1,ljmxp1*ljmxp1,lmxp1,9,9)
c scratch arrays:
      DOUBLE COMPLEX    gntci(limxp1,lmi,lmxp1*lmxp1),
     $          cgntcj(ljmxp1*ljmxp1,lmj,lmxp1*lmxp1)
c local declarations:
      DIMENSION  ckm(9)
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      fourpi = pi + pi + pi + pi
c zero angsav:
      call MKZERO( limxp1*ljmxp1*ljmxp1*lmxp1*9*9, angsav )
c
c    Collect scale factors:
c
      do  llpot=1,lmxp1
        k = llpot - 1
        km0 = k*k
        numkm = 2*k + 1
        scale = fourpi* DBLE( numkm )
        do  km=km0+1,km0+numkm
          ckm(km) = scale
        enddo
      enddo
      maxkm = lmxp1*lmxp1
c
c    Pack gaunt coef * ylm's for i:
c
      call MKZERO( 2*limxp1*lmi*maxkm, gntci )
c
      ilm = 0
      iplst = 1
      do 100 mmi=1,limxp1
        do  lli=mmi,limxp1
          ilm = ilm + 1
          do  ipprl=1,iplst
c
            do  km=1,maxkm
              scale = ckm(km)*ylmi(ipprl,ilm)
              do  lmpi=1,lmi
                gntci(lli,lmpi,km) = gntci(lli,lmpi,km) +
     $           scale*gntcomb(lmpi,lli,mmi,ipprl,km)
              enddo
            enddo
c
          enddo
        enddo
  100 iplst = 2
c
c    Pack gaunt coef's for j:
c
      jlx = 0
      jplst = 1
      do 200 mmj=1,ljmxp1
        do  llj=mmj,ljmxp1
          do  jpprl=1,jplst
            jlx = jlx + 1
c
            do  km=1,maxkm
              do  lmpj=1,lmj
                cgntcj(jlx,lmpj,km) =
     $           CONJG( gntcomb(lmpj,llj,mmj,jpprl,km) )
              enddo
            enddo
c
          enddo
        enddo
  200 jplst=2
c
c    Do prods of gaunt coef's:
c
      do 302 lmpj=1,lmj
        do 301 lmpi=1,lmi
c
          do  llpot=1,lmxp1
            k = llpot - 1
            km0 = k*k
            numkm = 2*k + 1
c
            do  km=km0+1,km0+numkm
              do  lli=1,limxp1
                do  jlx=1,ljmxp1*ljmxp1
                  angsav(lli,jlx,llpot,lmpi,lmpj) =
     $             angsav(lli,jlx,llpot,lmpi,lmpj) +
     $             gntci(lli,lmpi,km)*cgntcj(jlx,lmpj,km)
                enddo
              enddo
            enddo
c
          enddo
c
  301   continue
  302 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NLANGF
c
c
      subroutine NLANGF( lmi,lmj,limxp1,ljmxp1,lmxp1,lisq,ljsq,
     $ ylmi,ylmj,grylmi,grylmj,gntcomb,
     $ angsav,angtmp,gntci,cgntcj )
c---------------------------------------------------------------
c Purpose: do angular products and sums necessary for evaluation
c          of contribution to the force from the non-local part
c          of the potential.
c
c Written: Peter A. Schultz, 14-June-89,  based on PJF's
c          original ANGSETF,LLOOPSF,VLOOPSF routines.
c
c Revision history:
c  21Jun01-PAS/2.48: replace STOPs
c  15Oct99-PAS/2.41: cleaned up and minor tuning
c   5Oct99-DBR/2.41: optimization (unroll loops, reord dims)
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c  For later usage, need a variety of angular sums.  They are
c  stored in angsav() as follows:
c
c   angsav(1...) = sum of 3-j symbols * ylmj * ylmi
c   angsav(2...) = "" * ylmj * d/dx(ylmi) [=grylmi(i,1,ii)]
c   angsav(3...) = "" * ylmj * d/dy(ylmi) [=grylmi(i,2,ii)]
c   angsav(4...) = "" * ylmj * d/dz(ylmi) [=grylmi(i,3,ii)]
c   angsav(5...) = "" * d/dx(ylmj) * ylmi
c   angsav(6...) = "" * d/dy(ylmj) * ylmi
c   angsav(7...) = "" * d/dz(ylmj) * ylmi
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c input arrays:
      DOUBLE COMPLEX    gntcomb(9,5,5,2,9)
c output array:
      DIMENSION  angsav(7,limxp1,ljmxp1,lmxp1,9,9)
c scratch arrays:
      DIMENSION  angtmp(lisq,ljsq)
      DOUBLE COMPLEX    gntci(lisq,lmi,lmxp1*lmxp1),
     $                 cgntcj(ljsq,lmj,lmxp1*lmxp1)
c local declarations:
      DIMENSION  ckm(9)
      DIMENSION  angij(25,25)
      DIMENSION  ang_yi(25,25), ang_yj(25,25)
      DIMENSION  ylmj(2,5,5), ylmi(2,5,5)
      DIMENSION  grylmj(3,2,5,5), grylmi(3,2,5,5)
      DIMENSION  ylmj_t(25), ylmi_t(25)
      DIMENSION  grylmj_t(25,3), grylmi_t(25,3)
      DIMENSION  angi(9),angj(9)
      DIMENSION  ime(5)
      DATA  ime/ 1,2,2,2,2/
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      if( limxp1 .gt. 5 .or. ljmxp1 .gt. 5 )then
        call STOPXERR( 'nlangf-0/NLANGFlmax exceeded' )
      endif
c
      fourpi = pi + pi + pi + pi
c zero angsav():
      call MKZERO( 7*limxp1*ljmxp1*lmxp1*9*9, angsav )
c
c    Collect scale factors:
c
      m = 0
      do  lli=1,limxp1
        do  mmi=1,lli
          do  ipprl=1,ime(mmi)
            m = m + 1
            ylmi_t(m) = ylmi(ipprl,mmi,lli)
            grylmi_t(m,1) = grylmi(1,ipprl,mmi,lli)
            grylmi_t(m,2) = grylmi(2,ipprl,mmi,lli)
            grylmi_t(m,3) = grylmi(3,ipprl,mmi,lli)
          enddo
        enddo
      enddo
c
      m = 0
      do  llj=1,ljmxp1
        do  mmj=1,llj
          do  jpprl=1,ime(mmj)
            m = m + 1
            ylmj_t(m) = ylmj(jpprl,mmj,llj)
            grylmj_t(m,1) = grylmj(1,jpprl,mmj,llj)
            grylmj_t(m,2) = grylmj(2,jpprl,mmj,llj)
            grylmj_t(m,3) = grylmj(3,jpprl,mmj,llj)
          enddo
        enddo
      enddo
c
      do  llpot=1,lmxp1
        k = llpot - 1
        km0 = k*k
        numkm = 2*k + 1
        scale = fourpi* DBLE(numkm)
        do  km=km0+1,km0+numkm
          ckm(km) = scale
        enddo
      enddo
      maxkm = lmxp1*lmxp1
c
      ilx = 0
      do  lli=1,limxp1
        do  mmi=1,lli
          do  ipprl=1,ime(mmi)
            ilx = ilx + 1
c
            do  km=1,maxkm
              scale = ckm(km)
              do  lmpi=1,lmi
                gntci(ilx,lmpi,km) = scale*
     $           gntcomb(lmpi,lli,mmi,ipprl,km)
              enddo
            enddo
c
          enddo
        enddo
      enddo
c
c zero out cgntcj():
      call MKZERO( 2*ljsq*lmj*maxkm, cgntcj )
c
      jlx = 0
      do  llj=1,ljmxp1
        do  mmj=1,llj
          do  jpprl=1,ime(mmj)
            jlx = jlx + 1
c
            do  km=1,maxkm
              do  lmpj=1,lmj
                cgntcj(jlx,lmpj,km) =
     $           CONJG(gntcomb(lmpj,llj,mmj,jpprl,km))
              enddo
            enddo
c
          enddo
        enddo
      enddo
c
c    Generate products of gnt coef's and factor in ylm's,grylm's:
c
      do 302 lmpj=1,lmj
        do 301 lmpi=1,lmi
c
          do 290 llpot=1,lmxp1
            k = llpot - 1
            km0 = k*k
            numkm = 2*k + 1
c
            call MKZERO( 25*25, angij )
            do  km=km0+1,km0+numkm
              do  jlx=1,ljsq
                do  ilx=1,lisq
                  angij(ilx,jlx) = angij(ilx,jlx) +
     $             gntci(ilx,lmpi,km)*cgntcj(jlx,lmpj,km)
                enddo
              enddo
            enddo
c
            if( lisq .ge. ljsq )then
              do  jlx=1,ljsq
                ylj = ylmj_t(jlx)
                do  ilx=1,lisq
                  ang_yj(jlx,ilx) = angij(ilx,jlx)*ylj
                  ang_yi(ilx,jlx) = angij(ilx,jlx)*ylmi_t(ilx)
                enddo
              enddo
            else
              do  ilx=1,lisq
                yli = ylmi_t(ilx)
                do  jlx=1,ljsq
                  ang_yj(jlx,ilx) = angij(ilx,jlx)*ylmj_t(jlx)
                  ang_yi(ilx,jlx) = angij(ilx,jlx)*yli
                enddo
              enddo
            endif
c
            do  llj=1,ljmxp1
c
              if( llj .eq. 1 )then
c
                do  lli=1,limxp1
c
                  if( lli .eq. 1 )then
c
                    angi(1) = ang_yi(1,1)
c
                    angj(1) = ang_yj(1,1)
c
                    angsav(1,1,1,llpot,lmpi,lmpj) =
     $               ylmi_t(1)*angj(1)
c
                    angsav(2,1,1,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,1)
                    angsav(3,1,1,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,2)
                    angsav(4,1,1,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,3)
c
                    angsav(5,1,1,llpot,lmpi,lmpj) =
     $               angi(1)*grylmj_t(1,1)
                    angsav(6,1,1,llpot,lmpi,lmpj) =
     $               angi(1)*grylmj_t(1,2)
                    angsav(7,1,1,llpot,lmpi,lmpj) =
     $               angi(1)*grylmj_t(1,3)
c
                  elseif( lli .eq. 2 )then
c
                    angi(1) = ang_yi(2,1)
     $                      + ang_yi(3,1)
     $                      + ang_yi(4,1)
c
                    angsav(1,2,1,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(1)
c
                    angsav(2,2,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,2)*grylmi_t(2,1) +
     $               ang_yj(1,3)*grylmi_t(3,1) +
     $               ang_yj(1,4)*grylmi_t(4,1)
                    angsav(3,2,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,2)*grylmi_t(2,2) +
     $               ang_yj(1,3)*grylmi_t(3,2) +
     $               ang_yj(1,4)*grylmi_t(4,2)
                    angsav(4,2,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,2)*grylmi_t(2,3) +
     $               ang_yj(1,3)*grylmi_t(3,3) +
     $               ang_yj(1,4)*grylmi_t(4,3)
c
                    angsav(5,2,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,1)*angi(1)
                    angsav(6,2,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,2)*angi(1)
                    angsav(7,2,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,3)*angi(1)
c
                  elseif( lli .eq. 3 )then
c
                    angi(1) = ang_yi(5,1)
     $                      + ang_yi(6,1)
     $                      + ang_yi(7,1)
     $                      + ang_yi(8,1)
     $                      + ang_yi(9,1)
c
                    angsav(1,3,1,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(1)
c
                    angsav(2,3,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,5)*grylmi_t(5,1) +
     $               ang_yj(1,6)*grylmi_t(6,1) +
     $               ang_yj(1,7)*grylmi_t(7,1) +
     $               ang_yj(1,8)*grylmi_t(8,1) +
     $               ang_yj(1,9)*grylmi_t(9,1)
                    angsav(3,3,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,5)*grylmi_t(5,2) +
     $               ang_yj(1,6)*grylmi_t(6,2) +
     $               ang_yj(1,7)*grylmi_t(7,2) +
     $               ang_yj(1,8)*grylmi_t(8,2) +
     $               ang_yj(1,9)*grylmi_t(9,2)
                    angsav(4,3,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,5)*grylmi_t(5,3) +
     $               ang_yj(1,6)*grylmi_t(6,3) +
     $               ang_yj(1,7)*grylmi_t(7,3) +
     $               ang_yj(1,8)*grylmi_t(8,3) +
     $               ang_yj(1,9)*grylmi_t(9,3)
c
                    angsav(5,3,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,1)*angi(1)
                    angsav(6,3,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,2)*angi(1)
                    angsav(7,3,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,3)*angi(1)
c
                  elseif( lli .eq. 4 )then
c
                    angi(1) = ang_yi(10,1)
     $                      + ang_yi(11,1)
     $                      + ang_yi(12,1)
     $                      + ang_yi(13,1)
     $                      + ang_yi(14,1)
     $                      + ang_yi(15,1)
     $                      + ang_yi(16,1)
c
                    angsav(1,4,1,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(1)
c
                    angsav(2,4,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,10)*grylmi_t(10,1) +
     $               ang_yj(1,11)*grylmi_t(11,1) +
     $               ang_yj(1,12)*grylmi_t(12,1) +
     $               ang_yj(1,13)*grylmi_t(13,1) +
     $               ang_yj(1,14)*grylmi_t(14,1) +
     $               ang_yj(1,15)*grylmi_t(15,1) +
     $               ang_yj(1,16)*grylmi_t(16,1)
                    angsav(3,4,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,10)*grylmi_t(10,2) +
     $               ang_yj(1,11)*grylmi_t(11,2) +
     $               ang_yj(1,12)*grylmi_t(12,2) +
     $               ang_yj(1,13)*grylmi_t(13,2) +
     $               ang_yj(1,14)*grylmi_t(14,2) +
     $               ang_yj(1,15)*grylmi_t(15,2) +
     $               ang_yj(1,16)*grylmi_t(16,2)
                    angsav(4,4,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,10)*grylmi_t(10,3) +
     $               ang_yj(1,11)*grylmi_t(11,3) +
     $               ang_yj(1,12)*grylmi_t(12,3) +
     $               ang_yj(1,13)*grylmi_t(13,3) +
     $               ang_yj(1,14)*grylmi_t(14,3) +
     $               ang_yj(1,15)*grylmi_t(15,3) +
     $               ang_yj(1,16)*grylmi_t(16,3)
c
                    angsav(5,4,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,1)*angi(1)
                    angsav(6,4,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,2)*angi(1)
                    angsav(7,4,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,3)*angi(1)
c
                  elseif( lli .eq. 5 )then
c
                    angi(1) = ang_yi(17,1)
     $                      + ang_yi(18,1)
     $                      + ang_yi(19,1)
     $                      + ang_yi(20,1)
     $                      + ang_yi(21,1)
     $                      + ang_yi(22,1)
     $                      + ang_yi(23,1)
     $                      + ang_yi(24,1)
     $                      + ang_yi(25,1)
c
                    angsav(1,5,1,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(1)
c
                    angsav(2,5,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,17)*grylmi_t(17,1) +
     $               ang_yj(1,18)*grylmi_t(18,1) +
     $               ang_yj(1,19)*grylmi_t(19,1) +
     $               ang_yj(1,20)*grylmi_t(20,1) +
     $               ang_yj(1,21)*grylmi_t(21,1) +
     $               ang_yj(1,22)*grylmi_t(22,1) +
     $               ang_yj(1,23)*grylmi_t(23,1) +
     $               ang_yj(1,24)*grylmi_t(24,1) +
     $               ang_yj(1,25)*grylmi_t(25,1)
                    angsav(3,5,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,17)*grylmi_t(17,2) +
     $               ang_yj(1,18)*grylmi_t(18,2) +
     $               ang_yj(1,19)*grylmi_t(19,2) +
     $               ang_yj(1,20)*grylmi_t(20,2) +
     $               ang_yj(1,21)*grylmi_t(21,2) +
     $               ang_yj(1,22)*grylmi_t(22,2) +
     $               ang_yj(1,23)*grylmi_t(23,2) +
     $               ang_yj(1,24)*grylmi_t(24,2) +
     $               ang_yj(1,25)*grylmi_t(25,2)
                    angsav(4,5,1,llpot,lmpi,lmpj) =
     $               ang_yj(1,17)*grylmi_t(17,3) +
     $               ang_yj(1,18)*grylmi_t(18,3) +
     $               ang_yj(1,19)*grylmi_t(19,3) +
     $               ang_yj(1,20)*grylmi_t(20,3) +
     $               ang_yj(1,21)*grylmi_t(21,3) +
     $               ang_yj(1,22)*grylmi_t(22,3) +
     $               ang_yj(1,23)*grylmi_t(23,3) +
     $               ang_yj(1,24)*grylmi_t(24,3) +
     $               ang_yj(1,25)*grylmi_t(25,3)
c
                    angsav(5,5,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,1)*angi(1)
                    angsav(6,5,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,2)*angi(1)
                    angsav(7,5,1,llpot,lmpi,lmpj) =
     $               grylmj_t(1,3)*angi(1)
c
                  else
c
                    call STOPXERR( 'nlangf 1' )
c
                  endif
c
                enddo
c
              elseif( llj .eq. 2 )then
c
                do  lli=1,limxp1
c
                  if( lli .eq. 1 )then
c
                    angj(1) = ang_yj(2,1)
     $                      + ang_yj(3,1)
     $                      + ang_yj(4,1)
c
                    angsav(1,1,2,llpot,lmpi,lmpj) =
     $               ylmi_t(1)*angj(1)
c
                    angsav(2,1,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,1)
                    angsav(3,1,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,2)
                    angsav(4,1,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,3)
c
                    angsav(5,1,2,llpot,lmpi,lmpj) =
     $               ang_yi(1,2)*grylmj_t(2,1) +
     $               ang_yi(1,3)*grylmj_t(3,1) +
     $               ang_yi(1,4)*grylmj_t(4,1)
                    angsav(6,1,2,llpot,lmpi,lmpj) =
     $               ang_yi(1,2)*grylmj_t(2,2) +
     $               ang_yi(1,3)*grylmj_t(3,2) +
     $               ang_yi(1,4)*grylmj_t(4,2)
                    angsav(7,1,2,llpot,lmpi,lmpj) =
     $               ang_yi(1,2)*grylmj_t(2,3) +
     $               ang_yi(1,3)*grylmj_t(3,3) +
     $               ang_yi(1,4)*grylmj_t(4,3)
c
                  elseif( lli .eq. 2 )then
c
                    angi(1) = ang_yi(2,2)
     $                      + ang_yi(3,2)
     $                      + ang_yi(4,2)
                    angi(2) = ang_yi(2,3)
     $                      + ang_yi(3,3)
     $                      + ang_yi(4,3)
                    angi(3) = ang_yi(2,4)
     $                      + ang_yi(3,4)
     $                      + ang_yi(4,4)
c
                    angj(1) = ang_yj(2,2)
     $                      + ang_yj(3,2)
     $                      + ang_yj(4,2)
                    angj(2) = ang_yj(2,3)
     $                      + ang_yj(3,3)
     $                      + ang_yj(4,3)
                    angj(3) = ang_yj(2,4)
     $                      + ang_yj(3,4)
     $                      + ang_yj(4,4)
c
                    angsav(1,2,2,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(2) +
     $               angi(2)*ylmj_t(3) +
     $               angi(3)*ylmj_t(4)
c
                    angsav(2,2,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,1) +
     $               angj(2)*grylmi_t(3,1) +
     $               angj(3)*grylmi_t(4,1)
                    angsav(3,2,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,2) +
     $               angj(2)*grylmi_t(3,2) +
     $               angj(3)*grylmi_t(4,2)
                    angsav(4,2,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,3) +
     $               angj(2)*grylmi_t(3,3) +
     $               angj(3)*grylmi_t(4,3)
c
                    angsav(5,2,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,1)*angi(1) +
     $               grylmj_t(3,1)*angi(2) +
     $               grylmj_t(4,1)*angi(3)
                    angsav(6,2,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,2)*angi(1) +
     $               grylmj_t(3,2)*angi(2) +
     $               grylmj_t(4,2)*angi(3)
                    angsav(7,2,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,3)*angi(1) +
     $               grylmj_t(3,3)*angi(2) +
     $               grylmj_t(4,3)*angi(3)
c
                  elseif( lli .eq. 3 )then
c
                    angi(1) = ang_yi(5,2)
     $                      + ang_yi(6,2)
     $                      + ang_yi(7,2)
     $                      + ang_yi(8,2)
     $                      + ang_yi(9,2)
                    angi(2) = ang_yi(5,3)
     $                      + ang_yi(6,3)
     $                      + ang_yi(7,3)
     $                      + ang_yi(8,3)
     $                      + ang_yi(9,3)
                    angi(3) = ang_yi(5,4)
     $                      + ang_yi(6,4)
     $                      + ang_yi(7,4)
     $                      + ang_yi(8,4)
     $                      + ang_yi(9,4)
c
                    angj(1) = ang_yj(2,5)
     $                      + ang_yj(3,5)
     $                      + ang_yj(4,5)
                    angj(2) = ang_yj(2,6)
     $                      + ang_yj(3,6)
     $                      + ang_yj(4,6)
                    angj(3) = ang_yj(2,7)
     $                      + ang_yj(3,7)
     $                      + ang_yj(4,7)
                    angj(4) = ang_yj(2,8)
     $                      + ang_yj(3,8)
     $                      + ang_yj(4,8)
                    angj(5) = ang_yj(2,9)
     $                      + ang_yj(3,9)
     $                      + ang_yj(4,9)
c
                    angsav(1,3,2,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(2) +
     $               angi(2)*ylmj_t(3) +
     $               angi(3)*ylmj_t(4)
c
                    angsav(2,3,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,1) +
     $               angj(2)*grylmi_t(6,1) +
     $               angj(3)*grylmi_t(7,1) +
     $               angj(4)*grylmi_t(8,1) +
     $               angj(5)*grylmi_t(9,1)
                    angsav(3,3,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,2) +
     $               angj(2)*grylmi_t(6,2) +
     $               angj(3)*grylmi_t(7,2) +
     $               angj(4)*grylmi_t(8,2) +
     $               angj(5)*grylmi_t(9,2)
                    angsav(4,3,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,3) +
     $               angj(2)*grylmi_t(6,3) +
     $               angj(3)*grylmi_t(7,3) +
     $               angj(4)*grylmi_t(8,3) +
     $               angj(5)*grylmi_t(9,3)
c
                    angsav(5,3,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,1)*angi(1) +
     $               grylmj_t(3,1)*angi(2) +
     $               grylmj_t(4,1)*angi(3)
                    angsav(6,3,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,2)*angi(1) +
     $               grylmj_t(3,2)*angi(2) +
     $               grylmj_t(4,2)*angi(3)
                    angsav(7,3,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,3)*angi(1) +
     $               grylmj_t(3,3)*angi(2) +
     $               grylmj_t(4,3)*angi(3)
c
                  elseif( lli .eq. 4 )then
c
                    angi(1) = ang_yi(10,2)
     $                      + ang_yi(11,2)
     $                      + ang_yi(12,2)
     $                      + ang_yi(13,2)
     $                      + ang_yi(14,2)
     $                      + ang_yi(15,2)
     $                      + ang_yi(16,2)
                    angi(2) = ang_yi(10,3)
     $                      + ang_yi(11,3)
     $                      + ang_yi(12,3)
     $                      + ang_yi(13,3)
     $                      + ang_yi(14,3)
     $                      + ang_yi(15,3)
     $                      + ang_yi(16,3)
                    angi(3) = ang_yi(10,4)
     $                      + ang_yi(11,4)
     $                      + ang_yi(12,4)
     $                      + ang_yi(13,4)
     $                      + ang_yi(14,4)
     $                      + ang_yi(15,4)
     $                      + ang_yi(16,4)
c
                    angj(1) = ang_yj(2,10)
     $                      + ang_yj(3,10)
     $                      + ang_yj(4,10)
                    angj(2) = ang_yj(2,11)
     $                      + ang_yj(3,11)
     $                      + ang_yj(4,11)
                    angj(3) = ang_yj(2,12)
     $                      + ang_yj(3,12)
     $                      + ang_yj(4,12)
                    angj(4) = ang_yj(2,13)
     $                      + ang_yj(3,13)
     $                      + ang_yj(4,13)
                    angj(5) = ang_yj(2,14)
     $                      + ang_yj(3,14)
     $                      + ang_yj(4,14)
                    angj(6) = ang_yj(2,15)
     $                      + ang_yj(3,15)
     $                      + ang_yj(4,15)
                    angj(7) = ang_yj(2,16)
     $                      + ang_yj(3,16)
     $                      + ang_yj(4,16)
c
                    angsav(1,4,2,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(2) +
     $               angi(2)*ylmj_t(3) +
     $               angi(3)*ylmj_t(4)
c
                    angsav(2,4,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,1) +
     $               angj(2)*grylmi_t(11,1) +
     $               angj(3)*grylmi_t(12,1) +
     $               angj(4)*grylmi_t(13,1) +
     $               angj(5)*grylmi_t(14,1) +
     $               angj(6)*grylmi_t(15,1) +
     $               angj(7)*grylmi_t(16,1)
                    angsav(3,4,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,2) +
     $               angj(2)*grylmi_t(11,2) +
     $               angj(3)*grylmi_t(12,2) +
     $               angj(4)*grylmi_t(13,2) +
     $               angj(5)*grylmi_t(14,2) +
     $               angj(6)*grylmi_t(15,2) +
     $               angj(7)*grylmi_t(16,2)
                    angsav(4,4,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,3) +
     $               angj(2)*grylmi_t(11,3) +
     $               angj(3)*grylmi_t(12,3) +
     $               angj(4)*grylmi_t(13,3) +
     $               angj(5)*grylmi_t(14,3) +
     $               angj(6)*grylmi_t(15,3) +
     $               angj(7)*grylmi_t(16,3)
c
                    angsav(5,4,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,1)*angi(1) +
     $               grylmj_t(3,1)*angi(2) +
     $               grylmj_t(4,1)*angi(3)
                    angsav(6,4,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,2)*angi(1) +
     $               grylmj_t(3,2)*angi(2) +
     $               grylmj_t(4,2)*angi(3)
                    angsav(7,4,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,3)*angi(1) +
     $               grylmj_t(3,3)*angi(2) +
     $               grylmj_t(4,3)*angi(3)
c
                  elseif( lli .eq. 5 )then
c
                    angi(1) = ang_yi(17,2)
     $                      + ang_yi(18,2)
     $                      + ang_yi(19,2)
     $                      + ang_yi(20,2)
     $                      + ang_yi(21,2)
     $                      + ang_yi(22,2)
     $                      + ang_yi(23,2)
     $                      + ang_yi(24,2)
     $                      + ang_yi(25,2)
                    angi(2) = ang_yi(17,3)
     $                      + ang_yi(18,3)
     $                      + ang_yi(19,3)
     $                      + ang_yi(20,3)
     $                      + ang_yi(21,3)
     $                      + ang_yi(22,3)
     $                      + ang_yi(23,3)
     $                      + ang_yi(24,3)
     $                      + ang_yi(25,3)
                    angi(3) = ang_yi(17,4)
     $                      + ang_yi(18,4)
     $                      + ang_yi(19,4)
     $                      + ang_yi(20,4)
     $                      + ang_yi(21,4)
     $                      + ang_yi(22,4)
     $                      + ang_yi(23,4)
     $                      + ang_yi(24,4)
     $                      + ang_yi(25,4)
c
                    angj(1) = ang_yj(2,17)
     $                      + ang_yj(3,17)
     $                      + ang_yj(4,17)
                    angj(2) = ang_yj(2,18)
     $                      + ang_yj(3,18)
     $                      + ang_yj(4,18)
                    angj(3) = ang_yj(2,19)
     $                      + ang_yj(3,19)
     $                      + ang_yj(4,19)
                    angj(4) = ang_yj(2,20)
     $                      + ang_yj(3,20)
     $                      + ang_yj(4,20)
                    angj(5) = ang_yj(2,21)
     $                      + ang_yj(3,21)
     $                      + ang_yj(4,21)
                    angj(6) = ang_yj(2,22)
     $                      + ang_yj(3,22)
     $                      + ang_yj(4,22)
                    angj(7) = ang_yj(2,23)
     $                      + ang_yj(3,23)
     $                      + ang_yj(4,23)
                    angj(8) = ang_yj(2,24)
     $                      + ang_yj(3,24)
     $                      + ang_yj(4,24)
                    angj(9) = ang_yj(2,25)
     $                      + ang_yj(3,25)
     $                      + ang_yj(4,25)
c
                    angsav(1,5,2,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(2) +
     $               angi(2)*ylmj_t(3) +
     $               angi(3)*ylmj_t(4)
c
                    angsav(2,5,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,1) +
     $               angj(2)*grylmi_t(18,1) +
     $               angj(3)*grylmi_t(19,1) +
     $               angj(4)*grylmi_t(20,1) +
     $               angj(5)*grylmi_t(21,1) +
     $               angj(6)*grylmi_t(22,1) +
     $               angj(7)*grylmi_t(23,1) +
     $               angj(8)*grylmi_t(24,1) +
     $               angj(9)*grylmi_t(25,1)
                    angsav(3,5,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,2) +
     $               angj(2)*grylmi_t(18,2) +
     $               angj(3)*grylmi_t(19,2) +
     $               angj(4)*grylmi_t(20,2) +
     $               angj(5)*grylmi_t(21,2) +
     $               angj(6)*grylmi_t(22,2) +
     $               angj(7)*grylmi_t(23,2) +
     $               angj(8)*grylmi_t(24,2) +
     $               angj(9)*grylmi_t(25,2)
                    angsav(4,5,2,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,3) +
     $               angj(2)*grylmi_t(18,3) +
     $               angj(3)*grylmi_t(19,3) +
     $               angj(4)*grylmi_t(20,3) +
     $               angj(5)*grylmi_t(21,3) +
     $               angj(6)*grylmi_t(22,3) +
     $               angj(7)*grylmi_t(23,3) +
     $               angj(8)*grylmi_t(24,3) +
     $               angj(9)*grylmi_t(25,3)
c
                    angsav(5,5,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,1)*angi(1) +
     $               grylmj_t(3,1)*angi(2) +
     $               grylmj_t(4,1)*angi(3)
                    angsav(6,5,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,2)*angi(1) +
     $               grylmj_t(3,2)*angi(2) +
     $               grylmj_t(4,2)*angi(3)
                    angsav(7,5,2,llpot,lmpi,lmpj) =
     $               grylmj_t(2,3)*angi(1) +
     $               grylmj_t(3,3)*angi(2) +
     $               grylmj_t(4,3)*angi(3)
c
                  else
c
                    call STOPXERR( 'nlangf-2' )
c
                  endif
c
                enddo
c
              elseif( llj .eq. 3 )then
c
                do  lli=1,limxp1
c
                  if( lli .eq. 1 )then
c
                    angj(1) = ang_yj(5,1)
     $                      + ang_yj(6,1)
     $                      + ang_yj(7,1)
     $                      + ang_yj(8,1)
     $                      + ang_yj(9,1)
c
                    angsav(1,1,3,llpot,lmpi,lmpj) =
     $               ylmi_t(1)*angj(1)
c
                    angsav(2,1,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,1)
                    angsav(3,1,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,2)
                    angsav(4,1,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,3)
c
                    angsav(5,1,3,llpot,lmpi,lmpj) =
     $               ang_yi(1,5)*grylmj_t(5,1) +
     $               ang_yi(1,6)*grylmj_t(6,1) +
     $               ang_yi(1,7)*grylmj_t(7,1) +
     $               ang_yi(1,8)*grylmj_t(8,1) +
     $               ang_yi(1,9)*grylmj_t(9,1)
                    angsav(6,1,3,llpot,lmpi,lmpj) =
     $               ang_yi(1,5)*grylmj_t(5,2) +
     $               ang_yi(1,6)*grylmj_t(6,2) +
     $               ang_yi(1,7)*grylmj_t(7,2) +
     $               ang_yi(1,8)*grylmj_t(8,2) +
     $               ang_yi(1,9)*grylmj_t(9,2)
                    angsav(7,1,3,llpot,lmpi,lmpj) =
     $               ang_yi(1,5)*grylmj_t(5,3) +
     $               ang_yi(1,6)*grylmj_t(6,3) +
     $               ang_yi(1,7)*grylmj_t(7,3) +
     $               ang_yi(1,8)*grylmj_t(8,3) +
     $               ang_yi(1,9)*grylmj_t(9,3)
c
                  elseif( lli .eq. 2 )then
c
                    angi(1) = ang_yi(2,5)
     $                      + ang_yi(3,5)
     $                      + ang_yi(4,5)
                    angi(2) = ang_yi(2,6)
     $                      + ang_yi(3,6)
     $                      + ang_yi(4,6)
                    angi(3) = ang_yi(2,7)
     $                      + ang_yi(3,7)
     $                      + ang_yi(4,7)
                    angi(4) = ang_yi(2,8)
     $                      + ang_yi(3,8)
     $                      + ang_yi(4,8)
                    angi(5) = ang_yi(2,9)
     $                      + ang_yi(3,9)
     $                      + ang_yi(4,9)
c
                    angj(1) = ang_yj(5,2)
     $                      + ang_yj(6,2)
     $                      + ang_yj(7,2)
     $                      + ang_yj(8,2)
     $                      + ang_yj(9,2)
                    angj(2) = ang_yj(5,3)
     $                      + ang_yj(6,3)
     $                      + ang_yj(7,3)
     $                      + ang_yj(8,3)
     $                      + ang_yj(9,3)
                    angj(3) = ang_yj(5,4)
     $                      + ang_yj(6,4)
     $                      + ang_yj(7,4)
     $                      + ang_yj(8,4)
     $                      + ang_yj(9,4)
c
                    angsav(1,2,3,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(5) +
     $               angi(2)*ylmj_t(6) +
     $               angi(3)*ylmj_t(7) +
     $               angi(4)*ylmj_t(8) +
     $               angi(5)*ylmj_t(9)
c
                    angsav(2,2,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,1) +
     $               angj(2)*grylmi_t(3,1) +
     $               angj(3)*grylmi_t(4,1)
                    angsav(3,2,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,2) +
     $               angj(2)*grylmi_t(3,2) +
     $               angj(3)*grylmi_t(4,2)
                    angsav(4,2,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,3) +
     $               angj(2)*grylmi_t(3,3) +
     $               angj(3)*grylmi_t(4,3)
c
                    angsav(5,2,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,1)*angi(1) +
     $               grylmj_t(6,1)*angi(2) +
     $               grylmj_t(7,1)*angi(3) +
     $               grylmj_t(8,1)*angi(4) +
     $               grylmj_t(9,1)*angi(5)
                    angsav(6,2,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,2)*angi(1) +
     $               grylmj_t(6,2)*angi(2) +
     $               grylmj_t(7,2)*angi(3) +
     $               grylmj_t(8,2)*angi(4) +
     $               grylmj_t(9,2)*angi(5)
                    angsav(7,2,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,3)*angi(1) +
     $               grylmj_t(6,3)*angi(2) +
     $               grylmj_t(7,3)*angi(3) +
     $               grylmj_t(8,3)*angi(4) +
     $               grylmj_t(9,3)*angi(5)
c
                  elseif( lli .eq. 3 )then
c
                    angi(1) = ang_yi(5,5)
     $                      + ang_yi(6,5)
     $                      + ang_yi(7,5)
     $                      + ang_yi(8,5)
     $                      + ang_yi(9,5)
                    angi(2) = ang_yi(5,6)
     $                      + ang_yi(6,6)
     $                      + ang_yi(7,6)
     $                      + ang_yi(8,6)
     $                      + ang_yi(9,6)
                    angi(3) = ang_yi(5,7)
     $                      + ang_yi(6,7)
     $                      + ang_yi(7,7)
     $                      + ang_yi(8,7)
     $                      + ang_yi(9,7)
                    angi(4) = ang_yi(5,8)
     $                      + ang_yi(6,8)
     $                      + ang_yi(7,8)
     $                      + ang_yi(8,8)
     $                      + ang_yi(9,8)
                    angi(5) = ang_yi(5,9)
     $                      + ang_yi(6,9)
     $                      + ang_yi(7,9)
     $                      + ang_yi(8,9)
     $                      + ang_yi(9,9)
c
                    angj(1) = ang_yj(5,5)
     $                      + ang_yj(6,5)
     $                      + ang_yj(7,5)
     $                      + ang_yj(8,5)
     $                      + ang_yj(9,5)
                    angj(2) = ang_yj(5,6)
     $                      + ang_yj(6,6)
     $                      + ang_yj(7,6)
     $                      + ang_yj(8,6)
     $                      + ang_yj(9,6)
                    angj(3) = ang_yj(5,7)
     $                      + ang_yj(6,7)
     $                      + ang_yj(7,7)
     $                      + ang_yj(8,7)
     $                      + ang_yj(9,7)
                    angj(4) = ang_yj(5,8)
     $                      + ang_yj(6,8)
     $                      + ang_yj(7,8)
     $                      + ang_yj(8,8)
     $                      + ang_yj(9,8)
                    angj(5) = ang_yj(5,9)
     $                      + ang_yj(6,9)
     $                      + ang_yj(7,9)
     $                      + ang_yj(8,9)
     $                      + ang_yj(9,9)
c
                    angsav(1,3,3,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(5) +
     $               angi(2)*ylmj_t(6) +
     $               angi(3)*ylmj_t(7) +
     $               angi(4)*ylmj_t(8) +
     $               angi(5)*ylmj_t(9)
c
                    angsav(2,3,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,1) +
     $               angj(2)*grylmi_t(6,1) +
     $               angj(3)*grylmi_t(7,1) +
     $               angj(4)*grylmi_t(8,1) +
     $               angj(5)*grylmi_t(9,1)
                    angsav(3,3,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,2) +
     $               angj(2)*grylmi_t(6,2) +
     $               angj(3)*grylmi_t(7,2) +
     $               angj(4)*grylmi_t(8,2) +
     $               angj(5)*grylmi_t(9,2)
                    angsav(4,3,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,3) +
     $               angj(2)*grylmi_t(6,3) +
     $               angj(3)*grylmi_t(7,3) +
     $               angj(4)*grylmi_t(8,3) +
     $               angj(5)*grylmi_t(9,3)
c
                    angsav(5,3,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,1)*angi(1) +
     $               grylmj_t(6,1)*angi(2) +
     $               grylmj_t(7,1)*angi(3) +
     $               grylmj_t(8,1)*angi(4) +
     $               grylmj_t(9,1)*angi(5)
                    angsav(6,3,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,2)*angi(1) +
     $               grylmj_t(6,2)*angi(2) +
     $               grylmj_t(7,2)*angi(3) +
     $               grylmj_t(8,2)*angi(4) +
     $               grylmj_t(9,2)*angi(5)
                    angsav(7,3,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,3)*angi(1) +
     $               grylmj_t(6,3)*angi(2) +
     $               grylmj_t(7,3)*angi(3) +
     $               grylmj_t(8,3)*angi(4) +
     $               grylmj_t(9,3)*angi(5)
c
                  elseif( lli .eq. 4 )then
c
                    angi(1) = ang_yi(10,5)
     $                      + ang_yi(11,5)
     $                      + ang_yi(12,5)
     $                      + ang_yi(13,5)
     $                      + ang_yi(14,5)
     $                      + ang_yi(15,5)
     $                      + ang_yi(16,5)
                    angi(2) = ang_yi(10,6)
     $                      + ang_yi(11,6)
     $                      + ang_yi(12,6)
     $                      + ang_yi(13,6)
     $                      + ang_yi(14,6)
     $                      + ang_yi(15,6)
     $                      + ang_yi(16,6)
                    angi(3) = ang_yi(10,7)
     $                      + ang_yi(11,7)
     $                      + ang_yi(12,7)
     $                      + ang_yi(13,7)
     $                      + ang_yi(14,7)
     $                      + ang_yi(15,7)
     $                      + ang_yi(16,7)
                    angi(4) = ang_yi(10,8)
     $                      + ang_yi(11,8)
     $                      + ang_yi(12,8)
     $                      + ang_yi(13,8)
     $                      + ang_yi(14,8)
     $                      + ang_yi(15,8)
     $                      + ang_yi(16,8)
                    angi(5) = ang_yi(10,9)
     $                      + ang_yi(11,9)
     $                      + ang_yi(12,9)
     $                      + ang_yi(13,9)
     $                      + ang_yi(14,9)
     $                      + ang_yi(15,9)
     $                      + ang_yi(16,9)
c
                    angj(1) = ang_yj(5,10)
     $                      + ang_yj(6,10)
     $                      + ang_yj(7,10)
     $                      + ang_yj(8,10)
     $                      + ang_yj(9,10)
                    angj(2) = ang_yj(5,11)
     $                      + ang_yj(6,11)
     $                      + ang_yj(7,11)
     $                      + ang_yj(8,11)
     $                      + ang_yj(9,11)
                    angj(3) = ang_yj(5,12)
     $                      + ang_yj(6,12)
     $                      + ang_yj(7,12)
     $                      + ang_yj(8,12)
     $                      + ang_yj(9,12)
                    angj(4) = ang_yj(5,13)
     $                      + ang_yj(6,13)
     $                      + ang_yj(7,13)
     $                      + ang_yj(8,13)
     $                      + ang_yj(9,13)
                    angj(5) = ang_yj(5,14)
     $                      + ang_yj(6,14)
     $                      + ang_yj(7,14)
     $                      + ang_yj(8,14)
     $                      + ang_yj(9,14)
                    angj(6) = ang_yj(5,15)
     $                      + ang_yj(6,15)
     $                      + ang_yj(7,15)
     $                      + ang_yj(8,15)
     $                      + ang_yj(9,15)
                    angj(7) = ang_yj(5,16)
     $                      + ang_yj(6,16)
     $                      + ang_yj(7,16)
     $                      + ang_yj(8,16)
     $                      + ang_yj(9,16)
c
                    angsav(1,4,3,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(5) +
     $               angi(2)*ylmj_t(6) +
     $               angi(3)*ylmj_t(7) +
     $               angi(4)*ylmj_t(8) +
     $               angi(5)*ylmj_t(9)
c
                    angsav(2,4,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,1) +
     $               angj(2)*grylmi_t(11,1) +
     $               angj(3)*grylmi_t(12,1) +
     $               angj(4)*grylmi_t(13,1) +
     $               angj(5)*grylmi_t(14,1) +
     $               angj(6)*grylmi_t(15,1) +
     $               angj(7)*grylmi_t(16,1)
                    angsav(3,4,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,2) +
     $               angj(2)*grylmi_t(11,2) +
     $               angj(3)*grylmi_t(12,2) +
     $               angj(4)*grylmi_t(13,2) +
     $               angj(5)*grylmi_t(14,2) +
     $               angj(6)*grylmi_t(15,2) +
     $               angj(7)*grylmi_t(16,2)
                    angsav(4,4,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,3) +
     $               angj(2)*grylmi_t(11,3) +
     $               angj(3)*grylmi_t(12,3) +
     $               angj(4)*grylmi_t(13,3) +
     $               angj(5)*grylmi_t(14,3) +
     $               angj(6)*grylmi_t(15,3) +
     $               angj(7)*grylmi_t(16,3)
c
                    angsav(5,4,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,1)*angi(1) +
     $               grylmj_t(6,1)*angi(2) +
     $               grylmj_t(7,1)*angi(3) +
     $               grylmj_t(8,1)*angi(4) +
     $               grylmj_t(9,1)*angi(5)
                    angsav(6,4,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,2)*angi(1) +
     $               grylmj_t(6,2)*angi(2) +
     $               grylmj_t(7,2)*angi(3) +
     $               grylmj_t(8,2)*angi(4) +
     $               grylmj_t(9,2)*angi(5)
                    angsav(7,4,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,3)*angi(1) +
     $               grylmj_t(6,3)*angi(2) +
     $               grylmj_t(7,3)*angi(3) +
     $               grylmj_t(8,3)*angi(4) +
     $               grylmj_t(9,3)*angi(5)
c
                  elseif( lli .eq. 5 )then
c
                    angi(1) = ang_yi(17,5)
     $                      + ang_yi(18,5)
     $                      + ang_yi(19,5)
     $                      + ang_yi(20,5)
     $                      + ang_yi(21,5)
     $                      + ang_yi(22,5)
     $                      + ang_yi(23,5)
     $                      + ang_yi(24,5)
     $                      + ang_yi(25,5)
                    angi(2) = ang_yi(17,6)
     $                      + ang_yi(18,6)
     $                      + ang_yi(19,6)
     $                      + ang_yi(20,6)
     $                      + ang_yi(21,6)
     $                      + ang_yi(22,6)
     $                      + ang_yi(23,6)
     $                      + ang_yi(24,6)
     $                      + ang_yi(25,6)
                    angi(3) = ang_yi(17,7)
     $                      + ang_yi(18,7)
     $                      + ang_yi(19,7)
     $                      + ang_yi(20,7)
     $                      + ang_yi(21,7)
     $                      + ang_yi(22,7)
     $                      + ang_yi(23,7)
     $                      + ang_yi(24,7)
     $                      + ang_yi(25,7)
                    angi(4) = ang_yi(17,8)
     $                      + ang_yi(18,8)
     $                      + ang_yi(19,8)
     $                      + ang_yi(20,8)
     $                      + ang_yi(21,8)
     $                      + ang_yi(22,8)
     $                      + ang_yi(23,8)
     $                      + ang_yi(24,8)
     $                      + ang_yi(25,8)
                    angi(5) = ang_yi(17,9)
     $                      + ang_yi(18,9)
     $                      + ang_yi(19,9)
     $                      + ang_yi(20,9)
     $                      + ang_yi(21,9)
     $                      + ang_yi(22,9)
     $                      + ang_yi(23,9)
     $                      + ang_yi(24,9)
     $                      + ang_yi(25,9)
c
                    angj(1) = ang_yj(5,17)
     $                      + ang_yj(6,17)
     $                      + ang_yj(7,17)
     $                      + ang_yj(8,17)
     $                      + ang_yj(9,17)
                    angj(2) = ang_yj(5,18)
     $                      + ang_yj(6,18)
     $                      + ang_yj(7,18)
     $                      + ang_yj(8,18)
     $                      + ang_yj(9,18)
                    angj(3) = ang_yj(5,19)
     $                      + ang_yj(6,19)
     $                      + ang_yj(7,19)
     $                      + ang_yj(8,19)
     $                      + ang_yj(9,19)
                    angj(4) = ang_yj(5,20)
     $                      + ang_yj(6,20)
     $                      + ang_yj(7,20)
     $                      + ang_yj(8,20)
     $                      + ang_yj(9,20)
                    angj(5) = ang_yj(5,21)
     $                      + ang_yj(6,21)
     $                      + ang_yj(7,21)
     $                      + ang_yj(8,21)
     $                      + ang_yj(9,21)
                    angj(6) = ang_yj(5,22)
     $                      + ang_yj(6,22)
     $                      + ang_yj(7,22)
     $                      + ang_yj(8,22)
     $                      + ang_yj(9,22)
                    angj(7) = ang_yj(5,23)
     $                      + ang_yj(6,23)
     $                      + ang_yj(7,23)
     $                      + ang_yj(8,23)
     $                      + ang_yj(9,23)
                    angj(8) = ang_yj(5,24)
     $                      + ang_yj(6,24)
     $                      + ang_yj(7,24)
     $                      + ang_yj(8,24)
     $                      + ang_yj(9,24)
                    angj(9) = ang_yj(5,25)
     $                      + ang_yj(6,25)
     $                      + ang_yj(7,25)
     $                      + ang_yj(8,25)
     $                      + ang_yj(9,25)
c
                    angsav(1,5,3,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(5) +
     $               angi(2)*ylmj_t(6) +
     $               angi(3)*ylmj_t(7) +
     $               angi(4)*ylmj_t(8) +
     $               angi(5)*ylmj_t(9)
c
                    angsav(2,5,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,1) +
     $               angj(2)*grylmi_t(18,1) +
     $               angj(3)*grylmi_t(19,1) +
     $               angj(4)*grylmi_t(20,1) +
     $               angj(5)*grylmi_t(21,1) +
     $               angj(6)*grylmi_t(22,1) +
     $               angj(7)*grylmi_t(23,1) +
     $               angj(8)*grylmi_t(24,1) +
     $               angj(9)*grylmi_t(25,1)
                    angsav(3,5,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,2) +
     $               angj(2)*grylmi_t(18,2) +
     $               angj(3)*grylmi_t(19,2) +
     $               angj(4)*grylmi_t(20,2) +
     $               angj(5)*grylmi_t(21,2) +
     $               angj(6)*grylmi_t(22,2) +
     $               angj(7)*grylmi_t(23,2) +
     $               angj(8)*grylmi_t(24,2) +
     $               angj(9)*grylmi_t(25,2)
                    angsav(4,5,3,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,3) +
     $               angj(2)*grylmi_t(18,3) +
     $               angj(3)*grylmi_t(19,3) +
     $               angj(4)*grylmi_t(20,3) +
     $               angj(5)*grylmi_t(21,3) +
     $               angj(6)*grylmi_t(22,3) +
     $               angj(7)*grylmi_t(23,3) +
     $               angj(8)*grylmi_t(24,3) +
     $               angj(9)*grylmi_t(25,3)
c
                    angsav(5,5,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,1)*angi(1) +
     $               grylmj_t(6,1)*angi(2) +
     $               grylmj_t(7,1)*angi(3) +
     $               grylmj_t(8,1)*angi(4) +
     $               grylmj_t(9,1)*angi(5)
                    angsav(6,5,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,2)*angi(1) +
     $               grylmj_t(6,2)*angi(2) +
     $               grylmj_t(7,2)*angi(3) +
     $               grylmj_t(8,2)*angi(4) +
     $               grylmj_t(9,2)*angi(5)
                    angsav(7,5,3,llpot,lmpi,lmpj) =
     $               grylmj_t(5,3)*angi(1) +
     $               grylmj_t(6,3)*angi(2) +
     $               grylmj_t(7,3)*angi(3) +
     $               grylmj_t(8,3)*angi(4) +
     $               grylmj_t(9,3)*angi(5)
c
                  else
c
                    call STOPXERR( 'nlangf-3' )
c
                  endif
c
                enddo
c
              elseif( llj .eq. 4 )then
c
                do  lli=1,limxp1
c
                  if( lli .eq. 1 )then
c
                    angj(1) = ang_yj(10,1)
     $                      + ang_yj(11,1)
     $                      + ang_yj(12,1)
     $                      + ang_yj(13,1)
     $                      + ang_yj(14,1)
     $                      + ang_yj(15,1)
     $                      + ang_yj(16,1)
c
                    angsav(1,1,4,llpot,lmpi,lmpj) =
     $               ylmi_t(1)*angj(1)
c
                    angsav(2,1,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,1)
                    angsav(3,1,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,2)
                    angsav(4,1,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,3)
c
                    angsav(5,1,4,llpot,lmpi,lmpj) =
     $               ang_yi(1,10)*grylmj_t(10,1) +
     $               ang_yi(1,11)*grylmj_t(11,1) +
     $               ang_yi(1,12)*grylmj_t(12,1) +
     $               ang_yi(1,13)*grylmj_t(13,1) +
     $               ang_yi(1,14)*grylmj_t(14,1) +
     $               ang_yi(1,15)*grylmj_t(15,1) +
     $               ang_yi(1,16)*grylmj_t(16,1)
                    angsav(6,1,4,llpot,lmpi,lmpj) =
     $               ang_yi(1,10)*grylmj_t(10,2) +
     $               ang_yi(1,11)*grylmj_t(11,2) +
     $               ang_yi(1,12)*grylmj_t(12,2) +
     $               ang_yi(1,13)*grylmj_t(13,2) +
     $               ang_yi(1,14)*grylmj_t(14,2) +
     $               ang_yi(1,15)*grylmj_t(15,2) +
     $               ang_yi(1,16)*grylmj_t(16,2)
                    angsav(7,1,4,llpot,lmpi,lmpj) =
     $               ang_yi(1,10)*grylmj_t(10,3) +
     $               ang_yi(1,11)*grylmj_t(11,3) +
     $               ang_yi(1,12)*grylmj_t(12,3) +
     $               ang_yi(1,13)*grylmj_t(13,3) +
     $               ang_yi(1,14)*grylmj_t(14,3) +
     $               ang_yi(1,15)*grylmj_t(15,3) +
     $               ang_yi(1,16)*grylmj_t(16,3)
c
                  elseif( lli .eq. 2 )then
c
                    angi(1) = ang_yi(2,10)
     $                      + ang_yi(3,10)
     $                      + ang_yi(4,10)
                    angi(2) = ang_yi(2,11)
     $                      + ang_yi(3,11)
     $                      + ang_yi(4,11)
                    angi(3) = ang_yi(2,12)
     $                      + ang_yi(3,12)
     $                      + ang_yi(4,12)
                    angi(4) = ang_yi(2,13)
     $                      + ang_yi(3,13)
     $                      + ang_yi(4,13)
                    angi(5) = ang_yi(2,14)
     $                      + ang_yi(3,14)
     $                      + ang_yi(4,14)
                    angi(6) = ang_yi(2,15)
     $                      + ang_yi(3,15)
     $                      + ang_yi(4,15)
                    angi(7) = ang_yi(2,16)
     $                      + ang_yi(3,16)
     $                      + ang_yi(4,16)
c
                    angj(1) = ang_yj(10,2)
     $                      + ang_yj(11,2)
     $                      + ang_yj(12,2)
     $                      + ang_yj(13,2)
     $                      + ang_yj(14,2)
     $                      + ang_yj(15,2)
     $                      + ang_yj(16,2)
                    angj(2) = ang_yj(10,3)
     $                      + ang_yj(11,3)
     $                      + ang_yj(12,3)
     $                      + ang_yj(13,3)
     $                      + ang_yj(14,3)
     $                      + ang_yj(15,3)
     $                      + ang_yj(16,3)
                    angj(3) = ang_yj(10,4)
     $                      + ang_yj(11,4)
     $                      + ang_yj(12,4)
     $                      + ang_yj(13,4)
     $                      + ang_yj(14,4)
     $                      + ang_yj(15,4)
     $                      + ang_yj(16,4)
c
                    angsav(1,2,4,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(10) +
     $               angi(2)*ylmj_t(11) +
     $               angi(3)*ylmj_t(12) +
     $               angi(4)*ylmj_t(13) +
     $               angi(5)*ylmj_t(14) +
     $               angi(6)*ylmj_t(15) +
     $               angi(7)*ylmj_t(16)
c
                    angsav(2,2,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,1) +
     $               angj(2)*grylmi_t(3,1) +
     $               angj(3)*grylmi_t(4,1)
                    angsav(3,2,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,2) +
     $               angj(2)*grylmi_t(3,2) +
     $               angj(3)*grylmi_t(4,2)
                    angsav(4,2,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,3) +
     $               angj(2)*grylmi_t(3,3) +
     $               angj(3)*grylmi_t(4,3)
c
                    angsav(5,2,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,1)*angi(1) +
     $               grylmj_t(11,1)*angi(2) +
     $               grylmj_t(12,1)*angi(3) +
     $               grylmj_t(13,1)*angi(4) +
     $               grylmj_t(14,1)*angi(5) +
     $               grylmj_t(15,1)*angi(6) +
     $               grylmj_t(16,1)*angi(7)
                    angsav(6,2,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,2)*angi(1) +
     $               grylmj_t(11,2)*angi(2) +
     $               grylmj_t(12,2)*angi(3) +
     $               grylmj_t(13,2)*angi(4) +
     $               grylmj_t(14,2)*angi(5) +
     $               grylmj_t(15,2)*angi(6) +
     $               grylmj_t(16,2)*angi(7)
                    angsav(7,2,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,3)*angi(1) +
     $               grylmj_t(11,3)*angi(2) +
     $               grylmj_t(12,3)*angi(3) +
     $               grylmj_t(13,3)*angi(4) +
     $               grylmj_t(14,3)*angi(5) +
     $               grylmj_t(15,3)*angi(6) +
     $               grylmj_t(16,3)*angi(7)
c
                  elseif( lli .eq. 3 )then
c
                    angi(1) = ang_yi(5,10)
     $                      + ang_yi(6,10)
     $                      + ang_yi(7,10)
     $                      + ang_yi(8,10)
     $                      + ang_yi(9,10)
                    angi(2) = ang_yi(5,11)
     $                      + ang_yi(6,11)
     $                      + ang_yi(7,11)
     $                      + ang_yi(8,11)
     $                      + ang_yi(9,11)
                    angi(3) = ang_yi(5,12)
     $                      + ang_yi(6,12)
     $                      + ang_yi(7,12)
     $                      + ang_yi(8,12)
     $                      + ang_yi(9,12)
                    angi(4) = ang_yi(5,13)
     $                      + ang_yi(6,13)
     $                      + ang_yi(7,13)
     $                      + ang_yi(8,13)
     $                      + ang_yi(9,13)
                    angi(5) = ang_yi(5,14)
     $                      + ang_yi(6,14)
     $                      + ang_yi(7,14)
     $                      + ang_yi(8,14)
     $                      + ang_yi(9,14)
                    angi(6) = ang_yi(5,15)
     $                      + ang_yi(6,15)
     $                      + ang_yi(7,15)
     $                      + ang_yi(8,15)
     $                      + ang_yi(9,15)
                    angi(7) = ang_yi(5,16)
     $                      + ang_yi(6,16)
     $                      + ang_yi(7,16)
     $                      + ang_yi(8,16)
     $                      + ang_yi(9,16)
c
                    angj(1) = ang_yj(10,5)
     $                      + ang_yj(11,5)
     $                      + ang_yj(12,5)
     $                      + ang_yj(13,5)
     $                      + ang_yj(14,5)
     $                      + ang_yj(15,5)
     $                      + ang_yj(16,5)
                    angj(2) = ang_yj(10,6)
     $                      + ang_yj(11,6)
     $                      + ang_yj(12,6)
     $                      + ang_yj(13,6)
     $                      + ang_yj(14,6)
     $                      + ang_yj(15,6)
     $                      + ang_yj(16,6)
                    angj(3) = ang_yj(10,7)
     $                      + ang_yj(11,7)
     $                      + ang_yj(12,7)
     $                      + ang_yj(13,7)
     $                      + ang_yj(14,7)
     $                      + ang_yj(15,7)
     $                      + ang_yj(16,7)
                    angj(4) = ang_yj(10,8)
     $                      + ang_yj(11,8)
     $                      + ang_yj(12,8)
     $                      + ang_yj(13,8)
     $                      + ang_yj(14,8)
     $                      + ang_yj(15,8)
     $                      + ang_yj(16,8)
                    angj(5) = ang_yj(10,9)
     $                      + ang_yj(11,9)
     $                      + ang_yj(12,9)
     $                      + ang_yj(13,9)
     $                      + ang_yj(14,9)
     $                      + ang_yj(15,9)
     $                      + ang_yj(16,9)
c
                    angsav(1,3,4,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(10) +
     $               angi(2)*ylmj_t(11) +
     $               angi(3)*ylmj_t(12) +
     $               angi(4)*ylmj_t(13) +
     $               angi(5)*ylmj_t(14) +
     $               angi(6)*ylmj_t(15) +
     $               angi(7)*ylmj_t(16)
c
                    angsav(2,3,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,1) +
     $               angj(2)*grylmi_t(6,1) +
     $               angj(3)*grylmi_t(7,1) +
     $               angj(4)*grylmi_t(8,1) +
     $               angj(5)*grylmi_t(9,1)
                    angsav(3,3,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,2) +
     $               angj(2)*grylmi_t(6,2) +
     $               angj(3)*grylmi_t(7,2) +
     $               angj(4)*grylmi_t(8,2) +
     $               angj(5)*grylmi_t(9,2)
                    angsav(4,3,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,3) +
     $               angj(2)*grylmi_t(6,3) +
     $               angj(3)*grylmi_t(7,3) +
     $               angj(4)*grylmi_t(8,3) +
     $               angj(5)*grylmi_t(9,3)
c
                    angsav(5,3,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,1)*angi(1) +
     $               grylmj_t(11,1)*angi(2) +
     $               grylmj_t(12,1)*angi(3) +
     $               grylmj_t(13,1)*angi(4) +
     $               grylmj_t(14,1)*angi(5) +
     $               grylmj_t(15,1)*angi(6) +
     $               grylmj_t(16,1)*angi(7)
                    angsav(6,3,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,2)*angi(1) +
     $               grylmj_t(11,2)*angi(2) +
     $               grylmj_t(12,2)*angi(3) +
     $               grylmj_t(13,2)*angi(4) +
     $               grylmj_t(14,2)*angi(5) +
     $               grylmj_t(15,2)*angi(6) +
     $               grylmj_t(16,2)*angi(7)
                    angsav(7,3,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,3)*angi(1) +
     $               grylmj_t(11,3)*angi(2) +
     $               grylmj_t(12,3)*angi(3) +
     $               grylmj_t(13,3)*angi(4) +
     $               grylmj_t(14,3)*angi(5) +
     $               grylmj_t(15,3)*angi(6) +
     $               grylmj_t(16,3)*angi(7)
c
                  elseif( lli .eq. 4 )then
c
                    angi(1) = ang_yi(10,10)
     $                      + ang_yi(11,10)
     $                      + ang_yi(12,10)
     $                      + ang_yi(13,10)
     $                      + ang_yi(14,10)
     $                      + ang_yi(15,10)
     $                      + ang_yi(16,10)
                    angi(2) = ang_yi(10,11)
     $                      + ang_yi(11,11)
     $                      + ang_yi(12,11)
     $                      + ang_yi(13,11)
     $                      + ang_yi(14,11)
     $                      + ang_yi(15,11)
     $                      + ang_yi(16,11)
                    angi(3) = ang_yi(10,12)
     $                      + ang_yi(11,12)
     $                      + ang_yi(12,12)
     $                      + ang_yi(13,12)
     $                      + ang_yi(14,12)
     $                      + ang_yi(15,12)
     $                      + ang_yi(16,12)
                    angi(4) = ang_yi(10,13)
     $                      + ang_yi(11,13)
     $                      + ang_yi(12,13)
     $                      + ang_yi(13,13)
     $                      + ang_yi(14,13)
     $                      + ang_yi(15,13)
     $                      + ang_yi(16,13)
                    angi(5) = ang_yi(10,14)
     $                      + ang_yi(11,14)
     $                      + ang_yi(12,14)
     $                      + ang_yi(13,14)
     $                      + ang_yi(14,14)
     $                      + ang_yi(15,14)
     $                      + ang_yi(16,14)
                    angi(6) = ang_yi(10,15)
     $                      + ang_yi(11,15)
     $                      + ang_yi(12,15)
     $                      + ang_yi(13,15)
     $                      + ang_yi(14,15)
     $                      + ang_yi(15,15)
     $                      + ang_yi(16,15)
                    angi(7) = ang_yi(10,16)
     $                      + ang_yi(11,16)
     $                      + ang_yi(12,16)
     $                      + ang_yi(13,16)
     $                      + ang_yi(14,16)
     $                      + ang_yi(15,16)
     $                      + ang_yi(16,16)
c
                    angj(1) = ang_yj(10,10)
     $                      + ang_yj(11,10)
     $                      + ang_yj(12,10)
     $                      + ang_yj(13,10)
     $                      + ang_yj(14,10)
     $                      + ang_yj(15,10)
     $                      + ang_yj(16,10)
                    angj(2) = ang_yj(10,11)
     $                      + ang_yj(11,11)
     $                      + ang_yj(12,11)
     $                      + ang_yj(13,11)
     $                      + ang_yj(14,11)
     $                      + ang_yj(15,11)
     $                      + ang_yj(16,11)
                    angj(3) = ang_yj(10,12)
     $                      + ang_yj(11,12)
     $                      + ang_yj(12,12)
     $                      + ang_yj(13,12)
     $                      + ang_yj(14,12)
     $                      + ang_yj(15,12)
     $                      + ang_yj(16,12)
                    angj(4) = ang_yj(10,13)
     $                      + ang_yj(11,13)
     $                      + ang_yj(12,13)
     $                      + ang_yj(13,13)
     $                      + ang_yj(14,13)
     $                      + ang_yj(15,13)
     $                      + ang_yj(16,13)
                    angj(5) = ang_yj(10,14)
     $                      + ang_yj(11,14)
     $                      + ang_yj(12,14)
     $                      + ang_yj(13,14)
     $                      + ang_yj(14,14)
     $                      + ang_yj(15,14)
     $                      + ang_yj(16,14)
                    angj(6) = ang_yj(10,15)
     $                      + ang_yj(11,15)
     $                      + ang_yj(12,15)
     $                      + ang_yj(13,15)
     $                      + ang_yj(14,15)
     $                      + ang_yj(15,15)
     $                      + ang_yj(16,15)
                    angj(7) = ang_yj(10,16)
     $                      + ang_yj(11,16)
     $                      + ang_yj(12,16)
     $                      + ang_yj(13,16)
     $                      + ang_yj(14,16)
     $                      + ang_yj(15,16)
     $                      + ang_yj(16,16)
c
                    angsav(1,4,4,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(10) +
     $               angi(2)*ylmj_t(11) +
     $               angi(3)*ylmj_t(12) +
     $               angi(4)*ylmj_t(13) +
     $               angi(5)*ylmj_t(14) +
     $               angi(6)*ylmj_t(15) +
     $               angi(7)*ylmj_t(16)
c
                    angsav(2,4,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,1) +
     $               angj(2)*grylmi_t(11,1) +
     $               angj(3)*grylmi_t(12,1) +
     $               angj(4)*grylmi_t(13,1) +
     $               angj(5)*grylmi_t(14,1) +
     $               angj(6)*grylmi_t(15,1) +
     $               angj(7)*grylmi_t(16,1)
                    angsav(3,4,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,2) +
     $               angj(2)*grylmi_t(11,2) +
     $               angj(3)*grylmi_t(12,2) +
     $               angj(4)*grylmi_t(13,2) +
     $               angj(5)*grylmi_t(14,2) +
     $               angj(6)*grylmi_t(15,2) +
     $               angj(7)*grylmi_t(16,2)
                    angsav(4,4,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,3) +
     $               angj(2)*grylmi_t(11,3) +
     $               angj(3)*grylmi_t(12,3) +
     $               angj(4)*grylmi_t(13,3) +
     $               angj(5)*grylmi_t(14,3) +
     $               angj(6)*grylmi_t(15,3) +
     $               angj(7)*grylmi_t(16,3)
c
                    angsav(5,4,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,1)*angi(1) +
     $               grylmj_t(11,1)*angi(2) +
     $               grylmj_t(12,1)*angi(3) +
     $               grylmj_t(13,1)*angi(4) +
     $               grylmj_t(14,1)*angi(5) +
     $               grylmj_t(15,1)*angi(6) +
     $               grylmj_t(16,1)*angi(7)
                    angsav(6,4,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,2)*angi(1) +
     $               grylmj_t(11,2)*angi(2) +
     $               grylmj_t(12,2)*angi(3) +
     $               grylmj_t(13,2)*angi(4) +
     $               grylmj_t(14,2)*angi(5) +
     $               grylmj_t(15,2)*angi(6) +
     $               grylmj_t(16,2)*angi(7)
                    angsav(7,4,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,3)*angi(1) +
     $               grylmj_t(11,3)*angi(2) +
     $               grylmj_t(12,3)*angi(3) +
     $               grylmj_t(13,3)*angi(4) +
     $               grylmj_t(14,3)*angi(5) +
     $               grylmj_t(15,3)*angi(6) +
     $               grylmj_t(16,3)*angi(7)
c
                  elseif( lli .eq. 5 )then
c
                    angi(1) = ang_yi(17,10)
     $                      + ang_yi(18,10)
     $                      + ang_yi(19,10)
     $                      + ang_yi(20,10)
     $                      + ang_yi(21,10)
     $                      + ang_yi(22,10)
     $                      + ang_yi(23,10)
     $                      + ang_yi(24,10)
     $                      + ang_yi(25,10)
                    angi(2) = ang_yi(17,11)
     $                      + ang_yi(18,11)
     $                      + ang_yi(19,11)
     $                      + ang_yi(20,11)
     $                      + ang_yi(21,11)
     $                      + ang_yi(22,11)
     $                      + ang_yi(23,11)
     $                      + ang_yi(24,11)
     $                      + ang_yi(25,11)
                    angi(3) = ang_yi(17,12)
     $                      + ang_yi(18,12)
     $                      + ang_yi(19,12)
     $                      + ang_yi(20,12)
     $                      + ang_yi(21,12)
     $                      + ang_yi(22,12)
     $                      + ang_yi(23,12)
     $                      + ang_yi(24,12)
     $                      + ang_yi(25,12)
                    angi(4) = ang_yi(17,13)
     $                      + ang_yi(18,13)
     $                      + ang_yi(19,13)
     $                      + ang_yi(20,13)
     $                      + ang_yi(21,13)
     $                      + ang_yi(22,13)
     $                      + ang_yi(23,13)
     $                      + ang_yi(24,13)
     $                      + ang_yi(25,13)
                    angi(5) = ang_yi(17,14)
     $                      + ang_yi(18,14)
     $                      + ang_yi(19,14)
     $                      + ang_yi(20,14)
     $                      + ang_yi(21,14)
     $                      + ang_yi(22,14)
     $                      + ang_yi(23,14)
     $                      + ang_yi(24,14)
     $                      + ang_yi(25,14)
                    angi(6) = ang_yi(17,15)
     $                      + ang_yi(18,15)
     $                      + ang_yi(19,15)
     $                      + ang_yi(20,15)
     $                      + ang_yi(21,15)
     $                      + ang_yi(22,15)
     $                      + ang_yi(23,15)
     $                      + ang_yi(24,15)
     $                      + ang_yi(25,15)
                    angi(7) = ang_yi(17,16)
     $                      + ang_yi(18,16)
     $                      + ang_yi(19,16)
     $                      + ang_yi(20,16)
     $                      + ang_yi(21,16)
     $                      + ang_yi(22,16)
     $                      + ang_yi(23,16)
     $                      + ang_yi(24,16)
     $                      + ang_yi(25,16)
c
                    angj(1) = ang_yj(10,17)
     $                      + ang_yj(11,17)
     $                      + ang_yj(12,17)
     $                      + ang_yj(13,17)
     $                      + ang_yj(14,17)
     $                      + ang_yj(15,17)
     $                      + ang_yj(16,17)
                    angj(2) = ang_yj(10,18)
     $                      + ang_yj(11,18)
     $                      + ang_yj(12,18)
     $                      + ang_yj(13,18)
     $                      + ang_yj(14,18)
     $                      + ang_yj(15,18)
     $                      + ang_yj(16,18)
                    angj(3) = ang_yj(10,19)
     $                      + ang_yj(11,19)
     $                      + ang_yj(12,19)
     $                      + ang_yj(13,19)
     $                      + ang_yj(14,19)
     $                      + ang_yj(15,19)
     $                      + ang_yj(16,19)
                    angj(4) = ang_yj(10,20)
     $                      + ang_yj(11,20)
     $                      + ang_yj(12,20)
     $                      + ang_yj(13,20)
     $                      + ang_yj(14,20)
     $                      + ang_yj(15,20)
     $                      + ang_yj(16,20)
                    angj(5) = ang_yj(10,21)
     $                      + ang_yj(11,21)
     $                      + ang_yj(12,21)
     $                      + ang_yj(13,21)
     $                      + ang_yj(14,21)
     $                      + ang_yj(15,21)
     $                      + ang_yj(16,21)
                    angj(6) = ang_yj(10,22)
     $                      + ang_yj(11,22)
     $                      + ang_yj(12,22)
     $                      + ang_yj(13,22)
     $                      + ang_yj(14,22)
     $                      + ang_yj(15,22)
     $                      + ang_yj(16,22)
                    angj(7) = ang_yj(10,23)
     $                      + ang_yj(11,23)
     $                      + ang_yj(12,23)
     $                      + ang_yj(13,23)
     $                      + ang_yj(14,23)
     $                      + ang_yj(15,23)
     $                      + ang_yj(16,23)
                    angj(8) = ang_yj(10,24)
     $                      + ang_yj(11,24)
     $                      + ang_yj(12,24)
     $                      + ang_yj(13,24)
     $                      + ang_yj(14,24)
     $                      + ang_yj(15,24)
     $                      + ang_yj(16,24)
                    angj(9) = ang_yj(10,25)
     $                      + ang_yj(11,25)
     $                      + ang_yj(12,25)
     $                      + ang_yj(13,25)
     $                      + ang_yj(14,25)
     $                      + ang_yj(15,25)
     $                      + ang_yj(16,25)
c
                    angsav(1,5,4,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(10) +
     $               angi(2)*ylmj_t(11) +
     $               angi(3)*ylmj_t(12) +
     $               angi(4)*ylmj_t(13) +
     $               angi(5)*ylmj_t(14) +
     $               angi(6)*ylmj_t(15) +
     $               angi(7)*ylmj_t(16)
c
                    angsav(2,5,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,1) +
     $               angj(2)*grylmi_t(18,1) +
     $               angj(3)*grylmi_t(19,1) +
     $               angj(4)*grylmi_t(20,1) +
     $               angj(5)*grylmi_t(21,1) +
     $               angj(6)*grylmi_t(22,1) +
     $               angj(7)*grylmi_t(23,1) +
     $               angj(8)*grylmi_t(24,1) +
     $               angj(9)*grylmi_t(25,1)
                    angsav(3,5,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,2) +
     $               angj(2)*grylmi_t(18,2) +
     $               angj(3)*grylmi_t(19,2) +
     $               angj(4)*grylmi_t(20,2) +
     $               angj(5)*grylmi_t(21,2) +
     $               angj(6)*grylmi_t(22,2) +
     $               angj(7)*grylmi_t(23,2) +
     $               angj(8)*grylmi_t(24,2) +
     $               angj(9)*grylmi_t(25,2)
                    angsav(4,5,4,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,3) +
     $               angj(2)*grylmi_t(18,3) +
     $               angj(3)*grylmi_t(19,3) +
     $               angj(4)*grylmi_t(20,3) +
     $               angj(5)*grylmi_t(21,3) +
     $               angj(6)*grylmi_t(22,3) +
     $               angj(7)*grylmi_t(23,3) +
     $               angj(8)*grylmi_t(24,3) +
     $               angj(9)*grylmi_t(25,3)
c
                    angsav(5,5,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,1)*angi(1) +
     $               grylmj_t(11,1)*angi(2) +
     $               grylmj_t(12,1)*angi(3) +
     $               grylmj_t(13,1)*angi(4) +
     $               grylmj_t(14,1)*angi(5) +
     $               grylmj_t(15,1)*angi(6) +
     $               grylmj_t(16,1)*angi(7)
                    angsav(6,5,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,2)*angi(1) +
     $               grylmj_t(11,2)*angi(2) +
     $               grylmj_t(12,2)*angi(3) +
     $               grylmj_t(13,2)*angi(4) +
     $               grylmj_t(14,2)*angi(5) +
     $               grylmj_t(15,2)*angi(6) +
     $               grylmj_t(16,2)*angi(7)
                    angsav(7,5,4,llpot,lmpi,lmpj) =
     $               grylmj_t(10,3)*angi(1) +
     $               grylmj_t(11,3)*angi(2) +
     $               grylmj_t(12,3)*angi(3) +
     $               grylmj_t(13,3)*angi(4) +
     $               grylmj_t(14,3)*angi(5) +
     $               grylmj_t(15,3)*angi(6) +
     $               grylmj_t(16,3)*angi(7)
c
                  else
c
                    call STOPXERR( 'nlangf-4' )
c
                  endif
c
                enddo
c
              elseif( llj .eq. 5 )then
c
                do  lli=1,limxp1
c
                  if( lli .eq. 1 )then
c
                    angj(1) = ang_yj(17,1)
     $                      + ang_yj(18,1)
     $                      + ang_yj(19,1)
     $                      + ang_yj(20,1)
     $                      + ang_yj(21,1)
     $                      + ang_yj(22,1)
     $                      + ang_yj(23,1)
     $                      + ang_yj(24,1)
     $                      + ang_yj(25,1)
c
                    angsav(1,1,5,llpot,lmpi,lmpj) =
     $               ylmi_t(1)*angj(1)
c
                    angsav(2,1,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,1)
                    angsav(3,1,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,2)
                    angsav(4,1,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(1,3)
c
                    angsav(5,1,5,llpot,lmpi,lmpj) =
     $               ang_yi(1,17)*grylmj_t(17,1) +
     $               ang_yi(1,18)*grylmj_t(18,1) +
     $               ang_yi(1,19)*grylmj_t(19,1) +
     $               ang_yi(1,20)*grylmj_t(20,1) +
     $               ang_yi(1,21)*grylmj_t(21,1) +
     $               ang_yi(1,22)*grylmj_t(22,1) +
     $               ang_yi(1,23)*grylmj_t(23,1) +
     $               ang_yi(1,24)*grylmj_t(24,1) +
     $               ang_yi(1,25)*grylmj_t(25,1)
                    angsav(6,1,5,llpot,lmpi,lmpj) =
     $               ang_yi(1,17)*grylmj_t(17,2) +
     $               ang_yi(1,18)*grylmj_t(18,2) +
     $               ang_yi(1,19)*grylmj_t(19,2) +
     $               ang_yi(1,20)*grylmj_t(20,2) +
     $               ang_yi(1,21)*grylmj_t(21,2) +
     $               ang_yi(1,22)*grylmj_t(22,2) +
     $               ang_yi(1,23)*grylmj_t(23,2) +
     $               ang_yi(1,24)*grylmj_t(24,2) +
     $               ang_yi(1,25)*grylmj_t(25,2)
                    angsav(7,1,5,llpot,lmpi,lmpj) =
     $               ang_yi(1,17)*grylmj_t(17,3) +
     $               ang_yi(1,18)*grylmj_t(18,3) +
     $               ang_yi(1,19)*grylmj_t(19,3) +
     $               ang_yi(1,20)*grylmj_t(20,3) +
     $               ang_yi(1,21)*grylmj_t(21,3) +
     $               ang_yi(1,22)*grylmj_t(22,3) +
     $               ang_yi(1,23)*grylmj_t(23,3) +
     $               ang_yi(1,24)*grylmj_t(24,3) +
     $               ang_yi(1,25)*grylmj_t(25,3)
c
                  elseif( lli .eq. 2 )then
c
                    angi(1) = ang_yi(2,17)
     $                      + ang_yi(3,17)
     $                      + ang_yi(4,17)
                    angi(2) = ang_yi(2,18)
     $                      + ang_yi(3,18)
     $                      + ang_yi(4,18)
                    angi(3) = ang_yi(2,19)
     $                      + ang_yi(3,19)
     $                      + ang_yi(4,19)
                    angi(4) = ang_yi(2,20)
     $                      + ang_yi(3,20)
     $                      + ang_yi(4,20)
                    angi(5) = ang_yi(2,21)
     $                      + ang_yi(3,21)
     $                      + ang_yi(4,21)
                    angi(6) = ang_yi(2,22)
     $                      + ang_yi(3,22)
     $                      + ang_yi(4,22)
                    angi(7) = ang_yi(2,23)
     $                      + ang_yi(3,23)
     $                      + ang_yi(4,23)
                    angi(8) = ang_yi(2,24)
     $                      + ang_yi(3,24)
     $                      + ang_yi(4,24)
                    angi(9) = ang_yi(2,25)
     $                      + ang_yi(3,25)
     $                      + ang_yi(4,25)
c
                    angj(1) = ang_yj(17,2)
     $                      + ang_yj(18,2)
     $                      + ang_yj(19,2)
     $                      + ang_yj(20,2)
     $                      + ang_yj(21,2)
     $                      + ang_yj(22,2)
     $                      + ang_yj(23,2)
     $                      + ang_yj(24,2)
     $                      + ang_yj(25,2)
                    angj(2) = ang_yj(17,3)
     $                      + ang_yj(18,3)
     $                      + ang_yj(19,3)
     $                      + ang_yj(20,3)
     $                      + ang_yj(21,3)
     $                      + ang_yj(22,3)
     $                      + ang_yj(23,3)
     $                      + ang_yj(24,3)
     $                      + ang_yj(25,3)
                    angj(3) = ang_yj(17,4)
     $                      + ang_yj(18,4)
     $                      + ang_yj(19,4)
     $                      + ang_yj(20,4)
     $                      + ang_yj(21,4)
     $                      + ang_yj(22,4)
     $                      + ang_yj(23,4)
     $                      + ang_yj(24,4)
     $                      + ang_yj(25,4)
c
                    angsav(1,2,5,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(17) +
     $               angi(2)*ylmj_t(18) +
     $               angi(3)*ylmj_t(19) +
     $               angi(4)*ylmj_t(20) +
     $               angi(5)*ylmj_t(21) +
     $               angi(6)*ylmj_t(22) +
     $               angi(7)*ylmj_t(23) +
     $               angi(8)*ylmj_t(24) +
     $               angi(9)*ylmj_t(25)
c
                    angsav(2,2,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,1) +
     $               angj(2)*grylmi_t(3,1) +
     $               angj(3)*grylmi_t(4,1)
                    angsav(3,2,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,2) +
     $               angj(2)*grylmi_t(3,2) +
     $               angj(3)*grylmi_t(4,2)
                    angsav(4,2,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(2,3) +
     $               angj(2)*grylmi_t(3,3) +
     $               angj(3)*grylmi_t(4,3)
c
                    angsav(5,2,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,1)*angi(1) +
     $               grylmj_t(18,1)*angi(2) +
     $               grylmj_t(19,1)*angi(3) +
     $               grylmj_t(20,1)*angi(4) +
     $               grylmj_t(21,1)*angi(5) +
     $               grylmj_t(22,1)*angi(6) +
     $               grylmj_t(23,1)*angi(7) +
     $               grylmj_t(24,1)*angi(8) +
     $               grylmj_t(25,1)*angi(9)
                    angsav(6,2,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,2)*angi(1) +
     $               grylmj_t(18,2)*angi(2) +
     $               grylmj_t(19,2)*angi(3) +
     $               grylmj_t(20,2)*angi(4) +
     $               grylmj_t(21,2)*angi(5) +
     $               grylmj_t(22,2)*angi(6) +
     $               grylmj_t(23,2)*angi(7) +
     $               grylmj_t(24,2)*angi(8) +
     $               grylmj_t(25,2)*angi(9)
                    angsav(7,2,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,3)*angi(1) +
     $               grylmj_t(18,3)*angi(2) +
     $               grylmj_t(19,3)*angi(3) +
     $               grylmj_t(20,3)*angi(4) +
     $               grylmj_t(21,3)*angi(5) +
     $               grylmj_t(22,3)*angi(6) +
     $               grylmj_t(23,3)*angi(7) +
     $               grylmj_t(24,3)*angi(8) +
     $               grylmj_t(25,3)*angi(9)
c
                  elseif( lli .eq. 3 )then
c
                    angi(1) = ang_yi(5,17)
     $                      + ang_yi(6,17)
     $                      + ang_yi(7,17)
     $                      + ang_yi(8,17)
     $                      + ang_yi(9,17)
                    angi(2) = ang_yi(5,18)
     $                      + ang_yi(6,18)
     $                      + ang_yi(7,18)
     $                      + ang_yi(8,18)
     $                      + ang_yi(9,18)
                    angi(3) = ang_yi(5,19)
     $                      + ang_yi(6,19)
     $                      + ang_yi(7,19)
     $                      + ang_yi(8,19)
     $                      + ang_yi(9,19)
                    angi(4) = ang_yi(5,20)
     $                      + ang_yi(6,20)
     $                      + ang_yi(7,20)
     $                      + ang_yi(8,20)
     $                      + ang_yi(9,20)
                    angi(5) = ang_yi(5,21)
     $                      + ang_yi(6,21)
     $                      + ang_yi(7,21)
     $                      + ang_yi(8,21)
     $                      + ang_yi(9,21)
                    angi(6) = ang_yi(5,22)
     $                      + ang_yi(6,22)
     $                      + ang_yi(7,22)
     $                      + ang_yi(8,22)
     $                      + ang_yi(9,22)
                    angi(7) = ang_yi(5,23)
     $                      + ang_yi(6,23)
     $                      + ang_yi(7,23)
     $                      + ang_yi(8,23)
     $                      + ang_yi(9,23)
                    angi(8) = ang_yi(5,24)
     $                      + ang_yi(6,24)
     $                      + ang_yi(7,24)
     $                      + ang_yi(8,24)
     $                      + ang_yi(9,24)
                    angi(9) = ang_yi(5,25)
     $                      + ang_yi(6,25)
     $                      + ang_yi(7,25)
     $                      + ang_yi(8,25)
     $                      + ang_yi(9,25)
c
                    angj(1) = ang_yj(17,5)
     $                      + ang_yj(18,5)
     $                      + ang_yj(19,5)
     $                      + ang_yj(20,5)
     $                      + ang_yj(21,5)
     $                      + ang_yj(22,5)
     $                      + ang_yj(23,5)
     $                      + ang_yj(24,5)
     $                      + ang_yj(25,5)
                    angj(2) = ang_yj(17,6)
     $                      + ang_yj(18,6)
     $                      + ang_yj(19,6)
     $                      + ang_yj(20,6)
     $                      + ang_yj(21,6)
     $                      + ang_yj(22,6)
     $                      + ang_yj(23,6)
     $                      + ang_yj(24,6)
     $                      + ang_yj(25,6)
                    angj(3) = ang_yj(17,7)
     $                      + ang_yj(18,7)
     $                      + ang_yj(19,7)
     $                      + ang_yj(20,7)
     $                      + ang_yj(21,7)
     $                      + ang_yj(22,7)
     $                      + ang_yj(23,7)
     $                      + ang_yj(24,7)
     $                      + ang_yj(25,7)
                    angj(4) = ang_yj(17,8)
     $                      + ang_yj(18,8)
     $                      + ang_yj(19,8)
     $                      + ang_yj(20,8)
     $                      + ang_yj(21,8)
     $                      + ang_yj(22,8)
     $                      + ang_yj(23,8)
     $                      + ang_yj(24,8)
     $                      + ang_yj(25,8)
                    angj(5) = ang_yj(17,9)
     $                      + ang_yj(18,9)
     $                      + ang_yj(19,9)
     $                      + ang_yj(20,9)
     $                      + ang_yj(21,9)
     $                      + ang_yj(22,9)
     $                      + ang_yj(23,9)
     $                      + ang_yj(24,9)
     $                      + ang_yj(25,9)
c
                    angsav(1,3,5,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(17) +
     $               angi(2)*ylmj_t(18) +
     $               angi(3)*ylmj_t(19) +
     $               angi(4)*ylmj_t(20) +
     $               angi(5)*ylmj_t(21) +
     $               angi(6)*ylmj_t(22) +
     $               angi(7)*ylmj_t(23) +
     $               angi(8)*ylmj_t(24) +
     $               angi(9)*ylmj_t(25)
c
                    angsav(2,3,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,1) +
     $               angj(2)*grylmi_t(6,1) +
     $               angj(3)*grylmi_t(7,1) +
     $               angj(4)*grylmi_t(8,1) +
     $               angj(5)*grylmi_t(9,1)
                    angsav(3,3,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,2) +
     $               angj(2)*grylmi_t(6,2) +
     $               angj(3)*grylmi_t(7,2) +
     $               angj(4)*grylmi_t(8,2) +
     $               angj(5)*grylmi_t(9,2)
                    angsav(4,3,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(5,3) +
     $               angj(2)*grylmi_t(6,3) +
     $               angj(3)*grylmi_t(7,3) +
     $               angj(4)*grylmi_t(8,3) +
     $               angj(5)*grylmi_t(9,3)
c
                    angsav(5,3,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,1)*angi(1) +
     $               grylmj_t(18,1)*angi(2) +
     $               grylmj_t(19,1)*angi(3) +
     $               grylmj_t(20,1)*angi(4) +
     $               grylmj_t(21,1)*angi(5) +
     $               grylmj_t(22,1)*angi(6) +
     $               grylmj_t(23,1)*angi(7) +
     $               grylmj_t(24,1)*angi(8) +
     $               grylmj_t(25,1)*angi(9)
                    angsav(6,3,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,2)*angi(1) +
     $               grylmj_t(18,2)*angi(2) +
     $               grylmj_t(19,2)*angi(3) +
     $               grylmj_t(20,2)*angi(4) +
     $               grylmj_t(21,2)*angi(5) +
     $               grylmj_t(22,2)*angi(6) +
     $               grylmj_t(23,2)*angi(7) +
     $               grylmj_t(24,2)*angi(8) +
     $               grylmj_t(25,2)*angi(9)
                    angsav(7,3,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,3)*angi(1) +
     $               grylmj_t(18,3)*angi(2) +
     $               grylmj_t(19,3)*angi(3) +
     $               grylmj_t(20,3)*angi(4) +
     $               grylmj_t(21,3)*angi(5) +
     $               grylmj_t(22,3)*angi(6) +
     $               grylmj_t(23,3)*angi(7) +
     $               grylmj_t(24,3)*angi(8) +
     $               grylmj_t(25,3)*angi(9)
c
                  elseif( lli .eq. 4 )then
c
                    angi(1) = ang_yi(10,17)
     $                      + ang_yi(11,17)
     $                      + ang_yi(12,17)
     $                      + ang_yi(13,17)
     $                      + ang_yi(14,17)
     $                      + ang_yi(15,17)
     $                      + ang_yi(16,17)
                    angi(2) = ang_yi(10,18)
     $                      + ang_yi(11,18)
     $                      + ang_yi(12,18)
     $                      + ang_yi(13,18)
     $                      + ang_yi(14,18)
     $                      + ang_yi(15,18)
     $                      + ang_yi(16,18)
                    angi(3) = ang_yi(10,19)
     $                      + ang_yi(11,19)
     $                      + ang_yi(12,19)
     $                      + ang_yi(13,19)
     $                      + ang_yi(14,19)
     $                      + ang_yi(15,19)
     $                      + ang_yi(16,19)
                    angi(4) = ang_yi(10,20)
     $                      + ang_yi(11,20)
     $                      + ang_yi(12,20)
     $                      + ang_yi(13,20)
     $                      + ang_yi(14,20)
     $                      + ang_yi(15,20)
     $                      + ang_yi(16,20)
                    angi(5) = ang_yi(10,21)
     $                      + ang_yi(11,21)
     $                      + ang_yi(12,21)
     $                      + ang_yi(13,21)
     $                      + ang_yi(14,21)
     $                      + ang_yi(15,21)
     $                      + ang_yi(16,21)
                    angi(6) = ang_yi(10,22)
     $                      + ang_yi(11,22)
     $                      + ang_yi(12,22)
     $                      + ang_yi(13,22)
     $                      + ang_yi(14,22)
     $                      + ang_yi(15,22)
     $                      + ang_yi(16,22)
                    angi(7) = ang_yi(10,23)
     $                      + ang_yi(11,23)
     $                      + ang_yi(12,23)
     $                      + ang_yi(13,23)
     $                      + ang_yi(14,23)
     $                      + ang_yi(15,23)
     $                      + ang_yi(16,23)
                    angi(8) = ang_yi(10,24)
     $                      + ang_yi(11,24)
     $                      + ang_yi(12,24)
     $                      + ang_yi(13,24)
     $                      + ang_yi(14,24)
     $                      + ang_yi(15,24)
     $                      + ang_yi(16,24)
                    angi(9) = ang_yi(10,25)
     $                      + ang_yi(11,25)
     $                      + ang_yi(12,25)
     $                      + ang_yi(13,25)
     $                      + ang_yi(14,25)
     $                      + ang_yi(15,25)
     $                      + ang_yi(16,25)
c
                    angj(1) = ang_yj(17,10)
     $                      + ang_yj(18,10)
     $                      + ang_yj(19,10)
     $                      + ang_yj(20,10)
     $                      + ang_yj(21,10)
     $                      + ang_yj(22,10)
     $                      + ang_yj(23,10)
     $                      + ang_yj(24,10)
     $                      + ang_yj(25,10)
                    angj(2) = ang_yj(17,11)
     $                      + ang_yj(18,11)
     $                      + ang_yj(19,11)
     $                      + ang_yj(20,11)
     $                      + ang_yj(21,11)
     $                      + ang_yj(22,11)
     $                      + ang_yj(23,11)
     $                      + ang_yj(24,11)
     $                      + ang_yj(25,11)
                    angj(3) = ang_yj(17,12)
     $                      + ang_yj(18,12)
     $                      + ang_yj(19,12)
     $                      + ang_yj(20,12)
     $                      + ang_yj(21,12)
     $                      + ang_yj(22,12)
     $                      + ang_yj(23,12)
     $                      + ang_yj(24,12)
     $                      + ang_yj(25,12)
                    angj(4) = ang_yj(17,13)
     $                      + ang_yj(18,13)
     $                      + ang_yj(19,13)
     $                      + ang_yj(20,13)
     $                      + ang_yj(21,13)
     $                      + ang_yj(22,13)
     $                      + ang_yj(23,13)
     $                      + ang_yj(24,13)
     $                      + ang_yj(25,13)
                    angj(5) = ang_yj(17,14)
     $                      + ang_yj(18,14)
     $                      + ang_yj(19,14)
     $                      + ang_yj(20,14)
     $                      + ang_yj(21,14)
     $                      + ang_yj(22,14)
     $                      + ang_yj(23,14)
     $                      + ang_yj(24,14)
     $                      + ang_yj(25,14)
                    angj(6) = ang_yj(17,15)
     $                      + ang_yj(18,15)
     $                      + ang_yj(19,15)
     $                      + ang_yj(20,15)
     $                      + ang_yj(21,15)
     $                      + ang_yj(22,15)
     $                      + ang_yj(23,15)
     $                      + ang_yj(24,15)
     $                      + ang_yj(25,15)
                    angj(7) = ang_yj(17,16)
     $                      + ang_yj(18,16)
     $                      + ang_yj(19,16)
     $                      + ang_yj(20,16)
     $                      + ang_yj(21,16)
     $                      + ang_yj(22,16)
     $                      + ang_yj(23,16)
     $                      + ang_yj(24,16)
     $                      + ang_yj(25,16)
c
                    angsav(1,4,5,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(17) +
     $               angi(2)*ylmj_t(18) +
     $               angi(3)*ylmj_t(19) +
     $               angi(4)*ylmj_t(20) +
     $               angi(5)*ylmj_t(21) +
     $               angi(6)*ylmj_t(22) +
     $               angi(7)*ylmj_t(23) +
     $               angi(8)*ylmj_t(24) +
     $               angi(9)*ylmj_t(25)
c
                    angsav(2,4,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,1) +
     $               angj(2)*grylmi_t(11,1) +
     $               angj(3)*grylmi_t(12,1) +
     $               angj(4)*grylmi_t(13,1) +
     $               angj(5)*grylmi_t(14,1) +
     $               angj(6)*grylmi_t(15,1) +
     $               angj(7)*grylmi_t(16,1)
                    angsav(3,4,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,2) +
     $               angj(2)*grylmi_t(11,2) +
     $               angj(3)*grylmi_t(12,2) +
     $               angj(4)*grylmi_t(13,2) +
     $               angj(5)*grylmi_t(14,2) +
     $               angj(6)*grylmi_t(15,2) +
     $               angj(7)*grylmi_t(16,2)
                    angsav(4,4,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(10,3) +
     $               angj(2)*grylmi_t(11,3) +
     $               angj(3)*grylmi_t(12,3) +
     $               angj(4)*grylmi_t(13,3) +
     $               angj(5)*grylmi_t(14,3) +
     $               angj(6)*grylmi_t(15,3) +
     $               angj(7)*grylmi_t(16,3)
c
                    angsav(5,4,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,1)*angi(1) +
     $               grylmj_t(18,1)*angi(2) +
     $               grylmj_t(19,1)*angi(3) +
     $               grylmj_t(20,1)*angi(4) +
     $               grylmj_t(21,1)*angi(5) +
     $               grylmj_t(22,1)*angi(6) +
     $               grylmj_t(23,1)*angi(7) +
     $               grylmj_t(24,1)*angi(8) +
     $               grylmj_t(25,1)*angi(9)
                    angsav(6,4,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,2)*angi(1) +
     $               grylmj_t(18,2)*angi(2) +
     $               grylmj_t(19,2)*angi(3) +
     $               grylmj_t(20,2)*angi(4) +
     $               grylmj_t(21,2)*angi(5) +
     $               grylmj_t(22,2)*angi(6) +
     $               grylmj_t(23,2)*angi(7) +
     $               grylmj_t(24,2)*angi(8) +
     $               grylmj_t(25,2)*angi(9)
                    angsav(7,4,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,3)*angi(1) +
     $               grylmj_t(18,3)*angi(2) +
     $               grylmj_t(19,3)*angi(3) +
     $               grylmj_t(20,3)*angi(4) +
     $               grylmj_t(21,3)*angi(5) +
     $               grylmj_t(22,3)*angi(6) +
     $               grylmj_t(23,3)*angi(7) +
     $               grylmj_t(24,3)*angi(8) +
     $               grylmj_t(25,3)*angi(9)
c
                  elseif( lli .eq. 5 )then
c
                    angi(1) = ang_yi(17,17)
     $                      + ang_yi(18,17)
     $                      + ang_yi(19,17)
     $                      + ang_yi(20,17)
     $                      + ang_yi(21,17)
     $                      + ang_yi(22,17)
     $                      + ang_yi(23,17)
     $                      + ang_yi(24,17)
     $                      + ang_yi(25,17)
                    angi(2) = ang_yi(17,18)
     $                      + ang_yi(18,18)
     $                      + ang_yi(19,18)
     $                      + ang_yi(20,18)
     $                      + ang_yi(21,18)
     $                      + ang_yi(22,18)
     $                      + ang_yi(23,18)
     $                      + ang_yi(24,18)
     $                      + ang_yi(25,18)
                    angi(3) = ang_yi(17,19)
     $                      + ang_yi(18,19)
     $                      + ang_yi(19,19)
     $                      + ang_yi(20,19)
     $                      + ang_yi(21,19)
     $                      + ang_yi(22,19)
     $                      + ang_yi(23,19)
     $                      + ang_yi(24,19)
     $                      + ang_yi(25,19)
                    angi(4) = ang_yi(17,20)
     $                      + ang_yi(18,20)
     $                      + ang_yi(19,20)
     $                      + ang_yi(20,20)
     $                      + ang_yi(21,20)
     $                      + ang_yi(22,20)
     $                      + ang_yi(23,20)
     $                      + ang_yi(24,20)
     $                      + ang_yi(25,20)
                    angi(5) = ang_yi(17,21)
     $                      + ang_yi(18,21)
     $                      + ang_yi(19,21)
     $                      + ang_yi(20,21)
     $                      + ang_yi(21,21)
     $                      + ang_yi(22,21)
     $                      + ang_yi(23,21)
     $                      + ang_yi(24,21)
     $                      + ang_yi(25,21)
                    angi(6) = ang_yi(17,22)
     $                      + ang_yi(18,22)
     $                      + ang_yi(19,22)
     $                      + ang_yi(20,22)
     $                      + ang_yi(21,22)
     $                      + ang_yi(22,22)
     $                      + ang_yi(23,22)
     $                      + ang_yi(24,22)
     $                      + ang_yi(25,22)
                    angi(7) = ang_yi(17,23)
     $                      + ang_yi(18,23)
     $                      + ang_yi(19,23)
     $                      + ang_yi(20,23)
     $                      + ang_yi(21,23)
     $                      + ang_yi(22,23)
     $                      + ang_yi(23,23)
     $                      + ang_yi(24,23)
     $                      + ang_yi(25,23)
                    angi(8) = ang_yi(17,24)
     $                      + ang_yi(18,24)
     $                      + ang_yi(19,24)
     $                      + ang_yi(20,24)
     $                      + ang_yi(21,24)
     $                      + ang_yi(22,24)
     $                      + ang_yi(23,24)
     $                      + ang_yi(24,24)
     $                      + ang_yi(25,24)
                    angi(9) = ang_yi(17,25)
     $                      + ang_yi(18,25)
     $                      + ang_yi(19,25)
     $                      + ang_yi(20,25)
     $                      + ang_yi(21,25)
     $                      + ang_yi(22,25)
     $                      + ang_yi(23,25)
     $                      + ang_yi(24,25)
     $                      + ang_yi(25,25)
c
                    angj(1) = ang_yj(17,17)
     $                      + ang_yj(18,17)
     $                      + ang_yj(19,17)
     $                      + ang_yj(20,17)
     $                      + ang_yj(21,17)
     $                      + ang_yj(22,17)
     $                      + ang_yj(23,17)
     $                      + ang_yj(24,17)
     $                      + ang_yj(25,17)
                    angj(2) = ang_yj(17,18)
     $                      + ang_yj(18,18)
     $                      + ang_yj(19,18)
     $                      + ang_yj(20,18)
     $                      + ang_yj(21,18)
     $                      + ang_yj(22,18)
     $                      + ang_yj(23,18)
     $                      + ang_yj(24,18)
     $                      + ang_yj(25,18)
                    angj(3) = ang_yj(17,19)
     $                      + ang_yj(18,19)
     $                      + ang_yj(19,19)
     $                      + ang_yj(20,19)
     $                      + ang_yj(21,19)
     $                      + ang_yj(22,19)
     $                      + ang_yj(23,19)
     $                      + ang_yj(24,19)
     $                      + ang_yj(25,19)
                    angj(4) = ang_yj(17,20)
     $                      + ang_yj(18,20)
     $                      + ang_yj(19,20)
     $                      + ang_yj(20,20)
     $                      + ang_yj(21,20)
     $                      + ang_yj(22,20)
     $                      + ang_yj(23,20)
     $                      + ang_yj(24,20)
     $                      + ang_yj(25,20)
                    angj(5) = ang_yj(17,21)
     $                      + ang_yj(18,21)
     $                      + ang_yj(19,21)
     $                      + ang_yj(20,21)
     $                      + ang_yj(21,21)
     $                      + ang_yj(22,21)
     $                      + ang_yj(23,21)
     $                      + ang_yj(24,21)
     $                      + ang_yj(25,21)
                    angj(6) = ang_yj(17,22)
     $                      + ang_yj(18,22)
     $                      + ang_yj(19,22)
     $                      + ang_yj(20,22)
     $                      + ang_yj(21,22)
     $                      + ang_yj(22,22)
     $                      + ang_yj(23,22)
     $                      + ang_yj(24,22)
     $                      + ang_yj(25,22)
                    angj(7) = ang_yj(17,23)
     $                      + ang_yj(18,23)
     $                      + ang_yj(19,23)
     $                      + ang_yj(20,23)
     $                      + ang_yj(21,23)
     $                      + ang_yj(22,23)
     $                      + ang_yj(23,23)
     $                      + ang_yj(24,23)
     $                      + ang_yj(25,23)
                    angj(8) = ang_yj(17,24)
     $                      + ang_yj(18,24)
     $                      + ang_yj(19,24)
     $                      + ang_yj(20,24)
     $                      + ang_yj(21,24)
     $                      + ang_yj(22,24)
     $                      + ang_yj(23,24)
     $                      + ang_yj(24,24)
     $                      + ang_yj(25,24)
                    angj(9) = ang_yj(17,25)
     $                      + ang_yj(18,25)
     $                      + ang_yj(19,25)
     $                      + ang_yj(20,25)
     $                      + ang_yj(21,25)
     $                      + ang_yj(22,25)
     $                      + ang_yj(23,25)
     $                      + ang_yj(24,25)
     $                      + ang_yj(25,25)
c
                    angsav(1,5,5,llpot,lmpi,lmpj) =
     $               angi(1)*ylmj_t(17) +
     $               angi(2)*ylmj_t(18) +
     $               angi(3)*ylmj_t(19) +
     $               angi(4)*ylmj_t(20) +
     $               angi(5)*ylmj_t(21) +
     $               angi(6)*ylmj_t(22) +
     $               angi(7)*ylmj_t(23) +
     $               angi(8)*ylmj_t(24) +
     $               angi(9)*ylmj_t(25)
c
                    angsav(2,5,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,1) +
     $               angj(2)*grylmi_t(18,1) +
     $               angj(3)*grylmi_t(19,1) +
     $               angj(4)*grylmi_t(20,1) +
     $               angj(5)*grylmi_t(21,1) +
     $               angj(6)*grylmi_t(22,1) +
     $               angj(7)*grylmi_t(23,1) +
     $               angj(8)*grylmi_t(24,1) +
     $               angj(9)*grylmi_t(25,1)
                    angsav(3,5,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,2) +
     $               angj(2)*grylmi_t(18,2) +
     $               angj(3)*grylmi_t(19,2) +
     $               angj(4)*grylmi_t(20,2) +
     $               angj(5)*grylmi_t(21,2) +
     $               angj(6)*grylmi_t(22,2) +
     $               angj(7)*grylmi_t(23,2) +
     $               angj(8)*grylmi_t(24,2) +
     $               angj(9)*grylmi_t(25,2)
                    angsav(4,5,5,llpot,lmpi,lmpj) =
     $               angj(1)*grylmi_t(17,3) +
     $               angj(2)*grylmi_t(18,3) +
     $               angj(3)*grylmi_t(19,3) +
     $               angj(4)*grylmi_t(20,3) +
     $               angj(5)*grylmi_t(21,3) +
     $               angj(6)*grylmi_t(22,3) +
     $               angj(7)*grylmi_t(23,3) +
     $               angj(8)*grylmi_t(24,3) +
     $               angj(9)*grylmi_t(25,3)
c
                    angsav(5,5,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,1)*angi(1) +
     $               grylmj_t(18,1)*angi(2) +
     $               grylmj_t(19,1)*angi(3) +
     $               grylmj_t(20,1)*angi(4) +
     $               grylmj_t(21,1)*angi(5) +
     $               grylmj_t(22,1)*angi(6) +
     $               grylmj_t(23,1)*angi(7) +
     $               grylmj_t(24,1)*angi(8) +
     $               grylmj_t(25,1)*angi(9)
                    angsav(6,5,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,2)*angi(1) +
     $               grylmj_t(18,2)*angi(2) +
     $               grylmj_t(19,2)*angi(3) +
     $               grylmj_t(20,2)*angi(4) +
     $               grylmj_t(21,2)*angi(5) +
     $               grylmj_t(22,2)*angi(6) +
     $               grylmj_t(23,2)*angi(7) +
     $               grylmj_t(24,2)*angi(8) +
     $               grylmj_t(25,2)*angi(9)
                    angsav(7,5,5,llpot,lmpi,lmpj) =
     $               grylmj_t(17,3)*angi(1) +
     $               grylmj_t(18,3)*angi(2) +
     $               grylmj_t(19,3)*angi(3) +
     $               grylmj_t(20,3)*angi(4) +
     $               grylmj_t(21,3)*angi(5) +
     $               grylmj_t(22,3)*angi(6) +
     $               grylmj_t(23,3)*angi(7) +
     $               grylmj_t(24,3)*angi(8) +
     $               grylmj_t(25,3)*angi(9)
c
                  else
c
                    call STOPXERR( 'nlangf-5' )
c
                  endif
c
                enddo
c
              endif
c
            enddo
c
  290     continue
c
  301   continue
  302 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NLINTEQ
c
c
      subroutine NLINTEQ( vnlr,vnli, vnlint,
     $ limxp1,ljmxp1,lmxp1,lstmx,lpowmx, rimag,rjmag,
     $ li,lj,izero,ai,aj,ylmj,angsav,
     $ nk,nlat, coskr,sinkr,
     $ neqlat,jlateq,  vnltmp )
c---------------------------------------------------------------
c Purpose: evaluate lm-sums for non-local part of
c          effective potential matrix elements
c
c Revision history:
c   2Oct02-PAS/2.54: optimization via unrolls, variable retasks
c   7Mar00-PAS/2.43: rename "lloops" to "nlint"
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Apr97-PAS/2.17: naming conventions
c  29Sep95-PAS/2.13; extract k-loop from bottom of loops
c  12Aug94-PAS/2.11: cleanup/dimensioning
c  19Jun89-PAS: move ANGSET/extract ylmi prod/pack angsav
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output arrays:
      DIMENSION  vnlr(nk),vnli(nk)
c input arrays:
      DIMENSION  vnlint(limxp1,ljmxp1,lstmx)
      LOGICAL    izero(9,9)
      DIMENSION  ai(9),aj(9,9,*), ylmj(2,25,*)
      DIMENSION  angsav(limxp1,ljmxp1*ljmxp1,lmxp1,9,9)
      DIMENSION  coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  jlateq(neqlat)
c scratch arrays:
      DIMENSION  vnltmp(neqlat)
c local declarations:
      DIMENSION  lang(9)
      DATA  lang / 0, 1,1,1, 2,2,2,2,2 /
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      call MKZERO( nk, vnlr )
      call MKZERO( nk, vnli )
c
      call MKZERO( neqlat, vnltmp )
      do 200 lmpi=1,li
        lpi = lang(lmpi)
c
        do 100 lmpj=1,lj
          if( izero(lmpi,lmpj) ) goto 100
c
          aii = ai(lmpi)
          lpj = lang(lmpj)
c
          do 90 llpot=1,lmxp1
            lstore = lpi + lpj + 1 + lpowmx*(llpot-1)
c
            do 70 lli=1,limxp1
              jlx = 0
              jlm = 0
c
              mmj = 1
                do 41 llj=mmj,ljmxp1
                  jlm = jlm + 1
c                 jpprl = 1
                  jlx = jlx + 1
                  angfac = angsav(lli,jlx,llpot,lmpi,lmpj)
                  if( angfac.ne.zero )then
                    vt = aii*angfac*vnlint(lli,llj,lstore)
                    do  jeql=1,neqlat
                      vnltmp(jeql) = vnltmp(jeql) +
     $                 vt*aj(lmpj,lj,jeql)*ylmj(    1,jlm,jeql)
                    enddo
                  endif
   41           continue
c
              do 52 mmj=2,ljmxp1
                do 51 llj=mmj,ljmxp1
                  jlm = jlm + 1
c                   jpprl = 1
                    jlx = jlx + 1
                    angfac = angsav(lli,jlx,llpot,lmpi,lmpj)
                    if( angfac.ne.zero )then
                      vt = aii*angfac*vnlint(lli,llj,lstore)
                      do  jeql=1,neqlat
                        vnltmp(jeql) = vnltmp(jeql) +
     $                   vt*aj(lmpj,lj,jeql)*ylmj(    1,jlm,jeql)
                      enddo
                    endif
c                   jpprl = 2
                    jlx = jlx + 1
                    angfac = angsav(lli,jlx,llpot,lmpi,lmpj)
                    if( angfac.ne.zero )then
                      vt = aii*angfac*vnlint(lli,llj,lstore)
                      do  jeql=1,neqlat
                        vnltmp(jeql) = vnltmp(jeql) +
     $                   vt*aj(lmpj,lj,jeql)*ylmj(    2,jlm,jeql)
                      enddo
                    endif
c
   51           continue
   52         continue
c
   70       continue
c
   90     continue
c
  100   continue
  200 continue
c
      do  jeql=1,neqlat
        vint = vnltmp(jeql)
        jlat = jlateq(jeql)
        do  k=1,nk
          vnlr(k) = vnlr(k) + vint*coskr(k,jlat)
          vnli(k) = vnli(k) + vint*sinkr(k,jlat)
        enddo
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NLINT
c
c
      subroutine NLINT( vnlr,vnli, vnlint,
     $ limxp1,ljmxp1,lmxp1,lstmx,lpowmx, rimag,rjmag,
     $ li,lj, ai,aj, ylmj,angsav,
     $ nk,nlat, coskr,sinkr, jlat )
c---------------------------------------------------------------
c Purpose: evaluate lm-sums for non-local part of
c          effective potential matrix elements
c
c Revision history:
c   2Oct02-PAS/2.54: single jlat version, extracted from NLINTEQ
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output arrays:
      DIMENSION  vnlr(nk),vnli(nk)
c input arrays:
      DIMENSION  vnlint(limxp1,ljmxp1,lstmx)
      DIMENSION  ai(9),aj(9), ylmj(2,25)
      DIMENSION  angsav(limxp1,ljmxp1*ljmxp1,lmxp1,9,9)
      DIMENSION  coskr(nk,nlat),sinkr(nk,nlat)
c local declarations:
      DIMENSION  lang(9)
      DATA  lang / 0, 1,1,1, 2,2,2,2,2 /
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      call MKZERO( nk, vnlr )
      call MKZERO( nk, vnli )
c
      vnltmp = zero
      do 200 lmpi=1,li
        if( ai(lmpi).eq.zero ) goto 200
c
        lpi = lang(lmpi)
c
        do 100 lmpj=1,lj
          if( aj(lmpj).eq.zero ) goto 100
c
          lpj = lang(lmpj)
          aij = ai(lmpi)*aj(lmpj)
c
          do 90 llpot=1,lmxp1
            lstore = lpi + lpj + 1 + lpowmx*(llpot-1)
c
            do 70 lli=1,limxp1
              jlm = 0
              jlx = 0
c
              mmj = 1
                do 41 llj=mmj,ljmxp1
                  jlm = jlm + 1
c                   jpprl = 1
                    jlx = jlx + 1
                    vnltmp = vnltmp + aij*vnlint(lli,llj,lstore)*
     $               ylmj(1,jlm)*angsav(lli,jlx,llpot,lmpi,lmpj)
   41           continue
c
              do 52 mmj=2,ljmxp1
                do 51 llj=mmj,ljmxp1
                  jlm = jlm + 1
c                   jpprl = 1
                    jlx = jlx + 1
                    vnltmp = vnltmp + aij*vnlint(lli,llj,lstore)*
     $               ylmj(1,jlm)*angsav(lli,jlx,llpot,lmpi,lmpj)
c                   jpprl = 2
                    jlx = jlx + 1
                    vnltmp = vnltmp + aij*vnlint(lli,llj,lstore)*
     $               ylmj(2,jlm)*angsav(lli,jlx,llpot,lmpi,lmpj)
c
   51           continue
   52         continue
c
   70       continue
c
   90     continue
c
  100   continue
  200 continue
c
        vint = vnltmp
        do  k=1,nk
          vnlr(k) = vnlr(k) + vint*coskr(k,jlat)
          vnli(k) = vnli(k) + vint*sinkr(k,jlat)
        enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NLINTF
c
c
      subroutine NLINTF( enpri,enprj, engri,engrj,
     $ vnln,vnli,vnlj, rimag,rjmag, lmi,lmj,
     $ limxp1,ljmxp1,lmxp1,lpowmx,lpowi,lpowj,lstmx,
     $ ai,gradai, aj,gradaj, angsav )
c---------------------------------------------------------------
c Purpose: do angular sums NLANGF has not already done
c
c Written: Peter A. Schultz, 28-August-1998, for v2.25
c
c Revision History:
c  15Oct99-PAS/2.41: cleaned up, and reorganized for further opt
c   5Oct99-DBR/2.41: optimization: reordered angv
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output arrays:
      DIMENSION  engri(3),engrj(3)
c input arrays:
      DIMENSION  vnln(limxp1+lpowi,ljmxp1+lpowj,lstmx)
      DIMENSION  vnli(limxp1+lpowi,ljmxp1+lpowj,lstmx)
      DIMENSION  vnlj(limxp1+lpowi,ljmxp1+lpowj,lstmx)
      DIMENSION  ai(9),gradai(3,9), aj(9),gradaj(3,9)
      DIMENSION  angsav(7,limxp1,ljmxp1,lmxp1,9,9)
c local declarations:
      LOGICAL    ri_gt_0, rj_gt_0
      DIMENSION  aigraj(3),ajgrai(3)
      DIMENSION  lang(9)
      DATA  lang / 0, 1,1,1, 2,2,2,2,2 /
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      enpri = zero
      enprj = zero
c
      engri(1) = zero
      engri(2) = zero
      engri(3) = zero
      engrj(1) = zero
      engrj(2) = zero
      engrj(3) = zero
c
      eneli = zero
      enelj = zero
c
      ri_gt_0 = .false.
      rj_gt_0 = .false.
      if( rimag .ge. 1.d-12 ) ri_gt_0 = .true.
      if( rjmag .ge. 1.d-12 ) rj_gt_0 = .true.
c
      do 200 lmpj=1,lmj
        sumj = DABS( aj(lmpj) ) + DABS( gradaj(1,lmpj) )
     $   + DABS( gradaj(2,lmpj) ) + DABS( gradaj(3,lmpj) )
        if( sumj .eq. zero ) goto 200
c
        lpj = lang(lmpj)
c
        do 100 lmpi=1,lmi
          sumi = DABS( ai(lmpi) ) + DABS( gradai(1,lmpi) )
     $     + DABS( gradai(2,lmpi) ) + DABS( gradai(3,lmpi) )
          if( sumi .eq. zero ) goto 100
c
          lpi = lang(lmpi)
c
          aiaj = ai(lmpi)*aj(lmpj)
c
          ajgrai(1) = gradai(1,lmpi)*aj(lmpj)
          ajgrai(2) = gradai(2,lmpi)*aj(lmpj)
          ajgrai(3) = gradai(3,lmpi)*aj(lmpj)
          aigraj(1) = ai(lmpi)*gradaj(1,lmpj)
          aigraj(2) = ai(lmpi)*gradaj(2,lmpj)
          aigraj(3) = ai(lmpi)*gradaj(3,lmpj)
c
          sum1i  = zero
          sum1i1 = zero
          sum1j  = zero
          sum1j1 = zero
          sum1n  = zero
          sum2n  = zero
          sum3n  = zero
          sum4n  = zero
          sum5n  = zero
          sum6n  = zero
          sum7n  = zero
c
          do  llpot=1,lmxp1
            lstore = lpi + lpj + 1 + lpowmx*(llpot-1)
c
            do  llj=1,ljmxp1
              do  lli=1,limxp1
c
                ang1 = angsav(1,lli,llj,llpot,lmpi,lmpj)
                venij = vnln(lli,llj,lstore)
c
                sum1i  = sum1i  + ang1*vnli(lli,llj,lstore)
                sum1i1 = sum1i1 + ang1*vnli(lli+1,llj,lstore+1)
c
                sum1j  = sum1j  + ang1*vnlj(lli,llj,lstore)
                sum1j1 = sum1j1 + ang1*vnlj(lli,llj+1,lstore+1)
c
                sum1n  = sum1n  + ang1*venij
c
                sum2n  = sum2n  + venij*
     $           angsav(2,lli,llj,llpot,lmpi,lmpj)
                sum3n  = sum3n  + venij*
     $           angsav(3,lli,llj,llpot,lmpi,lmpj)
                sum4n  = sum4n  + venij*
     $           angsav(4,lli,llj,llpot,lmpi,lmpj)
c
                sum5n  = sum5n  + venij*
     $           angsav(5,lli,llj,llpot,lmpi,lmpj)
                sum6n  = sum6n  + venij*
     $           angsav(6,lli,llj,llpot,lmpi,lmpj)
                sum7n  = sum7n  + venij*
     $           angsav(7,lli,llj,llpot,lmpi,lmpj)
c
              enddo
            enddo
c
          enddo
c
          eneli = eneli + aiaj*sum1i
          if( ri_gt_0 ) enpri = enpri - aiaj*sum1i1
c
          enelj = enelj + aiaj*sum1j
          if( rj_gt_0 ) enprj = enprj - aiaj*sum1j1
c
          engri(1) = engri(1) - ( aiaj*sum2n + ajgrai(1)*sum1n )
          engri(2) = engri(2) - ( aiaj*sum3n + ajgrai(2)*sum1n )
          engri(3) = engri(3) - ( aiaj*sum4n + ajgrai(3)*sum1n )
c
          engrj(1) = engrj(1) - ( aiaj*sum5n + aigraj(1)*sum1n )
          engrj(2) = engrj(2) - ( aiaj*sum6n + aigraj(2)*sum1n )
          engrj(3) = engrj(3) - ( aiaj*sum7n + aigraj(3)*sum1n )
c
  100   continue
  200 continue
c
      if( ri_gt_0 )then
        enpri = enpri/rimag + eneli
      else
        enpri = eneli
      endif
c
      if( rj_gt_0 )then
        enprj = enprj/rjmag + enelj
      else
        enprj = enelj
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NLOCFRC
c
c
      subroutine NLOCFRC( nafrc,iforce, ndim, frcnl,strnl,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat,  nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba, znuc,
     $ lmxnlp1,almnnl,  ratm, rlat,coskr,sinkr,
     $ nrd,nrad, radmsh,vpsrad, wkrad,
     $ dmat,    gntcomb, angsav, frctp )
c---------------------------------------------------------------
c Purpose: calculate the force and stress due to the non-local
c          part of the electron-effective nuclear potential
c          interaction
c
c Written: P.J. Feibelman, extensively revised by P.A. Schultz
c
c Revision history:
c  15Oct08-PAS/2.62: stripe-parallel
c  11May07-PAS/2.60: merged tp and serial
c   6Jul06-APT/2.59: merged task parallel and image parallel
c  25Sep04-PAS/tp0.1: clean-up task-parallel routines
c   6May03-DMC: Add frctp to argument list to provide a local copy
c               of the frcnl array, for parallelization.
c   7Mar02-PAS/2.52: ang constants extracted
c  23Jul01-PAS/2.49: compact dmat
c  21Jun01-PAS/2.48: replace STOPs
c  22May01-PAS/2.47: condense radial scratch space
c  15Mar00-PAS/2.43: rename routines to "nlXXXX"
c  15Feb00-PAS/2.43: opt single atom star angular calc.
c  15Oct99-PAS/2.41: Raczkowski optimizations integrated/cleaned up
c   5Oct99-DBR/2.41: optimization: angular terms
c  27Sep99-PAS/2.40: full three-dimensional stress tensor
c  31Aug99-PAS/2.39: consistent cutoffs - split stars
c  17Dec98-PAS/2.30: clean force/stress arrays
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  29Aug98-PAS/2.25: full rework of bottom loops: finally a full
c    separation of angular/radial terms, gaussian terms condensed;
c    algebra simplified; lower triangle only; renamed NLOCFRC
c  11Aug98-PAS/2.24: fix cutoff bug, full proper cutoff scaling
c  21Jul98-PAS/2.23: clean up cutoffs, extend I:N terms
c  22May98-PAS/2.22: bugfix
c  28Apr97-PAS/2.17: naming conventions
c  11Nov94-PAS/2.12: setup radial integral routine installed
c  27May94-PAS/2.11: big cleanup/ optimize
c   9Mar94-PAS/2.10: fix nlat, j-index bugs; match to setup routine;
c               purge complex declarations; partial cleanup
c---------------------------------------------------------------
c
c  Angular integrals are evaluated analytically
c  Radial integrals are evaluated numerically
c  Allows for non-locality up to l=lmxnlp1(ktyp)-1
c
c  Pseudopotential of atom type ktyp is assumed to fall to zero
c  at large radius as exp(-r**2*almnnl(ktyp)).
c  almnnl(ktyp) is taken from the fits of Bachelet, et al.
c
c  Because of the nature of the non-local potential, the scaling of
c  the matrix elements is not the same as for the local potential
c  integrals (as the norm of the 3-center overlap gaussian). Getting
c  an effective and efficient cutoff scheme is a bit tricky, and the
c  code implemented in the following reflects this.  The scheme
c  implemented here is overly inclusive. It does incorporate scaling
c  of the magnitude of the matrix element properly, but, at best,
c  takes only partial advantage of the "importance" scaling of the
c  matrix elements, i.e., the density matrix or overlap.  Whether an
c  efficient and effective scheme can be fashioned to incorporate
c  this importance evaluation is left as an exercise for the reader.
c    - 11Aug98-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, half=0.5d0 )
c
c Output arrays:
      DIMENSION  frcnl(3,natm), strnl(3,3)
c Input arrays:
      DIMENSION  iforce(natm)
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp), znuc(ntyp)
      DIMENSION  lmxnlp1(ntyp),almnnl(ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  gntcomb(*)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp),vpsrad(nrd,4,ntyp)
      DIMENSION  dmat(nk,*)
c scratch arrays: (missing wkrad dim=nald**2)
      DIMENSION  wkrad(nrd,*)
      DIMENSION  angsav(5*5*5*5*3*81)
c parallel scratch:
      DIMENSION  frctp(3,natm), strtp(3,3)
c
c Local declarations:
      LOGICAL    iatmi, diagshl
      PARAMETER  (lintd=6*6*18)
      DIMENSION  vnlint(lintd)
      DIMENSION  vnln(lintd),vnli(lintd),vnlj(lintd)
      DIMENSION  engri(3),engrj(3)
      DIMENSION  rnuc(3), ri(3),rj(3), risav(3)
c  need neqlatd to be pretty big for bulk
      PARAMETER  (neqlatd=72)
      DIMENSION  ristar(3,neqlatd)
      DIMENSION  aj(9,9),ai(9,9,neqlatd), ilateq(neqlatd)
      DIMENSION  ylmj(2,25),ylmi(2,25,neqlatd)
      DIMENSION  ylmj_t(2,5,5),ylmi_t(2,5,5,neqlatd)
      DIMENSION  gradaj(3,9,9),gradai(3,9,9,neqlatd),
     $           grylmj(2,3,25),grylmi(2,3,25,neqlatd)
      DIMENSION  grylmj_t(3,2,5,5),grylmi_t(3,2,5,5,neqlatd)
c
      DIMENSION  npprl(5)
      DATA       npprl / 1,2,2,2,2 /
c
      DIMENSION  vnorm(9)
c---------------------------------------------------------------
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'FDEV/NLOCFRC: stripe-parallel'
      call FLGETIWR( IWR )
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxf = cutgwfn
      emaxsl = cutslow
      emaxii = cutii
      emxslo = MAX( emaxsl, emaxii )
c
      rt4pi = two*rtpi
c
      mxeqil = 0
      call MKZERO( 3*natm, frcnl )
      call MKZERO( 9, strnl )
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c     
c  Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c     
c  Figure out how much belongs on local processor:
      call MATLOCSTR( iproc,nprocs,nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,   
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
c    Nucleus loop:
c
      do 3000 nuc=1,natm
c
Cc     Each processor will do every nprocs element in this loop.
C        if( MOD( nuc, nprocs ) .ne. iproc ) goto 3000
c
      ktyp = itypa(nuc)
      if( znuc(ktyp).eq.zero ) goto 3000
c
      lmxp1 = lmxnlp1(ktyp)
      if( lmxp1.lt.1 ) goto 3000
c
      alaminn = almnnl(ktyp)
      lmxnl = lmxp1 - 1
c
c    Nucleus lattice loop:
c
      do 2900 klat=1,nlat
c
      do  ir=1,3
        rnuc(ir) = ratm(ir,nuc) + rlat(ir,klat)
      enddo
c
c     Atom j loop:
c
      jjnext = 0
      jnext = myj0
      do 2000 jatm=myatm1,myatm2
        jtyp = itypa(jatm)
        nshlj = numshl(jtyp)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        njstripe = norb - jstart
        matjstr = norbatj*njstripe
        jjstart = jjnext
        jjnext = jjstart + matjstr*ncplx
c
        do  ir=1,3
          rj(ir) = ratm(ir,jatm) - rnuc(ir)
        enddo
        rjsquar = rj(1)*rj(1) + rj(2)*rj(2) + rj(3)*rj(3)
        rjmag = SQRT( rjsquar )
c
        alaminj = alamin(jtyp)
        emax = emxslo
        rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c       Test overlap of Atom j and short-range pot due to "nuc"
        if( rjsquar.gt.rjnmax ) goto 2000
c
        ljmax = 0
        do  jshl=1,nshlj
          if( lshel(jshl,jtyp).gt.ljmax ) ljmax = lshel(jshl,jtyp)
        enddo
        call AINITF( aj,gradaj )
        if( rjmag .lt. 1.d-12 )then
          lpowj = 0
          ljmxp1 = 1
          ylmj(1,1) = one / rt4pi
          call MKZERO( 6, grylmj )
c
          ylmj_t(1,1,1) = ylmj(1,1)
          call MKZERO( 6, grylmj_t )
c
        else
          lpowj = 1
          ljmxp1 = ljmax + lmxp1
          call AOFRF( aj,gradaj, rj )
          call DYLM( ylmj,grylmj, ljmax+lmxnl, rj )
c
          jlm = 0
          do  mmj=1,ljmxp1
            do  llj=mmj,ljmxp1
              jlm = jlm + 1
              do  jpprl=1,npprl(mmj)
                ylmj_t(jpprl,mmj,llj) = ylmj(jpprl,jlm)
                grylmj_t(1,jpprl,mmj,llj) = grylmj(jpprl,1,jlm)
                grylmj_t(2,jpprl,mmj,llj) = grylmj(jpprl,2,jlm)
                grylmj_t(3,jpprl,mmj,llj) = grylmj(jpprl,3,jlm)
              enddo
            enddo
          enddo
c
        endif
c
c       Atom j shell loop:
c
        jorbatnxt = 0
        j = jstart
        do 1800 jshl=1,nshlj
          nalj = nala(jshl,jtyp)
          lshlj = lshel(jshl,jtyp)
          norbshj = 2*lshlj + 1
          lj0 = lshlj*lshlj
c
          j0 = j
          jorbat0 = jorbatnxt
          jorbatnxt = jorbat0 + norbshj
c
          alminj = ala(1,jshl,jtyp)
          almaxj = ala(nalj,jshl,jtyp)
          do  jal=1,nalj
            alj = ala(jal,jshl,jtyp)
            if( alj.lt.alminj ) alminj = alj
            if( alj.gt.almaxj ) almaxj = alj
          enddo
          alaminj = alminj
c
          emax = emxslo
          rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c         Test whether this radial function will contribute:
          if( rjsquar.gt.rjnmax ) goto 1799
c
c         Atom i loop:
c
          ijnext = jjstart
          inext = jstart
          do 1000 iatm=jatm,natm
            ityp = itypa(iatm)
            nshli = numshl(ityp)
            norbati = norba(ityp)
            istart = inext
            inext = istart + norbati
c
            matij = norbati*norbatj
            ijstart = ijnext
            ijnext = ijstart + matij*ncplx
c
c           Following helps ensure only i.ge.j done:
            iorbatn0 = 0
            ishl1 = 1
            if( iatm.eq.jatm )then
              ishl1 = jshl
              do  ishl=1,ishl1-1
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                istart = istart + norbshi
                iorbat0 = iorbatn0
                iorbatn0 = iorbat0 + norbshi
              enddo
            endif
c
            alamini = alamin(ityp)
c           Criterion for including contribution of Atom i:
            ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
            rijnmax = (emaxsl-ex)*(alaminj+alamini+alaminn) /
     $                          ( (alaminj+alaminn)*alamini )
            riinmax = (emaxii-ex)*(alaminj+alamini+alaminn) /
     $                          ( (alaminj+alaminn)*alamini )
c
            if( iatm.eq.jatm )then
              emaxij = emaxii
              rijnmx0 = riinmax
            else
              emaxij = emaxsl
              rijnmx0 = rijnmax
            endif
            rinmax = emaxij*(alamini+alaminn) / (alamini*alaminn)
            rinmx1 = rinmax
            rjovlp = rjsquar * ( alaminj / (alaminj+alaminn) )**2
c
            limax = 0
            do  ishl=ishl1,nshli
              if( lshel(ishl,ityp).gt.limax ) limax = lshel(ishl,ityp)
            enddo
c
c           Find nearest iatm image:
            risqnxt = 9.d9
            do 90 ilat=1,nlat2c
              do  ir=1,3
                ri(ir) = ratm(ir,iatm) + rlat(ir,ilat) - rnuc(ir)
              enddo
              risquar = ri(1)*ri(1) + ri(2)*ri(2) + ri(3)*ri(3)
              if( risquar.lt.risqnxt )then
                risqnxt = risquar
                ilatnxt = ilat
              endif
   90       continue
c
c           Lattice vector loop for Atom i:
c
c           Need to preset initial ilat now.
c           I:I term, if it appears in star, appears in ilat=1.
c           If it is found, exit "star search", do the integrals,
c           and return with ilat1=2 to create non-I:I part of star
            ilat1 = 1
c
            do 900 ilatx=1,nlat2c
              risquar = risqnxt
              risqnxt = 9.d9
c
c             First test that iatm overlaps nuc ...
              if( risquar.gt.rinmx1 ) goto 1000
c
c               ... and test for 3-center overlap as well:
c                   (I align the ri and rj vectors for this test)
              rimag = SQRT( risquar )
              if( risquar.gt.rjovlp )then
                rinmx2 = rijnmx0 * ( (alaminj+alaminn) /
     $           (alaminj+alaminn-alaminj*rjmag/rimag) )**2
                if( risquar.gt.rinmx2 ) goto 1000
              endif
c
c             Align the iatm test vector along the jatm vector
              if( rjmag .gt. 1.d-6 )then
                scale = rimag/rjmag
                do  ir=1,3
                  risav(ir) = scale*rj(ir)
                enddo
              else
                do  ir=1,3
                  risav(ir) = ratm(ir,iatm)+rlat(ir,ilatnxt) - rnuc(ir)
                enddo
              endif
c
              f1 = alaminj / (alaminj+alaminn)
              rijn0 = zero
              do  ir=1,3
                rijn0 = rijn0 + (f1*rj(ir)-risav(ir))**2
              enddo
c
              iatmi = .false.
              ieqlat = 0
              do 190 ilat=ilat1,nlat2c
c
                do  ir=1,3
                  ri(ir) = ratm(ir,iatm) + rlat(ir,ilat) - rnuc(ir)
                enddo
                risqtst = ri(1)*ri(1) + ri(2)*ri(2) + ri(3)*ri(3)
c
c               Compile orientation info of atoms such that risq=risquar
c
                if( risqtst-risquar .gt. 1.d-6
     $           .or. ( iatmi .and. risqtst.ge.risquar ) )then
c
c                 This risq is bigger, check if it is next biggest ...
                  if( risqtst.lt.risqnxt )then
                    risqnxt = risqtst
                    ilatnxt = ilat
                  endif
c
                elseif( ABS( risqtst-risquar ) .le. 1.d-6 )then
c
c                 This risq is within current star, process it
c
                  if( ilat.eq.1 .and. iatm.eq.jatm )then
                    if( rijn0.gt.riinmax ) goto 190
                    iatmi = .true.
                  else
c                   Check tighter cutoff ...
                    if( rijn0.gt.rijnmax ) goto 190
                  endif
c
                  ieqlat = ieqlat + 1
                  if( ieqlat.gt.neqlatd ) goto 190
c
                  ilateq(ieqlat) = ilat
                  do  ir=1,3
                    ristar(ir,ieqlat) = ri(ir)
                  enddo
c
                  call AINITF( ai(1,1,ieqlat),gradai(1,1,1,ieqlat) )
                  if( risqtst .lt. 1.d-12 )then
                    limxp1 = 1
                    ylmi(1,1,ieqlat) = one / rt4pi
                    call MKZERO( 6, grylmi(1,1,1,ieqlat) )
c
                    ylmi_t(1,1,1,ieqlat) = ylmi(1,1,ieqlat)
                    call MKZERO( 6, grylmi_t(1,1,1,1,ieqlat) )
c
                  else
                    limxp1 = limax + lmxp1
                    call AOFRF( ai(1,1,ieqlat),gradai(1,1,1,ieqlat), ri)
                    call DYLM( ylmi(1,1,ieqlat),grylmi(1,1,1,ieqlat),
     $                         limax+lmxnl, ri )
c
                    ilm = 0
                    do  mmi=1,limxp1
                      do  lli=mmi,limxp1
                        ilm = ilm + 1
                        do  ipprl=1,npprl(mmi)
                          ylmi_t(ipprl,mmi,lli,ieqlat) =
     $                     ylmi(ipprl,ilm,ieqlat)
                          grylmi_t(1,ipprl,mmi,lli,ieqlat) =
     $                     grylmi(ipprl,1,ilm,ieqlat)
                          grylmi_t(2,ipprl,mmi,lli,ieqlat) =
     $                     grylmi(ipprl,2,ilm,ieqlat)
                          grylmi_t(3,ipprl,mmi,lli,ieqlat) =
     $                     grylmi(ipprl,3,ilm,ieqlat)
                        enddo
                      enddo
                    enddo
c
                  endif
c
                endif
c
  190         continue
c
              if( iatmi )then
                ilat1 = 2
                if( rijn0.gt.riinmax ) goto 900
              else
                ilat1 = 1
                if( rijn0.gt.rijnmax ) goto 900
              endif
c
c             Check how many atoms in star we picked up
              neqilat = ieqlat
              if( neqilat.gt.mxeqil ) mxeqil = neqilat
              if( neqilat.gt.neqlatd )then
                write(IWR,*) '>>>>> neqilat,neqlatd=',neqilat,neqlatd
                call STOPXERR( 'neqlatd - exceeded in NLOCFRC' )
              endif
              if( neqilat.le.0 ) goto 900
c
c             Find largest l for Atom i with alpha that will contribute:
              ilmax = -1
              do 280 ishl=ishl1,nshli
                nali = nala(ishl,ityp)
                lshli = lshel(ishl,ityp)
c
                almini = ala(1,ishl,ityp)
                almaxi = ala(nali,ishl,ityp)
                do  ial=1,nali
                  ali = ala(ial,ishl,ityp)
                  if( ali.lt.almini ) almini = ali
                  if( ali.gt.almaxi ) almaxi = ali
                enddo
c
                emax = emaxf
                if( almaxi.lt.alfast .and. almaxj.lt.alfast )emax=emaxsl
                if( iatmi ) emax = emaxii
c
                ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
                rijnmx = (emax-ex)*(alaminj+almini+alaminn) /
     $                           ( (alaminj+alaminn)*almini )
                if( rijn0.le.rijnmx )then
                  if( lshli.gt.ilmax ) ilmax = lshli
                endif
  280         continue
c
              if( ilmax.lt.0 ) goto 900
c
              rimag = SQRT( risquar )
c
              lisq = limxp1*limxp1
              ljsq = ljmxp1*ljmxp1
c
              maxlj = (lshlj+1)*(lshlj+1)
              maxli = (ilmax+1)*(ilmax+1)
c
c             Carve up space in angsav() for arrays in angsetf ...
c
              iangs = 1
c              ... angsav() needs:
              nangs = limxp1*ljmxp1*7*lmxp1*9*9
              iangt = iangs + nangs
c              ... angtmp() needs:
              nangt = lisq*ljsq
              igntj = iangt + nangt
c              ... gntcj() (complex, use 4* real space for safety) needs:
              ngntj = 4*(ljsq*maxlj*lmxp1*lmxp1)
              ignti = igntj + ngntj
c             ...  cgntci() (also complex) needs:
              ngnti = 4*(lisq*maxli*lmxp1*lmxp1)
c
              if( neqilat.eq.1 )then
c
c             If I have only one atom in a star, then compute the angular
c             stuff up here only once, rather than repeat for every shell
c             If more than one atom per star, I either have to duplicate
c             angsav for each element in the star, or, as done here, compute
c             it below for each star. 15Feb00-PAS/2.43
c
                ieqlat = 1
                call NLANGF(
     $           maxlj,maxli,ljmxp1,limxp1,lmxp1,ljsq,lisq,
     $           ylmj_t,ylmi_t(1,1,1,ieqlat),
     $           grylmj_t,grylmi_t(1,1,1,1,ieqlat),gntcomb,
     $           angsav,angsav(iangt),angsav(igntj),angsav(ignti) )
              endif
c
c             Atom i shell loop:
c
              iorbatnxt = iorbatn0
              i = istart
              do 800 ishl=ishl1,nshli
                nali = nala(ishl,ityp)
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                li0 = lshli*lshli
c
                i0 = i
                iorbat0 = iorbatnxt
                iorbatnxt = iorbat0 + norbshi
c
                diagshl = .false.
                if( i0.eq.j0 ) diagshl = .true.
c
                almini = ala(1,ishl,ityp)
                almaxi = ala(nali,ishl,ityp)
                do  ial=1,nali
                  ali = ala(ial,ishl,ityp)
                  if( ali.lt.almini ) almini = ali
                  if( ali.gt.almaxi ) almaxi = ali
                enddo
c
                emax = emaxf
                if( almaxi.lt.alfast .and. almaxj.lt.alfast )emax=emaxsl
                if( iatmi ) emax = emaxii
c
                lpowmx = lpowj
                lpowi = 0
                if( rimag .ge. 1.d-12 )then
                  lpowi = 1
                  lpowmx = 1
                endif
                limxpd = limxp1 + lpowi
                ljmxpd = ljmxp1 + lpowj
c
                lpowmx = lshli + lshlj + 1 + lpowmx
                lstmx = lpowmx*lmxp1
                lijmx = limxpd*ljmxpd*lstmx
c
                do  lij=1,lijmx
                  vnln(lij) = zero
                  vnli(lij) = zero
                  vnlj(lij) = zero
                enddo
c
c               Alpha loops:
c
                nx = 0
                do 320 jal=1,nalj
                  alj = ala(jal,jshl,jtyp)
                  calj = cala(jal,jshl,jtyp)
                  twoalj = alj + alj
c
c                 Test whether this alpha contributes:
                  rjnmx = emax*(alj+alaminn) / (alj*alaminn)
                  if( rjsquar.gt.rjnmx ) goto 320
c
                  fj1 = alj / (alj+alaminn)
                  rijn = zero
                  do  ir=1,3
                    rijn = rijn + (fj1*rj(ir)-risav(ir))**2
                  enddo
c
                  do 310 ial=1,nali
                    ali = ala(ial,ishl,ityp)
                    cali = cala(ial,ishl,ityp)
                    twoali = ali + ali
c
c                   Test whether this pair of alphas contributes:
                    ex = rjsquar*alj*alaminn / (alj+alaminn)
                    rijnmx = (emax-ex)*(alj+ali+alaminn) /
     $                               ( (alj+alaminn)*ali )
                    if( rijn.gt.rijnmx ) goto 310
c
                    nx = nx + 1
c
                    alsum = ali + alj
                    exparg = ali*risquar + alj*rjsquar
                    bargi = twoali*rimag
                    bargj = twoalj*rjmag
                    bargs = bargi + bargj
c
c                   Evaluate radial integrals
c
                    call NRSCUT( nrmn,nrmx,nrad(ktyp),argmx,
     $               exparg,bargs,alsum,radmsh(1,ktyp), wkrad )
                    nr0 = nrmn - 1
                    nrlen = nrmx - nrmn + 1
c
                    call NLRAD( vnlint, alsum,bargj,bargi,bargs,
     $               exparg, ljmxpd,limxpd,lmxp1,lstmx,lpowmx,
     $               nrlen,nrd,nr0, radmsh(1,ktyp),vpsrad(1,1,ktyp),
     $               wkrad(1,1), wkrad(1,8), wkrad(1,15),
     $               wkrad(1,22),wkrad(1,23),wkrad(1,24),
     $               wkrad(1,25),wkrad(1,26),wkrad(1,27) )
c
c                   Sum into running totals:
                    cnln = cali*calj
                    cnli = cnln*twoali
                    cnlj = cnln*twoalj
                    do  lij=1,lijmx
                      vnln(lij) = vnln(lij) + cnln*vnlint(lij)
                      vnli(lij) = vnli(lij) + cnli*vnlint(lij)
                      vnlj(lij) = vnlj(lij) + cnlj*vnlint(lij)
                    enddo
c
c                   Close alpha loops:
  310             continue
  320           continue
c
                if( nx.eq.0 ) goto 799
c
c               Loop over star of Atom j:
c
                do 490 ieqlat=1,neqilat
c
                  ilat = ilateq(ieqlat)
                  do  ir=1,3
                    ri(ir) = ristar(ir,ieqlat)
                  enddo
c
                  if( neqilat.gt.1 )then
                    call NLANGF(
     $               maxlj,maxli,ljmxp1,limxp1,lmxp1,ljsq,lisq,
     $               ylmj_t,ylmi_t(1,1,1,ieqlat),
     $               grylmj_t,grylmi_t(1,1,1,1,ieqlat),gntcomb,
     $               angsav,angsav(iangt),angsav(igntj),angsav(ignti) )
                  endif
c
c                 Angular loops:
c
                  ij0 = ijstart + jorbat0*norbati + iorbat0
                  ij0 = ij0 - norbati
                  mli1 = 1
                  do 420 mlj=1,norbshj
                    lj = lj0 + mlj
                    jorbat = jorbat0 + mlj
                    j = j0 + mlj
c
                    ij0 = ij0 + norbati
                    if( diagshl ) mli1 = mlj
                    do 410 mli=mli1,norbshi
                      li = li0 + mli
                      iorbat = iorbat0 + mli
                      i = i0 + mli
                      ij = ij0 + mli
c
                      denlilj = vnorm(li)*vnorm(lj)
c
c                     Do sum over density matrix:
                      dmsum = zero
                      if( i.eq.j )then
                        do  k=1,nk
C                          dmsum = dmsum + coskr(k,ilat)*dmat(i,i,k)
                          dmsum = dmsum + coskr(k,ilat)*dmat(k,ij)
                        enddo
                      else
c                       i.ne.j
                        do  k=1,nk
C                          dmsum = dmsum + coskr(k,ilat)*dmat(i,j,k)
                          dmsum = dmsum + coskr(k,ilat)*dmat(k,ij)
                        enddo
                        if( ncplx.eq.2 )then
                          ijc = ij + matij
                          do  k=1,nk
C                            dmsum = dmsum + sinkr(k,ilat)*dmat(j,i,k)
                            dmsum = dmsum + sinkr(k,ilat)*dmat(k,ijc)
                          enddo
                        endif
c                       Double because only doing one triangle
                        dmsum = dmsum + dmsum
                      endif
                      dmsum = dmsum / denlilj
c
                      call NLINTF( enprj,enpri, engrj,engri,
     $                 vnln,vnlj,vnli, rjmag,rimag, lj,li,
     $                 ljmxp1,limxp1,lmxp1,lpowmx,lpowj,lpowi,lstmx,
     $                 aj(1,lj),    gradaj(1,1,lj),
     $                 ai(1,li,ieqlat),gradai(1,1,li,ieqlat), angsav )
c
                      fxi = dmsum*( engri(1) + enpri*ri(1) )
                      fyi = dmsum*( engri(2) + enpri*ri(2) )
                      fzi = dmsum*( engri(3) + enpri*ri(3) )
                      fxj = dmsum*( engrj(1) + enprj*rj(1) )
                      fyj = dmsum*( engrj(2) + enprj*rj(2) )
                      fzj = dmsum*( engrj(3) + enprj*rj(3) )
c
                      frcnl(1,iatm) = frcnl(1,iatm) + fxi
                      frcnl(2,iatm) = frcnl(2,iatm) + fyi
                      frcnl(3,iatm) = frcnl(3,iatm) + fzi
c
                      frcnl(1,jatm) = frcnl(1,jatm) + fxj
                      frcnl(2,jatm) = frcnl(2,jatm) + fyj
                      frcnl(3,jatm) = frcnl(3,jatm) + fzj
c
                      frcnl(1,nuc) = frcnl(1,nuc) - fxi - fxj
                      frcnl(2,nuc) = frcnl(2,nuc) - fyi - fyj
                      frcnl(3,nuc) = frcnl(3,nuc) - fzi - fzj
c
                      strnl(1,1) = strnl(1,1) - fxi*ri(1) - fxj*rj(1)
                      strnl(2,1) = strnl(2,1) - fyi*ri(1) - fyj*rj(1)
                      strnl(3,1) = strnl(3,1) - fzi*ri(1) - fzj*rj(1)
                      strnl(1,2) = strnl(1,2) - fxi*ri(2) - fxj*rj(2)
                      strnl(2,2) = strnl(2,2) - fyi*ri(2) - fyj*rj(2)
                      strnl(3,2) = strnl(3,2) - fzi*ri(2) - fzj*rj(2)
                      strnl(1,3) = strnl(1,3) - fxi*ri(3) - fxj*rj(3)
                      strnl(2,3) = strnl(2,3) - fyi*ri(3) - fyj*rj(3)
                      strnl(3,3) = strnl(3,3) - fzi*ri(3) - fzj*rj(3)
c
c                     Close angular loops:
  410               continue
  420             continue
c
c                 Close star of iatm loop:
  490           continue
c
  799           continue
c               Close Atom i shell loop:
                i = i0 + norbshi
  800         continue
c
c              Close Atom i lattice loop:
  900       continue
c
c           Close Atom i loop:
 1000     continue
c
 1799     continue
c         Close Atom j shell loop:
          j = j0 + norbshj
 1800   continue
c
c       Close Atom j loop:
 2000 continue
c
c       Close Nucleus lattice loop:
c
 2900 continue
c
c       Close Nucleus loop:
c
 3000 continue
c
      if( nprocs .gt. 1 )then
c       Each local processor now has forces over its subset.
c       Need to sum these to a single value, on the master proc (0).
c       But for now, we will Broadcast total to all processors.
c
        nreduc = 3*natm
c
        call MPREDUC8( master, nreduc, frcnl , frctp , icomm )
C        call MPI_Reduce( frcnl , frctp , nreduc,
C     $   MPI_DOUBLE_PRECISION, MPI_SUM,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pnlocfrc - Reduce frcnl' )
        call DCOPY( nreduc, frctp,1, frcnl,1 )
c
        call MPBCAST8( master, nreduc, frcnl , icomm )
C        call MPI_Bcast( frcnl , nreduc, MPI_DOUBLE_PRECISION,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pnlocfrc - Bcast frcnl' )
c
        nreduc = 9
        call MPREDUC8( master, nreduc, strnl , strtp , icomm )
C        call MPI_Reduce( strnl , strtp , nreduc,
C     $   MPI_DOUBLE_PRECISION, MPI_SUM,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pnlocfrc - Reduce strnl' )
        call DCOPY( nreduc, strtp,1, strnl,1 )
c
        call MPBCAST8( master, nreduc, strnl , icomm )
C        call MPI_Bcast( strnl , nreduc, MPI_DOUBLE_PRECISION,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pnlocfrc - Bcast strnl' )
c
c       End tp
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NLOCMAT
c
c
      subroutine NLOCMAT( IWR,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat  ,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba, znuc,
     $ lmxnlp1,almnnl, ratm, rlat,coskr,sinkr, gntcomb,
     $ nrd,nrad, radmsh,vpsrad, wkrad,
     $ vnlr,vnli,
     $ vnlij,  angsav, vnltp )
c---------------------------------------------------------------
c Purpose: calculate matrix elements due to non-local part of
c          the electron:effective-nuclear-potential interaction
c
c Revision history:
c  17Sep08-PAS/2.62: stripe-distributed-parallel
c  20Jun07-PAS/2.60: merge tp and serial (2oct07: small cosmetic)
c   6Jul06-APT/2.60: merged task parallel and image parallel
c  25Sep04-PAS/tp0.1: clean-up task-parallel routines
c  16Apr03-DMC: Add vnltp to parameter list, to provide a local copy
c               of the vnlij array, for parallelism.
c   2Oct02-PAS/2.54: optimize NLINT, and clean out consequences
c   7Mar02-PAS/2.52: ang constants extracted
c  21Jun01-PAS/2.48: replace STOPs
c  22May01-PAS/2.47: condense radial scratch space
c   6Mar00-PAS/2.43: rename "nl" routines, "ennloc" to "nlocmat"
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  14Sep98-PAS/2.27: cosmetic - naming convention changed
c   5Aug98-PAS/2.24: fix cutoff bug, full proper cutoff scaling
c  21Jul98-PAS/2.23: clean up cutoffs, extend I:N terms
c  22May98-PAS/2.22: bugfix
c  28Apr97-PAS/2.17: naming conventions
c  18Jan94-PAS/2.04: fix nlat, j-indexing bugs; rationalize
c         arguments; full cleanup, match sij,tij,enij,ennloc
c  21Jun89-PAS: extract ANGSET and some of LLOOPS out of under
c               orbital loops, pack angsav
c    May89-PAS: extract RADNLOC out of under angular loops
c---------------------------------------------------------------
c
c  Angular integrals are evaluated analytically
c  Radial integrals are evaluated numerically
c  Allows for non-locality up to l=lmxnlp1(ktyp)-1
c
c  The pseudopotential for atom type ktyp is assumed to fall to
c  zero as exp(-r**2*almnnl(ktyp)).  almnnl(ktyp) here is
c  taken from the fits of Bachelet, et al.
c
c  Because of the nature of the non-local potential, the scaling of
c  the matrix elements is not the same as for the local potential
c  integrals (as the norm of the 3-center overlap gaussian). Getting
c  an effective and efficient cutoff scheme is a bit tricky, and the
c  code implemented in the following reflects this.  The scheme
c  implemented here is overly inclusive. It does incorporate scaling
c  of the magnitude of the matrix element properly, but, at best,
c  takes only partial advantage of the "importance" scaling of the
c  matrix elements, i.e., the density matrix or overlap.  Whether an
c  efficient and effective scheme can be fashioned to incorporate
c  this importance evaluation is left as an exercise for the reader.
c    - 11Aug98-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, half=0.5d0 )
c
c Output array:
      DIMENSION  vnlij(nk,*)
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp), znuc(ntyp)
      DIMENSION  lmxnlp1(ntyp),almnnl(ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
      DOUBLE COMPLEX    gntcomb(9,5,5,2,9)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp),vpsrad(nrd,4,ntyp)
c
c Scratch arrays:
      DIMENSION  wkrad(nrd,*)
      DIMENSION  vnlr(nk),vnli(nk)
      DIMENSION  angsav(*)
c     Angsav scratch space packed below needs space 
c       5x5x5x3x9x9 + 4*(5x9x3x3) + 4x(5x5x9x3x3)=30375+1620+8100=40095
c Task-parallel scratch:
      DIMENSION  vnltp(*)
c
c Local declarations:
      LOGICAL    Lmatreduce
      LOGICAL    iatmi, diagshl
      LOGICAL    izero(9,9)
      DIMENSION  vnlint(5*5*15),vnltmp(5*5*15)
      DIMENSION  rnuc(3),ri(3),rj(3),risav(3)
c neqlatd in main routine should match this too.
      PARAMETER  ( neqlatd = 72 )
      DIMENSION  aj(9,9),ai(9,9,neqlatd), ilateq(neqlatd)
      DIMENSION  ylmj(2,25),ylmi(2,25,neqlatd)
c
      DIMENSION  vnorm(9)
c lstout sets level of diagnostic output, least:0-5:most
      DATA  lstout / 0 /
c---------------------------------------------------------------
c
c >>>> EXECUTABLE CODE:
c
      Lmatreduce = .false.
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxf = cutgwfn
      emaxsl = cutslow
      emaxii = cutii
      emxslo = MAX( emaxsl, emaxii )
c
      rt4pi = two*rtpi
c
      nmat = nk*norb*norb
c
      mxeqil = 0
      if( lstout.gt.0 ) write(IWR,*) 'NLOCMAT: v-nonlocal diagnostics'
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
c  Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmatstr = ncplx*nk*matstr
c
c  Figure out how much belongs on local processor:
      call MATLOCSTR( iproc,nprocs,nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmatpr = mymatpr*ncplx*nk
c
      if( nprocs .gt. 0 ) call MKZERO( nmatpr, vnlij )
c
c    Nucleus loop:
c
      do 3000 nuc=1,natm
c
c     Each processor will do every nprocs element in this loop.
      if( Lmatreduce .and. ( MOD( nuc, nprocs ) .ne. iproc ) ) goto 3000
c
      ktyp = itypa(nuc)
      if( znuc(ktyp).eq.zero ) goto 3000
c
      lmxp1 = lmxnlp1(ktyp)
      if( lmxp1.lt.1 ) goto 3000
c
      alaminn = almnnl(ktyp)
      lmxnl = lmxp1 - 1
c
c    Nucleus lattice loop:
c
      do 2900 klat=1,nlat
c
      do  ir=1,3
        rnuc(ir) = ratm(ir,nuc) + rlat(ir,klat)
      enddo
c
c     Atom j loop:
c
      jjnext = 0
      jnext = myj0
      do 2000 jatm=myatm1,myatm2
        jtyp = itypa(jatm)
        nshlj = numshl(jtyp)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        njstripe = norb - jstart
        matjstr = norbatj*njstripe
        jjstart = jjnext
        jjnext = jjstart + matjstr*ncplx
c
        do  ir=1,3
          rj(ir) = ratm(ir,jatm) - rnuc(ir)
        enddo
        rjsquar = rj(1)*rj(1) + rj(2)*rj(2) + rj(3)*rj(3)
        rjmag = SQRT( rjsquar )
c
        alaminj = alamin(jtyp)
        emax = emxslo
        rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c       Test overlap of Atom j and short-range pot due to "nuc"
        if( rjsquar.gt.rjnmax ) goto 2000
c
        ljmax = 0
        do  jshl=1,nshlj
          if( lshel(jshl,jtyp).gt.ljmax ) ljmax = lshel(jshl,jtyp)
        enddo
        call AINIT( aj )
        if( rjmag .lt. 1.d-12 )then
          ljmxp1 = 1
          ylmj(1,1) = one / rt4pi
c
        else
          ljmxp1 = ljmax + lmxp1
          call AOFR( aj, rj )
          call YLMREAL( ylmj, ljmax+lmxnl, rj )
c
        endif
c
c       Atom j shell loop:
c
        jorbatnxt = 0
        j = jstart
        do 1800 jshl=1,nshlj
          nalj = nala(jshl,jtyp)
          lshlj = lshel(jshl,jtyp)
          norbshj = 2*lshlj + 1
          lj0 = lshlj*lshlj
c
          j0 = j
          jorbat0 = jorbatnxt
          jorbatnxt = jorbat0 + norbshj
c
          alminj = ala(1,jshl,jtyp)
          almaxj = ala(nalj,jshl,jtyp)
          do  jal=1,nalj
            alj = ala(jal,jshl,jtyp)
            if( alj.lt.alminj ) alminj = alj
            if( alj.gt.almaxj ) almaxj = alj
          enddo
          alaminj = alminj
c
          emax = emxslo
          rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c         Test whether this radial function will contribute:
          if( rjsquar.gt.rjnmax ) goto 1799
c
c         Atom i loop:
c
          ijnext = jjstart
          inext = jstart
          do 1000 iatm=jatm,natm
            ityp = itypa(iatm)
            nshli = numshl(ityp)
            norbati = norba(ityp)
            istart = inext
            inext = istart + norbati
c
            matij = norbati*norbatj
            ijstart = ijnext
            ijnext = ijstart + matij*ncplx
c
c           Following helps ensure only i.ge.j done:
            iorbatn0 = 0
            ishl1 = 1
            if( iatm.eq.jatm )then
              ishl1 = jshl
              do  ishl=1,ishl1-1
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                istart = istart + norbshi
                iorbat0 = iorbatn0
                iorbatn0 = iorbat0 + norbshi
              enddo
            endif
c
            alamini = alamin(ityp)
c
c           Criterion for including contribution of Atom i:
            ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
            rijnmax = (emaxsl-ex)*(alaminj+alamini+alaminn) /
     $                          ( (alaminj+alaminn)*alamini )
            riinmax = (emaxii-ex)*(alaminj+alamini+alaminn) /
     $                          ( (alaminj+alaminn)*alamini )
c
            if( iatm.eq.jatm )then
              emaxij = emaxii
              rijnmx0 = riinmax
            else
              emaxij = emaxsl
              rijnmx0 = rijnmax
            endif
            rinmax = emaxij*(alamini+alaminn) / (alamini*alaminn)
            rinmx1 = rinmax
            rjovlp = rjsquar * ( alaminj / (alaminj+alaminn) )**2
c
            limax = 0
            do  ishl=ishl1,nshli
              if( lshel(ishl,ityp).gt.limax ) limax = lshel(ishl,ityp)
            enddo
c
c           Find nearest iatm image:
            risqnxt = 9.d9
            do 90 ilat=1,nlat2c
              do  ir=1,3
                ri(ir) = ratm(ir,iatm) + rlat(ir,ilat) - rnuc(ir)
              enddo
              risquar = ri(1)*ri(1) + ri(2)*ri(2) + ri(3)*ri(3)
              if( risquar.lt.risqnxt )then
                risqnxt = risquar
                ilatnxt = ilat
              endif
   90       continue
c
c           Lattice vector loop for Atom i:
c
            do 900 ilatx=1,nlat2c
              risquar = risqnxt
              risqnxt = 9.d9
c
c             First test that iatm overlaps nuc ...
              if( risquar.gt.rinmx1 ) goto 1000
c
c              ... and test for 3-center overlap as well:
c               (I align the ri and rj vectors for this test)
              rimag = SQRT( risquar )
              if( risquar.gt.rjovlp )then
                rinmx2 = rijnmx0 * ( (alaminj+alaminn) /
     $           (alaminj+alaminn-alaminj*rjmag/rimag) )**2
                if( risquar.gt.rinmx2 ) goto 1000
              endif
c
c             Align the iatm test vector along the jatm vector
              if( rjmag .gt. 1.d-6 )then
                scale = rimag/rjmag
                do  ir=1,3
                  risav(ir) = scale*rj(ir)
                enddo
              else
                do  ir=1,3
                  risav(ir) = ratm(ir,iatm)+rlat(ir,ilatnxt) - rnuc(ir)
                enddo
              endif
c
              f1 = alaminj / (alaminj+alaminn)
              rijn0 = zero
              do  ir=1,3
                rijn0 = rijn0 + (f1*rj(ir)-risav(ir))**2
              enddo
c
              iatmi = .false.
              ieqlat = 0
              do 190 ilat=1,nlat2c
c
                do  ir=1,3
                  ri(ir) = ratm(ir,iatm) + rlat(ir,ilat) - rnuc(ir)
                enddo
                risqtst = ri(1)*ri(1) + ri(2)*ri(2) + ri(3)*ri(3)
c
c               Compile orientation info of atoms such that risq=risquar
c
                if( risqtst-risquar .gt.  1.d-6 )then
c
c                 This risq is bigger, check if it is next biggest ...
c
                  if( risqtst.lt.risqnxt )then
c                    ... it indeed is, and record it:
                    risqnxt = risqtst
                    ilatnxt = ilat
                  endif
c
                elseif( ABS( risqtst-risquar ) .le. 1.d-6 )then
c
c                 This risq is within current star, process it
c
                  if( ilat.eq.1 .and. iatm.eq.jatm )then
                    iatmi = .true.
                  else
c                   Check tighter cutoff ...
                    if( rijn0.gt.rijnmax ) goto 190
                  endif
c
                  ieqlat = ieqlat + 1
                  if( ieqlat.gt.neqlatd ) goto 190
c
                  ilateq(ieqlat) = ilat
c
                  call AINIT( ai(1,1,ieqlat) )
                  if( risqtst .lt. 1.d-12 )then
                    limxp1 = 1
                    ylmi(1,1,ieqlat) = one / rt4pi
c
                  else
                    limxp1 = limax + lmxp1
                    call AOFR( ai(1,1,ieqlat), ri )
                    call YLMREAL( ylmi(1,1,ieqlat), limax+lmxnl, ri )
c
                  endif
c
                endif
c
  190         continue
c
              if( iatmi )then
                if( rijn0.gt.riinmax ) goto 900
              else
                if( rijn0.gt.rijnmax ) goto 900
              endif
c
c             Check how many atoms in star we picked up
              neqilat = ieqlat
              if( neqilat.gt.mxeqil ) mxeqil = neqilat
              if( neqilat.gt.neqlatd )then
                write(IWR,*) '>>>>> neqilat,neqlatd=',neqilat,neqlatd
                call STOPXERR( 'neqlatd - exceeded in NLOCFRC' )
              endif
              if( neqilat.le.0 ) goto 900
c
c             Find largest l for Atom i with alpha that will contribute:
              ilmax = -1
              do 280 ishl=ishl1,nshli
                nali = nala(ishl,ityp)
                lshli = lshel(ishl,ityp)
c
                almini = ala(1,ishl,ityp)
                almaxi = ala(nali,ishl,ityp)
                do  ial=1,nali
                  ali = ala(ial,ishl,ityp)
                  if( ali.lt.almini ) almini = ali
                  if( ali.gt.almaxi ) almaxi = ali
                enddo
c
                emax = emaxf
                if( almaxi.lt.alfast .and. almaxj.lt.alfast )emax=emaxsl
                if( iatmi ) emax = emaxii
c
                ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
                rijnmx = (emax-ex)*(alaminj+almini+alaminn) /
     $                           ( (alaminj+alaminn)*almini )
                if( rijn0.le.rijnmx )then
                  if( lshli.gt.ilmax ) ilmax = lshli
                endif
  280         continue
c
              if( ilmax.lt.0 ) goto 900
c
              rimag = SQRT( risquar )
c
              maxlj = (lshlj+1)*(lshlj+1)
              maxli = (ilmax+1)*(ilmax+1)
c
c             Carve up space in angsav() for arrays in angset ...
              iangs = 1
c              ... angsav():
              nangs = ljmxp1*limxp1*limxp1*lmxp1*9*9
              igntj = iangs + nangs
c              ... gntci() (complex, allow 4* real space for safety):
              ngntj = 4*(ljmxp1*maxlj*lmxp1*lmxp1)
              ignti = igntj + ngntj
c              ... cgntcj() (also complex):
              ngnti = 4*(limxp1*limxp1*maxli*lmxp1*lmxp1)
c
c             Compute sums of three-j symbols:
              call NLANG( maxlj,maxli,ljmxp1,limxp1,lmxp1,rjmag,rimag,
     $         ylmj,gntcomb,angsav,angsav(igntj),angsav(ignti) )
c
c             Atom i shell loop:
c
              iorbatnxt = iorbatn0
              i = istart
              do 800 ishl=ishl1,nshli
                nali = nala(ishl,ityp)
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                li0 = lshli*lshli
c
                i0 = i
                iorbat0 = iorbatnxt
                iorbatnxt = iorbat0 + norbshi
c
                diagshl = .false.
                if( i0.eq.j0 ) diagshl = .true.
c
                almini = ala(1,ishl,ityp)
                almaxi = ala(nali,ishl,ityp)
                do  ial=1,nali
                  ali = ala(ial,ishl,ityp)
                  if( ali.lt.almini ) almini = ali
                  if( ali.gt.almaxi ) almaxi = ali
                enddo
c
                emax = emaxf
                if( almaxi.lt.alfast .and. almaxj.lt.alfast )emax=emaxsl
                if( iatmi ) emax = emaxii
c
                lpowmx = lshli + lshlj + 1
                lstmx = lpowmx*lmxp1
                lijmx = limxp1*ljmxp1*lstmx
                do  lij=1,lijmx
                  vnlint(lij) = zero
                enddo
c
c               Alpha loops:
c
                nx = 0
                do 320 jal=1,nalj
                  alj = ala(jal,jshl,jtyp)
c
c                 Test whether this alpha contributes:
                  rjnmx = emax*(alj+alaminn) / (alj*alaminn)
                  if( rjsquar.gt.rjnmx ) goto 320
c
                  fj1 = alj / (alj+alaminn)
                  rijn = zero
                  do  ir=1,3
                    rijn = rijn + (fj1*rj(ir)-risav(ir))**2
                  enddo
c
                  do 310 ial=1,nali
                    ali = ala(ial,ishl,ityp)
c
c                   Test whether this pair of alphas contributes:
                    ex = rjsquar*alj*alaminn / (alj+alaminn)
                    rijnmx = (emax-ex)*(ali+alj+alaminn) /
     $                               ( (alj+alaminn)*ali )
                    if( rijn.gt.rijnmx ) goto 310
c
                    alsum = ali + alj
                    exparg = ali*risquar + alj*rjsquar
                    bargi = two*ali*rimag
                    bargj = two*alj*rjmag
                    bargs = bargi + bargj
c
c                   Evaluate radial integrals
c
                    call NRSCUT( nrmn,nrmx,nrad(ktyp),argmx,
     $               exparg,bargs,alsum,radmsh(1,ktyp), wkrad )
                    nr0 = nrmn - 1
                    nrlen = nrmx - nrmn + 1
c
                    call NLRAD( vnltmp, alsum,bargj,bargi,bargs,
     $               exparg, ljmxp1,limxp1,lmxp1,lstmx,lpowmx,
     $               nrlen,nrd,nr0, radmsh(1,ktyp),vpsrad(1,1,ktyp),
     $               wkrad(1,1), wkrad(1,8), wkrad(1,15),
     $               wkrad(1,22),wkrad(1,23),wkrad(1,24),
     $               wkrad(1,25),wkrad(1,26),wkrad(1,27) )
c
                    fac = cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
                    do  lij=1,lijmx
                      vnlint(lij) = vnlint(lij) + fac*vnltmp(lij)
                    enddo
                    nx = nx + 1
c
c                   Close alpha loops:
  310             continue
  320           continue
c
                if( lstout.gt.3 )then
                  write(IWR,*) '   nuc,iatm,jatm,klat,ilatx,neqilat,nx'
                  write(IWR,9350)  nuc,iatm,jatm,klat,ilatx,neqilat,nx
 9350             format(1x,10i4)
                endif
c
                if( nx.eq.0 ) goto 799
c
c               Angular loops:
c
                ij0 = ijstart + jorbat0*norbati + iorbat0
                ij0 = ij0 - norbati
                mli1 = 1
                do 420 mlj=1,norbshj
                  lj = lj0 + mlj
                  jorbat = jorbat0 + mlj
                  j = j0 + mlj
c
                  ij0 = ij0 + norbati
                  if( diagshl ) mli1 = mlj
                  do 410 mli=mli1,norbshi
                    li = li0 + mli
                    iorbat = iorbat0 + mli
                    i = i0 + mli
                    ij = ij0 + mli
c
c                   Evaluate contribution to vnlij(i,j)
c
                    if( neqilat.eq.1 )then
                      call NLINT( vnlr,vnli, vnlint,
     $                 ljmxp1,limxp1,lmxp1,lstmx,lpowmx, rjmag,rimag,
     $                 lj,li, aj(1,lj),ai(1,li,1), ylmi,angsav,
     $                 nk,nlat, coskr,sinkr,
     $                 ilateq(1) )
                    else
c
                      do 405 lmpj=1,lj
                        if( aj(lmpj,lj).eq.zero )then
                          do  lmpi=1,li
                            izero(lmpj,lmpi) = .true.
                          enddo
                        else
                          do 404 lmpi=1,li
                            do  lateqi=1,neqilat
                              if( ai(lmpi,li,lateqi).ne.zero ) goto 403
                            enddo
                            izero(lmpj,lmpi) = .true.
                            goto 404
  403                       continue
                            izero(lmpj,lmpi) = .false.
  404                     continue
                        endif
  405                 continue
c
                      call NLINTEQ( vnlr,vnli, vnlint,
     $                 ljmxp1,limxp1,lmxp1,lstmx,lpowmx, rjmag,rimag,
     $                 lj,li,izero,aj(1,lj),ai,ylmi,angsav,
     $                 nk,nlat, coskr,sinkr,
     $                 neqilat,ilateq, wkrad )
c -->                                  vnltmp(neqilat)-s
                    endif
c
                    fac = one / (vnorm(li)*vnorm(lj))
c
                    do  k=1,nk
C                      vnlij(i,j,k) = vnlij(i,j,k) + fac*vnlr(k)
                      vnlij(k,ij) = vnlij(k,ij) + fac*vnlr(k)
                    enddo
                    if( ncplx.eq.2 .and. i.ne.j )then
                      ijc = ij + matij
                      do  k=1,nk
C                       vnlij(j,i,k) = vnlij(j,i,k) + fac*vnli(k)
                        vnlij(k,ijc) = vnlij(k,ijc) + fac*vnli(k)
                      enddo
                    endif
c
                    if( lstout.gt.4 )then
                      write(IWR,*) '      i,j,vnl=',i,j,vnlr(1),vnli(1)
                    endif
c
c                   Close angular loops:
  410             continue
  420           continue
c
  799           continue
c               Close Atom i shell loop:
                i = i0 + norbshi
  800         continue
c
c             Close Atom i lattice loop:
  900       continue
c
c           Close Atom i loop:
 1000     continue
c
 1799     continue
c         Close Atom j shell loop:
          j = j0 + norbshj
 1800   continue
c
c       Close Atom j loop:
 2000 continue
c
c       Close Nucleus lattice loop:
c
 2900 continue
c
c       Close Nucleus loop:
c
 3000 continue
c
c >>>> Reassamble final matrix
c
      if( nprocs.gt.1 ) call TIMER('  nlocmat compute')
      if( Lmatreduce .and. nprocs .gt. 1 )then
c
c       Each local processor has full non-local Hamiltonian over its
c       share of atomic potentials.
c       Reduce (sum) these to master, to get total non-local Ham matrix.
c
        call MPREDUC8( master, nmat, vnlij, vnltp, icomm )
C        call MPI_Reduce( vnlij, vnltp, nmat, MPI_DOUBLE_PRECISION,
C     $   MPI_SUM, master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pnlocmat - Reduce vnlij' )
c
c       Put the matrix into the right place
        call DCOPY( nmat, vnltp,1, vnlij,1 )
c
        call TIMER('  nlocmat Reduce ')
c
c       The final output matrix is only on the master processor
c
      endif
c
c  Dump diagnostics for debugging if wanted:
c
      write(IWR,*) 'NLOCMAT: Max neqilat=',mxeqil
C      if( iproc .eq. master )then
C        if( lstout.gt.0 )then
C          do  k=1,nk
C            sumii = zero
C            sumsqii = zero
C            sumij = zero
C            sumsqij = zero
C            do  i=1,norb
C              sumii = sumii + vnlij(i,i,k)
C              sumsqii = sumsqii + vnlij(i,i,k)**2
C              do  j=1,norb
C                sumij = sumij + vnlij(i,j,k)
C                sumsqij = sumsqij + vnlij(i,j,k)**2
C              enddo
C            enddo
C            write(IWR,*) '  k,sumii,sqii=',k,sumii,sumsqii
C            write(IWR,*) '  k,sumij,sqij=',k,sumij,sumsqij
C          enddo
C        endif
C        if( lstout.ge.2 )then
C          write(IWR,*)     '  diagonal elements (i,i,k=1):'
C          write(IWR,9400)  (vnlij(i,i,1),i=1,norb)
C 9400     format(1x,1p6d13.4/2x,6d13.4)
C        endif
C        if( lstout.ge.3 )then
C          write(IWR,*)     '  all elements (i,j,k=1):'
C          write(IWR,9400)  ((vnlij(i,j,1),i=1,norb),j=1,norb)
C        endif
Cc       End master-only diagnostic code
C      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NLOCMAT1
c
c
      subroutine NLOCMAT1( IWR,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat  ,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba, znuc,
     $ lmxnlp1,almnnl, ratm, rlat,coskr,sinkr, gntcomb,
     $ nrd,nrad, radmsh,vpsrad, wkrad,
     $ vnlr,vnli,
     $ vnlij,  angsav, vnltp )
c---------------------------------------------------------------
c Purpose: calculate matrix elements due to non-local part of
c          the electron:effective-nuclear-potential interaction
c
c Revision history:
c   7Sep08-PAS/2.62: switch ij-ji to natural order
c  20Jun07-PAS/2.60: merge tp and serial (2oct07: small cosmetic)
c   6Jul06-APT/2.60: merged task parallel and image parallel
c  25Sep04-PAS/tp0.1: clean-up task-parallel routines
c  16Apr03-DMC: Add vnltp to parameter list, to provide a local copy
c               of the vnlij array, for parallelism.
c   2Oct02-PAS/2.54: optimize NLINT, and clean out consequences
c   7Mar02-PAS/2.52: ang constants extracted
c  21Jun01-PAS/2.48: replace STOPs
c  22May01-PAS/2.47: condense radial scratch space
c   6Mar00-PAS/2.43: rename "nl" routines, "ennloc" to "nlocmat"
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  14Sep98-PAS/2.27: cosmetic - naming convention changed
c   5Aug98-PAS/2.24: fix cutoff bug, full proper cutoff scaling
c  21Jul98-PAS/2.23: clean up cutoffs, extend I:N terms
c  22May98-PAS/2.22: bugfix
c  28Apr97-PAS/2.17: naming conventions
c  18Jan94-PAS/2.04: fix nlat, j-indexing bugs; rationalize
c         arguments; full cleanup, match sij,tij,enij,ennloc
c  21Jun89-PAS: extract ANGSET and some of LLOOPS out of under
c               orbital loops, pack angsav
c    May89-PAS: extract RADNLOC out of under angular loops
c---------------------------------------------------------------
c
c  Angular integrals are evaluated analytically
c  Radial integrals are evaluated numerically
c  Allows for non-locality up to l=lmxnlp1(ktyp)-1
c
c  The pseudopotential for atom type ktyp is assumed to fall to
c  zero as exp(-r**2*almnnl(ktyp)).  almnnl(ktyp) here is
c  taken from the fits of Bachelet, et al.
c
c  Because of the nature of the non-local potential, the scaling of
c  the matrix elements is not the same as for the local potential
c  integrals (as the norm of the 3-center overlap gaussian). Getting
c  an effective and efficient cutoff scheme is a bit tricky, and the
c  code implemented in the following reflects this.  The scheme
c  implemented here is overly inclusive. It does incorporate scaling
c  of the magnitude of the matrix element properly, but, at best,
c  takes only partial advantage of the "importance" scaling of the
c  matrix elements, i.e., the density matrix or overlap.  Whether an
c  efficient and effective scheme can be fashioned to incorporate
c  this importance evaluation is left as an exercise for the reader.
c    - 11Aug98-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, half=0.5d0 )
c
c Output array:
      DIMENSION  vnlij(norb,norb,nk)
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp), znuc(ntyp)
      DIMENSION  lmxnlp1(ntyp),almnnl(ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
      DOUBLE COMPLEX    gntcomb(9,5,5,2,9)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp),vpsrad(nrd,4,ntyp)
c Scratch arrays:
      DIMENSION  wkrad(nrd,*)
      DIMENSION  vnlr(nk),vnli(nk)
      DIMENSION  angsav(5*5*5*5*3*81)
c Task-parallel scratch:
      DIMENSION  vnltp(*)
c
c Local declarations:
      LOGICAL    iatmi, diagshl
      LOGICAL    izero(9,9)
      DIMENSION  vnlint(5*5*15),vnltmp(5*5*15)
      DIMENSION  rnuc(3),ri(3),rj(3),risav(3)
c neqlatd in main routine should match this too.
      PARAMETER  ( neqlatd = 72 )
      DIMENSION  aj(9,9),ai(9,9,neqlatd), ilateq(neqlatd)
      DIMENSION  ylmj(2,25),ylmi(2,25,neqlatd)
c
      DIMENSION  vnorm(9)
c lstout sets level of diagnostic output, least:0-5:most
      DATA  lstout / 0 /
c---------------------------------------------------------------
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'SDEV/NLOCMAT1: ijkmat'
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxf = cutgwfn
      emaxsl = cutslow
      emaxii = cutii
      emxslo = MAX( emaxsl, emaxii )
c
      rt4pi = two*rtpi
c
      nmat = nk*norb*norb
c
      mxeqil = 0
      if( lstout.gt.0 ) write(IWR,*) 'NLOCMAT: v-nonlocal diagnostics'
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
      if( nprocs .gt. 0 ) call MKZERO( nmat, vnlij )
c
c    Nucleus loop:
c
      do 3000 nuc=1,natm
c
c     Each processor will do every nprocs element in this loop.
      if( MOD( nuc, nprocs ) .ne. iproc ) goto 3000
c
      ktyp = itypa(nuc)
      if( znuc(ktyp).eq.zero ) goto 3000
c
      lmxp1 = lmxnlp1(ktyp)
      if( lmxp1.lt.1 ) goto 3000
c
      alaminn = almnnl(ktyp)
      lmxnl = lmxp1 - 1
c
c    Nucleus lattice loop:
c
      do 2900 klat=1,nlat
c
      do  ir=1,3
        rnuc(ir) = ratm(ir,nuc) + rlat(ir,klat)
      enddo
c
c     Atom j loop:
c
      jnext = 0
      do 2000 jatm=1,natm
        jtyp = itypa(jatm)
        nshlj = numshl(jtyp)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        do  ir=1,3
          rj(ir) = ratm(ir,jatm) - rnuc(ir)
        enddo
        rjsquar = rj(1)*rj(1) + rj(2)*rj(2) + rj(3)*rj(3)
        rjmag = SQRT( rjsquar )
c
        alaminj = alamin(jtyp)
        emax = emxslo
        rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c       Test overlap of Atom j and short-range pot due to "nuc"
        if( rjsquar.gt.rjnmax ) goto 2000
c
        ljmax = 0
        do  jshl=1,nshlj
          if( lshel(jshl,jtyp).gt.ljmax ) ljmax = lshel(jshl,jtyp)
        enddo
        call AINIT( aj )
        if( rjmag .lt. 1.d-12 )then
          ljmxp1 = 1
          ylmj(1,1) = one / rt4pi
c
        else
          ljmxp1 = ljmax + lmxp1
          call AOFR( aj, rj )
          call YLMREAL( ylmj, ljmax+lmxnl, rj )
c
        endif
c
c       Atom j shell loop:
c
        j = jstart
        do 1800 jshl=1,nshlj
          nalj = nala(jshl,jtyp)
          lshlj = lshel(jshl,jtyp)
          norbshj = 2*lshlj + 1
          lj0 = lshlj*lshlj
c
          j0 = j
c
          alminj = ala(1,jshl,jtyp)
          almaxj = ala(nalj,jshl,jtyp)
          do  jal=1,nalj
            alj = ala(jal,jshl,jtyp)
            if( alj.lt.alminj ) alminj = alj
            if( alj.gt.almaxj ) almaxj = alj
          enddo
          alaminj = alminj
c
          emax = emxslo
          rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c         Test whether this radial function will contribute:
          if( rjsquar.gt.rjnmax ) goto 1799
c
c         Atom i loop:
c
          inext = jstart
          do 1000 iatm=jatm,natm
            ityp = itypa(iatm)
            nshli = numshl(ityp)
            norbati = norba(ityp)
            istart = inext
            inext = istart + norbati
c
c           Following helps ensure only i.ge.j done:
            ishl1 = 1
            if( iatm.eq.jatm )then
              ishl1 = jshl
              do  ishl=1,ishl1-1
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                istart = istart + norbshi
              enddo
            endif
c
            alamini = alamin(ityp)
c
c           Criterion for including contribution of Atom i:
            ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
            rijnmax = (emaxsl-ex)*(alaminj+alamini+alaminn) /
     $                          ( (alaminj+alaminn)*alamini )
            riinmax = (emaxii-ex)*(alaminj+alamini+alaminn) /
     $                          ( (alaminj+alaminn)*alamini )
c
            if( iatm.eq.jatm )then
              emaxij = emaxii
              rijnmx0 = riinmax
            else
              emaxij = emaxsl
              rijnmx0 = rijnmax
            endif
            rinmax = emaxij*(alamini+alaminn) / (alamini*alaminn)
            rinmx1 = rinmax
            rjovlp = rjsquar * ( alaminj / (alaminj+alaminn) )**2
c
            limax = 0
            do  ishl=ishl1,nshli
              if( lshel(ishl,ityp).gt.limax ) limax = lshel(ishl,ityp)
            enddo
c
c           Find nearest iatm image:
            risqnxt = 9.d9
            do 90 ilat=1,nlat2c
              do  ir=1,3
                ri(ir) = ratm(ir,iatm) + rlat(ir,ilat) - rnuc(ir)
              enddo
              risquar = ri(1)*ri(1) + ri(2)*ri(2) + ri(3)*ri(3)
              if( risquar.lt.risqnxt )then
                risqnxt = risquar
                ilatnxt = ilat
              endif
   90       continue
c
c           Lattice vector loop for Atom i:
c
            do 900 ilatx=1,nlat2c
              risquar = risqnxt
              risqnxt = 9.d9
c
c             First test that iatm overlaps nuc ...
              if( risquar.gt.rinmx1 ) goto 1000
c
c              ... and test for 3-center overlap as well:
c               (I align the ri and rj vectors for this test)
              rimag = SQRT( risquar )
              if( risquar.gt.rjovlp )then
                rinmx2 = rijnmx0 * ( (alaminj+alaminn) /
     $           (alaminj+alaminn-alaminj*rjmag/rimag) )**2
                if( risquar.gt.rinmx2 ) goto 1000
              endif
c
c             Align the iatm test vector along the jatm vector
              if( rjmag .gt. 1.d-6 )then
                scale = rimag/rjmag
                do  ir=1,3
                  risav(ir) = scale*rj(ir)
                enddo
              else
                do  ir=1,3
                  risav(ir) = ratm(ir,iatm)+rlat(ir,ilatnxt) - rnuc(ir)
                enddo
              endif
c
              f1 = alaminj / (alaminj+alaminn)
              rijn0 = zero
              do  ir=1,3
                rijn0 = rijn0 + (f1*rj(ir)-risav(ir))**2
              enddo
c
              iatmi = .false.
              ieqlat = 0
              do 190 ilat=1,nlat2c
c
                do  ir=1,3
                  ri(ir) = ratm(ir,iatm) + rlat(ir,ilat) - rnuc(ir)
                enddo
                risqtst = ri(1)*ri(1) + ri(2)*ri(2) + ri(3)*ri(3)
c
c               Compile orientation info of atoms such that risq=risquar
c
                if( risqtst-risquar .gt.  1.d-6 )then
c
c                 This risq is bigger, check if it is next biggest ...
c
                  if( risqtst.lt.risqnxt )then
c                    ... it indeed is, and record it:
                    risqnxt = risqtst
                    ilatnxt = ilat
                  endif
c
                elseif( ABS( risqtst-risquar ) .le. 1.d-6 )then
c
c                 This risq is within current star, process it
c
                  if( ilat.eq.1 .and. iatm.eq.jatm )then
                    iatmi = .true.
                  else
c                   Check tighter cutoff ...
                    if( rijn0.gt.rijnmax ) goto 190
                  endif
c
                  ieqlat = ieqlat + 1
                  if( ieqlat.gt.neqlatd ) goto 190
c
                  ilateq(ieqlat) = ilat
c
                  call AINIT( ai(1,1,ieqlat) )
                  if( risqtst .lt. 1.d-12 )then
                    limxp1 = 1
                    ylmi(1,1,ieqlat) = one / rt4pi
c
                  else
                    limxp1 = limax + lmxp1
                    call AOFR( ai(1,1,ieqlat), ri )
                    call YLMREAL( ylmi(1,1,ieqlat), limax+lmxnl, ri )
c
                  endif
c
                endif
c
  190         continue
c
              if( iatmi )then
                if( rijn0.gt.riinmax ) goto 900
              else
                if( rijn0.gt.rijnmax ) goto 900
              endif
c
c             Check how many atoms in star we picked up
              neqilat = ieqlat
              if( neqilat.gt.mxeqil ) mxeqil = neqilat
              if( neqilat.gt.neqlatd )then
                write(IWR,*) '>>>>> neqilat,neqlatd=',neqilat,neqlatd
                call STOPXERR( 'neqlatd - exceeded in NLOCFRC' )
              endif
              if( neqilat.le.0 ) goto 900
c
c             Find largest l for Atom i with alpha that will contribute:
              ilmax = -1
              do 280 ishl=ishl1,nshli
                nali = nala(ishl,ityp)
                lshli = lshel(ishl,ityp)
c
                almini = ala(1,ishl,ityp)
                almaxi = ala(nali,ishl,ityp)
                do  ial=1,nali
                  ali = ala(ial,ishl,ityp)
                  if( ali.lt.almini ) almini = ali
                  if( ali.gt.almaxi ) almaxi = ali
                enddo
c
                emax = emaxf
                if( almaxi.lt.alfast .and. almaxj.lt.alfast )emax=emaxsl
                if( iatmi ) emax = emaxii
c
                ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
                rijnmx = (emax-ex)*(alaminj+almini+alaminn) /
     $                           ( (alaminj+alaminn)*almini )
                if( rijn0.le.rijnmx )then
                  if( lshli.gt.ilmax ) ilmax = lshli
                endif
  280         continue
c
              if( ilmax.lt.0 ) goto 900
c
              rimag = SQRT( risquar )
c
              maxlj = (lshlj+1)*(lshlj+1)
              maxli = (ilmax+1)*(ilmax+1)
c
c             Carve up space in angsav() for arrays in angset ...
              iangs = 1
c              ... angsav():
              nangs = ljmxp1*limxp1*limxp1*lmxp1*9*9
              igntj = iangs + nangs
c              ... gntci() (complex, allow 4* real space for safety):
              ngntj = 4*(ljmxp1*maxlj*lmxp1*lmxp1)
              ignti = igntj + ngntj
c              ... cgntcj() (also complex):
              ngnti = 4*(limxp1*limxp1*maxli*lmxp1*lmxp1)
c
c             Compute sums of three-j symbols:
              call NLANG( maxlj,maxli,ljmxp1,limxp1,lmxp1,rjmag,rimag,
     $         ylmj,gntcomb,angsav,angsav(igntj),angsav(ignti) )
c
c             Atom i shell loop:
c
              i = istart
              do 800 ishl=ishl1,nshli
                nali = nala(ishl,ityp)
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                li0 = lshli*lshli
c
                i0 = i
c
                diagshl = .false.
                if( i0.eq.j0 ) diagshl = .true.
c
                almini = ala(1,ishl,ityp)
                almaxi = ala(nali,ishl,ityp)
                do  ial=1,nali
                  ali = ala(ial,ishl,ityp)
                  if( ali.lt.almini ) almini = ali
                  if( ali.gt.almaxi ) almaxi = ali
                enddo
c
                emax = emaxf
                if( almaxi.lt.alfast .and. almaxj.lt.alfast )emax=emaxsl
                if( iatmi ) emax = emaxii
c
                lpowmx = lshli + lshlj + 1
                lstmx = lpowmx*lmxp1
                lijmx = limxp1*ljmxp1*lstmx
                do  lij=1,lijmx
                  vnlint(lij) = zero
                enddo
c
c               Alpha loops:
c
                nx = 0
                do 320 jal=1,nalj
                  alj = ala(jal,jshl,jtyp)
c
c                 Test whether this alpha contributes:
                  rjnmx = emax*(alj+alaminn) / (alj*alaminn)
                  if( rjsquar.gt.rjnmx ) goto 320
c
                  fj1 = alj / (alj+alaminn)
                  rijn = zero
                  do  ir=1,3
                    rijn = rijn + (fj1*rj(ir)-risav(ir))**2
                  enddo
c
                  do 310 ial=1,nali
                    ali = ala(ial,ishl,ityp)
c
c                   Test whether this pair of alphas contributes:
                    ex = rjsquar*alj*alaminn / (alj+alaminn)
                    rijnmx = (emax-ex)*(ali+alj+alaminn) /
     $                               ( (alj+alaminn)*ali )
                    if( rijn.gt.rijnmx ) goto 310
c
                    alsum = ali + alj
                    exparg = ali*risquar + alj*rjsquar
                    bargi = two*ali*rimag
                    bargj = two*alj*rjmag
                    bargs = bargi + bargj
c
c                   Evaluate radial integrals
c
                    call NRSCUT( nrmn,nrmx,nrad(ktyp),argmx,
     $               exparg,bargs,alsum,radmsh(1,ktyp), wkrad )
                    nr0 = nrmn - 1
                    nrlen = nrmx - nrmn + 1
c
                    call NLRAD( vnltmp, alsum,bargj,bargi,bargs,
     $               exparg, ljmxp1,limxp1,lmxp1,lstmx,lpowmx,
     $               nrlen,nrd,nr0, radmsh(1,ktyp),vpsrad(1,1,ktyp),
     $               wkrad(1,1), wkrad(1,8), wkrad(1,15),
     $               wkrad(1,22),wkrad(1,23),wkrad(1,24),
     $               wkrad(1,25),wkrad(1,26),wkrad(1,27) )
c
                    fac = cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
                    do  lij=1,lijmx
                      vnlint(lij) = vnlint(lij) + fac*vnltmp(lij)
                    enddo
                    nx = nx + 1
c
c                   Close alpha loops:
  310             continue
  320           continue
c
                if( lstout.gt.3 )then
                  write(IWR,*) '   nuc,iatm,jatm,klat,ilatx,neqilat,nx'
                  write(IWR,9350)  nuc,iatm,jatm,klat,ilatx,neqilat,nx
 9350             format(1x,10i4)
                endif
c
                if( nx.eq.0 ) goto 799
c
c               Angular loops:
c
                mli1 = 1
                do 420 mlj=1,norbshj
                  lj = lj0 + mlj
                  j = j0 + mlj
c
                  if( diagshl ) mli1 = mlj
                  do 410 mli=mli1,norbshi
                    li = li0 + mli
                    i = i0 + mli
c
c                   Evaluate contribution to vnlij(i,j)
c
                    if( neqilat.eq.1 )then
                      call NLINT( vnlr,vnli, vnlint,
     $                 ljmxp1,limxp1,lmxp1,lstmx,lpowmx, rjmag,rimag,
     $                 lj,li, aj(1,lj),ai(1,li,1), ylmi,angsav,
     $                 nk,nlat, coskr,sinkr,
     $                 ilateq(1) )
                    else
c
                      do 405 lmpj=1,lj
                        if( aj(lmpj,lj).eq.zero )then
                          do  lmpi=1,li
                            izero(lmpj,lmpi) = .true.
                          enddo
                        else
                          do 404 lmpi=1,li
                            do  lateqi=1,neqilat
                              if( ai(lmpi,li,lateqi).ne.zero ) goto 403
                            enddo
                            izero(lmpj,lmpi) = .true.
                            goto 404
  403                       continue
                            izero(lmpj,lmpi) = .false.
  404                     continue
                        endif
  405                 continue
c
                      call NLINTEQ( vnlr,vnli, vnlint,
     $                 ljmxp1,limxp1,lmxp1,lstmx,lpowmx, rjmag,rimag,
     $                 lj,li,izero,aj(1,lj),ai,ylmi,angsav,
     $                 nk,nlat, coskr,sinkr,
     $                 neqilat,ilateq, wkrad )
c -->                                  vnltmp(neqilat)-s
                    endif
c
                    fac = one / (vnorm(li)*vnorm(lj))
c
                    do  k=1,nk
                      vnlij(i,j,k) = vnlij(i,j,k) + fac*vnlr(k)
                    enddo
                    if( ncplx.eq.2 .and. i.ne.j )then
                      do  k=1,nk
                        vnlij(j,i,k) = vnlij(j,i,k) + fac*vnli(k)
                      enddo
                    endif
c
                    if( lstout.gt.4 )then
                      write(IWR,*) '      i,j,vnl=',i,j,vnlr(1),vnli(1)
                    endif
c
c                   Close angular loops:
  410             continue
  420           continue
c
  799           continue
c               Close Atom i shell loop:
                i = i0 + norbshi
  800         continue
c
c             Close Atom i lattice loop:
  900       continue
c
c           Close Atom i loop:
 1000     continue
c
 1799     continue
c         Close Atom j shell loop:
          j = j0 + norbshj
 1800   continue
c
c       Close Atom j loop:
 2000 continue
c
c       Close Nucleus lattice loop:
c
 2900 continue
c
c       Close Nucleus loop:
c
 3000 continue
c
c >>>> Reassamble final matrix
c
      if( nprocs .gt. 1 )then
        call TIMER('  nlocmat compute')
c
c       Each local processor has full non-local Hamiltonian over its
c       share of atomic potentials.
c       Reduce (sum) these to master, to get total non-local Ham matrix.
c
        call MPREDUC8( master, nmat, vnlij, vnltp, icomm )
C        call MPI_Reduce( vnlij, vnltp, nmat, MPI_DOUBLE_PRECISION,
C     $   MPI_SUM, master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pnlocmat - Reduce vnlij' )
c
c       Put the matrix into the right place
        call DCOPY( nmat, vnltp,1, vnlij,1 )
c
        call TIMER('  nlocmat Reduce ')
c
c       The final output matrix is only on the master processor
c
      endif
c
c  Dump diagnostics for debugging if wanted:
c
      write(IWR,*) 'NLOCMAT: Max neqilat=',mxeqil
C      if( iproc .eq. master )then
C        if( lstout.gt.0 )then
C          do  k=1,nk
C            sumii = zero
C            sumsqii = zero
C            sumij = zero
C            sumsqij = zero
C            do  i=1,norb
C              sumii = sumii + vnlij(i,i,k)
C              sumsqii = sumsqii + vnlij(i,i,k)**2
C              do  j=1,norb
C                sumij = sumij + vnlij(i,j,k)
C                sumsqij = sumsqij + vnlij(i,j,k)**2
C              enddo
C            enddo
C            write(IWR,*) '  k,sumii,sqii=',k,sumii,sumsqii
C            write(IWR,*) '  k,sumij,sqij=',k,sumij,sumsqij
C          enddo
C        endif
C        if( lstout.ge.2 )then
C          write(IWR,*)     '  diagonal elements (i,i,k=1):'
C          write(IWR,9400)  (vnlij(i,i,1),i=1,norb)
C 9400     format(1x,1p6d13.4/2x,6d13.4)
C        endif
C        if( lstout.ge.3 )then
C          write(IWR,*)     '  all elements (i,j,k=1):'
C          write(IWR,9400)  ((vnlij(i,j,1),i=1,norb),j=1,norb)
C        endif
Cc       End master-only diagnostic code
C      endif
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NLRAD
c
c
      subroutine NLRAD( ven, alsum,bargi,bargj,bargs,
     $ exparg, llmxi,llmxj,lmxp1,lstmx,lpowmx,
     $ nrs,nrd,nr0, radmsh,vpsrad,
     $ bessi,bessj,radfac,w1,w2,w3,w4,w5,w6 )
c---------------------------------------------------------------
c Purpose: radial integrals needed to evaluate matrix elements
c   of non-local short-range part of effective nuclear potential
c
c Revision history:
c  14Mar00-_AS/2.43: rename "radnloc" to "nlrad"
c   7Dec99-PAS/2.42: clean-up loops
c  10Dec98-PAS/2.29: promote source to explicit double precision
c    Aug94-PAS/2.11: cleanup, external underflow control
c    May89-PAS: install optimized bessel function routines
c---------------------------------------------------------------
c
c  Assume vpsrad() contains l-dependent potential times "weight"
c  necessary for numerical quadrature on the radial mesh "radmsh"
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output array:
      DIMENSION  ven(llmxi,llmxj,lstmx)
c input arrays:
      DIMENSION  radmsh(*),vpsrad(nrd,4)
c scratch arrays:
      DIMENSION  bessi(nrs,*),bessj(nrs,*),radfac(nrs,*),
     $   w1(nrs),w2(nrs),w3(nrs),w4(nrs),w5(nrs),w6(nrs)
c local stuff:
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /
c
c >>>> EXECUTABLE CODE:
c
      call MKZERO( llmxi*llmxj*lstmx, ven )
c
      do  nr=1,nrs
        r = radmsh(nr0+nr)
        w2(nr) = r*EXP(-alsum*r**2 + bargs*r - exparg)
      enddo
c
c    Multiply potential by l-independent factors
c
      do  llpot=1,lmxp1
        do  nr=1,nrs
          radfac(nr,llpot) = vpsrad(nr0+nr,llpot)*w2(nr)
        enddo
      enddo
c
c    Compute spherical bessel functions of imaginary argument
c
      if( bargi.gt.zero )then
        call BSIALL( nrs, llmxi, bargi, bessi, radmsh(nr0+1),
     $   w1,w2,w3,w4,w5,w6 )
      else
        do  nr=1,nrs
          bessi(nr,1) = one
        enddo
      endif
c
      if( bargj.gt.zero )then
        call BSIALL( nrs, llmxj, bargj, bessj, radmsh(nr0+1),
     $   w1,w2,w3,w4,w5,w6)
      else
        do  nr=1,nrs
          bessj(nr,1) = one
        enddo
      endif
c
c    Loop on sum of l-primes and lpot
c
      lstore = 0
      do 102 llpot=1,lmxp1
        do 101 lpower=1,lpowmx
          lstore = lstore + 1
          do  nr=1,nrs
            radfac(nr,llpot) = radfac(nr,llpot)*radmsh(nr0+nr)
          enddo
c
          do 92 llj=1,llmxj
            do 91 lli=1,llmxi
              do  nr=1,nrs
                ven(lli,llj,lstore) = ven(lli,llj,lstore) +
     $           radfac(nr,llpot)*bessi(nr,lli)*bessj(nr,llj)
              enddo
   91       continue
   92     continue
c
  101   continue
  102 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NRSCUT
c
c
      subroutine NRSCUT( nrmn,nrmx,nrs,argmx,
     $ exparg,pmag,alsum,radmsh,w1 )
c---------------------------------------------------------------
c Purpose: find nr at which point shtrng exponential underflow
c
c Written: Peter A. Schultz
c
c Revision history:
c  24Sep08-PAS/2.61i: clean tab characters from source
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  radmsh(nrs)
      DIMENSION  w1(nrs)
c
      nrmn = 1
      nrmx = nrs
c
      rn = radmsh(nrs)
      argrn = exparg + alsum*rn*rn - pmag*rn
      if( exparg.lt.argmx .and. argrn.lt.argmx ) RETURN
      argmx2 = argmx - exparg
c
      do  nr=1,nrs
        r = radmsh(nr)
        w1(nr) = alsum*r*r - pmag*r
      enddo
c
      if( argrn.gt.argmx )then
        do 20 nr=nrs,1,-1
          if( w1(nr).lt.argmx2 ) goto 25
          nrmx = nr - 1
   20   continue
        RETURN
   25   continue
      endif
c
      if( exparg.gt.argmx )then
        do 30 nr=1,nrs
          if( w1(nr).lt.argmx2 ) goto 35
          nrmn = nr + 1
   30   continue
        RETURN
   35   continue
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ONECTR
c
c
      subroutine ONECTR( vij1,vradsr1,vij2,vradsr2,vij3,vradsr3,
     $ ipoint,na,lmx1ctr, alsum,p,li,lj,ci,cj )
c---------------------------------------------------------------
c Purpose: generalization of engaus for use with "vofn"
c
c Written: P.J. Feibelman
c
c Revision history:
c  24Sep08-PAS/2.62: change to get rid of compiler warning
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  15May89-PAS: pack vradsr, optimize code
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output arrays:
      DIMENSION  vij1(na),vij2(na),vij3(na)
c input arrays:
      DIMENSION  vradsr1(70,na),vradsr2(70,na),vradsr3(70,na)
      DIMENSION  p(3),ci(10),cj(10)
c local declarations:
      DIMENSION  potcoef(5,5,3,3),npot(3),ntimes(3),bfac(70)
      EQUIVALENCE  (nq(1),nq1),(nqmn(1),nqmn1),(psq(1),psq1)
      COMMON  /nqs/   nq1,nq2,nq3
      COMMON  /nqmns/ nqmn1,nqmn2,nqmn3
      COMMON  /psqs/  psq1,psq2,psq3
      DIMENSION  nq(3),nqmn(3),psq(3)
      DIMENSION  nsx(2)
      EQUIVALENCE  (nsx(1),nsi),(nsx(2),nsj)
      LOGICAL  EVEN
c
      DIMENSION  number(3),lang(10),istart(7)
      DATA  number / 1,4,10 /
      DATA  lang / 0, 1,1,1, 2,2,2,2,2,2 /
      DATA  istart / 1,9,10,18,19,27,28 /
c
      EQUIVALENCE  (bpq,beq)
      DIMENSION  beq(49)
      DIMENSION  ns(9),np(10,3),bpq(7,7),nqmin(7)
      DATA  ns / 1, 2,3,4, 5,6,7,9,10 /
      DATA  np / 0, 1,0,0, 1,0,1,2,0,0,
     $           0, 0,1,0, 1,1,0,0,2,0,
     $           0, 0,0,1, 0,1,1,0,0,2 /
      DATA  bpq / 1.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0,
     $            0.d0, 1.d0, 1.d0, 0.d0, 0.d0, 0.d0, 0.d0,
     $            0.d0, 0.d0, 1.d0, 3.d0, 3.d0, 0.d0, 0.d0,
     $            0.d0, 0.d0, 0.d0, 1.d0, 6.d0,15.d0,15.d0,
     $            0.d0, 0.d0, 0.d0, 0.d0, 1.d0,10.d0,45.d0,
     $            0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.d0,15.d0,
     $            0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.d0 /
      DATA  nqmin / 1,2,2,3,3,4,4 /
c
      DATA  zero,one / 0.d0,1.d0 /
c statement function:
cvax  EVEN(int) = ((int.and.1).eq.0)
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
c  Set potential coefficients ...
c   ... zeroth derivative of potential:
      do  j=1,3
        do  npower=1,5
          potcoef(npower,1,1,j) = one
        enddo
      enddo
      if( lmx1ctr.gt.0 )then
c  ... first derivative of potential:
        alsumt2 = alsum + alsum
        do  j=1,3
          do  npow=1,5
            potcoef(npow,1,2,j) =  DBLE(npow-1)
            potcoef(npow,2,2,j) = p(j)
            potcoef(npow,3,2,j) = -alsumt2
          enddo
        enddo
        if( lmx1ctr.gt.1 )then
c  ... second derivative of potential:
          alsumt4 = alsumt2 + alsumt2
          do  j=1,3
            pj = p(j)
            do  npow=1,5
              potcoef(npow,1,3,j) =  DBLE( MAX( (npow-1)*(npow-2), 0 ) )
              potcoef(npow,2,3,j) = (pj+pj)* DBLE(npow-1)
              potcoef(npow,3,3,j) = pj*pj -  DBLE(npow+npow-1)*alsumt2
              potcoef(npow,4,3,j) = -alsumt4*pj
              potcoef(npow,5,3,j) = alsumt4*alsum
            enddo
          enddo
        endif
      endif
c
      nv = lang(li) + lang(lj) + lmx1ctr + 1
      nqv = nv*number(lmx1ctr+1)
      do  iqv=1,nqv
        bfac(iqv) = zero
      enddo
      p1 = p(1)
      p2 = p(2)
      p3 = p(3)
      psq1 = p1*p1
      psq2 = p2*p2
      psq3 = p3*p3
c
      if( li.le.lj )then
        ki = 1
        kj = 2
        nsimx = ns(li)
        nsjmx = ns(lj)
      else
        ki = 2
        kj = 1
        nsimx = ns(lj)
        nsjmx = ns(li)
      endif
c
      do 102 nsi=1,nsimx
        do 101 nsj=nsi,nsjmx
          if( nsj.ne.nsi .and. nsj.le.nsimx )then
            pr0 = ci(nsi)*cj(nsj) + ci(nsj)*cj(nsi)
          else
            pr0 = ci(nsx(ki))*cj(nsx(kj))
          endif
          if( pr0.eq.zero ) goto 101
c
          npow1 = np(nsi,1) + np(nsj,1) + 1
          npow2 = np(nsi,2) + np(nsj,2) + 1
          npow3 = np(nsi,3) + np(nsj,3) + 1
          iv = -2
          do 90 lpot=1,number(lmx1ctr+1)
            do  j=1,3
              npj = np(lpot,j)
              npot(j) = npj
              ntimes(j) = npj + npj + 1
            enddo
c
            do 80 nt1=1,ntimes(1)
              nq1 = npow1 - 1 - npot(1) + nt1
              if( nq1.lt.1 ) goto 80
              potc1 = potcoef(npow1,nt1,np(lpot,1)+1,1)
              if( potc1.eq.zero ) goto 80
              nqmn1 = nqmin(nq1)
              ist1 = istart(nq1)
              if( EVEN(nq1) ) potc1 = p1*potc1
c
              do 70 nt2=1,ntimes(2)
                nq2 = npow2 - 1 - npot(2) + nt2
                if( nq2.lt.1 ) goto 70
                potc12 = potcoef(npow2,nt2,np(lpot,2)+1,2)
                if( potc12.eq.zero ) goto 70
                potc12 = potc12*potc1
                nqmn2 = nqmin(nq2)
                ist2 = istart(nq2)
                if( EVEN(nq2) ) potc12 = p2*potc12
c
                do 60 nt3=1,ntimes(3)
                  nq3 = npow3 - 1 - npot(3) + nt3
                  if( nq3.lt.1 ) goto 60
                  potc123 = potcoef(npow3,nt3,np(lpot,3)+1,3)
                  if( potc123.eq.zero ) goto 60
                  potc123 = potc123*potc12
                  nqmn3 = nqmin(nq3)
                  ist3 = istart(nq3)
                  if( EVEN(nq3) ) potc123 = p3*potc123
c
                  pr1 = pr0*potc123
                  ix1 = ist1
c     cdir$ novector
                  do 50 iq1=nqmn1,nq1
                    pr12 = pr1
                    ix2 = ist2
                    do 40 iq2=nqmn2,nq2
                      pr123 = pr12
                      do 30 iq3=nqmn3,nq3
                        bfac(iv+iq1+iq2+iq3) = bfac(iv+iq1+iq2+iq3) +
     $                   pr123*beq(ix1)*beq(ix2)*bpq(nq3,iq3)
                        pr123 = pr123*psq3
   30                 continue
                      pr12 = pr12*psq2
                      ix2 = ix2 + 7
   40               continue
                    pr1 = pr1*psq1
                    ix1 = ix1 + 7
   50             continue
c     cdir$ vector
   60           continue
   70         continue
   80       continue
c
            iv = iv + lang(li) + lang(lj) + lang(lpot) + 1
   90     continue
c
  101   continue
  102 continue
c
c      nqv = iv + 2
      do  ia=1,ipoint+1
        sum1 = zero
        sum2 = zero
        sum3 = zero
        do  iqv=1,nqv
          sum1 = sum1 + bfac(iqv)*vradsr1(iqv,ia)
          sum2 = sum2 + bfac(iqv)*vradsr2(iqv,ia)
          sum3 = sum3 + bfac(iqv)*vradsr3(iqv,ia)
        enddo
        vij1(ia) = sum1
        vij2(ia) = sum2
        vij3(ia) = sum3
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> POP
c
c
      subroutine POP( nspin, spindif,
     $ fermilvl, egap,
     $ etemp, elnumbr, esumsp, occfull,
     $ nstate,nk, wtk, eigval,eigpop,numpop,
     $ elvl,wlvl,klvl,nlvl,flvl )
c---------------------------------------------------------------
c Purpose: compute common (across spin) fermi level, up/dn-electrons
c
c Written: Peter A. Schultz, 12-January-2008, for 2.61
c
c Revision history:
c  30Sep08-PAS/2.62i: fix spin/non-spin initialization
c  12Jan08-PAS:2.61: adapted from function of original pop
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER ( zero=0.d0, one=1.d0, two=2.d0 )
c
c Input:
      DIMENSION  wtk(nk), eigval(*)
c Output:
      DIMENSION  eigpop(nstate,*)
c Scratch:
      DIMENSION  elvl(nstate*nk*nspin),klvl(*),nlvl(*)
      DIMENSION  wlvl(*),flvl(*)
c
c Local:
      DIMENSION  elspin(2), bandsum(2), npop(2)
      LOGICAL    xch,pos,neg
      DATA  elcerr,elconv / 1.d-6,1.d-11 /
      DATA  occnil / 1.d-9 /
c
c >>>> EXECUTABLE CODE:
c
      nstk = nstate*nk
      nstall = nstk*nspin
c
c  Sort the eigenstates by eigenvalue across all k-points
c  Do this by treating dn-spin (if I have two spins) as
c  second set of nk points
c
c First, load k-pt weights for sort, doubling nk for spin
c Use flvl as scratch for this.
      iksp = 0
      do  ispin=1,nspin
        do  ik=1,nk
          iksp = iksp + 1
          flvl(iksp) = wtk(ik)
        enddo
      enddo
      nksp = iksp
c
c Sort eigenstates across all k-points, and spin
      call LVLSORT( nstate,nksp, eigval,flvl,
     $ elvl,klvl,nlvl,wlvl )
c
c Initialize occupation factors to zero
      call MKZERO( nstall, flvl )
      call MKZERO( nstall, eigpop )
c
c >>>>> Find the fermi level
c
c Find the highest occupied (0K) orbital
        elnumt = occnil
        do 140 ist=1,nstall
        elnumt = elnumt + wlvl(ist)*occfull
c If no weight, skip level:
        if( wlvl(ist) .gt. zero )then
          if( elnumt .lt. elnumbr ) goto 140
          ihomo = ist
          ehomo = elvl(ihomo)
          goto 141
        endif
  140 continue
 1323 format(1x,a,3f12.6)
      call STOPXERR( 'elecnum - POP electron number' )
  141 continue
c
c Find first safely empty orbital
      ilumo = ihomo + 1
      elumo = ehomo + 40.d0*etemp
      do 150 ist=ihomo+1,nstall
        if( wlvl(ist) .gt. zero )then
          ilumo = ist
          elumo = elvl(ilumo)
          goto 151
        endif
  150 continue
  151 continue
c
c Compute first estimate of fermi level, and 0K gap
      efguess = ( ehomo + elumo ) / two
      gap = elumo - ehomo
      if( (elnumt-occnil) .gt. (elnumbr+occnil) )then
c       partially occupied 0K orbital -> gap=0
        gap = zero
      endif
      egap = gap
c
c Find average level spacing around fermi level
      de = ( elumo - ehomo ) / 4.d0
      if( de .lt. 10.d0*etemp ) de = 10.d0*etemp
c
c Find correct fermi level by interval halving
c
      itmax = 50
      pos = .false.
      neg = .false.
c
      do 200 itfermi=1,itmax
c
c       Compute electron counts for this temp/fermi level
        call FERMIPOP( efguess,etemp, elnumt, nstall,nstpop,
     $   occfull, flvl,elvl,wlvl )
c
c       Check if we have converged a fermi level (or close enough)
c        Look at total electron count ...
        elmiss = elnumt - elnumbr
        if( ABS( elmiss ) .lt. elconv ) goto 300
        if( itfermi .eq. itmax .and.
     $      ABS( elmiss ) .lt. elcerr ) goto 300
c
c       Adjust fermi level by interval halving
        if( elmiss .lt. zero )then
          neg = .true.
          if( pos .and. neg ) de = de / two
          efguess = efguess + de
        else
          pos = .true.
          if( pos .and. neg ) de = de / two
          efguess = efguess - de
        endif
c
  200 continue
      call STOPXERR( 'SPINfermi/ efermi not found' )
c
c >>>>> Fermi energy converged
c
  300 continue
      fermilvl = efguess
c
      do  ispin=1,2
        npop(ispin) = 0
        bandsum(ispin) = zero
        elspin(ispin) = zero
      enddo
c
c Count up number of electrons in each spin, with this fermi level
      do 310 ist=1,nstpop
        n = nlvl(ist)
        k = klvl(ist)
        if( flvl(ist) .eq. zero ) goto 311
c
        eigpop(n,k) = flvl(ist)
        elst = wlvl(ist)*flvl(ist)
        enst = elst*elvl(ist)
        if( k .gt. nk )then
c         dn-spin electrons
          elspin(2) = elspin(2) + elst
          bandsum(2) = bandsum(2) + enst
          if( nlvl(ist) .gt. npop(2) ) npop(2) = nlvl(ist)
        else
c         up-spin electrons
          elspin(1) = elspin(1) + elst
          bandsum(1) = bandsum(1) + enst
          if( nlvl(ist) .gt. npop(1) ) npop(1) = nlvl(ist)
        endif
  310 continue
  311 continue
c
      numpop = MAX( npop(1), npop(2) )
      esumsp = bandsum(1) + bandsum(2)
      spindif = elspin(1) - elspin(2)
c
c    That's all, Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LVLSORT
c
c
      subroutine LVLSORT( nstate,nk,
     $ eigval, wtk,
     $ elvl,klvl,nlvl,wlvl )
c---------------------------------------------------------------
c Purpose: sort of full eigenspectrum over multiple k-points
c
c Written: Peter A. Schultz, 10-January-2008
c
c Revision history:
c  none
c---------------------------------------------------------------
c Notes on this eigenstate sorting scheme:
c   I know that states within each k-point are already sorted
c   I will use this knowledge to optimize this sort
c   (1a) Initialize global sort with the lowest state from each k-point
c   (1b) Sort those nk states within that buffer by energy, tracking n,k
c   (2) Accept the lowest state in that active buffer into next position
c       in global sorted list, bumping active sort buffer up one.
c   (3) Take the next-highest state (if there are any more) in
c       the k-set corresponding to the state just accepted,
c       insert it into the correct location in the active buffer.
c       Start from the top in this small sort, as the new state is
c       likely to be close to the end.
c   (4) Return to (2), until all states have been ranked
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
      DIMENSION  eigval(nstate,nk)
      DIMENSION  wtk(nk)
c Output:
      DIMENSION  elvl(nstate*nk),klvl(*),nlvl(*),wlvl(*)
c
c Local:
      LOGICAL    xch
c
c >>>> EXECUTABLE CODE:
c
      nlevels = nstate*nk
c
c Load bottom state in each k into sort buffer
      lvls = 0
      do  ik=1,nk
        lvls = lvls + 1
        elvl(lvls) = eigval(1,ik)
        klvl(lvls) = ik
        nlvl(lvls) = 1
      enddo
c
c Sort these with a simple pair exchange (k is never huge)
  100 continue
      xch = .false.
      do  jlvl=1,lvls-1
        if( elvl(jlvl).gt.elvl(jlvl+1) )then
c         Move this state upwards
          ekj = elvl(jlvl)
          elvl(jlvl) = elvl(jlvl+1)
          elvl(jlvl+1) = ekj
          kkj = klvl(jlvl)
          klvl(jlvl) = klvl(jlvl+1)
          klvl(jlvl+1) = kkj
c         These nlvl() are all the first state, exchange is redundant
          xch = .true.
        endif
      enddo
      if( xch ) goto 100
c
c Now sort through the remainder of the states
c
      ilvl = 1
c
  200 continue
c
c The state ilvl is lowest in active sort buffer (lowest-energy state
c from each k-point), and thereby guaranteed to be next lowest in
c global sort:
      kprev = klvl(ilvl)
      nprev = nlvl(ilvl)
      ilvl = ilvl + 1
c Insert next higher state from that k-pt into active set (if exists):
      if( nprev .lt. nstate )then
        lvls = lvls + 1
c       Rank eigval from next state in this k-pt in active sort buffer
        ekn = eigval(nprev+1,kprev)
        lvlnew = ilvl
        do 210 jlvl=lvls,ilvl+1,-1
          if( ekn .lt. elvl(jlvl-1) )then
            elvl(jlvl) = elvl(jlvl-1)
            klvl(jlvl) = klvl(jlvl-1)
            nlvl(jlvl) = nlvl(jlvl-1)
          else
            lvlnew = jlvl
            goto 211
          endif
  210   continue
  211   continue
        elvl(lvlnew) = ekn
        klvl(lvlnew) = kprev
        nlvl(lvlnew) = nprev + 1
      endif
c
c If not all levels ranked, go sort some more
      if( lvls .lt. nlevels ) goto 200
c
c Done sorting, associate states with correct k-sample weighting factors:
      do  ilvl=1,nlevels
        k = klvl(ilvl)
        wlvl(ilvl) = wtk(k)
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> POP1K
c
c
      subroutine POP1K( closeshl,
     $ fermilvl,gap, ehomo,elumo,
     $ etemp,edegen, elnumbr,occfull,
     $ nstate,numpop, wtocc,
     $ eigval,eigpop, wlvl )
c---------------------------------------------------------------
c Purpose: construct level populations for eigenstates,
c          with option to impose 0K (closed shell) occupancies,
c          with proper treatment of degeneracies.
c
c Written: Peter A. Schultz, 20-February-2005, for v2.59
c          (extracted from real solver, and expanded)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0 )
c
c Input:
      LOGICAL    closeshl, doblas3
      DIMENSION  eigval(nstate)
c Output:
      DIMENSION  eigpop(nstate)
c Scratch arrays:
      DIMENSION  wlvl(nstate)
c
c Local:
      LOGICAL    pos,neg,closed
c  elconv=difference criterion for convergence of electron count
c  elcerr=worst tolerated error in electron count
      DATA  elconv,elcerr / 1.d-11,1.d-6 /
c  occnil=small number to make arithmetic safe for level occ manipulation
      DATA  occnil / 1.d-9 /
c  itmax=maximum number of iterations for fermi level finding:
      DATA  itmax / 50 /
c
c >>>> EXECUTABLE CODE:
c
c Clear out occupancy levels:
      numpop = 0
      call MKZERO( nstate, eigpop )
      if( elnumbr .le. zero )then
        elumo = eigval(1)
        ehomo = elumo
        fermilvl = ehomo
        gap = -one
        numpop = 0
        goto 900
      endif
c
c  Compute number of 0K occupied levels:
      nocc0k = ( elnumbr + occfull - occnil ) / occfull
      elfull = occfull*DBLE( nocc0k )
      elpart = ABS( elfull - elnumbr )
      nstfull = nocc0k
      if( elpart .gt. occnil ) nstfull = nocc0k - 1
c
      ihomo = nocc0k
      ehomo = eigval(ihomo)
c  Default fermi level to highest occupied state:
      elumo = ehomo
      fermilvl = ehomo
c
c Number of degenerate states at top, default to non-degen:
      ndegen = 1
c
      if( nstate .eq. nocc0k )then
c       Have only the occupied states, no unoccupied states
        closed = .true.
        if( elpart .gt. occnil )then
          gap = zero
        else
          gap = -one
        endif
c
      elseif( nstate .gt. nocc0k )then
c       Have empty states - can compute a gap
        closed = .false.
        ilumo = ihomo + 1
        elumo = eigval(ilumo)
        gap = elumo - ehomo
        fermilvl = (ehomo + elumo) / two
        if( closeshl )then
c         Impose closed shell (0K) occups, while checking for degens
          closed = .true.
c         I will allow for 5-fold degeneracy at most
c         Check 4 levels above homo for degeneracy with homo:
          itop = ihomo + 4
          itop = MIN( itop, nstate )
          do  ilvl=ihomo+1,itop
            eigi = eigval(ilvl)
            if( ABS( eigi-ehomo ) .lt. edegen )then
c             Add to degeneracy, and to 0K occup list
              ndegen = ndegen + 1
              if( nstfull.eq.ihomo ) nstfull = nstfull - 1
              nocc0k = nocc0k + 1
            endif
          enddo
c         If we have a degeneracy or partial occupancy, need
c         to check below to see if degeneracy extends deeper:
          if( ndegen .gt. 1 .or. elpart.gt.occnil )then
            nhomo = ihomo - (5-ndegen)
            do  ilvl=ihomo-1,nhomo,-1
              eigi = eigval(ilvl)
              if( ABS( eigi-ehomo ) .lt. edegen )then
c               Add to degeneracy, remove from full list
                ndegen = ndegen + 1
                nstfull = nstfull - 1
              endif
            enddo
          endif
        else
c         Determine if we have a closed shell system
          if( elpart .lt. occnil .and. gap .gt. 19*etemp )then
c           Closed shell anyway
            closed = .true.
          else
c           Will have partially occupied orbitals
            closed = .false.
            if( elpart .ge. occnil )then
              gap = zero
              fermilvl = ehomo
            endif
          endif
        endif
c
      endif
c
c Do 0K occupancies if we have closed shell system
c
      if( closed )then
        numpop = nocc0k
        do  ilvl=1,nstfull
          eigpop(ilvl) = occfull
        enddo
        if( ndegen .gt. 1 )then
          eldegen = elnumbr - occfull*DBLE( nstfull )
          occdegen = eldegen / DBLE( ndegen )
          do  ilvl=nstfull+1,nstfull+ndegen
            eigpop(ilvl) = occdegen
          enddo
        elseif( elpart .gt. occnil )then
c         Top level is only partially occupied
          eigpop(nocc0k) = elpart
        endif
c       Skip the fermi level determination
        goto 900
      endif
c
c Find average level spacing around fermi level
      de = ( elumo - ehomo ) / 4.d0
      if( de .lt.  5.d0*etemp ) de =  5.d0*etemp
c
c Find correct fermi level by interval halving
c
c     Set up weighting functions for electron counting:
      do  ilvl=1,nstate
        wlvl(ilvl) = one
      enddo
c
      pos = .false.
      neg = .false.
c
      do 200 itfermi=1,itmax
c       Compute electron counts for this temp and fermi level
        call FERMIPOP( fermilvl,etemp, elsum, nstate,numpop,
     $   occfull, eigpop, eigval, wlvl )
c
c       Check if we have good electron total (or close enough)
        elnumt = elsum*wtocc
        elmiss = elnumt - elnumbr
        if( ABS( elmiss ) .lt. elconv ) goto 900
        if( itfermi .eq. itmax .and.
     $      ABS( elmiss ) .lt. elcerr ) goto 900
c
c       Adjust fermi level by interval halving
        if( elmiss .lt. zero )then
          neg = .true.
          if( pos .and. neg ) de = de / two
          fermilvl = fermilvl + de
        else
          pos = .true.
          if( pos .and. neg ) de = de / two
          fermilvl = fermilvl - de
        endif
c       Go try this new fermi level
  200 continue
      call STOPXERR( 'efermirl/erlsolv efermi conv' )
c
c >>>>> Fermi energy converged
c
  900 continue
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> POPCLOSE
c
c
      subroutine POPCLOSE( icloseocc,dokdefct,ikdefct,
     $ efermi,egap, nstbulk,
     $ etemp,edegen, elnumbr,esumsp, occfull,
     $ nstate,nk, wtk, eigval,eigpop,npop,
     $ wlvl )
c---------------------------------------------------------------
c Purpose: set level populations using closed shell, and defect
c          sampling (gamma pt defect level)
c
c Written: Peter A. Schultz, 16-February-2005, for v2.59 code
c
c Revision history:
c  17Oct08-PAS/2.62: fix esumsp, installing proper wtk()
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER ( zero=0.d0, one=1.d0 )
c
c Input:
      LOGICAL    dokdefct
      DIMENSION  wtk(nk), eigval(nstate,nk)
c Output:
      DIMENSION  eigpop(nstate,nk)
c Scratch:
      DIMENSION  wlvl(*)
c
c Local:
      LOGICAL    closeshl
c
c >>>> EXECUTABLE CODE:
c
c Clear out occupancy levels:
      do  ik=1,nk
        call MKZERO( nstate, eigpop(1,ik) )
      enddo
c
c If we have no electrons, skip everything
      if( elnumbr .le. zero )then
        npop = 0
        esumsp = 0
        gap = -one
        efermi = eigval(1,1)
        goto 900
      endif
c
c Now go over each k-point and populate with
c a fixed number of electrons in each:
c
c First, check if doing defect calculation, in
c which case will populate only bulk (non-defect)
c states in the following:
      elbulk = elnumbr
      if( dokdefct ) elbulk = occfull*nstbulk
c
c Second, set closed shell flag if to do 0K occupations
      closeshl = .false.
      if( icloseocc .eq. 2 ) closeshl = .true.
      npop = 0
      do 1000 ik=1,nk
c       Use wt of one - to get closed-shell e-count
        eltot1k = elbulk
        wtocc = one
c
        call POP1K( closeshl,
     $   fermilvl,gap1k, ehomo1k,elumo1k,
     $   etemp,edegen, eltot1k,occfull,
     $   nstate,npop1k, wtocc,
     $   eigval(1,ik),eigpop(1,ik), wlvl )
c
        npop = MAX( npop, npop1k )
        if( ik.eq.1 )then
          efermi = fermilvl
          ehomo = ehomo1k
          elumo = elumo1k
        else
          efermi = MAX( efermi, fermilvl )
          ehomo = MAX( ehomo, ehomo1k )
          elumo = MIN( elumo, elumo1k )
        endif
 1000 continue
      egap = elumo - ehomo
c
c If we are doing a defect-sampling calculation,
c need to go back and put the defect electrons into
c the defect states at the defect k-point (presumably
c the gamma point):
      if( dokdefct )then
        if( npop .ne. nstbulk )then
cxxx:start
cxxx      New feature - dump added diagnostic if fails.
          call FLGETIWR( IWR )
          write(IWR,*) 'ERROR/POPCL: npop, nstbulk=',npop,nstbulk
          write(IWR,*) 'POPCL: levels(-3/+5) and occups near Ef:'
  913     format( 1x,i4,5(1x,f10.4,f7.3) )
          do  i=nstbulk-3,nstbulk+5
            write(IWR,913)  i, (eigval(i,ik),eigpop(i,ik), ik=1,nk)
          enddo
cxxx:end
          call STOPXERR( 'defect state is in the VB' )
        endif
c
        ikdef = IABS( ikdefct )
        if( ikdefct .lt. 0 )then
c         k-point outside of special point sample, blank bulk occs
          do  ilvl=1,nstbulk
            eigpop(ilvl,ikdef) = zero
          enddo
        endif
c
c       Occupy the defect state(s):
c        ... nstumo=number of available states above bulk states
        nstumo = nstate - nstbulk
c        ... eldefct=number of defect electrons
        eldefct = elnumbr - occfull*DBLE( nstbulk )
c        ... rescale "full" to get total electron count right
        if(  wtk(ikdef).le.zero ) call STOPXERR( 'wt(kdefct)=0' )
        eldef = eldefct / wtk(ikdef)
        fulldef = occfull / wtk(ikdef)
        wtdef = one
        ilvldef = nstbulk + 1
        call POP1K( closeshl,
     $   fermidef,gapdef, ehomodef,elumodef,
     $   etemp,edegen, eldef  ,fulldef,
     $   nstumo,npopdef, wtdef,
     $   eigval(ilvldef,ikdef),eigpop(ilvldef,ikdef), wlvl )
c
        npop = npop + npopdef
        efermi = fermidef
        egap = elumodef - ehomo
      endif
c
c Sum occupation-weighted eigenvalues to get "band energy" sum:
c
      esumsp = zero
      do  ik=1,nk
        esum1k = zero
        wtki = wtk(ik)
        do  ilvl=1,npop
          esum1k= esum1k + wtki*eigpop(ilvl,ik)*eigval(ilvl,ik)
        enddo
        esumsp = esumsp + esum1k
      enddo
c
  900 continue
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> POTNEAR
c
c
      subroutine POTNEAR( nearopt, natm,
     $ ratm,hh,rprim, mxwk,n1r,n2r,n3r,nptr, nearatm,
     $ vslnear,vesnear,excnear,
     $ vslo,vesslo,excslo, wtnr )
c---------------------------------------------------------------
c Purpose: construct values of grid potentials "nearby" atoms
c
c Written: Peter A. Schultz, 27-August-1993
c
c Revision history:
c  10Feb12-PAS/2.63: cut unused args, dignostic write, renamed nearest
c  14Jun05-PAS/2.59: File units
c  21Jul01-PAS/2.49: spin polarized calculations
c  28Jul98-PAS/2.37: altered diagnostics
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Apr97-PAS/2.17: naming conventions
c   8Jun94-PAS
c---------------------------------------------------------------
c Notes:
c   Code to do weighted sampling is ugly because need to account
c   for cases where nearby region overlaps more than one uc, in
c   arbitrary directions, and nearatm point is near an atom image
c   rather than atom.  Because of this, gaussian weighting is not
c   expensive.  Except for pathological mesh vectors, scheme should
c   not underflow, while giving a good sampling of nearby region.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  nearatm(3,natm), ratm(3,natm),hh(3,3),rprim(3,3)
      DIMENSION  vslo(n1r,n2r,n3r),vesslo(n1r,n2r,n3r)
      DIMENSION  excslo(n1r,n2r,n3r)
c output arrays:
      DIMENSION  vslnear(natm),vesnear(*),excnear(*)
c scratch arrays:
      DIMENSION  wtnr(*)
c local declarations:
      DIMENSION  nprim(3), nrng(3),nnr(3),nruc(3),nrst(3),nrnd(3)
      DIMENSION  rnr(3),rtmp(3),rat(3), gg(3,3)
      DATA  lstout / 0 /
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      call FLGETIWR( IWR )
c
      nprim(1) = n1r
      nprim(2) = n2r
      nprim(3) = n3r
      if( lstout.gt.0 )then
        write(IWR,900)
        if( lstout .gt. 2 ) write(IWR,901)
      endif
  900 format(/1x,'POTNEAR: nearby values of grid potentials')
  901 format(2x,'NEAR',' iatm',  8x,'vtot',11x,'ves',12x,'exc')
  902 format(2x,'NEAR',i4,       4(1x,f14.8) )
c
c  Set up ranges for nearby stuff:
c
      call CROSS( hh(1,1),hh(1,2), gg(1,3) )
      call CROSS( hh(1,2),hh(1,3), gg(1,1) )
      call CROSS( hh(1,3),hh(1,1), gg(1,2) )
      g1mag = SQRT( gg(1,1)**2 + gg(2,1)**2 + gg(3,1)**2 )
      g2mag = SQRT( gg(1,2)**2 + gg(2,2)**2 + gg(3,2)**2 )
      g3mag = SQRT( gg(1,3)**2 + gg(2,3)**2 + gg(3,3)**2 )
      do  ir=1,3
        gg(ir,1) = gg(ir,1)/g1mag
        gg(ir,2) = gg(ir,2)/g2mag
        gg(ir,3) = gg(ir,3)/g3mag
      enddo
      r1eff = ABS( hh(1,1)*gg(1,1) + hh(2,1)*gg(2,1) + hh(3,1)*gg(3,1) )
      r2eff = ABS( hh(1,2)*gg(1,2) + hh(2,2)*gg(2,2) + hh(3,2)*gg(3,2) )
      r3eff = ABS( hh(1,3)*gg(1,3) + hh(2,3)*gg(2,3) + hh(3,3)*gg(3,3) )
c
c     DEFAULT IS SET ALL NEARBY VALUES TO ZERO:
      do  iatm=1,natm
        vslnear(iatm) = zero
        vesnear(iatm) = zero
        excnear(iatm) = zero
      enddo
c
      if( nearopt.gt.0 )then
c
c       TAKE VALUES AT POINT NEAREST TO EACH ATOM:
        do  iatm=1,natm
          n1a = nearatm(1,iatm)
          n2a = nearatm(2,iatm)
          n3a = nearatm(3,iatm)
          vslnear(iatm) = vslo(n1a,n2a,n3a)
          vesnear(iatm) = vesslo(n1a,n2a,n3a)
          excnear(iatm) = excslo(n1a,n2a,n3a)
        enddo
c
        if( lstout.gt.2 )then
          write(IWR,*) 'values at nearby points:'
          do 30 iatm=1,natm
            write(IWR,902)  iatm, vslnear(iatm),vesnear(iatm),
     $       excnear(iatm)
   30     continue
        endif
c
        if( nearopt.eq.2 )then
c
          if( lstout.gt.0 )
     $     write(IWR,*) 'Using weighted sampling for NEARby values'
c        [NB: code in "grid0xc" and "potnear" must match]
c
c  nearby sampling function parameters:
          alfsmpl = 1.2d0
          rsampl  = 1.75d0
c
c  Determine range in grid point dimensions for nearby sampling:
          rng1 = (rsampl/r1eff + 0.5d0)
          rng2 = (rsampl/r2eff + 0.5d0)
          rng3 = (rsampl/r3eff + 0.5d0)
          nrng(1) = rng1
          nrng(2) = rng2
          nrng(3) = rng3
          nnr(1) = 2*nrng(1) + 1
          nnr(2) = 2*nrng(2) + 1
          nnr(3) = 2*nrng(3) + 1
          nsampl = nnr(1)*nnr(2)*nnr(3)
c
          if( nsampl.gt.mxwk .or. lstout.gt.1 )then
c           Have a problem, let us diagnose it
            write(IWR,'(a,1x,3f8.2,1x,3i5,1x,2i12)') 'NEARATM RNG=',
     $         rng1,rng2,rng3, (nnr(i),i=1,3), nsampl,mxwk
          endif
c
c
          if( nsampl.le.mxwk )then
c
            do 500 iatm=1,natm
              rsqnr = zero
              do  i=1,3
                rat(i) = ratm(i,iatm)
                rnr(i) = zero
                do  iprim=1,3
                  rnr(i) = rnr(i) + (nearatm(iprim,iatm)-1)*hh(i,iprim)
                enddo
                rsqnr = rsqnr + (rnr(i)-rat(i))*(rnr(i)-rat(i))
              enddo
c check that have atom image nearatm "nearatm" point
              do 123 iuc3=-1,1
                do 122 iuc2=-1,1
                  do 121 iuc1=-1,1
                    do  i=1,3
                      rtmp(i) = rnr(i) - ratm(i,iatm) - iuc1*rprim(i,1)
     $                              - iuc2*rprim(i,2) - iuc3*rprim(i,3)
                    enddo
                    rsqnr2 = rtmp(1)**2 + rtmp(2)**2 + rtmp(3)**2
                    if( rsqnr2.lt.rsqnr )then
                      do  i=1,3
                        rat(i) = rnr(i) - rtmp(i)
                      enddo
                      rsqnr = rsqnr2
                    endif
  121             continue
  122           continue
  123         continue
              rn = SQRT(rsqnr)
c
c Check if point is far enough away from atom to maybe be not nearatm
              if( rn.gt.SQRT(r1eff**2+r2eff**2+r3eff**2)/1.99d0 )then
                write(IWR,*) '**** WARNING: POTNEAR weighting suspect'
                write(IWR,*)   'weighted nearby, atom#',iatm
                write(IWR,913) 'r(iatm)   = ',(ratm(i,iatm),i=1,3)
                write(IWR,913) 'r,shifted = ',(rat(i),i=1,3)
                write(IWR,913) 'nearby pt = ',(rnr(i),i=1,3)
  913           format(1x,a,2x,3f12.6)
              endif
c
              do  i=1,3
                rnr(i) = rnr(i) - rat(i)
                do  iprim=1,3
                  rnr(i) = rnr(i) - DBLE(nrng(iprim))*hh(i,iprim)
                enddo
              enddo
              wtsum = zero
              do  ir=1,nsampl
                wtnr(ir) = zero
              enddo
              call MKNRWT( alfsmpl,wtsum,rnr,hh,nnr,nnr(2),nnr(3),wtnr )
              do  iprim=1,3
                nrst(iprim) = nearatm(iprim,iatm) - nrng(iprim)
                if( nrst(iprim).lt.1 )then
                  nv = -nrst(iprim) + nprim(iprim)
                  nv = nv/nprim(iprim)
                  nrst(iprim) = nrst(iprim) + nv*nprim(iprim)
                elseif( nrst(iprim).gt.nprim(iprim) )then
                  nv = (nrst(iprim) + 1)/nprim(iprim)
                  nrst(iprim) = nrst(iprim) - nv*nprim(iprim)
                endif
                nlast = nrst(iprim) + nnr(iprim) - 1
                nruc(iprim) = (nlast-1)/nprim(iprim) + 1
                nrnd(iprim) = nlast - (nruc(iprim)-1)*nprim(iprim)
              enddo
              wts = zero
              vslnr = zero
              vesnr = zero
              excnr = zero
              j3st = 0
              i3st = nrst(3)
              i3nd = n3r
              jtot = 0
              do 333 iuc3=1,nruc(3)
                if( iuc3.eq.nruc(3) ) i3nd = nrnd(3)
                i2st = nrst(2)
                i2nd = n2r
                j2st = j3st
                do 332 iuc2=1,nruc(2)
                  if( iuc2.eq.nruc(2) ) i2nd = nrnd(2)
                  i1st = nrst(1)
                  i1nd = n1r
                  j1st = j2st
                  do 331 iuc1=1,nruc(1)
                    if( iuc1.eq.nruc(1) ) i1nd = nrnd(1)
c
                    jr00 = j1st
                    do 233 i3=i3st,i3nd
                      jr0 = jr00
                      do 232 i2=i2st,i2nd
                        jr = jr0
                        do 231 i1=i1st,i1nd
                          jtot = jtot + 1
                          jr = jr + 1
                          wts = wts + wtnr(jr)
                          vslnr = vslnr + wtnr(jr)*vslo(i1,i2,i3)
                          vesnr = vesnr + wtnr(jr)*vesslo(i1,i2,i3)
                          excnr = excnr + wtnr(jr)*excslo(i1,i2,i3)
  231                   continue
                        jr0 = jr0 + nnr(1)
  232                 continue
                      jr00 = jr00 + nnr(1)*nnr(2)
  233               continue
c
                    j1st = j1st + (i1nd-i1st+1)
                    i1st = 1
  331             continue
                  j2st = j2st + (i2nd-i2st+1)*nnr(1)
                  i2st = 1
  332           continue
                j3st = j3st + (i3nd-i3st+1)*nnr(1)*nnr(2)
                i3st = 1
  333         continue
c
              if( lstout.gt.3 )write(IWR,*)' wtsum,wts=',wtsum,jtot,wts
              vslnear(iatm) = vslnr/wtsum
              vesnear(iatm) = vesnr/wtsum
              excnear(iatm) = excnr/wtsum
c
  500       continue
c           Close nearopt=2, weighting option
          else
            write(IWR,*) '***** ERROR: weighted sampling not done'
            write(IWR,*) '>>>>> nearby option changed from 2 to 1'
            nearopt = 1
          endif
        endif
c       Close non-zero nearby section
      endif
c
      if( lstout.gt.2 .and. nearopt.ne.1 )then
        do  iatm=1,natm
          write(IWR,902)  iatm, vslnear(iatm),vesnear(iatm),
     $     excnear(iatm)
        enddo
      endif
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> POTNR0
c
c
      subroutine POTNR0( IWR, do_gga, xcnrat,
     $ xcalcut,xcfac,xcrhocut,
     $ natm,ntyp,nshld,nald, nlat  , nptr,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ znuc,occsh,  nrd,nrcor,radmsh,corden, y2, u,  ratm,rlat, nearest,
     $ hh, wkr, mxwkrd )
c---------------------------------------------------------------
c Purpose: Compute "nearby" potentials for grid reference atoms
c
c Written: Peter A. Schultz,  9-December-2000, for v2.46 (gga)
c
c Revision history:
c  11Jun03-PAS/2.55: change DFTGGA arguments
c   8Apr02-PAS/2.53: gga stress
c   7Mar02-PAS/2.52: explicit constants to d0
c  15Aug01-PAS/2.48b: bugfix!!!! (gga/array not initialized)
c  21Jun01-PAS/2.48: replace STOPs
c   9Dec00-PAS/2.46: split off from grid0xc
c---------------------------------------------------------------
c
c Notes:
c  This routine should exactly reproduce the computation of the
c  potentials done in "grid0xc".  The distinction here is that all
c  we care about is a weighted sampling of the nearby potential,
c  for use in refining a correction term to the xc-energy to fix
c  inaccuracies in the grid integrals.  I separate this code (just
c  as I separated "eslofrc", the near-copy of "grid0xc" to used to
c  compute the phantom force) for clarity in coding, and to ease
c  complexity in memory management in "grid0xc".  I judge it
c  simpler to duplicate the computational task and code, than to
c  code in "grid0xc" the logic of how to manage memory and squeeze
c  the weighting operation into boxes.  This way, this weighting
c  operation can more cleanly be matched to that used in "potnear".
c
c  *** NB ***  Code is kept as close to that used in "grid0xc"
c  as possible, even when such code locally here seems redundant
c  or non-conforming, to ease later changes where common code
c  betweeen "grid0xc", "eslofrc", and "potnr0" is altered.
c  Changes to these routines should only be done in tandem.
c
c  The use of cutoffs in this routine should be compatible
c  with that used in calculating the grid wave functions.
c
c  The code for the nearby average must match that used in "potnear".
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c output array:
      DIMENSION  xcnrat(4,natm)
c input arrays:
      LOGICAL    do_gga
      DIMENSION  itypa(natm)
      DIMENSION  numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $  nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  znuc(ntyp)
      DIMENSION  occsh(nshld,ntyp)
      DIMENSION  nrcor(ntyp),radmsh(nrd,*),corden(nrd,*)
      DIMENSION  ratm(3,natm),rlat(3,*), hh(3,3)
      DIMENSION  nearest(3,*)
c scratch arrays:
      DIMENSION  y2(*),u(*)
      DIMENSION  wkr(*)
c
c local declarations:
      DIMENSION  rnr(3), r0(3),rr1(3),rr2(3),rr3(3), gg(3,3)
      DIMENSION  nrng(3),nnr(3)
c
c  nearby sampling function parameters:
      DATA  alfsmpl,rsampl / 1.2d0,1.75d0 /
      DATA  alcutfac / 1.33333333d0 /
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
      DATA  three / 3.d0 /
c flag for additional output 0-none/1-some/2-full
      DATA  lstout  / 0 /
c
c >>>> EXECUTABLE CODE:
c
      if( lstout.gt.0 ) write(IWR,*) 'POTNR0: grid reference nearby'
      fourpi = pi + pi + pi + pi
c
c  Set up ranges for nearby stuff:
c
      call CROSS( hh(1,1),hh(1,2), gg(1,3) )
      call CROSS( hh(1,2),hh(1,3), gg(1,1) )
      call CROSS( hh(1,3),hh(1,1), gg(1,2) )
      g1mag = SQRT( gg(1,1)**2 + gg(2,1)**2 + gg(3,1)**2 )
      g2mag = SQRT( gg(1,2)**2 + gg(2,2)**2 + gg(3,2)**2 )
      g3mag = SQRT( gg(1,3)**2 + gg(2,3)**2 + gg(3,3)**2 )
      do  ir=1,3
        gg(ir,1) = gg(ir,1)/g1mag
        gg(ir,2) = gg(ir,2)/g2mag
        gg(ir,3) = gg(ir,3)/g3mag
      enddo
      r1eff = ABS( hh(1,1)*gg(1,1) + hh(2,1)*gg(2,1) + hh(3,1)*gg(3,1) )
      r2eff = ABS( hh(1,2)*gg(1,2) + hh(2,2)*gg(2,2) + hh(3,2)*gg(3,2) )
      r3eff = ABS( hh(1,3)*gg(1,3) + hh(2,3)*gg(2,3) + hh(3,3)*gg(3,3) )
c
c  Clear out output array of nearby potentials:
c
      call MKZERO( 4*natm, xcnrat )
c
c >>>>>>>>>> Cycle over atoms:
c
      do 1000 iatm=1,natm
        ityp = itypa(iatm)
c
        nshli = nocc(ityp)
c
        noccsh = 0
        occatxc = zero
        occatm = zero
        almina = 9.d9
        do 38 ishl=1,nshli
          lshl = locc(ishl,ityp)
          occshl = occsh(ishl,ityp)
          if( occshl.eq.zero ) goto 38
c
          occatm = occatm + occshl
          if( occshl.gt.zero ) occatxc = occatxc + occshl
          noccsh = noccsh + 1
c
          almins = alsh(1,ishl,ityp)
          do  ial=2,nalsh(ishl,ityp)
            ali = alsh(ial,ishl,ityp)
            if( ali.lt.almins ) almins = ali
          enddo
          if( almins.lt.almina ) almina = almins
   38   continue
c
        if( noccsh.eq.0 ) goto 1000
c
c  Bring out xc slow/fast function parameters
c
        alminxc = two*almina
        if( xcalcut.lt.zero ) alminxc = -xcalcut*almina
        alcutxc = alcutfac*alminxc
        if( xcalcut.gt.zero ) alcutxc = xcalcut
c
        nrsc = nrcor(ityp) + 1
        if( nrsc.ne.1 )then
c         Interpolate core density
          ddy0 = 1.d31
          ddy1 = 1.d31
          call SPLINE(nrsc,radmsh(1,ityp),corden(1,ityp),ddy0,ddy1,y2,u)
        endif
c
c        [NB: code in "grid0nr" and "potnear" must match]
c
c  Compute "nearby" xc energy density if grid contains atom
c
        wts = 1.0
        vxcwtnr = zero
        excwtnr = zero
        vxcptnr = zero
        excptnr = zero
c
        do  jr=1,3
          r0(jr) = (nearest(1,iatm)-1)*hh(jr,1)
     $           + (nearest(2,iatm)-1)*hh(jr,2)
     $           + (nearest(3,iatm)-1)*hh(jr,3)
        enddo
c
c for grins, find "nearest" image closest to atom
        ilatnr = 1
        rsqnr = zero
        do  jr=1,3
          rnr(jr) = r0(jr) - ratm(jr,iatm)
          rsqnr = rsqnr + (rnr(jr)-rlat(jr,1))**2
        enddo
        do  ilat=1,nlat
          rsqnr2 = zero
          do  jr=1,3
            rsqnr2 = rsqnr2 + (rnr(jr)-rlat(jr,ilat))**2
          enddo
          if( rsqnr2.lt.rsqnr )then
            ilatnr = ilat
            rsqnr = rsqnr2
          endif
        enddo
        rnr(1) = r0(1) - ratm(1,iatm) - rlat(1,ilatnr)
        rnr(2) = r0(2) - ratm(2,iatm) - rlat(2,ilatnr)
        rnr(3) = r0(3) - ratm(3,iatm) - rlat(3,ilatnr)
c
c  Determine range in grid point dimensions for nearby sampling:
        rng1 = (rsampl/r1eff + half)
        rng2 = (rsampl/r2eff + half)
        rng3 = (rsampl/r3eff + half)
        nrng(1) = rng1
        nrng(2) = rng2
        nrng(3) = rng3
        nnr(1) = 2*nrng(1) + 1
        nnr(2) = 2*nrng(2) + 1
        nnr(3) = 2*nrng(3) + 1
        nrsmpl = nnr(1)*nnr(2)*nnr(3)
        nrpt = (nrsmpl+1) / 2
c
c  to accentuate similarity with "grid0xc":
        nrbox = nrsmpl
c  Set up temp space
        ir0 = 0
        irsq = ir0
        irngr = ir0 + 1*nrbox
        iatrh = ir0 + 2*nrbox
        icore = ir0 + 3*nrbox
        idcor = ir0 + 4*nrbox
        ia0e  = icore
        iwts  = ir0 + 5*nrbox
        inext = iwts + nrbox
        ia1e  = idcor
        ia2e  = iwts
        idrho = ir0 + 6*nrbox
        iddrh = ir0 + 7*nrbox
        inext = iddrh + nrbox
c I could neglect this memory check as I am in BIG workspace.
        if( inext.ge.mxwkrd ) call STOPXERR( 'nr0-wkrd' )
c
c  Generate r**2 on local grid:
c
        do  jr=1,3
          rr3(jr) = rnr(jr)
          do  iprim=1,3
            rr3(jr) = rr3(jr) - (DBLE(nrng(iprim))+1)*hh(jr,iprim)
          enddo
          rnr(jr) = rr3(jr) + hh(jr,1) + hh(jr,2) + hh(jr,3)
        enddo
        nr = 0
c
        do 1053 i3=1,nnr(3)
          do  jr=1,3
            rr3(jr) = rr3(jr) + hh(jr,3)
            rr2(jr) = rr3(jr)
          enddo
          do 1052 i2=1,nnr(2)
            do  jr=1,3
              rr2(jr) = rr2(jr) + hh(jr,2)
              rr1(jr) = rr2(jr)
            enddo
            do 1051 i1=1,nnr(1)
              rr1(1) = rr1(1) + hh(1,1)
              rr1(2) = rr1(2) + hh(2,1)
              rr1(3) = rr1(3) + hh(3,1)
              nr = nr + 1
c
              wkr(irsq+nr) = rr1(1)**2 + rr1(2)**2 + rr1(3)**2
              wkr(irngr+nr) = SQRT( wkr(irsq+nr) )
c
              wkr(iatrh+nr) = zero
c
 1051       continue
 1052     continue
 1053   continue
c
        if( do_gga )then
          do  nr=1,nrbox
            wkr(idrho+nr) = zero
            wkr(iddrh+nr) = zero
          enddo
        endif
c
        do 1800 ishl=1,nshli
          lshl = locc(ishl,ityp)
          twol = DBLE( 2*lshl )
c
          occshl = occsh(ishl,ityp)
          if( occshl.eq.zero ) goto 1800
c
          call MKZERO( nrbox, wkr(ia0e+1) )
          if( do_gga )then
            do  nr=1,nrbox
C             wkr(ia0e+nr) = zero
              wkr(ia1e+nr) = zero
              wkr(ia2e+nr) = zero
            enddo
          endif
c
          do 1190 ial=1,nalsh(ishl,ityp)
            ali = alsh(ial,ishl,ityp)
            cali = occshl*calsh(ial,ishl,ityp)
            cali0 = cali
            do 1180 jal=ial,1,-1
              alsum = ali + alsh(jal,ishl,ityp)
              als2 = alsum*alsum
              coef = cali*calsh(jal,ishl,ityp)/fourpi
              cali = cali0 + cali0
c
c  Sum over shell: occ*Ca*Cb*(a+b)**n*exp(-(a+b)r**2); n=0,1,2
              if( do_gga )then
                do  nr=1,nrbox
                  gauss = coef*EXP( -alsum*wkr(irsq+nr) )
                  wkr(ia0e+nr) = wkr(ia0e+nr) + gauss
                  wkr(ia1e+nr) = wkr(ia1e+nr) + gauss*alsum
                  wkr(ia2e+nr) = wkr(ia2e+nr) + gauss*als2
                enddo
              else
                do  nr=1,nrbox
                  gauss = coef*EXP( -alsum*wkr(irsq+nr) )
                  wkr(ia0e+nr) = wkr(ia0e+nr) + gauss
                enddo
              endif
c
c      Close alpha loops:
c
 1180       continue
 1190     continue
c
          if( do_gga )then
c
c           Assemble density and derivatives for GGA potential:
c
            call MKSHL2D( lshl, nrbox, wkr(irngr+1), wkr(irsq+1),
     $       wkr(ia0e+1),wkr(ia1e+1),wkr(ia2e+1),
     $       wkr(iatrh+1),wkr(idrho+1),wkr(iddrh+1) )
c
          else
c
c           Just need to assemble density for LDA calculation:
c
            call MKSHL( lshl, nrbox, wkr(irsq+1),
     $       wkr(ia0e+1), wkr(iatrh+1) )
c
          endif
c
c      Close shell loop:
c
 1800   continue
c
c  Now check if we have core density to worry about.
c
        call MKZERO( nrbox, wkr(icore+1) )
        if( nrsc.ne.1 )then
c
          if( do_gga )then
c Do core 2nd deriv before first and use (idcor) space for scratch.
c Don't need the core 2nd deriv separate from total rho 2nd deriv.
c Interpolate to get 2nd deriv. of core density ...
            call SPLIND2( nrsc, radmsh(1,ityp), corden(1,ityp),y2,
     $                    nrbox,wkr(irngr+1),wkr(idcor+1) )
c  ... and put into 2nd derivative of density for GGA potential:
            do  nr=1,nrbox
              wkr(iddrh+nr) = wkr(iddrh+nr) + wkr(idcor+nr)
            enddo
c
c Interpolate to get deriv. of core density ...
            call SPLIND( nrsc, radmsh(1,ityp),corden(1,ityp),y2,
     $                   nrbox,wkr(irngr+1),wkr(idcor+1) )
c  ... and put into density derivative for GGA potential calculation
            do  nr=1,nrbox
              wkr(idrho+nr) = wkr(idrho+nr) + wkr(idcor+nr)
            enddo
          endif
c
c Interpolate to get core density on grid from radial core density
          call SPLINT( nrsc, radmsh(1,ityp),corden(1,ityp),y2,
     $                 nrbox,wkr(irngr+1),wkr(icore+1) )
c
        endif
c
c  Local density assembled; now do local exc-dens, and weighted sampling
c
        wtsum = zero
        call MKNRWT( alfsmpl,wtsum,rnr,hh,nnr,nnr(2),nnr(3),wkr(iwts+1))
        wts = zero
        vxcwtnr = zero
        excwtnr = zero
        do 1200 nr=1,nrbox
          atrho = wkr(iatrh+nr)
          corho = wkr(icore+nr)
          rhopt = atrho + corho
c
          if( do_gga )then
c
c           Assemble gradient terms needed for GGA
c
            rmag = wkr(irngr+nr)
            if( rmag.gt.1.d-6 )then
c For r>0, general Cartesian derivs from radial derivs ...
c  ... note that dcor already added into drho above
              drh = wkr(idrho+nr)
c  ... terms for Cartesian reference derivatives:
              d1rhdr = drh/rmag
              d2rh = wkr(iddrh+nr) - d1rhdr
c  ... need gradients for the xc-potential generation:
              grho = ABS( drh )
              g2rho = wkr(iddrh+nr) + two*d1rhdr
              gpggp = grho*wkr(iddrh+nr)
c
            else
c At r=0, dp/du=0, and only d2p/du2 survives limits ...
              d2rh = wkr(iddrh+nr)
              grho = zero
              g2rho = three*wkr(iddrh+nr)
              gpggp = zero
            endif
c
            call DFTGGA( rhopt, grho,g2rho,gpggp,
     $                   vxcpt,excpt, dxcpt,dxc2pt )
c
c           End do_gga = .true.
          else
c           do_gga = .false.
c
            call DFTLDA( rhopt, vxcpt,excpt )
c
          endif
c
          wts = wts + wkr(iwts+nr)
c  Construct "fast" xc-potentials, and update:
          cfac = EXP( -alcutxc*wkr(irsq+nr) )
          fstfcn = cfac / ( (one-xcfac)*cfac + xcfac )
c
          vslow = vxcpt - vxcpt*fstfcn
          eslow = excpt - excpt*fstfcn
c
          vxcwtnr = vxcwtnr + wkr(iwts+nr)*vslow
          excwtnr = excwtnr + wkr(iwts+nr)*eslow
c
          if( nr.eq.nrpt )then
c  Construct "fast" part of xc-potentials, and remove:
            vxcptnr = vxcpt - vxcpt*fstfcn
            excptnr = excpt - excpt*fstfcn
          endif
 1200   continue
        vxcwtnr = vxcwtnr/wtsum
        excwtnr = excwtnr/wtsum
c
c Load the nearby potential values into storage arrays for "grid0xc":
        xcnrat(1,iatm) = vxcwtnr
        xcnrat(2,iatm) = excwtnr
        xcnrat(3,iatm) = vxcptnr
        xcnrat(4,iatm) = excptnr
c
c      Close atom loop:
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PRODBA
c
c
      subroutine PRODBA( b,a,nd,n,w )
c---------------------------------------------------------------
c Purpose:  multiply b * a, where a is upper triangular
c      output result in b, leaving a unaffected
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  10Dec97-PAS/2.21: Changed complex to real; opted for cache
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  a(2,nd,nd),b(2,nd,nd), w(2,nd)
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Transpose b-array for convenience in big loop below.
c  (this is cheap N**2, below is N**3)
      do  j=2,n
        do  i=1,j-1
          w(1,i) = b(1,i,j)
          w(2,i) = b(2,i,j)
        enddo
        do  i=1,j-1
          b(1,i,j) = b(1,j,i)
          b(2,i,j) = b(2,j,i)
          b(1,j,i) = w(1,i)
          b(2,j,i) = w(2,i)
        enddo
      enddo
c
      do 50 i=1,n
        do  j=1,n
c         w(j) = (0.,0.)
          w(1,j) = zero
          w(2,j) = zero
        enddo
c loop order gave up to 2X improvement for bigger n
        do  j=1,n
          do  k=1,j
c           w(j) = w(j) + b(k,i)*a(k,j)
c parens needed for precision, and is a bit faster, too
            w(1,j) = w(1,j) + ( b(1,k,i)*a(1,k,j)
     $                        - b(2,k,i)*a(2,k,j) )
            w(2,j) = w(2,j) + ( b(1,k,i)*a(2,k,j)
     $                        + b(2,k,i)*a(1,k,j) )
          enddo
        enddo
        do  j=1,n
c         b(j,i) = w(j)
          b(1,j,i) = w(1,j)
          b(2,j,i) = w(2,j)
        enddo
   50 continue
c
c Transpose back b-array
      do  j=2,n
        do  i=1,j-1
          w(1,i) = b(1,i,j)
          w(2,i) = b(2,i,j)
        enddo
        do  i=1,j-1
          b(1,i,j) = b(1,j,i)
          b(2,i,j) = b(2,j,i)
          b(1,j,i) = w(1,i)
          b(2,j,i) = w(2,i)
        enddo
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PRODHAB
c
c
      subroutine PRODHAB( a,b,nd,n,w )
c---------------------------------------------------------------
c Purpose: multiply h.c.(a) * b, where a is upper triangular
c      output result in b, leaving a unaffected
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  10Dec97-PAS/2.21: Changed cplx to real; flip loop order (2X)
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  a(2,nd,nd),b(2,nd,nd), w(2,nd)
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      do 50 i=1,n
        do  j=1,n
c         w(j) = (0.,0.)
          w(1,j) = zero
          w(2,j) = zero
        enddo
c loop order gave up to 2X improvement for bigger n
        do  j=1,n
          do  k=1,j
c           w(j) = w(j) + CONJG(a(k,j))*b(k,i)
c parens needed for precision, and is a bit faster, too
            w(1,j) = w(1,j) + ( a(1,k,j)*b(1,k,i)
     $                        + a(2,k,j)*b(2,k,i) )
            w(2,j) = w(2,j) + ( a(1,k,j)*b(2,k,i)
     $                        - a(2,k,j)*b(1,k,i) )
          enddo
        enddo
        do  j=1,n
c         b(j,i) = w(j)
          b(1,j,i) = w(1,j)
          b(2,j,i) = w(2,j)
        enddo
   50 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PROJLV
c
c
      subroutine PROJLV( r, a,b,c, v )
c---------------------------------------------------------------
c Purpose: project vector r() onto linearly independent vectors
c          a(), b(), c(), putting result (Cramer's rule) in v().
c
c Written: Peter A. Schultz, 8-May-1991
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  r(3),a(3),b(3),c(3)
c output arrays:
      DIMENSION  v(3)
c
c >>>> EXECUTABLE CODE:
c
      denom =  a(1)*(b(2)*c(3)-b(3)*c(2)) +
     $         b(1)*(c(2)*a(3)-c(3)*a(2)) +
     $         c(1)*(a(2)*b(3)-a(3)*b(2))
c
      v(1) = ( r(1)*(b(2)*c(3)-b(3)*c(2)) +
     $         b(1)*(c(2)*r(3)-c(3)*r(2)) +
     $         c(1)*(r(2)*b(3)-r(3)*b(2)) ) / denom
      v(2) = ( a(1)*(r(2)*c(3)-r(3)*c(2)) +
     $         r(1)*(c(2)*a(3)-c(3)*a(2)) +
     $         c(1)*(a(2)*r(3)-a(3)*r(2)) ) / denom
      v(3) = ( a(1)*(b(2)*r(3)-b(3)*r(2)) +
     $         b(1)*(r(2)*a(3)-r(3)*a(2)) +
     $         r(1)*(a(2)*b(3)-a(3)*b(2)) ) / denom
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PROJUC
c
c
      subroutine PROJUC( outuc,shift, ndim, rv,rvnew, rlat )
c---------------------------------------------------------------
c Purpose: project atoms into unit cell (in periodic dimensions)
c
c Written: Peter A. Schultz, 26-January-1996, for v2.15
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c  Code selects atoms as inside uc shifted by "edge" toward
c  zero sides of primary unit cell.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      LOGICAL  outuc,shift
      DIMENSION  rv(3),rvnew(3),rlat(3,3)
c local declarations:
      DIMENSION  v(3)
      DATA  edge / 0.0001d0 /
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      outuc = .false.
      do  i=1,3
        rvnew(i) = rv(i)
      enddo
c project coordinates onto lattice vectors:
      call PROJLV( rv, rlat(1,1),rlat(1,2),rlat(1,3), v )
c
      shift = .false.
      do 100 idim=1,3
        vchk = v(idim) + edge
        ilat = ABS(vchk)
        if( v(idim)+edge .lt. zero ) ilat = -ilat - 1
c
        if( ilat.ne.0 .and. idim.le.ndim )then
          shift = .true.
          clat = DBLE(ilat)
          do  i=1,3
            rvnew(i) = rvnew(i) - clat*rlat(i,idim)
          enddo
        elseif( ilat.ne.0 )then
          outuc = .true.
        endif
  100 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QHIST
c
c
      subroutine QHIST0( istatfl, statkey,
     $ ndim0,natm0,ntyp0, itypa, natmnm,typnm,atmnm )
c---------------------------------------------------------------
c Purpose: write out data as running log of code that can be
c          be parsed for post-processing.
c
c Written: Peter A. Schultz, 19-May-2001, for v2.55
c
c Revision history:
c  29Apr09-PAS/2.62: install r_units into fmax (thx ACPineda)
c  21Jan08-PAS/2.61: spin-optimization
c   3Jan08-PAS/2.61: enable skip if file-unit disabled
c  14Jun05-PAS/2.59: File units
c  18Mar04-PAS/2.57d: fix cell energy output
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      CHARACTER  statkey*(*)
c
      DIMENSION  itypa(*)
      CHARACTER*(*)  typnm(*),atmnm(*)
c
      DIMENSION  vdata(3,*)
c
c local declarations:
      DIMENSION  vec3(3)
      CHARACTER  wantlbl*4
      CHARACTER  keychar*1
      DATA  keychar / '@' /
c
      CHARACTER*4  dist
      DATA         dist / 'ANGS' /
      DATA         one     / 1.d0 /
      DATA         au_to_A / 0.5291771d0 /
c
c >>>> EXECUTABLE CODE:
c
 9100 format(a)
 9103 format(5x,3f20.8)
c
c Check that this feature is on ...
      if( istatfl .lt. 0 ) goto 1999
c
      wantlbl = statkey(1:4)
c
      if( wantlbl .eq. 'INIT' )then
c       Initialize system information in file:
c
        REWIND( unit=istatfl )
c
        write(istatfl,9100)  keychar // '=KEYCHAR'
c
        write(istatfl,9100)  keychar // 'DISTANCE UNIT'
        if( dist.eq.'BOHR' )then
          write(istatfl, '(1x, a)' )     'BOHR'
        elseif( dist.eq.'ANGS' )then
          write(istatfl, '(1x, a)' )     'ANGSTROM'
        else
          call FLGETIERR( IERRFL )
          write(IERRFL,*) 'QHIST0: unknown distance unit: ',dist
          call STOPXERR( 'QHIST0 - unknown distance unit' )
        endif
c
        ndim = ndim0
        natm = natm0
        ntyp = ntyp0
        write(istatfl,9100)  keychar // 'DIMENSION'
        write(istatfl, '(1x,i4)' )     ndim
c
        write(istatfl,9100)  keychar // 'NUMBER OF ATOMS'
        write(istatfl, '(1x,i8)' )    natm
        do  iatm0=0,natm-1,20
          iatm1 = iatm0 + 1
          iatms = iatm0 + 20
          if( natm.lt. (iatm0+20) ) iatms = natm
          write(istatfl,'(20i4)')  (itypa(iatm),iatm=iatm1,iatms)
        enddo
c
        write(istatfl,9100)  keychar // 'TYPES'
        write(istatfl, '(1x,i8)' )    ntyp
        do  ityp=1,ntyp
          write(istatfl,'(a)')  typnm(ityp)
        enddo
c
      endif
c
 1999 continue
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QHIST
c
c
      entry QHIST( istatfl, statkey, ndata, rdata, vdata )
c
c Check that this feature is on ...
      if( istatfl .lt. 0 ) goto 2999
c
      if( dist .eq. 'ANGS' )then
        r_units = au_to_A
      elseif( dist .eq. 'BOHR' )then
        r_units = one
      else
        call FLGETIERR( IERRFL )
        write(IERRFL,*) 'QHIST: unknown distance unit: ',dist
        call STOPXERR( 'Unknown distance unit in QHIST' )
      endif
c
      wantlbl = statkey(1:4)
      if( wantlbl .eq. 'IMAG' )then
c       Write out current NEB image number:
        write(istatfl,9100)  keychar // 'IMAGE'
        write(istatfl,'(1x,i8)')  ndata
c
      elseif( wantlbl .eq. 'UCST' )then
c       Write out current cell step number:
        write(istatfl,9100)  keychar // 'UCSTEP'
        write(istatfl,'(1x,i8)')  ndata
c
      elseif( wantlbl .eq. 'CELL' )then
c       Write out current cell vectors:
        write(istatfl,9100)  keychar // 'CELL VECTORS'
        do  idim=1,3
          vec3(1) = vdata(1,idim) * r_units
          vec3(2) = vdata(2,idim) * r_units
          vec3(3) = vdata(3,idim) * r_units
          write(istatfl,9103)  vec3
        enddo
c
      elseif( wantlbl .eq. 'GSTE' )then
c       Write out current geometry step number:
        write(istatfl,9100)  keychar // 'GSTEP'
        write(istatfl,'(1x,i8)')  ndata
c
      elseif( wantlbl .eq. 'COOR' )then
c       Write out current geometry information
        write(istatfl,9100)  keychar // 'COORDINATES'
        natm = ndata
        do  iatm=1,natm
          vec3(1) = vdata(1,iatm) * r_units
          vec3(2) = vdata(2,iatm) * r_units
          vec3(3) = vdata(3,iatm) * r_units
          write(istatfl,9103)  vec3
        enddo
c
      elseif( wantlbl .eq. 'ESPI' )then
c       Write out converged SCF energy
        write(istatfl,9100)  keychar // 'ESPINSCF(Ry): E, e(up), e(dn)'
        write(istatfl,9103)  rdata, vdata(1,1),vdata(2,1)
c
      elseif( wantlbl .eq. 'SP-F' )then
c       Write out new spin polarization
        write(istatfl,9100)  keychar // 'SPIN-POLARIZATION (e)'
        write(istatfl,9103)  rdata
c
      elseif( wantlbl .eq. 'ESCF' )then
c       Write out converged SCF energy
        write(istatfl,9100)  keychar // 'ESCF'
        write(istatfl,9103)  rdata
c
      elseif( wantlbl .eq. 'FORC' )then
c       Write out forces
        write(istatfl,9100)  keychar // 'FORCES'
        natm = ndata
        do  iatm=1,natm
          vec3(1) = vdata(1,iatm) / r_units
          vec3(2) = vdata(2,iatm) / r_units
          vec3(3) = vdata(3,iatm) / r_units
          write(istatfl,9103)  vec3
        enddo
c
      elseif( wantlbl .eq. 'VELO' )then
c       Write out velocities
        write(istatfl,9100)  keychar // 'VELOCITY'
        natm = ndata
        do  iatm=1,natm
          vec3(1) = vdata(1,iatm) * r_units
          vec3(2) = vdata(2,iatm) * r_units
          vec3(3) = vdata(3,iatm) * r_units
          write(istatfl,9103)  vec3
        enddo
c
      elseif( wantlbl .eq. 'FMAX' )then
c       Write out maximum force
        write(istatfl,9100)  keychar // 'FMAX'
        write(istatfl,9103)  rdata / r_units
c
      elseif( wantlbl .eq. 'FRMS' )then
c       Write out rms force
        write(istatfl,9100)  keychar // 'FRMS'
        write(istatfl,9103)  rdata / r_units
c
      elseif( wantlbl .eq. 'ECEL' )then
c       Write out converged geometry energy
        write(istatfl,9100)  keychar // 'ECELL'
        write(istatfl,9103)  rdata
c
      elseif( wantlbl .eq. 'STRE' )then
c       Write out stress tensor
        write(istatfl,9100)  keychar // 'STRESS'
        ndim = 3
        do  idim=1,ndim
          vec3(1) = vdata(1,idim)
          vec3(2) = vdata(2,idim)
          vec3(3) = vdata(3,idim)
          write(istatfl,9103)  (vec3(i),i=1,ndim)
        enddo
c
      elseif( wantlbl .eq. 'MAXS' )then
c       Write out maximum stress
        write(istatfl,9100)  keychar // 'MAXSTRESS'
        write(istatfl,9103)  rdata
c
      elseif( wantlbl .eq. 'RMSS' )then
c       Write out rms stress
        write(istatfl,9100)  keychar // 'RMSSTRESS'
        write(istatfl,9103)  rdata
c
      elseif( wantlbl .eq. 'END ' )then
c       Close the record
        write(istatfl,9100)  keychar // 'END FILE'
c
      else
        call FLGETIERR( IERRFL )
        write(IERRFL,*) '***** This qhist key unknown:',statkey
        call STOPXERR( 'QHIST: unknown keyword' )
c
      endif
c
cpas: machine dependent flush. - I should replace this (utl)
      call FLUSH( istatfl )
c
 2999 continue
c
      RETURN
c
c    That's all Folks!
c
      END
c***********************************************************************
c     QMD - Quest MD Module
c     Written: Rick Muller 2004
c
c     Public subroutines
c      Configuring the MD module ...
c      QMDSETIWR( IWR ) - Set the write unit for QMD output
c      QMDTYPSET( iphase, mdlabel )      Set MD method/thermostat
c         iphase=1: initialization/equilibration
c         iphase=2: temperature ramp
c         iphase=3: equilibration
c         iphase=4: molecular dynamics
c      QMDTEMPSET( ti )          Set MD ionic temperature
c      QMDTSTEPSET( dt )         Set time step interval
c      QMDNEQSTEPSET( neqsteps ) Set number of equilibration steps
c      QMDNTSTEPSET( ntsteps )   Set number of thermalized MD steps
c      QMDSTEPSGET( nsteptot )   Returns total number of steps in MD
c      Launching a configured MD run ...
c      QMDINIT           Initialize the Quest MD run
c      Updating/tracking a MD run in progress ...
c      QMDUPDATE         Update the MD variables at the end of a
c                          geometry optimization step
c      QMDPRINT          Print a snapshot of the MD configuration
c      QMDCONVCHK        Check for whether MD is done
c      QMDEPSET          Set the potential energy from the El Energy
c
c     Private subroutines
c      GET_VCOM          Compute the velocity of the center of mass
c      GET_EKIN          Convert kinetic energy to temperature
c      GET_TEMP_E        Compute the temperature from the kinetic energy
c      GET_TEMP_V        Compute the temperature from the velocities
c      QMDSUBVCOM        Remove center of mass velocity
c      QMDSUBFCOM        Subtract the center of mass forces
c      QMDUPDATE_DAMPED  Minimization MD runs using a constant velocity damping
c      QMDUPDATE_TSCALE  Velocity scaled to temperature update
c      QMDUPDATE_NVE_LF  NVE ensemble, Leapfrog Verlet update
c      QMDUPDATE_LANGVN  NVT ensemble, Langevin thermostat, Leapfrog
c      QMDUPDATE_HOOVER  NVT ensemble, Nose-Hoover thermostat, Leapfrog
c      QMDUPDATE_BEREND  NVT ensemble, Berendsen thermostat, Leapfrog
c      QMDVINIT          Initialize velocities to a temperature (boltzmann)
c      QMDVDAMP          Damp the velocities by a factor
c      QMDVRESET         Reset all of the atomic velocities to a new temp
c
c     Submodules:
c      TMON /qmdtmon/    Used to monitor temperatures over atom types
c
c     QMD Module data:
c      natmd         i   Parameter - number of atoms module permits
c     Private data stored in common block /questmd/
c      tempinit      f   Target temperature
c      tempprnt      f   Current temperature (in synch with position)
c      tempcurr      f   Current temperature (in synch with velocity)
c      timestep      f   Time step
c      Ekinprnt      f   Kinetic energy (in synch with position)
c      Ekincurr      f   Kinetic energy (in synch with velocity)
c      Epot          f   Potential energy
c      shv           f   Nose-Hoover s (sometimes eta) coupling to heat bath
c      vel           f*  Velocities: leapfrog, kept at half steps w.r.t. the coords
c                        coordinates
c      vprint        f*  Velocities: in synch with positions (interpolated)
c      atom_mass     f*  Atomic Mass of each element
c      ieq_type      i   method for equilibration step
c      md_type       i   Type of Quest MD Run (see QMDTYPSET/QMDUPDATE)
c                        1   NVE Dynamics
c                        2   NVT Dynamics, Berendsen Thermostat
c                        3   NVT Dynamics, Hoover Thermostat
c                        4   NVT Dynamics, Scaled Temperatures
c                        5   Damped dynamics
c                        6   NVP Dynamics, Anderson Thermostat (n/a)
c                        7   Hugoniotstat Dynamics (n/a)
c                        8   NVT Dynamics, Langevin Thermostat (n/a)
c      ntsteps       i   Number of time steps
c      neqtsteps     i   Number of scaled temperature time steps for equilibration
c      md_natoms     i   Number of atoms
c      itimestep     i   Current time step
c      md_nmodes     i   3*Nat-6 or 3*Nat-5; actually just 3*Nat for now
c      imd_wr        i   Output unit for MD, IWR from the main routine
c      irestarted    i   0 if the MD case did not restart; 1 otherwise
c      temp_eq       f   target temperature for equil phase
c      temp_md       f   target temperature for MD phase
c      param_eq      f   parameter for thermostat control, equil phase
c      param_md      f   parameter for thermostat control, MD phase
c      parstat       f   parameter for currently active thermostat
c
c     Private constant data (see QMDCONST)
c      fconst        f   Converts Force in Ry/bohr to ???
c      tconst        f   Converts Temperature from Kelvin to Ry
c***********************************************************************
c Revision history:
c   8Feb13-PAS/2.65: use clean, full atomic symbol tables
c  25Apr08-PAS/2.61b: add energy monitor into monitor function
c  10Feb08-PAS/2.61: fix thermostats/initialization, wire thermostat controls
c  27Jun07-PAS/2.60: add data to restart file for clean thermostat continue
c***********************************************************************
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDSETIWR
c
c
      subroutine QMDSETIWR( IWR )
c---------------------------------------------------------------
c Purpose: set thermostat/type of molecular dyanmics
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c >>>> EXECUTABLE CODE:
c
      imd_wr = IWR
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDTYPSET
c
c
      subroutine QMDTYPSET( imdphase, mdlabel )
c---------------------------------------------------------------
c Purpose: set thermostat/type of molecular dyanmics
c
c Written: Richard P. Muller, 8-May-2004, for v2.58 (qmd)
c
c Revision history:
c   8May04-PAS: extract from RPM's routines into this routine
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
C      COMMON /qmddata/ timestep,itimestep,irestarted,
C     $ md_natoms,md_nmodes,atoms_mass, vel,vprint,
C     $ neqtsteps,ieq_type, temp_eq, param_eq,
C     $ ntsteps  , md_type, temp_md, param_md,
C     $ tempinit,tempcurr,Ekincurr,Epot,shv,parstat,
C     $ imd_wr
c
c input declarations:
      CHARACTER*(*)  mdlabel
c local declarations:
      CHARACTER*6  mdmeth
c
c The following are MD method id tags; they must be distinct.
      DATA imd_nve   ,imd_berend,imd_hoover,imd_tscale,imd_damped
     $    /    1     ,    2     ,    3     ,    4     ,    5     /
      DATA imd_anders,imd_hugoni,imd_langvn
     $    /    6     ,    7     ,    8     /
c
      DIMENSION  paramsmd(8)
      DATA  paramsmd / 0.d0, 400.d0, 100.d0, 0.98d0, 0.95d0,
     $       0.0d0,    0.d0, 100.d0 /
c paramsmd defines default control parameter for each thermostat:
c  1/NVE - none
c  2/Berend - t/time(fs), s=(1/2t)*(T/Told-1)
c  3/Hoover - t/time(fs), ds=(1/t^2)*(T/Told-1)
c  4/Tscale - f/scaling factor (simple: Tnew=  f*Told + (1-f)*T )
c  5/damped - f/scaling factor (simple: Tnew = f*Told )
c  6/anders - n/a
c  7/hugoni - n/a
c  8/langvn - t/time(fs)
c
c >>>> EXECUTABLE CODE:
c
      mdmeth = mdlabel(1:6)
c
      imdtype = 0
c
      if(     mdmeth .eq. 'nve   ' .or. mdmeth .eq. 'NVE   ' )then
c       NVE/Microcanonical update, leapfrog-verlet
        imdtype = imd_nve
c
      elseif( mdmeth .eq. 'langev' .or. mdmeth .eq. 'LANGEV' .or.
     $        mdmeth .eq. 'Langev' )then
c       NVT/Langevin thermostat, leapfrog-verlet
        imdtype = imd_langvn
c
      elseif( mdmeth .eq. 'berend' .or. mdmeth .eq. 'BEREND' .or.
     $        mdmeth .eq. 'Berend' )then
c       NVT/Berendsen thermostat, leapfrog-verlet
        imdtype = imd_berend
c
      elseif( mdmeth .eq. 'hoover' .or. mdmeth .eq. 'HOOVER' .or.
     $        mdmeth .eq. 'Hoover' .or.
     $        mdmeth .eq. 'NVT' )then
c       NVT/Nose-Hoover thermostat, leapfrog-verlet ***NVT default***
        imdtype = imd_hoover
c
      elseif( mdmeth .eq. 'tscale' .or. mdmeth .eq. 'TSCALE' .or.
     $        mdmeth .eq. 'Tscale' )then
c       Temperature scaling, leapfrog-verlet
        imdtype = imd_tscale
c
      elseif( mdmeth .eq. 'damped' .or. mdmeth .eq. 'DAMPED' )then
c       Damped dynamics (bleeding out K.E.), leapfrog-verlet
        imdtype = imd_damped
c
      elseif( mdmeth .eq. 'anders' .or. mdmeth .eq. 'ANDERS' .or.
     $        mdmeth .eq. 'Anders' )then
c       Anderson thermostat
        imdtype = imd_anders
c
      elseif( mdmeth .eq. 'hugoni' .or. mdmeth .eq. 'HUGONI' .or.
     $        mdmeth .eq. 'Hugoni' )then
c       Hugoniostat
        imdtype = imd_hugoni
c
      else
        write(imd_wr,*) 'QMDTYPSET: unknown MD method tag=',mdmeth
        call STOPXERR( 'qmdtypset: invalid dynamics method' )
c
      endif
c
c  Enter MD type into Module data:
      if( imdphase .eq. 1 )then
c       This is the initial equilibration phase
        ieq_type = imdtype
        param_eq = paramsmd(imdtype)
        write(imd_wr,*) '# equilibration param set to=',param_eq
      elseif( imdphase .eq. 4 )then
c       This is the thermalized MD phase
        md_type = imdtype
        param_md = paramsmd(imdtype)
        write(imd_wr,*) '# MD thermostat param set to=',param_md
      else
c       Default: thermalized MD phase
        call STOPXERR( 'mdtypset code error: invalid MD phase' )
        md_type = imdtype
        param_md = paramsmd(imdtype)
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDSETGETS
c
c
c---------------------------------------------------------------
c Purpose: public routines that set/get configurable MD params
c Written: Richard P. Muller, 8-May-2004, for v2.58 (qmd)
c Revision history:
c  17May04-PAS: renamed w/ QMD prefixes, moved to "public" section
c---------------------------------------------------------------
c
      subroutine QMDTEMPSET( temp )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c Configure temperature for MD run:
      tempinit = temp
      temp_md  = temp
c For the moment, also set the equilibration target temp to this, too:
      call QMDEQTSET( temp )
c
      RETURN
      END
c
      subroutine QMDEQTSET( temp )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c Configure temperature for equilibration
      temp_eq = temp
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDPARAMSET
c
c
      subroutine QMDPARAMSET( parmd )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c Configure thermostat parameter for MD run:
      param_md = parmd
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDEQPARSET
c
c
      subroutine QMDEQPARSET( parmd )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c Configure thermostat parameter for equilibration
      param_eq = parmd
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDTSTEPSET
c
c
      subroutine QMDTSTEPSET( dt_md )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c Configure timestep for MD run:
      timestep = dt_md
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDNEQSTEPSET
c
c
      subroutine QMDNEQSTEPSET( nstepeq )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c Configure number of equilibration steps:
      neqtsteps = nstepeq
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDTSTEPGET
c
c
      subroutine QMDNTSTEPSET( nstepmd )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c Configure number of thermalized MD steps:
      ntsteps = nstepmd
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDSTEPSGET
c
c
      subroutine QMDSTEPSGET( nsteptot )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c Total number of steps is equilibration + thermalized MD steps
      nsteptot = ntsteps + neqtsteps
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDINIT
c
c
      subroutine QMDINIT( iwr,nat,itypa,atmass,ratm,igstart )
c
c     Initialize variables for Quest MD module. Also do some
c     simple sanity checks. Had to pass in ratm so we can optionally
c     update the atom positions from the vxyz file
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c     Argument arrays
      DIMENSION  itypa(natmd),atmass(*),ratm(3,natmd)
c Local declarations:
      PARAMETER  (ntypchk=10)
      DIMENSION  itypchk(ntypchk)
c
c >>>> EXECUTABLE CODE:
c
c Initialize temperature-monitoring apparatus
      call TMONINIT( nat, itypa )
      call TMONRESET( )
c
      imd_wr = iwr
      irestarted = 0
c Set dynamics flag in geometry engine:
      call GTYPSET( 'DYNAMICS' )
c
      if (tempinit .lt. zero) then
         call STOPXERR('QMDINIT -- Temperature < 0')
      else if (tempinit .gt. 2000d0) then
         write(imd_wr,*) 'WARNING: Quest MD -- Temperature high',
     $        tempinit
         write(imd_wr,*) '         I hope you know what you are doing'
      endif
      tempcurr = tempinit
      shv = zero
c
c
      if (timestep .gt. 10d0) then
         write(imd_wr,*) 'WARNING: Quest MD -- Large time step entered',
     $        timestep
      else if (timestep .lt. 0.01d0) then
         write(imd_wr,*) 'WARNING: Quest MD -- Small time step entered',
     $        timestep
      endif
c
      if( ntsteps .le. 0 )then
         write(imd_wr,*) 'QMDINIT: invalid # time steps=',ntsteps
         call STOPXERR('QMDINIT - invalid # time steps')
      endif
c
      if( neqtsteps .lt. 0 )then
         write(imd_wr,*) 'QMDINIT: invalid # equil steps=',neqtsteps
         call STOPXERR('QMDINIT - invalid # equilibration steps')
      endif
      itimestep = 0
c
      if( nat .gt. natmd )then
         write(imd_wr,*) 'QMDINIT: too many atoms for MD module'
         write(imd_wr,*) 'Input number ot atoms, max=',nat,natmd
         call STOPXERR('QMDINIT - too many QMD atoms')
      elseif( nat .le. 0 )then
         write(imd_wr,*) 'QMDINIT: bad number of atoms=',nat
         call STOPXERR('QMDINIT - invalid # atoms')
      else
c        Install number of atoms into the MD module:
         md_natoms = nat
c
c        Set the number of modes to 3*nat (rather than 3*nat-6),
c        For periodic system it includes the lattice modes:
c        This is not really correct, but it's just a scaling factor
c
         md_nmodes = 3*md_natoms
         write(imd_wr,*) 'MD atoms, modes=',md_natoms,md_nmodes
      endif
c
c     Install the atom masses into the MD module
c
cqmd: treatment of atomic masses needs to be handled better
      do  ityp=1,ntypchk
        itypchk(ityp) = 0
      enddo
      do  i=1,md_natoms
        itypatom = itypa(i)
        ximass = atmass(itypatom)
        if( itypchk(itypatom) .eq. 0 )then
c         Check this mass vs. an unitialized mass
          diff = ABS( ximass - 1.d0 )
          if( diff .lt. 5.d-7 )then
            write(imd_wr,*) '***** WARNING: likely uninitialized mass'
            write(imd_wr,*) '>>>>> atom type #, mass=',itypatom,ximass
          endif
          itypchk(itypatom) = 1
        endif
        atom_mass(i) = ximass
      enddo
c
c     Acquire restart data for a continued run, if lcao.vxyz file exists
      call QMDRESTART( ratm )
c
c     If no restart, then Initialize velocities and kinetic energy
      if( irestarted .eq. 0 ) call QMDVINIT
c
c     Set geometry step to correct place.
c       Remember itimestep is zero-indexed, igstart is one-indexed
c       This might be done otherwise/where, but convention is ambiguous
      igstart = itimestep + 1
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDRESTART
c
c
      subroutine QMDRESTART( ratm )
c
c     Check for the existance of a restart file
c     If found, use it for the x,y,z,vx,vy,vz information for all atoms,
c               and use it to smoothly continue the thermostat.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c Output:
      dimension ratm(3,natmd)
c
c Local declarations:
      CHARACTER*3  sym
      CHARACTER*8  wantlbl,readlbl
c
c >>>> EXECUTABLE CODE:
c
      call QMDCONST( fconst, tconst )
      sym = ""
      vx = zero
      vy = zero
      vz = zero
      x = zero
      y = zero
      z = zero
c
      call FLEXIST(iexist, 'lcao.vxyz', 'FOR')
      if (iexist .eq. 1) then
         irestarted = 1
         call FLOPEN(ifl, 'lcao.vxyz', 'OLD', 'FOR',ierror)
         if( ierror.ne.0 )
     $        call STOPXERR( 'QMD-VINIT: error opening restart' )
c
c
         read(ifl,*) nat_restart
         if (nat_restart .ne. md_natoms)
     $        call STOPXERR( 'QMD-VINIT: wrong nat in restart' )
c
c     Skip title line
         read(ifl,*)
c
c      Input the atomic positions and velocities
         Ekin_dt = zero
         do i =1, nat_restart
            read(ifl,'(A2,6f12.8)',err=113,end=113) sym,x,y,z,vx,vy,vz
            vel(1,i) = vx
            vel(2,i) = vy
            vel(3,i) = vz
            ratm(1,i) = x
            ratm(2,i) = y
            ratm(3,i) = z
            xm = atom_mass(i)
            Ekin_dt = Ekin_dt + 0.5d0*xm*(vx*vx+vy*vy+vz*vz)/fconst
         enddo
c
c     Remove net momentum, if any:
         call QMDSUBVCOM
         call GET_EKIN( md_natoms,atom_mass,vel, Ekin )
         call GET_TEMP_E( Ekin,md_nmodes, temp )
         Ekincurr = Ekin
         tempcurr = temp
c
         write(imd_wr,'(a,f10.4)') 'Raw Ekin from vel(dt) = ',Ekin_dt
         write(imd_wr,'(a,f10.4)') 'Processed Ekin        = ',Ekin
         write(imd_wr,'(a,f10.4)') 'Processed tempcurr    = ',tempcurr
c
c Recover thermostat continuation data if it exists
c
 8108    format(a8)
c
c Find entry label for section, skip thermostat restart if do not find
         wantlbl = 'thermost'
         read(ifl,8108,err=200,end=200)  readlbl
         if( readlbl .ne. wantlbl ) goto 200
c
         write(imd_wr,'(/a)') 'QMD Restart: found thermostat data'
c
c Found thermostat continuation data: read it, kill job if corrupted
         wantlbl = 'itimeste'
         read(ifl,8108,err=113,end=113)  readlbl
         if( readlbl .ne. wantlbl ) goto 113
         read(ifl,*)  itime_restart
         itimestep = itime_restart
c
         wantlbl = 'temp    '
         read(ifl,8108,err=113,end=113)  readlbl
c        For backward compatibility
         if( readlbl .ne. wantlbl ) wantlbl = 'tempcurr'
         if( readlbl .ne. wantlbl ) goto 113
         read(ifl,*)  temp_restart
         tempprnt = temp_restart
c
         wantlbl = 'Ekin    '
         read(ifl,8108,err=113,end=113)  readlbl
         if( readlbl .ne. wantlbl ) goto 113
         read(ifl,*)  Ekin_restart
         Ekinprnt = Ekin_restart
c
         wantlbl = 'shv     '
         read(ifl,8108,err=113,end=113)  readlbl
         if( readlbl .ne. wantlbl ) goto 113
         read(ifl,*)  shv_restart
         shv = shv_restart
c
         wantlbl = 'end ther'
         read(ifl,8108,err=113,end=113)  readlbl
         if( readlbl .ne. wantlbl ) goto 113
c
         write(imd_wr,'(a,3f18.8)')
     $    'QMD Restart data: temp,Ekin,shv=',
     $     tempprnt,Ekinprnt,shv
         goto 200
c
  113    continue
c        We had an error processing the MD restart file
         write(imd_wr,*) 'Error processing MD restart file (lcao.vxyz)'
         call STOPXERR( 'Corrupted MD restart file' )
c
  200    continue
         call FLCLOSE( ifl )
c
c        May want to turn this printing off or flag with verbose
         write(imd_wr,*) "Following data input in QMDRestart:"
         do  iatm=1,md_natoms
            write(imd_wr,'(i4,7f10.5)') iatm,atom_mass(iatm),
     $           (ratm(j,iatm),j=1,3),
     $           (vel(j,iatm),j=1,3)
         enddo
c
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDVINIT0
c
c
      subroutine QMDVINIT0
c
c     Set velocities to reproduce the Boltzmann distribution. This
c     was the old method, which has been superceded by the version
c     in QMDVINIT
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c     Local storage
      dimension vrand(3),xsign(3),iseed(4)
c iseed=Seeds for the random number generator
c   - Probably a more intelligent set exists (1-3.lt.4096, 4 is odd)
      data iseed /4,3,2,1/
c
c     This sets the initial temperature to twice Ti; the reasoning behind
c     this is that if we set the velocities to twice the temp, if the
c     molecule is at equilibrium, we have on the average that temperature
c     in the molecule
c
c >>>> EXECUTABLE CODE:
c
      call QMDCONST( fconst, tconst )
      Ekin_per_mode = 0.5*tempinit*tconst
c
      do i = 1, md_natoms
         xm = atom_mass(i)
         vavg = dsqrt(2*Ekin_per_mode*fconst/xm)
c     Find a more intelligent setting for stdev!
         stdev = 0.1*vavg     
         call DLARNV(3,iseed,3,vrand)
         call DLARNV(2,iseed,3,xsign)
c     This is unnecessarily complex. The vx,vy,vz
c     components should be centered around +/-vavg. The call to
c     dlarnv(3) gives a normal distribution centered around vavg.
c     The calls to xsign and dsign simply toggle the +/- part.
c         vel(1,i) = sign(vavg,xsign(1))
c         vel(2,i) = sign(vavg,xsign(2))
c         vel(3,i) = sign(vavg,xsign(3))
         vel(1,i) = sign(vavg,xsign(1))+stdev*vrand(1)
         vel(2,i) = sign(vavg,xsign(2))+stdev*vrand(2)
         vel(3,i) = sign(vavg,xsign(3))+stdev*vrand(3)
         vprint(1,i) = zero
         vprint(2,i) = zero
         vprint(3,i) = zero
      enddo
c
c Remove net momentum of cell:
      call QMDSUBVCOM
c
      call GET_EKIN( md_natoms,atom_mass,vel, Ekin )
      call GET_TEMP_E( Ekin,md_nmodes, temp )
c
      factor = SQRT( tempinit/temp )
      call QMDVDAMP( factor )
c
      call GET_EKIN( md_natoms,atom_mass,vel, Ekin )
      call GET_TEMP_E( Ekin,md_nmodes, temp )
      Ekincurr = Ekin
      tempcurr = temp
      Ekinprnt = Ekin
      tempprnt = temp
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDVINIT2
c
c
      subroutine QMDVINIT2
c
c     Set velocities to 3/2 kT in random directions
c
c      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      IMPLICIT NONE
c
      DOUBLE PRECISION  zero,one,two
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      INTEGER  natmd
      PARAMETER  ( natmd =  400 )
      DOUBLE PRECISION  tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,   vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat
      INTEGER  md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,ieq_type
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
      DOUBLE PRECISION  fconst,tconst
c
c
c  Local declarations
      DOUBLE PRECISION  xm,vavg,Ekin,temp
      INTEGER  iseed
      INTEGER  iatm
      DIMENSION iseed(4)
      DATA  iseed /4,3,2,1/
c Probably a more intelligent set for iseed exists
      DOUBLE PRECISION  theta,phi
      DOUBLE PRECISION  pi,twopi
      DOUBLE PRECISION  Ekin_per_atom
c
c >>>> EXECUTABLE CODE:
c
      call QMDCONST( fconst, tconst )
      pi = DACOS( -1.0d0 )
      twopi = two*pi
c        
c     Set the initial temperature to 3/2 kT.
c     The factor of 2 accounts for the fact that half of this energy will
c     eventually go into potential modes.
      Ekin_per_atom = 2*1.5*tempinit*tconst 
c     
      do  iatm=1,md_natoms
         vavg = dsqrt(2d0*Ekin_per_atom*fconst/atom_mass(iatm))
c         
c        Does the following scheme bias toward equatorial vectors? -PAS
         call DLARUV( iseed,1, theta )
         theta = 2*pi*theta
         call DLARUV( iseed,1, phi )
         phi = pi*phi
c        
         vel(1,iatm) = vavg*dcos(theta)*dsin(phi)
         vel(2,iatm) = vavg*dsin(theta)*dsin(phi)
         vel(3,iatm) = vavg*dcos(phi)
         vprint(1,iatm) = zero
         vprint(2,iatm) = zero
         vprint(3,iatm) = zero
      enddo
c     
c      call QMDTEMPANAL( md_natoms,atom_mass,vel,fconst*tconst,
c     $     imd_wr)
c  Compute the raw temperature:
      call GET_TEMP_V( md_natoms,atom_mass,vel, Ekin,temp )
c  Do analysis of temperature over atom types:
      call TMONTEMP( -2 )
      write(imd_wr,*)   'VINIT: raw temp = ',temp
c
c  Remove net momentum:
      call QMDSUBVCOM
      call GET_TEMP_V( md_natoms,atom_mass,vel, Ekin,temp )
      Ekincurr = Ekin
      tempcurr = temp
      Ekinprnt = Ekin
      tempprnt = temp
c
      call TMONTEMP( -2 )
      write(imd_wr,*)  'VINIT: post subvcom temp = ',temp
c
c  Could, at this point, scale the velocities to get T, but since
c   this is initialization and we will miss target anyway, skip it.
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDVINIT
c
c
      subroutine QMDVINIT
c---------------------------------------------------------------
c Initialize atom velocities to random from Boltzmann distribution
c---------------------------------------------------------------
c
c      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      IMPLICIT NONE
c
      DOUBLE PRECISION  zero,one,two
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      integer natmd
      PARAMETER  ( natmd =  400 )
      DOUBLE PRECISION  tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,   vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat
      INTEGER  md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,ieq_type
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
      DOUBLE PRECISION  fconst,tconst
c
c  Local declarations
      DOUBLE PRECISION  pi,twopi
      INTEGER  iatm,i
      DOUBLE PRECISION  xm,vavg,v2mode,vmode, Ekin,temp
      DOUBLE PRECISION  Ekin_per_atom,Ekin_per_mode
cpas      DOUBLE PRECISION  DACOS,DSQRT
cpas      EXTERNAL  DACOS,DSQRT
c
c We use the DLARUV Lapack routine to generate a vector of random numbers
c from a uniform (0,1) distribution:
c  DLARUV( iseed, N, X )
c   iseed(4) - input/output: all elements 0:4095, iseed(4) must be odd
c   N - input: # random numbers to be generated in vector X(N), N.le.128
c   X(N) - output: vector of N random numbers
c  DLARNV( idist, iseed, N, Z ) offers different distributions:
c   idist=1/uniform(0:1), idist=2/uniform(-1:1), idist=3/normal(gaussian)
c We will use the A&T recommended Box-Muller method
c     u1,u2 from uniform distribution (0:1), to get normal distribution:
c     gdist = sqrt(-2*ln( u1 ) ) * cos( 2pi*u2 ) [also with sin(2pi*u2)]
c
      DOUBLE PRECISION  urndm, gdist
      INTEGER    iseed
      DIMENSION  urndm(2,3)
      DIMENSION  iseed(4)
c Probably could do a more intelligent set of input seeds than 4,3,2,1:
c At least select not so obviously trivial a set
      DATA  iseed / 1342, 731,3621, 331 /
c
c >>>> EXECUTABLE CODE:
c
      call QMDCONST( fconst, tconst )
      pi = DACOS( -1.0d0 )
      twopi = two*pi
c
c  This would set the initial temperature to 3/2 kT:
      Ekin_per_mode = 0.5d0*tempinit*tconst
      Ekin_per_atom = 1.5d0*tempinit*tconst
c  Add extra factor of 2: half this energy will seep into potential modes
c   (Note: this assumes that system is at/near equilibrium)
      Ekin_per_mode = two*Ekin_per_mode
      Ekin_per_atom = two*Ekin_per_atom
c
      write(imd_wr,*) 'Initialize MD velocities, Boltzmann distribution'
c
      do  iatm=1,md_natoms
c         vavg = DSQRT( 2d0*Ekin_per_atom*fconst/atom_mass(iatm) )
C         v2atom = two*Ekin_per_atom*fconst / atom_mass(iatm)
C         vatom = DSQRT( v2atom )
         v2mode = two*Ekin_per_mode*fconst / atom_mass(iatm)
         vmode = DSQRT( v2mode )
c
         call DLARUV( iseed, 6, urndm )
         do  i=1,3
           gdist = SQRT(-two*LOG(urndm(1,i)))*DCOS(twopi*urndm(2,i))
cccc          Should truncate this thing to prevent big excursions?
ccc           if( ABS(gdist) .gt. two ) gdist = two*gdist/ABS(gdist)
           vel(i,iatm) = vmode*gdist
         enddo
         vprint(1,iatm) = zero
         vprint(2,iatm) = zero
         vprint(3,iatm) = zero
      enddo
c
c      call QMDTEMPANAL( md_natoms,atom_mass,vel,fconst*tconst,
c     $     imd_wr )
c
c  Compute the temperature of the raw system:
      call GET_TEMP_V( md_natoms,atom_mass,vel, Ekin,temp )
c  Do analysis of temperature over atom types:
      call TMONTEMP( -2 )
      write(imd_wr,*)   'VINIT: raw temp = ',temp
c
c  Remove net momentum:
      call QMDSUBVCOM
      call GET_TEMP_V( md_natoms,atom_mass,vel, Ekin,temp )
      Ekincurr = Ekin
      tempcurr = temp
      Ekinprnt = Ekin
      tempprnt = temp
c
      call TMONTEMP( -1 )
      write(imd_wr,*)  'VINIT: post subvcom temp = ',temp
c
c  Could, at this point, scale the momenta to get T, but since
c   this is initialization and we will miss target anyway, skip it.
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDVDAMP
c
c
      subroutine QMDVDAMP( velfac )
c
c     Rescale the velocities by a desired factor
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
      do  iatm=1,md_natoms
         vel(1,iatm) = vel(1,iatm)*velfac
         vel(2,iatm) = vel(2,iatm)*velfac
         vel(3,iatm) = vel(3,iatm)*velfac
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GET_VCOM
c
c
      subroutine GET_VCOM( nat,atom_mass,vel, vcomx,vcomy,vcomz )
c
c     Compute the velocity of the center of mass
c
c     nat        The number of atoms
c     atom_mass  The mass of each atom
c     vel        The velocity of each atom
c     vcomx      The CoM velocity, x-direction
c     vcomy      The CoM velocity, y-direction
c     vcomz      The CoM velocity, z-direction
c
c     Rick Muller, September 2007
c
      IMPLICIT NONE
c
      DOUBLE PRECISION  zero,one,two
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
      INTEGER  nat
      DOUBLE PRECISION  atom_mass(nat),vel(3,nat),vcomx,vcomy,vcomz
c
      INTEGER  iatm
      DOUBLE PRECISION  xm,totmass,totatm
c
      vcomx = zero
      vcomy = zero
      vcomz = zero
      totmass = zero
      do  iatm=1,nat
         xm =atom_mass(iatm)
         totmass = totmass + xm
         vcomx = vcomx + atom_mass(iatm)*vel(1,iatm)
         vcomy = vcomy + atom_mass(iatm)*vel(2,iatm)
         vcomz = vcomz + atom_mass(iatm)*vel(3,iatm)
      enddo
c
      totatm = DBLE( nat )
c  Now divide by total mass to get net velocity of CoM
      vcomx = vcomx / totmass
      vcomy = vcomy / totmass
      vcomz = vcomz / totmass
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDSUBVCOM
c
c
      subroutine QMDSUBVCOM
c---------------------------------------------------------------
c Removes center-f-mass velocity from the cell
c---------------------------------------------------------------
c
c Make sure there is no net momentum in the cell
c Remove center-of-mass velocitu from all atoms to achieve this
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c >>>> EXECUTABLE CODE
c
      call GET_VCOM( md_natoms,atom_mass,vel, vcomx,vcomy,vcomz )
c
      write(imd_wr,'(a,1p3d12.4)') 'QMDSUBVCOM: Removing velocity_CM=',
     $ vcomx,vcomy,vcomz
c
      do  iatm=1,md_natoms
         xm = atom_mass(iatm)
         vel(1,iatm) = vel(1,iatm) - vcomx
         vel(2,iatm) = vel(2,iatm) - vcomy
         vel(3,iatm) = vel(3,iatm) - vcomz
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDPRINT
c
c
      subroutine QMDPRINT( ratm )
c     Print a snapshot of the current MD run
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
      COMMON /savepress/ presssave,prgpasave
c
c     Argument arrays
      dimension ratm(3,natmd),fatm(3,natmd)
c     Local variables
      character*2 sym
c
c >>>> EXECUTABLE CODE:
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c  Record current MD status to the standard output file
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if (itimestep .le. neqtsteps) then
         write(imd_wr,*) '<QMD0>'
      else
         write(imd_wr,*) '<QMD>'
      endif
c
      write(imd_wr,'(A,i8)') 'Nat:           ',md_natoms
c
      write(imd_wr,'(A,3F14.5)')
     $  'MDtemperature(K): target, T(t), T(t+1/2)=',
     $                     tempinit,tempprnt,tempcurr
c
      write(imd_wr,'(A,3F14.5)')
     $  'MDenergy(Ry;t) kin+pot=tot: ',
     $   Ekinprnt, Epot, Ekinprnt+Epot
c
      write(imd_wr,'(A,F12.5)') 'Pressure (GPa) ',prgpasave
c
      write(imd_wr,'(A,i8,F12.5,i8,i8)')
     $  'MDtime(fs) # dt tot eq: ',itimestep,timestep,ntsteps,neqtsteps
c
c     Consider putting in units for velocities (bohr/fs)??
      call GET_VCOM( md_natoms,atom_mass,vel, vcomx,vcomy,vcomz )
      write(imd_wr,'(A,F12.5,F12.5,F12.5)')
     $  'Vcom x y z:    ',vcomx,vcomy,vcomz
c
      write(imd_wr,*) 'Positions (bohr) and velocities (bohr/fs) at t'
      write(imd_wr,*) '#  mass  x   y   z   vx   vy   vz'
      do i = 1, md_natoms
        call round(atom_mass(i),imass)
        write(imd_wr,'(2i3,6f12.8)') i,imass,
     $        (ratm(j,i),j=1,3),
     $        (vprint(j,i),j=1,3)
      enddo
c
      write(imd_wr,*) 'Restart information'
      write(imd_wr,*) md_natoms
      write(imd_wr,'(2A,i8)') 'Quest pos (bohr), at t ',
     $     ' vel (bohr/fs) at t+1/2, for t = ',
     $     itimestep
      do i = 1, md_natoms
        call round(atom_mass(i),imass)
        call mass2sym(imass,sym)
        write(imd_wr,'(A2,6f12.8)') sym,(ratm(j,i),j=1,3),
     $        (vel(j,i),j=1,3)
      enddo
c
      write(imd_wr,'(a)')  'shv      - current Hoover parameter'
      write(imd_wr,'(2x,f18.8)')   shv 
c
      if (itimestep .le. neqtsteps) then
         write(imd_wr,*) '</QMD0>'
      else
         write(imd_wr,*) '</QMD>'
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     Dump the current snapshot to the lcao.vxyz file
c * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      call FLOPEN( ifl,'lcao.vxyz','UNK','FOR',ierror )
      if (ierror .ne. 0)
     $     call STOPXERR( 'QMDRESTART: error opening vxyz' )
c
      write(ifl,*) md_natoms
      write(ifl,'(2A,i8)') 'Quest pos (bohr), at t ',
     $     ' vel (bohr/fs) at t+1/2, for t = ',
     $     itimestep
      do i = 1, md_natoms
        call round(atom_mass(i),imass)
        call mass2sym(imass,sym)
        write(ifl,'(A2,6f12.8)') sym,(ratm(j,i),j=1,3),
     $        (vel(j,i),j=1,3)
      enddo
c
c Write out some information for clean thermostat continuation:
      write(ifl,'(a)')  'thermostat continuation data'
      write(ifl,'(a)')  'itimestep - index of current step in MD'
      write(ifl,'(2x,i12)')   itimestep
      write(ifl,'(a)')  'temp     - in-synch temp(t), not temp(t+dt)'
      write(ifl,'(2x,f18.8)')   tempprnt
      write(ifl,'(a)')  'Ekin     - in-synch Ekin(t), not Ekin(t+dt)'
      write(ifl,'(2x,f18.8)')   Ekinprnt
      write(ifl,'(a)')  'shv      - current Hoover parameter'
      write(ifl,'(2x,f18.8)')   shv 
      write(ifl,'(a)')  'end thermostat data'
c
      call FLCLOSE( ifl )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDTEMPANAL
c
c
      subroutine QMDTEMPANAL(nat,xm,v,xk,imd_wr)
      implicit none
      integer nat,i,imass,imd_wr
      character*2 sym
      double precision xm(nat),v(3,nat),xk,v2
c
      write(imd_wr,*) 'Temperature analysis'
      do i = 1, nat
        call round(xm(i),imass)
        call mass2sym(imass,sym)
        v2 = v(1,i)**2 + v(2,i)**2 + v(3,i)**2
        write(imd_wr,'(i4,x,a4,x,7f10.4)') i,sym,v2,xm(i)*v2/(3*xk)
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDUPDATE
c
c
      subroutine QMDUPDATE( ratm, fatm )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c     Argument arrays
      dimension ratm(3,natmd),fatm(3,natmd)
c The following are MD method id tags; they must match QMDTYPSET
      DATA imd_nve   ,imd_berend,imd_hoover,imd_tscale,imd_damped
     $    /    1     ,    2     ,    3     ,    4     ,    5     /
      DATA imd_anders,imd_hugoni,imd_langvn
     $    /    6     ,    7     ,    8     /
c
c >>>> EXECUTABLE CODE:
c
c     RPM: temporarily suspended, so see if this causes the 
c     temp difference between O and H. 9/4/2007
      call QMDSUBFCOM( fatm )
c
c Default to production MD settings
      tempinit = temp_md
      imdtype = md_type
      parstat = param_md
      if( itimestep .lt. neqtsteps )then
c       Equilibration phase - use equilibration MD settings
        write(imd_wr,*) 'MD-update: equilibration phase'
        tempinit = temp_eq
        imdtype = ieq_type
        parstat = param_eq
      endif
      if( itimestep .eq. neqtsteps )then
c       Turnover of thermostats, reset temperature monitor
        call TMONRESET( )
        shv = zero
      endif
c
      if( imdtype .eq. imd_nve    )then 
c       NVE/Microcanonical update, leapfrog-verlet
         write(imd_wr,*) 'MD-update: NVE/leapfrog'
         call QMDUPDATE_NVE_LF( ratm, fatm )
c
      elseif( imdtype .eq. imd_langvn )then 
c       NVT/Langevin thermostat, leapfrog-verlet
         write(imd_wr,*) 'MD-update: NVT/Langevin/leapfrog'
         call QMDUPDATE_LANGVN( ratm, fatm )
c
      elseif( imdtype .eq. imd_berend )then
c       NVT/Berendsen thermostat, leapfrog-verlet
         write(imd_wr,*) 'MD-update: NVT/Berendsen/leapfrog'
         call QMDUPDATE_BEREND( ratm, fatm )
c
      elseif( imdtype .eq. imd_hoover )then
c       NVT/Nose-Hoover thermostat, leapfrom-verlet
         write(imd_wr,*) 'MD-update: NVT/Hoover/leapfrog'
         call QMDUPDATE_HOOVER( ratm, fatm )
c
      elseif( imdtype .eq. imd_tscale )then
c       Temperature scaling, leapfrog-verlet
         write(imd_wr,*) 'MD-update: tscale/leapfrog'
         call QMDUPDATE_TSCALE( ratm, fatm )
c
      elseif( imdtype .eq. imd_damped )then
c       Damped dynamics, leapfrog-verlet
         write(imd_wr,*) 'MD-update: damped/leapfrog'
         call QMDUPDATE_DAMPED( ratm, fatm )
c
      else
         write(imd_wr,*) 'MD Type = ',imdtype,' not currently supported'
         call STOPXERR('QMDUPDATE - invalid MD type')
      endif
cdbg:start
c     RPM 9/17/2007
c     Remove the net momentum, if any.
c     This call should technically not be needed, and, if it fixes
c     things, we must investigate why it is necessary before checking
c     this into the main code
      call QMDSUBVCOM
cdbg:end
c
      itimestep = itimestep + 1
      maxtsteps = ntsteps + neqtsteps
c
c     Need to exit more gracefully (will let main code handle exit)
      if( itimestep .ge. maxtsteps )then
c        Do not call QMD a final time, here --- not in proper units!
C         call QMDPRINT( ratm )
         write(imd_wr,*) '>>>>> MD run completed at timestep ',itimestep
c        Do not stop here, pop up, let main handle final exit,
c         and let main handle the update and final vxyz properly
C         call STOPXOK( 'QMD Complete' )
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDSUBFCOM
c
c
      subroutine QMDSUBFCOM( fatm )
c---------------------------------------------------------------
c     Purify the forces to remove net forces on the Unit Cell
c     arising from numerical errors in force evaluation.
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c     Argument arrays
      dimension fatm(3,natmd)
c
      ftotx = zero
      ftoty = zero
      ftotz = zero
c
c     Compute the total net force present in the cell:
      do i = 1, md_natoms
         ftotx = ftotx + fatm(1,i)
         ftoty = ftoty + fatm(2,i)
         ftotz = ftotz + fatm(3,i)
      enddo
c
      totatom = DBLE( md_natoms )
      ftotx = ftotx / totatom
      ftoty = ftoty / totatom
      ftotz = ftotz / totatom
c
      write(imd_wr,'(a,1p3d12.4)')
     $ 'QMDSUBFCOM: Removing net cell force/atom=', ftotx,ftoty,ftotz
c
c     Subtract this from force on each atom
      do i = 1, md_natoms
         fatm(1,i) = fatm(1,i) - ftotx
         fatm(2,i) = fatm(2,i) - ftoty
         fatm(3,i) = fatm(3,i) - ftotz
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDUPDATE_NVE_LF
c
c
      subroutine QMDUPDATE_NVE_LF( ratm, fatm )
c---------------------------------------------------------------
c Purpose: do NVE (microcanonical) update, leapfrog verlet
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c     Argument arrays
      DIMENSION  ratm(3,natmd),fatm(3,natmd)
c
c >>>> EXECUTABLE CODE:
c
      call QMDCONST( fconst, tconst )
c
      call TMONPREP( )
c
      Ekin_t = zero
      Ekin_n = zero
      Ekin_at = zero
      Ekin_an = zero
c
      do  i=1,md_natoms
        xm = atom_mass(i)
        ax = fatm(1,i)*fconst/xm
        ay = fatm(2,i)*fconst/xm
        az = fatm(3,i)*fconst/xm
c
c       Advance the velocities and compute Ekin
c
c       Compute the off-synch velocity v(t+dt) for next step
        vnewx = vel(1,i) + timestep*ax
        vnewy = vel(2,i) + timestep*ay
        vnewz = vel(3,i) + timestep*az
        vn2 = vnewx*vnewx + vnewy*vnewy + vnewz*vnewz
        ekinn_atm = 0.5d0*xm*vn2/fconst
        Ekin_n = Ekin_n + ekinn_atm
c
c       But which velocity to use in KE?  v(t+d), v(t)?
c       Maybe neither.  Time-average v^2 around t where a(t) computed?
c       Could consider doing t-ave around vnew, the vel that will 
c       be used in the next update, but then a(t) less valid there.
c
c       Compute the in-synch velocity v(t)
        vtx = vel(1,i) + timestep*ax/2d0
        vty = vel(2,i) + timestep*ay/2d0
        vtz = vel(3,i) + timestep*az/2d0
        vt2 = vtx*vtx + vty*vty + vtz*vtz
        ekint_atm = 0.5d0*xm*vt2/fconst
        Ekin_t = Ekin_t + ekint_atm
c
c       KE averaged over this segment of the trajectory:
c       INT(-dt/2,+dt/2) (v+au)^2 du / dt = v^2+a^2dt^2/12.0
c
        accel2 = ax*ax + ay*ay + az*az
        dt2 = timestep*timestep
c
c        ... centered around in-synch position:
        vt2ave = (vt2 + accel2*dt2/12.0d0)
        akint_atm = 0.5d0 * xm*vt2ave/fconst
        Ekin_at = Ekin_at + akint_atm
c
c        ... centered around off-synch velocity:
        vn2ave = (vn2 + accel2*dt2/12.0d0)
        akinn_atm = 0.5d0 * xm*vn2ave/fconst
        Ekin_an = Ekin_an + akinn_atm
c
        call TMONATOM( i   ,ekint_atm,ekinn_atm,akint_atm,akinn_atm )
c
        vprint(1,i) = vtx
        vprint(2,i) = vty
        vprint(3,i) = vtz
c
c       Advance the positions
        ratm(1,i) = ratm(1,i) + timestep*vnewx
        ratm(2,i) = ratm(2,i) + timestep*vnewy
        ratm(3,i) = ratm(3,i) + timestep*vnewz
c
c       Save the new velocities
        vel(1,i) = vnewx
        vel(2,i) = vnewy
        vel(3,i) = vnewz
c
      enddo
c
c  Update the current temperature
      Ekincurr = Ekin_n
      call GET_TEMP_E( Ekincurr,md_nmodes, temp )
      tempcurr = temp
c  Update the in-synch temperature
      Ekinprnt = Ekin_t
      call GET_TEMP_E( Ekinprnt,md_nmodes, temp )
      tempprnt = temp
c
      write(imd_wr,'(a,2f12.3)') 'DBG/NVE: tempts(t,t+1/2)=',
     $ tempprnt,tempcurr
c
      call TMONSTEP( 'NVE' )
c
      Ekinmon = Ekinprnt
      Epotmon = Epot
c Emdmon should contain the heat bath energy, which is zero for NVE
      Emdmon = zero
      call TMONENGY( Ekinmon,Epotmon,Emdmon )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDUPDATE_TSCALE
c
c
      subroutine QMDUPDATE_TSCALE( ratm, fatm )
c---------------------------------------------------------------
c Purpose: NVE (microcanonical), leapfrog verlet update
c
c     Version of MD that does a Leapfrog step and then rescales
c     the velocities to match the temperature.
c
c     WARNING: This type of dynamics puts more energy into the 
c     heavy atoms than the light ones. Use at your own risk!
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c     Argument arrays
      DIMENSION  ratm(3,natmd),fatm(3,natmd)
c
c Local declarations:
      DATA  itypscale / 1 /
      DATA  lstoutmd / 2 /
c
c >>>> EXECUTABLE CODE:
c
c First, start with an NVE update ...
      call QMDUPDATE_NVE_LF( ratm, fatm )
c
c  ... and then scale the resulting velocities to the temperature
c
c  The simple scaling rule appears to work best (how so?)
c
      if( itypscale .eq. 1 )then
c       Simple Tscale: Tnew = tscale*Told + (1-tscale)*T
        tscale = parstat
        if( tscale .lt. zero .or. tscale .gt. one )then
          write(imd_wr,*) 'Simple Tscale factor must be (0,1):',tscale
          call STOPXERR( 'out-of-range factor for simple Tscale' )
        endif
C        velfac = SQRT( tempinit/tempcurr )
c       Let us try something with a parameter that makes this softer
        temp = tempinit + tscale*(tempcurr-tempinit)
        tfac = temp / tempcurr
        velfac = SQRT( tfac )
c
      if( lstoutmd .gt. 1 )
     $  write(imd_wr,'(a,f12.8,3f12.3)')
     $  'MD-Tscale: tscale, T,Told,Tnew=',
     $   tscale, tempinit,tempcurr,temp
c
      elseif( itypscale .eq. 2 )then
c       Alternate Tscale
c       (Berendsen, Postma, van Gunsteren, DiNola and Haak, 1984)
        tscale = 200d0
        tscale = parstat
        write(imd_wr,*) 'TSCALE: time scaling parameter=',tscale
        velfac = SQRT( one + (timestep/tscale)*(tempinit/tempcurr-one) )
c
      else
c       Invalid Tscale type
        call STOPXERR( 'invalid Tscale method' )
      endif
c
c  Now actually scale the velocities!
      call QMDVDAMP( velfac )
c
c  And get the output temperature
      call GET_EKIN( md_natoms,atom_mass,vel, Ekin )
      call GET_TEMP_E( Ekin,md_nmodes, temp )
      Ekincurr = Ekin
      tempcurr = temp
      Ekinprnt = Ekin
      tempprnt = temp
c
      call TMONSTEP( 'NVE' )
      Ekinmon = Ekinprnt
      Epotmon = Epot
c Emdmon should contain the heat bath energy, but not done yet
      Emdmon = zero
      call TMONENGY( Ekinmon,Epotmon,Emdmon )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDUPDATE_LANGVN
c
c
      subroutine QMDUPDATE_LANGVN( ratm, fatm )
c---------------------------------------------------------------
c Purpose: Langevin thermostat, leapfrom verlet update
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c     Argument arrays
      DIMENSION  ratm(3,natmd),fatm(3,natmd)
c Local declarations:
      DATA  lstoutmd / 2 /
c
c >>>> EXECUTABLE CODE:
c
      call STOPXERR( 'LANGVN thermostat not yet implemented' )
c
      call TMONPREP( )
      t_langvn = parstat
c
      if( lstoutmd .gt. 1 )
     $write(imd_wr,'(a,f12.3)') 'MD-Langvn: t_langvn(fs)=',t_langvn
c 
      call QMDCONST( fconst, tconst )
c
      call QMDUPDATE_NVE_LF( ratm, fatm )
c
      call GET_EKIN( md_natoms,atom_mass,vel, Ekin )
      call GET_TEMP_E( Ekin,md_nmodes, temp )
      Ekincurr = Ekin
      tempcurr = temp
      Ekinprnt = Ekin
      tempprnt = temp
c
      call TMONSTEP( 'LVN' )
c
      Ekinmon = Ekinprnt
      Epotmon = Epot
c Emdmon should contain the heat bath energy, but not done yet
      Emdmon = zero
      call TMONENGY( Ekinmon,Epotmon,Emdmon )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDUPDATE_DAMPED
c
c
      subroutine QMDUPDATE_DAMPED( ratm, fatm )
c---------------------------------------------------------------
c Purpose: damped dynamics, leapfrog verlet update
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c     Argument arrays
      DIMENSION  ratm(3,natmd),fatm(3,natmd)
c Local declarations:
      DATA  lstoutmd / 2 /
c
c >>>> EXECUTABLE CODE:
c
c     Take damping factor from current thermostat definition
      damping = parstat
c
      if( lstoutmd .gt. 1 )
     $write(imd_wr,'(a,f12.8)') 'MD-Damped: damping factor=',damping
c
      if( damping .gt. one .or. damping .lt. zero )then
        write(imd_wr,*) 'MD damping factor is invalid=',damping
        call STOPXERR( 'QMD damping factor is out-of-range' )
      endif
c
      call QMDUPDATE_NVE_LF( ratm, fatm )
      call QMDVDAMP( damping )
c
      call GET_EKIN( md_natoms,atom_mass,vel, Ekin )
      call GET_TEMP_E( Ekin,md_nmodes, temp )
      Ekincurr = Ekin
      tempcurr = temp
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDUPDATE_BEREND
c
c
      subroutine QMDUPDATE_BEREND( ratm, fatm )
c---------------------------------------------------------------
c Purpose: Berendsen thermostart, leapfrog verlet update
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c     Argument arrays
      DIMENSION  ratm(3,natmd),fatm(3,natmd)
c
c Local declarations:
      DATA  lstoutmd / 3 /
c
c >>>> EXECUTABLE CODE:
c
      call QMDCONST( fconst, tconst )
c Berendsen friction constant: t_berend
c  t_berend=time (fs) constant to scale connection to the friction
c  Allen&Tildesley quote Berendsen: t_b=0.4ps=400fs for water
c  The O-H stretch is ~10fs, hence this is over 40 vib periods.
c  t_berend has been converted into a user-settable input parameter
      t_berend = parstat
c
      if( lstoutmd .gt. 1 )
     $write(imd_wr,*) 'MD-BERENDSEN: t_berend(fs)=',t_berend
c
      s = ( one / (two*t_berend) ) * (tempcurr-tempinit)/tempcurr
c
      if( lstoutmd .gt. 3 ) write(imd_wr,'(a,i8,4f14.6)')
     $ 'BEREND/in:',itimestep,tempinit,tempcurr,Ekin,s
c
      call TMONPREP( )
c
      Ekin_t = zero
      Ekin_n = zero
      Ekin_at = zero
      Ekin_an = zero
c
      do  i=1,md_natoms
        xm = atom_mass(i)
        ax = fatm(1,i)*fconst/xm - s*vel(1,i)
        ay = fatm(2,i)*fconst/xm - s*vel(2,i)
        az = fatm(3,i)*fconst/xm - s*vel(3,i)
c
c       Advance the velocities and compute Ekin
c       
c       Compute the off-synch velocity v(t+dt) for next step
        vnewx = vel(1,i) + timestep*ax 
        vnewy = vel(2,i) + timestep*ay
        vnewz = vel(3,i) + timestep*az
        vn2 = vnewx*vnewx + vnewy*vnewy + vnewz*vnewz
        ekinn_atm = 0.5d0*xm*vn2/fconst
        Ekin_n = Ekin_n + ekinn_atm
c       
c       But which velocity to use in KE?  v(t+d), v(t)?
c       Maybe neither.  Time-average v^2 around t where a(t) computed?
c       Could consider doing t-ave around vnew, the vel that will
c       be used in the next update, but then a(t) less valid there.
c       
c       Compute the in-synch velocity v(t)
        vtx = vel(1,i) + timestep*ax/2d0
        vty = vel(2,i) + timestep*ay/2d0 
        vtz = vel(3,i) + timestep*az/2d0 
        vt2 = vtx*vtx + vty*vty + vtz*vtz
        ekint_atm = 0.5d0*xm*vt2/fconst
        Ekin_t = Ekin_t + ekint_atm
c       
c       KE averaged over this segment of the trajectory:
c       INT(-dt/2,+dt/2) (v+au)^2 du / dt = v^2+a^2dt^2/12.0
c
        accel2 = ax*ax + ay*ay + az*az
        dt2 = timestep*timestep
c     
c        ... centered around in-synch position:
        vt2ave = (vt2 + accel2*dt2/12.0d0)
        akint_atm = 0.5d0 * xm*vt2ave/fconst
        Ekin_at = Ekin_at + akint_atm
c
c        ... centered around off-synch velocity:
        vn2ave = (vn2 + accel2*dt2/12.0d0)
        akinn_atm = 0.5d0 * xm*vn2ave/fconst
        Ekin_an = Ekin_an + akinn_atm
c
        call TMONATOM( i   ,ekint_atm,ekinn_atm,akint_atm,akinn_atm )
c
        vprint(1,i) = vtx
        vprint(2,i) = vty
        vprint(3,i) = vtz
c       
c       Advance the positions
        ratm(1,i) = ratm(1,i) + timestep*vnewx
        ratm(2,i) = ratm(2,i) + timestep*vnewy
        ratm(3,i) = ratm(3,i) + timestep*vnewz
c       
c       Save the new velocities
        vel(1,i) = vnewx
        vel(2,i) = vnewy
        vel(3,i) = vnewz
c
      enddo
c
c  Update the current temperature
      Ekincurr = Ekin_n
      call GET_TEMP_E( Ekincurr,md_nmodes, temp )
      tempcurr = temp
c  Update the in-synch temperature
      Ekinprnt = Ekin_t
      call GET_TEMP_E( Ekinprnt,md_nmodes, temp )
      tempprnt = temp
c
      if( lstoutmd .gt. 4 )
     $write(imd_wr,'(a,2f12.3)') 'DBG/BER: tempts(t,t+1/2)=',
     $ tempprnt,tempcurr
c
      call TMONSTEP( 'BER' )
c
      Ekinmon = Ekinprnt
      Epotmon = Epot
c Emdmon should contain the heat bath energy, but not done yet
      Emdmon = zero
      call TMONENGY( Ekinmon,Epotmon,Emdmon )
c
      if( lstoutmd .gt. 3 ) write(imd_wr,'(a,4f12.6)')
     $ 'BEREND/out:',tempinit,tempcurr,Ekin
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDUPDATE_HOOVER
c
c
      subroutine QMDUPDATE_HOOVER( ratm, fatm )
c---------------------------------------------------------------
c Purpose: Nose/Hoover thermostart, leapfrog verlet update
c---------------------------------------------------------------
c
c This does a single-pass, non-self-consistent update.
c I.e., the temperature/velocities used as input to the Hoover are
c   from the previous step, T(t-1/2), but we actually use it as T(t),
c   to modify velocities/temperatures from t-1/2 to t+1/2 (leapfrog).
c However, with a short time step and a longer friction time constant,
c   where we are integrating over a large number of short steps,
c   this should wash out.
c But, it is something to think about how to do better in the future.
c   - 9Feb08-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
c     Argument arrays
      DIMENSION  ratm(3,natmd),fatm(3,natmd)
c Local declarations
      DATA  lstoutmd / 3 /
c
c >>>> EXECUTABLE CODE:
c
      call QMDCONST( fconst, tconst )
c Hoover friction constant
c  In A&T, X is generated as dX/dt=(f/Q) (Tcurr-Tinit)
c    f=# modes; Q=thermal inertia, but no guidance on how to set.
c    RPM had used Q=-2.d6, f=md_nmodes
c      Q = -2d6
c      xnu = md_nmodes/Q
c  Can also define (like here) as (1/t_h^2)*(Tcurr-Tinit)/Tcurr
c    where t_h is a time constant (for Troom water 20-100fs seems good)
c  This has been turned into a user-settable input parameter
      t_hoover = parstat
      x_hoover = one / ( tempinit * t_hoover**2 )
      etadot = x_hoover * ( tempcurr - tempinit )
c
      shv = shv + timestep*etadot
c
      if( lstoutmd .gt. 1 )then
        write(imd_wr,9010) 'MD-Hoover: t_hoover(fs)=',t_hoover
      endif
      if( lstoutmd .gt. 3 )then
        write(imd_wr,9010) 'MD-Hoover: xnu   =',x_hoover
        write(imd_wr,9010) 'MD-Hoover: etadot=',etadot
      endif
      if( lstoutmd .gt. 2 )then
        write(imd_wr,9011) 'HoovComp(T,Tcurr,shv):',
     $   itimestep,tempinit,tempcurr,shv
      endif
 9010 format(1x,a,1pd15.8)
 9011 format(1x,a,1x,i7,1x,2f12.3,1x,1pd15.8)
c
      call TMONPREP( )
c
      Ekin_t = zero
      Ekin_n = zero
      Ekin_at = zero
      Ekin_an = zero
c
      do  i=1,md_natoms
        xm = atom_mass(i)
        ax = fatm(1,i)*fconst/xm - shv*vel(1,i)
        ay = fatm(2,i)*fconst/xm - shv*vel(2,i)
        az = fatm(3,i)*fconst/xm - shv*vel(3,i)
c
c       Advance the velocities and compute Ekin
c       
c       Compute the off-synch velocity v(t+dt) for next step
        vnewx = vel(1,i) + timestep*ax 
        vnewy = vel(2,i) + timestep*ay
        vnewz = vel(3,i) + timestep*az
        vn2 = vnewx*vnewx + vnewy*vnewy + vnewz*vnewz
        ekinn_atm = 0.5d0*xm*vn2/fconst
        Ekin_n = Ekin_n + ekinn_atm
c       
c       But which velocity to use in KE?  v(t+d), v(t)?
c       Maybe neither.  Time-average v^2 around t where a(t) computed?
c       Could consider doing t-ave around vnew, the vel that will
c       be used in the next update, but then a(t) less valid there.
c       
c       Compute the in-synch velocity v(t)
        vtx = vel(1,i) + timestep*ax/2d0
        vty = vel(2,i) + timestep*ay/2d0 
        vtz = vel(3,i) + timestep*az/2d0 
        vt2 = vtx*vtx + vty*vty + vtz*vtz
        ekint_atm = 0.5d0*xm*vt2/fconst
        Ekin_t = Ekin_t + ekint_atm
c       
c       KE averaged over this segment of the trajectory:
c       INT(-dt/2,+dt/2) (v+au)^2 du / dt = v^2+a^2dt^2/12.0
c
        accel2 = ax*ax + ay*ay + az*az
        dt2 = timestep*timestep
c     
c        ... centered around in-synch position:
        vt2ave = (vt2 + accel2*dt2/12.0d0)
        akint_atm = 0.5d0 * xm*vt2ave/fconst
        Ekin_at = Ekin_at + akint_atm
c
c        ... centered around off-synch velocity:
        vn2ave = (vn2 + accel2*dt2/12.0d0)
        akinn_atm = 0.5d0 * xm*vn2ave/fconst
        Ekin_an = Ekin_an + akinn_atm
c
        call TMONATOM( i   ,ekint_atm,ekinn_atm,akint_atm,akinn_atm )
c
        vprint(1,i) = vtx
        vprint(2,i) = vty
        vprint(3,i) = vtz
c       
c       Advance the positions
        ratm(1,i) = ratm(1,i) + timestep*vnewx
        ratm(2,i) = ratm(2,i) + timestep*vnewy
        ratm(3,i) = ratm(3,i) + timestep*vnewz
c       
c       Save the new velocities
        vel(1,i) = vnewx
        vel(2,i) = vnewy
        vel(3,i) = vnewz
c
      enddo
c
c  Update the current temperature
      Ekincurr = Ekin_n
      call GET_TEMP_E( Ekincurr,md_nmodes, temp )
      tempcurr = temp
c  Update the in-synch temperature
      Ekinprnt = Ekin_t
      call GET_TEMP_E( Ekinprnt,md_nmodes, temp )
      tempprnt = temp
c
      if( lstoutmd .gt. 4 )
     $write(imd_wr,'(a,2f12.3)') 'DBG/HVR: tempts(t,t+1/2)=',
     $ tempprnt,tempcurr
c
      call TMONSTEP( 'HVR' )
      Ekinmon = Ekinprnt
      Epotmon = Epot
c Emdmon should contain the heat bath energy, but not done yet
      Emdmon = zero
      call TMONENGY( Ekinmon,Epotmon,Emdmon )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDCONVCHK
c
c
      subroutine QMDCONVCHK( igstat )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
      maxtsteps = ntsteps + neqtsteps
c
c itimestep is zero-indexed. Increment for proper stop-check
c
      if( (itimestep+1) .lt. maxtsteps )then
c       Set igstat to 0=continue
        igstat = 0
      else
c       Set to 1=out-of-steps, not 2="converged"
        igstat = 1
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GET_TEMP_V
c
c
      subroutine GET_TEMP_V( nat,atom_mass,vel, Ekin,temp)
c
c     A function that computes the kinetic energy from
c     the number of atoms, the mass of each atom, 
c     and the velocities of each atom
c
c     nat        The number of atoms
c     atom_mass  The mass of each atom in atomic units
c     vel        The velocity of each atom in bohr/fs
c     ekin[out]  The kinetic energy in Ry
c     temp[out]  The temperature in Kelvin
c
c     WARNING: for simplicity, this routine assumes that 
c     md_nmodes = 3*nat.
c
c     Rick Muller, September 2008
c
      IMPLICIT NONE
c
      DOUBLE PRECISION  zero,one,two
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
      integer nat
      double precision atom_mass(nat),vel(3,nat),v2,ekin,
     $     temp
c
      call GET_EKIN( nat,atom_mass,vel, ekin )
      call GET_TEMP_E( ekin,3*nat, temp )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GET_EKIN
c
c
      subroutine GET_EKIN( nat,atom_mass,vel, ekin )
c
c     A function that computes the kinetic energy from
c     the number of atoms, the mass of each atom, 
c     and the velocities of each atom
c
c     nat        The number of atoms
c     atom_mass  The mass of each atom in atomic units
c     vel        The velocity of each atom in bohr/fs
c     ekin[out]  The kinetic energy in Ry
c
c     Rick Muller, September 2008
c
      IMPLICIT NONE
c
      DOUBLE PRECISION  zero,one,two
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
      double precision fconst,tconst
      integer nat,i
      double precision atom_mass(nat),vel(3,nat),v2,ekin
      double precision ddot
      external ddot
c
      call QMDCONST( fconst, tconst )
      ekin = zero
      do i=1,nat
         v2 = ddot(3,vel(1,i),1,vel(1,i),1)
         ekin = ekin + 0.5d0*atom_mass(i)*v2/fconst
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> GET_TEMP_E
c
c
      subroutine GET_TEMP_E( ekin,nmodes, temp )
c
c     A function that computes the temperature in K from
c     the kinetic energy per mode in Ry
c
c     Rick Muller, September 2008
c
      IMPLICIT NONE
c
      DOUBLE PRECISION  zero,one,two
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
      double precision fconst,tconst
      integer nmodes
      double precision ekin,temp
c
      call QMDCONST( fconst, tconst )
      temp = 2d0*ekin/(tconst*dble(nmodes))
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDEPSET
c
c
      subroutine QMDEPSET(epotin)
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c
      Epot = epotin
      return
      end
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ROUND
c
c
      subroutine round(fnum,inum)
c     Simple rounding
      IMPLICIT NONE
c
      double precision fnum, rem
      integer inum
c
      inum = int(fnum)
      rem = fnum-inum
      if (rem .gt. 0.5) inum = inum + 1
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDCONST
c
c
      subroutine QMDCONST( fconvert, tconvert )
c---------------------------------------------------------------
c Purpose: energy conversion, and temperature conversion factors
c---------------------------------------------------------------
c
c fconst converts atomic mass units into E[Ry]*t[fs]^2/r[bohr]^2
c    Internal units: fs, Ry, bohr, amu; Output=KE in Rydberg
c    Essentially it converts mv^2/2 into KE, where m is in
c    atomic mass units, v is in bohr/fs, and KE is in Rydberg.
c    fconst = ( Ry*(fs^2)/bohr^2 ) / amu
c    Or, how to best compute it: amu*(bohr/fs)^2 = Ry * fconst
c    Equivalently, think of to convert F/m into a, where
c    F is (Ry/bohr), a is bohr/fs^2, and m is amu.
c
c tconst converts Kelvin to Ry: tconst = Ry/Kelvin
c
      IMPLICIT NONE
c
      DOUBLE PRECISION  fconst, tconst
      DOUBLE PRECISION  fconvert, tconvert
      PARAMETER  ( fconst = 0.468786d0, tconst = 6.3358d-6 )
c
      fconvert = fconst
      tconvert = tconst
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MASS2SYM
c
c
      subroutine mass2sym( imass, symb )
c  Convert the rounded mass to a symbol; symbols only defined
c  through Hg (symbols now defined through Lr, masses only through Hg )
c  8Feb13-PAS/2.65: call new (expanded) symbol table; cosmetics
      IMPLICIT NONE
c
      INTEGER  imass,iatno
      CHARACTER*2 symb
c
      call mass2atno( imass,iatno )
C      call atno2symbol( iatno,symb )
      call ELEMZ2SYMB( iatno, symb )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MASS2ATNO
c
c
      subroutine mass2atno( imass, iatno )
c  Convert rounded mass to atomic number; only defined through Hg
c  8Feb13-PAS/2.65: protect from bad (out-of-range) input; cosmetics
c
      IMPLICIT NONE
      INTEGER imass,iatno,  numtable(201)
      DATA    numtable
     $  / 1, 0, 0, 2, 0,      0, 3, 0, 4, 0,     5, 6, 0, 7, 0,
     $    8, 0, 0, 9, 10,     0, 0, 11, 12, 0,   0, 13, 14, 0, 0,
     $   15, 16, 0, 0, 17,    0, 0, 0, 19, 20,   0, 0, 0, 0, 21, 
     $    0, 0, 22, 0, 0,    23, 24, 0, 0, 25,  26, 0, 0, 28, 0,
     $    0, 0, 0, 29, 30,    0, 0, 0, 0, 31,    0, 0, 32, 0, 33,
     $    0, 0, 0, 34, 35,    0, 0, 0, 36, 37,   0, 0, 38, 39, 0,
     $   40, 0, 41, 0, 0,    42, 0, 43, 0, 0,   44, 0, 45, 0, 0,
     $   46, 0, 47, 0, 0,     0, 48, 0, 0, 49,   0, 0, 0, 50, 0,
     $    0, 51, 0, 0, 0,     0, 53, 52, 0, 0,  54, 0, 55, 0, 0,
     $    0, 56, 0, 57, 58,  59, 0, 0, 60, 61,   0, 0, 0, 0, 62,
     $    0, 63, 0, 0, 0,     0, 64, 0, 65, 0,   0, 0, 66, 0, 67,
     $    0, 68, 0, 69, 0,    0, 0, 70, 0, 71,   0, 0, 72, 0, 0,
     $   73, 0, 0, 74, 0,    75, 0, 0, 0, 76,    0, 77, 0, 0, 78,
     $    0, 79, 0, 0, 0,    80                 /
cxxx: check if Z=53,52 are truly in inverse order of mass, for table
c
      if( imass .gt. 0 .and. imass .le. 120 )then
        iatno = numtable(imass)
      else
c       Assign a Z=0 to an invalid/out-of-range input
        iatno = 0
      endif
c     If we can't determine a good atomic number, just return Carbon's
      if( iatno .eq. 0 ) iatno = 6
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ATNO2SYMBOL
c
c
cxxx subroutine atno2symbol(iatno,sym) ! is this safe to be retired now?
cxxx This routine now replaced by new general "element" module routine 8Feb13-PAS
      subroutine xxx_at2symb(iatno,sym)
c     Convert the atomic number to a two character symbol
      IMPLICIT NONE
      integer iatno
      character*2 sym,symtable(80)
      data symtable/'H ', 'He', 'Li', 'Be', 'B ', 'C ', 'N ', 'O ',
     $     'F ', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P ', 'S ', 'Cl',
     $     'Ar', 'K ', 'Ca', 'Sc', 'Ti', 'V ', 'Cr', 'Mn', 'Fe',
     $     'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br',
     $     'Kr', 'Rb', 'Sr', 'Y ', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru',
     $     'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I ',
     $     'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm',
     $     'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu',
     $     'Hf', 'Ta', 'W ', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg'/
      sym = symtable(iatno)
      return
      end
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TMON
c
c
c---------------------------------------------------------------
c Purpose: monitor temperature over atom types in a MD simulation
c
c Routines:
c  TMONINIT( natm, itypa ) - load type-by-atom information into module
c  TMONRESET( ) - clear running totals to zero/initialize sums
c  TMONPREP( ) - clear ekin sums
c  TMONATOM( i,e1,e2,e3,e4 ) - load ekin for specific atom
c  TMONSTEP( ) - do temperature analysis as of this step
c  TMONENGY( ke,pe,xe,tote ) - do energy analysis as of this step
c  TMONTEMP( ) - evaluate temperature over types for given vel()
c
c Revision history:
c  24Sep08-PAS/2.62: add zero=0 initialize into TMONSTEP/ENGY
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TMONINIT
c
c
      subroutine TMONINIT( natm,itypa )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c QMD/monitor data
      PARAMETER  ( ntypmond=6 )
      COMMON /qmdtmon/ sumttyp(ntypmond,4),sumt100(ntypmond,4),
     $ sumengy(4),sume100(4),
     $ ektyp(ntypmond,4),modesty(ntypmond),itypmon(natmd),ntypmon,ntemp
c
c Input arguments:
      DIMENSION  itypa(natm)
c
c >>>> EXECUTABLE CODE
c
      itypmax = 1
      do  iatm=1,natm
        ityp = itypa(iatm)
        if( ityp .gt. itypmax ) itypmax = ityp
        if( ityp .ge. (ntypmond-1) )then
c         With more types than monitor slots, lump excess together
          itypmon(iatm) = ntypmond - 1
        elseif( ityp .ge. 0 )then
c         Put it into its appropriate slot
          itypmon(iatm) = ityp
        endif
      enddo
      if( itypmax .ge. ntypmond ) itypmax = ntypmond - 1
      ntypmon = itypmax
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TMONRESET
c
      subroutine TMONRESET( )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero=0.d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c QMD/monitor data
      PARAMETER  ( ntypmond=6 )
      COMMON /qmdtmon/ sumttyp(ntypmond,4),sumt100(ntypmond,4),
     $ sumengy(4),sume100(4),
     $ ektyp(ntypmond,4),modesty(ntypmond),itypmon(natmd),ntypmon,ntemp
c
c >>>> EXECUTABLE CODE:
c
      ntemp = 0
c
      do  imon=1,4
        do  ityp=1,ntypmond
          sumttyp(ityp,imon) = zero
          sumt100(ityp,imon) = zero
        enddo
      enddo
c
      do  ityp=1,4
        sumengy(ityp) = zero
        sume100(ityp) = zero
      enddo
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TMONPREP
c
      subroutine TMONPREP( )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero=0.d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c QMD/monitor data
      PARAMETER  ( ntypmond=6 )
      COMMON /qmdtmon/ sumttyp(ntypmond,4),sumt100(ntypmond,4),
     $ sumengy(4),sume100(4),
     $ ektyp(ntypmond,4),modesty(ntypmond),itypmon(natmd),ntypmon,ntemp
c
c >>>> EXECUTABLE CODE:
c
      do  imon=1,4
        do  ityp=1,ntypmond
          ektyp(ityp,imon) = zero
        enddo
      enddo
      do  ityp=1,ntypmond
        modesty(ityp) = 0
      enddo
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TMONATOM
c
      subroutine TMONATOM( iatm, ekint_a,ekinn_a,akint_a,akinn_a )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero=0.d0 )
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c QMD/monitor data
      PARAMETER  ( ntypmond=6 )
      COMMON /qmdtmon/ sumttyp(ntypmond,4),sumt100(ntypmond,4),
     $ sumengy(4),sume100(4),
     $ ektyp(ntypmond,4),modesty(ntypmond),itypmon(natmd),ntypmon,ntemp
c
c >>>> EXECUTABLE CODE:
c
      ityp = itypmon(iatm)
      if( ityp .ge. ntypmond ) ityp = ntypmond - 1
c
      ektyp(ityp,1) = ektyp(ityp,1) + ekint_a
      ektyp(ityp,2) = ektyp(ityp,2) + ekinn_a
      ektyp(ityp,3) = ektyp(ityp,3) + akint_a
      ektyp(ityp,4) = ektyp(ityp,4) + akinn_a
      modesty(ityp) = modesty(ityp) + 3
c
      ityp = ntypmond
      ektyp(ityp,1) = ektyp(ityp,1) + ekint_a
      ektyp(ityp,2) = ektyp(ityp,2) + ekinn_a
      ektyp(ityp,3) = ektyp(ityp,3) + akint_a
      ektyp(ityp,4) = ektyp(ityp,4) + akinn_a
      modesty(ityp) = modesty(ityp) + 3
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TMONSTEP
c
      subroutine TMONSTEP( chtstat )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero = 0.d0 )
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c QMD/monitor data
      PARAMETER  ( ntypmond=6 )
      COMMON /qmdtmon/ sumttyp(ntypmond,4),sumt100(ntypmond,4),
     $ sumengy(4),sume100(4),
     $ ektyp(ntypmond,4),modesty(ntypmond),itypmon(natmd),ntypmon,ntemp
c
c Input declarations:
      CHARACTER*3  chtstat
c Local declarations
      DIMENSION  tempty(ntypmond),tavety(ntypmond)
c
      DATA  lvlprnt / 3 /
c
c >>>> EXECUTABLE CODE:
c
      ntemp = ntemp + 1
      rntemp = DBLE( ntemp)
c
      do 1000 imon=1,4
c
        do  ityp=1,ntypmon
          Ekin = ektyp(ityp,imon)
          modes = modesty(ityp)
          call GET_TEMP_E( Ekin,modes, temp )
          tempty(ityp) = temp
          sumttyp(ityp,imon) = sumttyp(ityp,imon) + temp
          sumt100(ityp,imon) = sumt100(ityp,imon) + temp
        enddo
c
        ityp = ntypmond
        Ekin = ektyp(ityp,imon)
        modes = modesty(ityp)
        call GET_TEMP_E( Ekin,modes, temp )
        tempall = temp
        sumttyp(ityp,imon) = sumttyp(ityp,imon) + temp
        sumt100(ityp,imon) = sumt100(ityp,imon) + temp
c
        do  ityp=1,ntypmon
          tavety(ityp) = sumttyp(ityp,imon) / rntemp
        enddo
        ityp = ntypmond
        taveall = sumttyp(ityp,imon) / rntemp
c       
        if( lvlprnt .gt. 2 )then
          write(imd_wr,9100) chtstat,'TEMP',imon,'(typs;all)=',
     $     itimestep,ntemp,(tempty(ityp),ityp=1,ntypmon),tempall
          write(imd_wr,9100) chtstat,'ave temps',imon,'(typs;all)=',
     $     itimestep,ntemp,(tavety(ityp),ityp=1,ntypmon),taveall
        endif
c
 1000 continue
c
 9100 format(1x,a3,a,i1,a,i8,i7,3x,6f10.3)
c
c Also do averages over even nbunch's of steps:
c
      ibunch = 100
      nbunch = ntemp / ibunch
      ntempx = nbunch*ibunch
      if( ntempx .eq. ntemp )then
c       We have an even nbunch, put out the average over ibunch
c
        rntemp = DBLE( ibunch )
        do  imon=1,4
          do  ityp=1,ntypmon
            tavety(ityp) = sumt100(ityp,imon) / rntemp
            sumt100(ityp,imon) = zero
          enddo
          ityp = ntypmond
          taveall = sumt100(ityp,imon) / rntemp
          sumt100(ityp,imon) = zero
c
          if( lvlprnt .gt. 1 )then
            write(imd_wr,9100) chtstat,'last100T',imon,'(typs;all)=',
     $      itimestep,ntemp,(tavety(ityp),ityp=1,ntypmon),taveall
          endif
        enddo
c
      endif
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TMONENGY
c
      subroutine TMONENGY( Ekinmon,Epotmon,Emdmon )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero = 0.d0 )
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c QMD/monitor data
      PARAMETER  ( ntypmond=6 )
      COMMON /qmdtmon/ sumttyp(ntypmond,4),sumt100(ntypmond,4),
     $ sumengy(4),sume100(4),
     $ ektyp(ntypmond,4),modesty(ntypmond),itypmon(natmd),ntypmon,ntemp
c
c Local declarations
      DIMENSION  engyave(4)
c
      DATA  lvlprnt / 3 /
c
c >>>> EXECUTABLE CODE:
c
      rntemp = DBLE( ntemp)
c
        Etotmon = Ekinmon + Epotmon + Emdmon
        sumengy(1) = sumengy(1) + Ekinmon
        sumengy(2) = sumengy(2) + Epotmon
        sumengy(3) = sumengy(3) + Emdmon 
        sumengy(4) = sumengy(4) + Etotmon
        sume100(1) = sume100(1) + Ekinmon
        sume100(2) = sume100(2) + Epotmon
        sume100(3) = sume100(3) + Emdmon 
        sume100(4) = sume100(4) + Etotmon
c
        do  ityp=1,4
          engyave(ityp) = sumengy(ityp) / rntemp
        enddo
c       
        if( lvlprnt .gt. 4 )then
          write(imd_wr,9100) 'MDENGYAVE (ke,pe,xe,tote)=',
     $     itimestep,ntemp,(engyave(ityp),ityp=1,4)
        endif
c
 1000 continue
c
 9100 format(1x,a,i8,i7,3x,4f15.5)
c
c Also do averages over even nbunch's of steps:
c
      ibunch = 100
      nbunch = ntemp / ibunch
      ntempx = nbunch*ibunch
      if( ntempx .eq. ntemp )then
c       We have an even nbunch, put out the average over ibunch
c
        rntemp = DBLE( ibunch )
c
          do  ityp=1,4
            engyave(ityp) = sume100(ityp) / rntemp
            sume100(ityp) = zero
          enddo
c
          if( lvlprnt .gt. 1 )then
            write(imd_wr,9100) 'MDlast100E (ke,pe,xe,tote)=',
     $      itimestep,ntemp,(engyave(ityp),ityp=1,4)
          endif
c
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TMONTEMP
c
c
      subroutine TMONTEMP( itemp )
c---------------------------------------------------------------
c Purpose: look at temperature by atom type for new velocities
c Written: 17Feb08-PAS for 2.61
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0d0, one=1d0, two=2d0 )
c
c QMD Module declarations:
      PARAMETER  ( natmd =  400 )
      DIMENSION  vel(3,natmd),atom_mass(natmd),vprint(3,natmd)
      COMMON /questmd/ tempinit,tempcurr,tempprnt,timestep,
     $     Ekinprnt,Ekincurr,Epot,shv,vel,
     $     atom_mass,md_type,ntsteps,neqtsteps,md_natoms,itimestep,
     $     md_nmodes,imd_wr,irestarted,vprint,temp_eq,temp_md,
     $     param_eq,param_md,parstat,ieq_type
c QMD/monitor data
      PARAMETER  ( ntypmond=6 )
      COMMON /qmdtmon/ sumttyp(ntypmond,4),sumt100(ntypmond,4),
     $ sumengy(4),sume100(4),
     $ ektyp(ntypmond,4),modesty(ntypmond),itypmon(natmd),ntypmon,ntemp
c
c Local declarations
      DIMENSION  tempty(ntypmond)
c
c >>>> EXECUTABLE CODE:
c
      call QMDCONST( fconst, tconst )
c
      do  ityp=1,ntypmond
        ektyp(ityp,1) = zero
        modesty(ityp) = 0
      enddo
c
      do  iatm=1,md_natoms
        xm = atom_mass(iatm)
c
        vtx = vel(1,iatm)
        vty = vel(2,iatm)
        vtz = vel(3,iatm)
        vt2 = vtx*vtx + vty*vty + vtz*vtz
        ekint_atm = 0.5d0*xm*vt2 / fconst
c
        ityp = itypmon(iatm)
        ektyp(ityp,1) = ektyp(ityp,1) + ekint_atm
        modesty(ityp) = modesty(ityp) + 3
        ityp = ntypmond
        ektyp(ityp,1) = ektyp(ityp,1) + ekint_atm
        modesty(ityp) = modesty(ityp) + 3
      enddo
c
      do  ityp=1,ntypmon
        Ekin = ektyp(ityp,1)
        modes = modesty(ityp)
        call GET_TEMP_E( Ekin,modes,temp )
        tempty(ityp) = temp
      enddo
      ityp = ntypmond
      Ekin = ektyp(ityp,1)
      modes = modesty(ityp)
      call GET_TEMP_E( Ekin,modes,temp )
      tempall = temp
c       
      write(imd_wr,9101) 'TEMPS1: (typs;all)=',itemp,
     $ (tempty(ityp),ityp=1,ntypmon),tempall
 9101 format(1x,a,i6,1x,6f10.3)
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> QMDDAT
c
c
      subroutine QMDDAT( IWR,IDAT )
c--------------------------------------------------------------
c Purpose: set parameters for Quest-MD run
c Written: Richard P. Muller, for 2.58 (MD)
c Revision history:
c   9Apr15-PAS/2.66 lnwrite lines
c  10Feb08-PAS/2.61: wire in more thermostat controls
c  10May04-PAS/2.58: extracted to Quest code, and polished
c--------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( nline = 128 )
      CHARACTER  label*(nline), readlbl*6, wantlbl*6
      EQUIVALENCE  (label,readlbl)
      CHARACTER  mdlabel*8
      INTEGER    istart, iend
c
c >>>> EXECUTABLE CODE:
c
 8000 format(a128)
 9000 format(1x,a)
 9010 format(1x,3f20.8)
c
 100  continue
      read(IDAT,8000,err=1300,end=1300)  label
      call LNWRIT( IWR, label, nline )
c
cqmd: "end dynamics" OR "end md" in qmdinput
      if( readlbl .eq. 'end dy' .or.
     $    readlbl .eq. 'end md' )then
c       End of MD data input section
        goto 900
c
      elseif( readlbl .eq. 'dynami' .or.
     $        readlbl .eq. 'md dat' )then
c       Start of dynamics data input
        write(IWR,*) '>>> Reading MD data'
c
      elseif( readlbl .eq. 'timest' )then
c       Set time step for dynamics (fs)
        read(IDAT,*)  dt_md
        write(IWR,'(1x,f10.5)')  dt_md
        call QMDTSTEPSET( dt_md )
c
      elseif( readlbl .eq. 'md_met' )then
c       Specify MD method/thermostat
        read(IDAT,8000,err=1300,end=1300)  label
        call LNWRIT( IWR, label, nline )
c
        call STRPARS( label, 1,72, istart, iend)
        if( istart .eq. 0 ) call STOPXERR('no md type - blank label')
        mdlabel = '        '
        iend = MIN( iend, istart+7 )
        nlbl = iend - istart + 1
        mdlabel(1:nlbl) = label(istart:iend)
        call QMDTYPSET( 4, mdlabel )
c
      elseif( readlbl .eq. 'md_par' )then
c       Set thermostat param - equilibrarion phase
c        (damp for Tscale/Langvn, time for Berend,Hoover)
        read(IDAT,*)  factormd
        write(IWR,'(1x,f14.5)')  factormd
        call QMDPARAMSET( factormd )
c
      elseif( readlbl .eq. 'md_ste' )then
c       Set number of (thermalized) MD steps
        read(IDAT,*)  nstep
        write(IWR,'(1x,i8)')  nstep
        call QMDNTSTEPSET( nstep )
c
      elseif( readlbl .eq. 'md_tem' )then
c       Set temperature (Kelvin) for MD simulation
        read(IDAT,*)  temp
        write(IWR,'(1x,f14.5)')  temp
        call QMDTEMPSET( temp )
c
      elseif( readlbl .eq. 'eq_met' )then
c       Specify equilibration method/thermostat
        read(IDAT,8000,err=1300,end=1300)  label
        call LNWRIT( IWR, label, nline )
c
        call STRPARS( label, 1,72, istart, iend )
        if( istart .eq. 0 ) call STOPXERR('no md type - blank label')
        mdlabel = '        '
        iend = MIN( iend, istart+7 )
        nlbl = iend - istart + 1
        mdlabel(1:nlbl) = label(istart:iend)
        call QMDTYPSET( 1, mdlabel )
c
      elseif( readlbl .eq. 'eq_par' )then
c       Set thermostat param - equilibrarion phase
c        (damp for Tscale/Langvn, time for Berend,Hoover)
        read(IDAT,*)  factormd
        write(IWR,'(1x,f14.5)')  factormd
        call QMDEQPARSET( factormd )
c
      elseif( readlbl .eq. 'equili' .or. readlbl .eq. 'eq_ste' )then
c       Set number of equilibration steps
        read(IDAT,*)  nstep
        write(IWR,'(1x,i8)')  nstep
        call QMDNEQSTEPSET( nstep )
c
      elseif( readlbl .eq. 'eq_tem' )then
c       Set temperature (Kelvin) for equilibration
        read(IDAT,*)  temp
        write(IWR,'(1x,f14.5)')  temp
        call QMDEQTSET( temp )
c
      else
c       Did not find a matching keyword
        call STOPXERR('qmddat - unknown keyword')
c
      endif
c
      goto 100
c
c  Error Handling
c
 1300 continue
      write(IWR,*)  'QMD data: error/end reading QMD data'
      write(IWR,*) readlbl
      call STOPXERR( 'QMDDAT: format error in input file' )
c
c  Normal return
c
 900  continue
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DAT0QMD
c
c
      subroutine DAT0QMD
c--------------------------------------------------------------
c Purpose: set defaults for Quest-MD run
c Written: Richard P. Muller, for 2.58 (MD)
c Revision history:
c  10Feb08-PAS/2.61: wire in more thermostat controls
c  10May04-PAS/2.58: extracted to Quest code, and polished
c--------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c >>>> EXECUTABLE CODE:
c
c Set default output to Quest output:
      call FLGETIWR( IWR )
      call QMDSETIWR( IWR )
c
c Set default MD method to microcanonical ensemble - NVE
      call QMDTYPSET( 4, 'NVE   ' )
c
c Set default equilibration method to TSCALE
      call QMDTYPSET( 1, 'TSCALE' )
c
c Set default temperature (Kelvin) for MD simulation
      temp = 300.d0
      call QMDTEMPSET( temp )
c
c Set default temperature (Kelvin) for equilibration
      temp = 300.d0
      call QMDTEMPSET( temp )
c
c Set default time step (fs)
      dt_md = 0.5
      call QMDTSTEPSET( dt_md )
c
c Set default number of equilibration steps
      nstep = 0
      call QMDNEQSTEPSET( nstep )
c
c Set default number of (thermalized) MD steps
      nstep = 100 000
      call QMDNTSTEPSET( nstep )
c
      RETURN
c
c    That's all Folks!
c
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RDSTAT
c
c
      subroutine RDSTAT( IWR, istatfl,
     $ dosetup, doiters, doforce, do_geom, do_cell, opt_spin,
     $ iucstart,igstart,itstart, engytotl,excengy,esnsengy,
     $ istart_sp, elecno, spindata,
     $ rprim, natm, ratm, frctot,strtot )
c---------------------------------------------------------------
c Purpose: acquire status of old calculation and restart info
c
c Written: Peter A. Schultz, 29-November-2001, for v2.51
c
c Revision history:
c  21Jan08-PAS/2.61: spin optimization integrated
c  21Jan08-PAS/2.61: bugfix/FORCE(S) keyword
c---------------------------------------------------------------
c
c The assumption is that the restart file is correct, since it
c is also written by this code, so I will do no error checking.
c This is a bare bones restart file.  E.g., No forces, and no
c velocities or inertia factors are currently included from
c damped dynamics/ASD.  Since this file is for internal use
c only, I will have the freedom to modify this in the future.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      LOGICAL  dosetup,doiters,doforce,do_geom,do_cell,opt_spin
      DIMENSION  rprim(3,3), ratm(3,natm)
      DIMENSION  frctot(3,natm), strtot(3,3)
      DIMENSION  elecno(2), spindata(4,2)
c
c local declarations:
      CHARACTER  label*80, readlbl*6
      CHARACTER  statkey*(*), wantlbl*4
      EQUIVALENCE  ( label, readlbl )
c
c >>>> EXECUTABLE CODE:
c
 8000 format(a80)
 9030 format(1x,3f16.10)
c
      REWIND( unit=istatfl )
c In case status file empty and need to initialize in wrstat:
      wantlbl = 'INPU'
c
      read(istatfl,8000, err=1000, end=1000)  label
c
      write(IWR,*) '>>>>> FOUND RESTART FILE - loading data'
      write(IWR,*   )  label
c
      if( readlbl .eq. 'GLINES' )then
c       Formatted data - number of lines of geom/cell info
        read(istatfl,*)  nline
        write(IWR,*   )  nline
        read(istatfl,8000, err=899, end=899) label
        write(IWR,*   )  label
      endif
c
      if( readlbl .eq. 'IGSTEP' )then
c       Recover atomic coordinates
        read(istatfl,*) igstart
        write(IWR,*   ) 'Restarting from geometry#',igstart
        read(istatfl,8000)  label
        write(IWR,*   )  label
        if( readlbl .ne. 'COORDI' ) call STOPXERR( 'RDSTAT: COORD' )
        do  iatm=1,natm
          read(istatfl,*)  (ratm(i,iatm),i=1,3)
          write(IWR,9030)  (ratm(i,iatm),i=1,3)
        enddo
        read(istatfl,8000, err=899, end=899)  label
        write(IWR,*   )  label
      endif
c
      if( readlbl .eq. 'IUCELL' )then
c       Recover cell parameters
        read(istatfl,*) iucstart
        write(IWR,'(a,i4)') 'Restarting from cell#',iucstart
        read(istatfl,8000)  label
        write(IWR,*   )  label
        if( readlbl .ne. 'primit' ) call STOPXERR( 'RDSTAT: primit' )
        do  id=1,3
          read(istatfl,*)  (rprim(i,id),i=1,3)
          write(IWR,9030)  (rprim(i,id),i=1,3)
        enddo
        read(istatfl,8000, err=899, end=899)  label
        write(IWR,*   )  label
      endif
c
      if( readlbl .eq. 'SPININ' )then
c       This is the latest spin polarization:
        read(istatfl,*)  elecno
        write(IWR,9030)  elecno
        read(istatfl,8000, err=899, end=899)  label
        write(IWR,*   )  label
      endif
c
      if( readlbl .eq. 'SETUP ' )then
c       Do not need to redo setup
        dosetup = .false.
        read(istatfl,8000, err=899, end=899)  label
        write(IWR,*   )  label
      endif
c
      if( readlbl .eq. 'SPINEW' )then
c       This is now the current spin polarization in spin opt:
        read(istatfl,*)  elecno
        write(IWR,9030)  elecno
        read(istatfl,8000, err=899, end=899)  label
        write(IWR,*   )  label
      endif
c
cspdat:start - the following should probably be in separate object
      if( readlbl .eq. 'SPDATA' )then
        read(istatfl,*) istart_sp
        write(IWR,'(1x,i4)') istart_sp
        nspdat = MIN( 2, istart_sp )
        do  ispdat=1,nspdat
          read(istatfl,*)  (spindata(i,ispdat),i=1,4)
          write(IWR,'(1x,4f16.8)')  (spindata(i,ispdat),i=1,4)
        enddo
        read(istatfl,8000, err=899, end=899)  label
        write(IWR,*   )  label
      endif
cspdat:end
c
      if( readlbl .eq. 'ITERAT' )then
c       We have this many iterations done:
        read(istatfl,*)  itstart
        write(IWR,'(1x,i4)')  itstart
        read(istatfl,8000, err=899, end=899)  label
        write(IWR,*   )  label
      endif
c
      if( readlbl .eq. 'SPIN-F' )then
c       This is the final converged spin polarization:
        read(istatfl,*)  elecno
        write(IWR,9030)  elecno
        read(istatfl,8000, err=899, end=899)  label
        write(IWR,*   )  label
      endif
c
      if( readlbl .eq. 'SCF-EN' )then
c       We are converged, and need to acquire some energies
        doiters = .false.
        read(istatfl,*)  engytotl,excengy,esnsengy
        write(IWR,9030)  engytotl,excengy,esnsengy
c
        read(istatfl,8000, err=899, end=899)  label
        write(IWR,*   )  label
      endif
c
      if( readlbl .eq. 'FORCES' )then
c       We have forces and stresses
        doforce = .false.
        do  iatm=1,natm
          read(istatfl,*)  (frctot(i,iatm),i=1,3)
        enddo
        read(istatfl,8000)  label
        if( readlbl .ne. 'STRESS' ) call STOPXERR( 'RDSTAT: stress' )
        do  id=1,3
          read(istatfl,*)  (strtot(i,id),i=1,3)
        enddo
c
        read(istatfl,8000, err=899, end=899)  label
        write(IWR,*   )  label
      endif
c
      if( readlbl .ne. 'END ST' )then
c       If it is not an "end status", there is a bug
        call STOPXERR( 'rdstart: unknown extra data in file' )
      endif
c
  899 write(IWR,*) 'Restart file ended'
      write(IWR,*)
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WRSTAT
c
c
      entry      WRSTAT( IWR, istatfl, statkey,
     $ do_geom, do_cell, opt_spin,
     $ iucstep,igstep,iter, engytotl,excengy,esnsengy,
     $ istep_sp, elecno, spindata,
     $ rprim, natm, ratm )
c
c >>>> EXECUTABLE CODE:
c
      wantlbl = statkey(1:4)
 9100 format(a)
c
c jump here from RDSTAT for initialization of status file:
 1000 continue
c
      REWIND( unit=istatfl )
c
      if( wantlbl .eq. 'INPU' )then
        write(istatfl,9100) 'PRESETUP'
        goto 999
      endif
c
      if( wantlbl .eq. 'CELL' .or. wantlbl .eq. 'GEOM' )then
c       Put out geom/cell info
c
c       First, record how many lines of geom data we will dump:
        nline = 0
        if( do_geom ) nline = nline + 3 + natm
        if( do_cell ) nline = nline + 3 + 3
        if( opt_spin ) nline = nline + 2
        write(istatfl,9100) 'GLINES'
        write(istatfl,*   )  nline
c
        if( do_geom )then
          write(istatfl,9100)  'IGSTEP'
          write(istatfl,*   )   igstep
          write(istatfl,9100)  'COORDINATES'
          do  iatm=1,natm
            write(istatfl,*   ) (ratm(i,iatm),i=1,3)
          enddo
        endif
c
        if( do_cell )then
          write(istatfl,9100) 'IUCELL'
          write(istatfl,*   )  iucstep
          write(istatfl,9100) 'primitive lattive vectors'
          do  id=1,3
            write(istatfl,*   ) (rprim(i,id),i=1,3)
          enddo
        endif
c
        if( opt_spin )then
          write(istatfl,9100) 'SPININ'
          write(istatfl,*   )  elecno
        endif
c
        goto 999
c
      else
c       Need to skip through geom/cell info, if we have it.
c
        read(istatfl,8000) label
        if( readlbl .eq. 'END ST' .or.
     $      readlbl .eq. 'PRESET' .or.
     $      readlbl .eq. 'SETUP ' )then
          REWIND( unit=istatfl )
          goto 1100
        elseif( readlbl .eq. 'GLINES' )then
c         Skip through cell/geom info
          read(istatfl,*)  nline
          do  iline=1,nline
            read(istatfl,*)
          enddo
        else
          write(IWR,*) 'label(1:20)=',label(1:20)
          call STOPXERR( 'WRSTAT - bad format' )
        endif
      endif
c
 1100 continue
c
      if( wantlbl .eq. 'SETU' )then
        write(istatfl,9100) 'SETUP COMPLETED'
        goto 999
      else
        read(istatfl,*)
C        read(istatfl,8000, err=899, end=899)  label
      endif
c
      if( wantlbl .eq. 'SPIT' )then
        write(istatfl,9100) 'SPINEW'
        write(istatfl,*   )  elecno
cspdat:start - following should be done in separate object
        write(istatfl,9100) 'SPDATA'
        write(istatfl,*   )  istep_sp
        nspdat = MIN( 2, istep_sp )
        do  ispdat=1,nspdat
          write(istatfl,*   ) (spindata(i,ispdat),i=1,4)
        enddo
cspdat:end
        goto 999
      endif
c
      if( wantlbl .eq. 'ITER' )then
c       Current iteration count, keeping spin-iteration data if exists
        if( opt_spin .and. ( istep_sp .gt. 1 )  )then
c         Skip spin-pol iteration data - it is present
          ndone_sp = istep_sp - 1
          nspdat = MIN( 2, ndone_sp )
          nskip = 2 + 2 + nspdat
          do  iline=1,nskip
            read(istatfl,*)
          enddo
        endif
        write(istatfl,9100) 'ITERATION'
        write(istatfl,*   )  iter
        goto 999
C      else
C        read(istatfl,*)
C        read(istatfl,*)
      endif
c
      if( wantlbl .eq. 'SP-F' )then
c       Record converged spin-polarization:
        write(istatfl,9100) 'SPIN-FINAL'
        write(istatfl,*   )  elecno
        goto 999
      else
c       Skip a couple lines (i.e., final spin) if spin-opt:
        if( opt_spin )then
          read(istatfl,*)
          read(istatfl,*)
        endif
      endif
c
      if( wantlbl .eq. 'SCF-' )then
        write(istatfl,9100) 'SCF-ENERGIES (tot,exc,del-es)'
        write(istatfl,*   )  engytotl,excengy,esnsengy
        goto 999
      else
        read(istatfl,*)
        read(istatfl,*)
      endif
c
      if( wantlbl .eq. 'FORC' )then
        write(istatfl,9100) 'FORCES'
c       Forces got passed in through atom coordinate array:
        do  iatm=1,natm
          write(istatfl,*   ) (ratm(i,iatm),i=1,3)
        enddo
c
        write(istatfl,9100) 'STRESS TENSOR'
        do  id=1,3
          write(istatfl,*   ) (rprim(i,id),i=1,3)
        enddo
        goto 999
      else
        nline = 1 + natm + 1 + 3
        do  iline=1,nline
          read(istatfl,*)
        enddo
      endif
c
      write(IWR,*) 'This restart key unknown:',statkey
      call STOPXERR( 'WRSTAT: unknown status key' )
c
  999 write(istatfl,9100) 'END STATUS FILE'
cpas: machine dependent flush. - I should replace this (utl)
      call FLUSH(istatfl)
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> REAPPUT
c
c
      subroutine REAPPUT( node_put, image, engytotl,
     $ ndata, data_img, ntmp, tmp, icomm )
c---------------------------------------------------------------
c Purpose: Put out results of assignment to master node
c
c Written: Peter A. Schultz, 28-January-2002, for v2.54
c
c Revision history:
c   6Jul06-APT/    : merged task parallel and image parallel
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input/Output (data for image)
      DIMENSION  data_img(*)
c Scratch space (buffer space for send/receive)
      DIMENSION  tmp(*)
c Local:
      DATA       zero / 0.d0 /
c converting int to real, add a little so back-conversion is clean:
      DATA       xtra / 0.1d0 /
c
c >>>> EXECUTABLE CODE:
c
      if( image.gt.0 )then
c       Pack up the image id, and the data that goes along
        rimage = DBLE( image ) + xtra
        tmp(1) = rimage
        tmp(2) = engytotl
        call DCOPY( ndata, data_img,1, tmp(3),1 )
        lenmsg = 1 + 1 + ndata
      else
c       We did not have an assignment to work on and return
        rimage = xtra
        tmp(1) = rimage
        lenmsg = 1
      endif
c
      call MPSENDR8( node_put, lenmsg, tmp, icomm )
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> REAPGET
c
c
      entry      REAPGET( node_get, image, engytotl,
     $ ndata, data_img, ntmp, tmp, icomm )
c---------------------------------------------------------------
c Purpose: Get results of assignment worked on
c
c Written: Peter A. Schultz, 28-January-2002, for v2.54
c
c Revision history:
c   6Jul06-APT/    : merged task parallel and image parallel
c---------------------------------------------------------------
c
      lenmsg = ndata + 2
      call MPRECVR8( node_get, lenmsg, tmp, icomm )
c
      rimage = tmp(1)
      image = rimage
c
      if( image.gt.0 )then
c       Unload data
        if( ndata.ne. (lenmsg-2) ) call STOPXERR( 'REAPGET: lenmsg' )
        engytotl = tmp(2)
        call DCOPY( ndata, tmp(3),1, data_img,1 )
      else
c       Nothing to get ... this node was idle
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RH1ORB
c
c
      subroutine RH1ORB( irh1orb,
     $ natm,ntyp,nshld,nald, n1r,n2r,n3r,nptr,nlat,maxwf,
     $ itypa, numshl,lshel,nala,ala,cala,  ratm,hh,rlat,
     $ lmx1ctr,almnv1c,  mngr3,mxgr3,ngr,
     $ r, dfn,rsq,gsum, wf )
c---------------------------------------------------------------
c Purpose: computes on the mesh the products of the orbitals
c          of each atom and summing these products over the
c          lattice vectors.  Needed for the subtraction of the
c          "1-atom terms" from the density in RHO1CTR
c
c Written: Peter A. Schultz, based on PJF's original routine
c
c Revision history:
c  24Sep08-PAS/2.62: fix unit variable in this unused routine
c   7Mar02-PAS/2.52: ang constants extracted
c  21Jun01-PAS/2.48: replace STOPs
c  19Dec99-PAS/2.42: clean-up; read/write big records
c  10Dec98-PAS/2.29: promote source to explicit double precision
c   1May97-PAS/2.17: naming conventions, on/off criterion,
c                    new grid coord rtn
c  15Dec95-PAS/2.14: shell-by-shell grid ranges, cleanup
c  17Sep93-PAS: more stringent cutoffs installed, some opt.
c   5Apr90-PAS: made more efficient and smaller storage
c---------------------------------------------------------------
c
c   On input, the coordinate mesh is assumed to lie in r()
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  ratm(3,natm),hh(3,3),rlat(3,nlat)
      DIMENSION  lmx1ctr(ntyp),almnv1c(ntyp)
      DIMENSION  mngr3(*),mxgr3(*),ngr(*)
      DIMENSION  r(3,nptr)
c scratch arrays:
      DIMENSION  dfn(5,nptr),rsq(nptr),gsum(nptr)
      DIMENSION  wf(*)
c local declarations:
      DIMENSION  r0(3),ratom(3),rlast(3)
c
      DIMENSION  vnorm(5)
      DATA  zero,half, three / 0.d0,0.5d0, 3.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Get angular normalizations:
      call VNORMS( vnorm )
c
      argmx = half*cutgaus
      do  jr=1,3
        rlast(jr) = zero
      enddo
c
c  Compute grid coordinates
c
      r0(1) = zero
      r0(2) = zero
      r0(3) = zero
      call MKRBOX( hh,r0, n1r,n2r,n3r, r )
c
c    Center loop:
c
      i1next = 1
      do 1000 iatm=1,natm
        ityp = itypa(iatm)
        nshl = numshl(ityp)
c I need this for grid indexing arrays:
        iorb1 = i1next
        do  ishl=1,nshl
          i1next = i1next + 2*lshel(ishl,ityp) + 1
        enddo
        if( lmx1ctr(ityp).lt.0 ) goto 1000
c
        al1cmin = almnv1c(ityp)
c
        almin = ala(1,1,ityp)
        almax = ala(1,1,ityp)
        do  ishl=1,nshl
          do  ial=1,nala(ishl,ityp)
            if( ala(ial,ishl,ityp).lt.almin ) almin = ala(ial,ishl,ityp)
            if( ala(ial,ishl,ityp).gt.almax ) almax = ala(ial,ishl,ityp)
          enddo
        enddo
c       rsqtop = cutgrid/(almin+almin)
c find range-limiting gaussian (smallest of (largest alf of 1c pair)):
        al1c = almax
        do  ishl=1,nshl
          do  jshl=1,ishl
            do  ial=1,nala(ishl,ityp)
              ali = ala(ial,ishl,ityp)
              do  jal=1,nala(jshl,ityp)
                alj = ala(jal,jshl,ityp)
                als = ali + alj
                if( als.ge.al1cmin )then
                  algt = MAX(ali,alj)
                  al1c = MIN(al1c,algt)
                endif
              enddo
            enddo
          enddo
        enddo
        twoalc = al1c + almin
        rsqtop = cutgrid/twoalc
c
        nlatm = nlat
        iorbat0 = 0
        do 850 ishl=1,nshl
          lshli = lshel(ishl,ityp)
          nali = nala(ishl,ityp)
          norbshi = 2*lshli + 1
c
          nrshi = ngr(iorb1+iorbat0)
          imin3sh = mngr3(iorb1+iorbat0)
c
          alimax = ala(nali,ishl,ityp)
          do  ial=1,nali
            ali = ala(ial,ishl,ityp)
            if( ali.gt.alimax ) alimax = ali
          enddo
c
          jorbat0 = 0
          do 800 jshl=1,ishl
            lshlj = lshel(jshl,ityp)
            nalj = nala(jshl,ityp)
            norbshj = 2*lshlj + 1
            lsum = lshli + lshlj
c
            nrshj = ngr(iorb1+jorbat0)
            jmin3sh = mngr3(iorb1+jorbat0)
c
            nrs = MIN( nrshi,nrshj )
            ijmin3 = MAX( imin3sh,jmin3sh )
            nr0 = n1r*n2r*(ijmin3-1)
c
            aljmax = ala(nalj,jshl,ityp)
            do  jal=1,nalj
              alj = ala(jal,jshl,ityp)
              if( alj.gt.aljmax )  aljmax = alj
            enddo
            alsmx = alimax + aljmax
c
            if( lsum.gt.lmx1ctr(ityp) .or. alsmx.lt.al1cmin)goto 800
c
            al1c = almax
            do  ial=1,nala(ishl,ityp)
              ali = ala(ial,ishl,ityp)
              do  jal=1,nala(jshl,ityp)
                alj = ala(jal,jshl,ityp)
                als = ali + alj
                if( als.ge.al1cmin )then
                  algt = MAX(ali,alj)
                  al1c = MIN(al1c,algt)
                endif
              enddo
            enddo
            twoalc = al1c + almin
            r2cutsh = cutgrid/twoalc
c
c this stuff below used to ensure only i<j calculated in lower loops:
            norbij = norbshi*norbshj
            norbj0 = norbshj
            joff = 0
            if( ishl.eq.jshl )then
              norbij = (norbij + norbshi)/2
              norbj0 = 0
              joff = 1
            endif
            nrset = norbij*nrs
            if( nrset.gt.2*maxwf ) call STOPXERR( 'rh1orb1' )
c
            do  nr=1,nrset
              wf(nr) = zero
            enddo
c
            nlatmx = 1
            do 900 ilat=1,nlatm
c
              do  jr=1,3
                ratom(jr) = ratm(jr,iatm) + rlat(jr,ilat)
              enddo
c
              do  nr=1,nrs
                r(1,nr0+nr) = r(1,nr0+nr) - ratom(1) + rlast(1)
                r(2,nr0+nr) = r(2,nr0+nr) - ratom(2) + rlast(2)
                r(3,nr0+nr) = r(3,nr0+nr) - ratom(3) + rlast(3)
                rsq(nr) = r(1,nr0+nr)**2 + r(2,nr0+nr)**2
     $                  + r(3,nr0+nr)**2
                gsum(nr) = zero
              enddo
c
              do  jr=1,3
                rlast(jr) = ratom(jr)
              enddo
c
              rsqmin = rsq(1)
              rsqmax = rsq(1)
              do  nr=1,nrs
                if( rsq(nr).lt.rsqmin ) rsqmin = rsq(nr)
                if( rsq(nr).gt.rsqmax ) rsqmax = rsq(nr)
              enddo
              if( rsqmin.lt.rsqtop .and. ilat.gt.nlatmx ) nlatmx = ilat
              if( rsqmin.gt.r2cutsh ) goto 900
c
              if( lshli.ge.2 .or. lshlj.ge.2 )then
                ang4 = vnorm(3)/vnorm(4)
                ang5 = vnorm(3)/vnorm(5)
                do  nr=1,nrs
                  dfn(1,nr) = r(1,nr0+nr)*r(2,nr0+nr)
                  dfn(2,nr) = r(2,nr0+nr)*r(3,nr0+nr)
                  dfn(3,nr) = r(3,nr0+nr)*r(1,nr0+nr)
                  dfn(4,nr) = (r(1,nr0+nr)**2 - r(2,nr0+nr)**2)*ang4
                  dfn(5,nr) = (three*r(3,nr0+nr)**2 - rsq(nr))*ang5
                enddo
              endif
c
              do 290 ial=1,nali
                ali = ala(ial,ishl,ityp)
                cfi = cala(ial,ishl,ityp)/vnorm(lshli+1)
                do 280 jal=1,nalj
                  alj = ala(jal,jshl,ityp)
                  alsum = ali + alj
                  if( alsum.lt.al1cmin ) goto 280
c
                  algt = ali
                  if( alj.gt.ali ) algt = alj
                  twoalgt = algt + algt
                  twoalc = algt + almin
                  rsqcut = cutgrid/twoalc
c  Skip if alphas too large
                  if( rsqmin.gt.rsqcut ) goto 280
c
                  cij = cfi*cala(jal,jshl,ityp)/vnorm(lshlj+1)
                  if( twoalgt*rsqmax.lt.argmx )then
                    do  nr=1,nrs
                      gsum(nr) = gsum(nr) + cij*EXP( -alsum*rsq(nr) )
                    enddo
                  else
                    do  nr=1,nrs
                      if( rsq(nr).lt.rsqcut )
     $                gsum(nr) = gsum(nr) + cij*EXP( -alsum*rsq(nr) )
                    enddo
                  endif
  280           continue
  290         continue
c
              if( lshli+lshlj.eq.0 )then
c
                do  nr=1,nrs
                  wf(nr) = wf(nr) + gsum(nr)
                enddo
c
              elseif( lshli+lshlj.eq.1 )then
c
                do  nr=1,nrs
                  wf(      nr) = wf(      nr) + gsum(nr)*r(1,nr0+nr)
                  wf(  nrs+nr) = wf(  nrs+nr) + gsum(nr)*r(2,nr0+nr)
                  wf(2*nrs+nr) = wf(2*nrs+nr) + gsum(nr)*r(3,nr0+nr)
                enddo
c
              elseif( lshli+lshlj.eq.2.and.lshli*lshlj.eq.0 )then
c
                do  nr=1,nrs
                  wf(      nr) = wf(      nr) + gsum(nr)*dfn(1,nr)
                  wf(  nrs+nr) = wf(  nrs+nr) + gsum(nr)*dfn(2,nr)
                  wf(2*nrs+nr) = wf(2*nrs+nr) + gsum(nr)*dfn(3,nr)
                  wf(3*nrs+nr) = wf(3*nrs+nr) + gsum(nr)*dfn(4,nr)
                  wf(4*nrs+nr) = wf(4*nrs+nr) + gsum(nr)*dfn(5,nr)
                enddo
c
              elseif( lshli.eq.1.and.lshlj.eq.1 )then
c
                norbshj = norbj0
                nr00 = 0
                do  iorbsh=1,norbshi
                  norbshj = norbshj + joff
                  do  jorbsh=1,norbshj
                    do  nr=1,nrs
                      wf(nr00+nr) = wf(nr00+nr) + gsum(nr)*
     $                 r(iorbsh,nr0+nr)*r(jorbsh,nr0+nr)
                    enddo
                    nr00 = nr00 + nrs
                  enddo
                enddo
c
              elseif( lshli+lshlj.eq.3.and.lshli*lshlj.eq.2 )then
c
                if(lshli.eq.1)then
                  n1 = 5
                  n2 = 1
                else
                  n1 = 1
                  n2 = 3
                endif
                do  k1=1,3
                  do  k2=1,5
                    nr00 = (n1*(k1-1)+n2*(k2-1))*nrs
                    do  nr=1,nrs
                      wf(nr00+nr) = wf(nr00+nr) + gsum(nr)*
     $                 r(k1,nr0+nr) * dfn(k2,nr)
                    enddo
                  enddo
                enddo
c
              elseif( lshli.eq.2.and.lshlj.eq.2 )then
c
                norbshj = norbj0
                nr00 = 0
                do  iorbsh=1,norbshi
                  norbshj = norbshj + joff
                  do  jorbsh=1,norbshj
                    do  nr=1,nrs
                      wf(nr00+nr) = wf(nr00+nr) + gsum(nr)*
     $                 dfn(iorbsh,nr)*dfn(jorbsh,nr)
                    enddo
                    nr00 = nr00 + nrs
                  enddo
                enddo
c
              else
                call STOPXERR( 'rh1orb2' )
              endif
c
c    Close lattice vector loop:
c
  900       continue
            nlatm = nlatmx
c
c    Write out the results:
c
            nrset0 = 0
            do  ijprod=1,norbij
C             write(irh1orb)  (wf(nr),nr=nrset0+1,nrset0+nrs)
              call WRITBIG( irh1orb, nrs, wf(nrset0+1) )
              nrset0 = nrset0 + nrs
            enddo
c
c    Reset the coordinate mesh:
c
            do  nr=1,nrs
              r(1,nr0+nr) = r(1,nr0+nr) + rlast(1)
              r(2,nr0+nr) = r(2,nr0+nr) + rlast(2)
              r(3,nr0+nr) = r(3,nr0+nr) + rlast(3)
            enddo
            do  jr=1,3
              rlast(jr) = zero
            enddo
c
c    Close radial function loops:
c
  800     jorbat0 = jorbat0 + norbshj
  850   iorbat0 = iorbat0 + norbshi
c
c    Close center loop:
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RHDMAT
c
c
      subroutine RHDMAT( idmatfl, ncplx, norb,
     $ nk,nk0,nkloc,
     $ dmat,             dmatrd )
c      R4(nc*nkloc*mat)  R8(mat)
c---------------------------------------------------------------
c Purpose: read eigenvectors and sort them into an order most
c          convenient for use in the density routines in real.
c
c Written: Peter A. Schultz, 23-July-2001, for v2.49 (spin)
c
c Revision history:
c  26Nov08-PAS/2.63: k-parallel dmat distribution
c   6Jul06-APT/    : merged task parallel and image parallel
c  30Jul05-PAS/2.59: master-only matrix files
c---------------------------------------------------------------
c
c We are only doing triangles of density matrix, hence we need
c need to double the off-diagonals.
c One might think that transposing the dmat's here would lead
c to better memory access in dmat in the box density routines.
c However, tests reversing i-j result in slower execution, at
c least in tests on one DEC Alpha.  Hence, leave it. - Aug01-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  dmat
      REAL  r4zero, r4two
c
c Output array:
cpas: could pack the dmat here by 2X
      DIMENSION  dmat(ncplx*nkloc,norb,norb)
c Scratch array:
      DIMENSION  dmatrd(norb,norb)
c
c Local declarations
      DATA  r4zero,r4two / 0.e0,2.e0 /
      DATA  two / 2.d0 /
c
c >>>> EXECUTABLE CODE:
c
c  Get Local MP info
      call MPNODES( nprocl )
      call MPNODE( iprocl )
      call MPNODE0( masterl )
      call MPCOMM( icomml )
c
      call MPNODES_K( nproc_k )
      call MPNODE_K( iproc_k )
      call MPNODE0_K( master_k )
      call MPCOMM_K( icomm_k )
c
      matrd = norb*norb
c
      ikloc = 0
      do 100 ik=1,nk
c
        lenmsg = matrd
        call KPMASTER( nk,nprocl, ik,kmasterpr )
        if( nkloc .eq. nk ) kmasterpr = masterl
c
        if( iprocl .eq. masterl )then
c         Image/local master reads dmat, and send to correct k-master proc
          call READBIG( idmatfl, matrd, dmatrd )
          if( kmasterpr .ne. masterl )then
c           This k-point goes off to kmasterpr
            call MPSENDR8( kmasterpr, lenmsg, dmatrd, icomml )
            goto 100
          endif
        elseif( iprocl .eq. kmasterpr )then
c         Proc is master of this k-point, get dmatrd from masterl
          call MPRECVR8( masterl, lenmsg, dmatrd, icomml )
        else
c         This proc is not leading this k-point
          goto 100
        endif
        ikloc = ikloc + 1
c
        if( ncplx.eq.2 )then
c         Complex density matrix
          kr = 2*(ikloc-1) + 1
          ki = kr + 1
          do  j=1,norb
            do  i=1,j-1
              dmat(kr,i,j) =  two*dmatrd(j,i)
              dmat(ki,i,j) =  two*dmatrd(i,j)
            enddo
            dmat(kr,j,j) =  dmatrd(j,j)
            dmat(ki,j,j) =  r4zero
            do  i=j+1,norb
              dmat(kr,i,j) =  two*dmatrd(i,j)
              dmat(ki,i,j) = -two*dmatrd(j,i)
            enddo
          enddo
        else
c         Real density matrix
          do  j=1,norb
            do  i=1,norb
              dmat(1,i,j) = two*dmatrd(i,j)
            enddo
            dmat(1,j,j) = dmat(1,j,j) / r4two
          enddo
        endif
c
  100 continue
c
C      if( nkloc .ne. nk .and. nkloc .gt. 0 .and. nproc_k .gt. 1 )then
      if( nproc_k .gt. 1 .and. nkloc .gt. 0 )then
c       Send around each k-group its r4 dmat
        lenmsg = ncplx*nkloc*norb*norb
        call MPBCAST4( master_k, lenmsg, dmat, icomm_k )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RHEIGVEC
c
c
      subroutine RHEIGVEC( ivecfl, ncplx,norb,nstate,numpop,
     $ nk,nk0,nkloc,
     $ wtk,eigpop,rtpop, eigvec,eigvrd )
c---------------------------------------------------------------
c Purpose: read eigenvectors and sort them into an order most
c          convenient for use in the density routines, while
c          reducing precision, too.
c
c Written: Peter A. Schultz, 23-July-2001, for v2.49 (spin)
c
c Revision history:
c  26Nov08-PAS/2.63: k-parallel eigvec distribution
c  24Sep08-PAS/2.62: better diagnostics on occup<0 error
c   6Jul06-APT/    : merged task parallel and image parallel
c  30Jul05-PAS/2.59: master-only matrix files
c  27Oct04-PAS/2.59: task-parallelism
c---------------------------------------------------------------
c
c Note: have "nstate" eigenvectors that must be read through,
c but only "numpop" of those states are occupied and are needed
c for the density calculation, hence the different dimensions
c of the eigenvectors as read in (eigvrd) and output (eigvec).
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL       eigvec
c
      PARAMETER  ( zero = 0.d0 )
c
      DIMENSION  wtk(nk),eigpop(nstate,nk), rtpop(nstate)
      DIMENSION  eigvec(ncplx,numpop,nkloc,norb)
      DIMENSION  eigvrd(ncplx,norb,nstate)
c
c >>>> EXECUTABLE CODE:
c
c  Get Local MP info
      call MPNODES( nprocl )
      call MPNODE( iprocl )
      call MPNODE0( masterl )
      call MPCOMM( icomml )
c
      call MPNODES_K( nproc_k )
      call MPNODE_K( iproc_k )
      call MPNODE0_K( master_k )
      call MPCOMM_K( icomm_k )
c
      nvecrd = ncplx*norb*nstate
c
      ikloc = 0
      do 100 ik=1,nk
c
        lenmsg = nvecrd
        call KPMASTER( nk,nprocl, ik,kmasterpr )
        if( nkloc .eq. nk ) kmasterpr = masterl
c
        if( iprocl .eq. masterl )then
c         Image/local master reads eigvecs, sends to correct k-master proc
          call READBIG( ivecfl, nvecrd, eigvrd )
          if( kmasterpr .ne. masterl )then
c           This k-point goes off to kmasterpr
            call MPSENDR8( kmasterpr, lenmsg, eigvrd, icomml )
            goto 100
          endif
        elseif( iprocl .eq. kmasterpr )then
c         Proc is master of this k-point, get eigvecrd from masterl
          call MPRECVR8( masterl, lenmsg, eigvrd, icomml )
        else
c         This proc is not leading this k-point
          goto 100
        endif
        ikloc = ikloc + 1
c
c       Set up occupancies for states (must be strictly non-negative).
        do  n=1,numpop
          rtpop(n) = wtk(ik)*eigpop(n,ik)
          if( rtpop(n).gt.zero )then
            rtpop(n) = SQRT( rtpop(n) )
          elseif( rtpop(n).lt.zero )then
c           We have an error - do some documentation
            call FLGETIERR( IERR )
            write(IERR,*) 'RHEIGVEC: state occups mangled, k=',ik
            write(IERR,'(1x,1p8d10.3)') (eigpop(i,k),i=1,numpop)
            write(IERR,*) 'If pop<0 intended, must use DM density'
            call STOPXERR( 'RHEIGVEC: negative state populations' )
          endif
        enddo
c
        if( ncplx.eq.2 )then
c         Complex eigenvector matrix
          do  i=1,norb
            do  n=1,numpop
              eigvec(1,n,ikloc,i) = rtpop(n)*eigvrd(1,i,n)
              eigvec(2,n,ikloc,i) = rtpop(n)*eigvrd(2,i,n)
            enddo
          enddo
        else
c         Real eigenvector matrix
          do  i=1,norb
            do  n=1,numpop
              eigvec(1,n,1,i) = rtpop(n)*eigvrd(1,i,n)
            enddo
          enddo
        endif
c
  100 continue
c
C      if( nkloc. ne. nk .and. nkloc .gt.0 .and. nproc_k .gt. 1 )then
      if( nproc_k .gt. 1 .and. nkloc .gt. 0 )then
c       Send around each k-group its r4 eigvec from kmaster
        lenmsg = ncplx*nkloc*norb*numpop
        call MPBCAST4( master_k, lenmsg, eigvec, icomm_k )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RHO1CTR
c
c
      subroutine RHO1CTR( IWR, irh1orb,icpctfl,icountr,
     $ norb,nk, natm,ntyp,nshld,nald, noad,
     $ itypa, numshl,lshel,nala,ala,cala,  norba,ioffa, occij,
     $ lmx1ctr,almnv1c, nsyms,dsym,naofsym,
     $ hh,vk, n1r,n2r,n3r,nptr, weight, mngr3,mxgr3,ngr,
     $ dcountr,rh1coef, dmatwk,
     $ rho, dmatofk, r,cnrho )
c---------------------------------------------------------------
c Purpose: Computes and subtracts from grid density rho()
c   rapidly-varying "1-ctr density" due to delta density matrix
c   whose electrostatic potential has already been done in
c   VLOCxxx routines, and must not be repeated in FFT.
c
c Written: P.J. Feibelman
c
c Revision history:
c  19Dec99-PAS/2.42: clean-up; read/write big grid records
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  29Jul98-PAS/2.23: split basis occs
c   1May97-PAS/2.17: naming conventions, new grid coord rtn
c  15Dec95-PAS/2.14: shell-by-shell grid ranges, cleanup
c  29Aug94-PAS/2.11: cleanup, rationalize args.
c   6Apr90-PAS: make more efficient; use less disk
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  norba(ntyp),ioffa(natm), occij(nshld,nshld,ntyp)
      DIMENSION  hh(3,3),vk(3,nk), dsym(5,5,3,*),naofsym(natm,*)
      DIMENSION  lmx1ctr(ntyp),almnv1c(ntyp)
      DIMENSION  dcountr(10,natm),rh1coef(10,noad,natm)
      DIMENSION  mngr3(*),mxgr3(*),ngr(*)
      DIMENSION  dmatofk(2,norb,norb,nk)
c input/output:
      DIMENSION  rho(nptr)
c scratch arrays:
      DIMENSION  cnrho(nptr),r(3,nptr)
      DIMENSION  dmatwk(noad,noad)
c local declarations:
      DIMENSION  r0(3),rij(3)
      DIMENSION  number(3)
      DATA  number / 1,4,10 /
      DATA  zero,two / 0.d0,2.d0 /
      DATA  lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
      r0(1) = zero
      r0(2) = zero
      r0(3) = zero
      call MKRBOX( hh,r0, n1r,n2r,n3r, r )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * *
c              One atom contributions
c * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      i1next = 1
      do 100 iatm=1,natm
        ityp = itypa(iatm)
        nshl = numshl(ityp)
c I need this for grid indexing arrays:
        iorb1 = i1next
        do  ishl=1,nshl
          i1next = i1next + 2*lshel(ishl,ityp) + 1
        enddo
        if( lmx1ctr(ityp).lt.0 ) goto 100
c
        al1cmin = almnv1c(ityp)
c
        do  jr=1,3
          rij(jr) = zero
        enddo
c
c        Sum density matrix over surface Brillouin zone
c
        call MKZERO( noad**2, dmatwk )
        call ROTGRP( dmatwk, iatm,iatm,rij,
     $   norb,nk, natm,ntyp,nshld, noad,
     $   itypa, numshl,lshel, ioffa, vk,rij,
     $   nsyms,dsym,naofsym,
     $   dmatofk,cnrho )
c -->    dmat-i  cphi-s
c
        iorbat0 = 0
        do 85 ishl=1,nshl
          lshli = lshel(ishl,ityp)
          li0 = lshli*lshli
          nali = nala(ishl,ityp)
          norbshi = 2*lshli + 1
c
          nrshi = ngr(iorb1+iorbat0)
          imin3sh = mngr3(iorb1+iorbat0)
c
          alimax = ala(nali,ishl,ityp)
          do  ial=1,nali
            ali = ala(ial,ishl,ityp)
            if( ali.gt.alimax )  alimax = ali
          enddo
c
          jorbat0 = 0
          do 80 jshl=1,ishl
            lshlj = lshel(jshl,ityp)
            lj0 = lshlj*lshlj
            nalj = nala(jshl,ityp)
            norbshj = 2*lshlj + 1
            lsum = lshli + lshlj
c
            nrshj = ngr(iorb1+jorbat0)
            jmin3sh = mngr3(iorb1+jorbat0)
c
            nrs = MIN( nrshi,nrshj )
            ijmin3 = MAX( imin3sh,jmin3sh )
            nr0 = n1r*n2r*(ijmin3-1)
c
            aljmax = ala(nalj,jshl,ityp)
            do  jal=1,nalj
              alj = ala(jal,jshl,ityp)
              if( alj.gt.aljmax )  aljmax = alj
            enddo
            alsmx = alimax + aljmax
c
            if( lsum .gt.lmx1ctr(ityp) .or. alsmx.lt.al1cmin ) goto 80
c
            norbj0 = norbshj
            joff = 0
            if( jshl.eq.ishl )then
              norbj0 = 0
              joff = 1
            endif
c
            occ = occij(ishl,jshl,ityp)
c
            li = li0
            norbshj = norbj0
            do 75 iorbsh=1,norbshi
              iorbat = iorbat0 + iorbsh
              li = li + 1
c
              lj = lj0
              norbshj = norbshj + joff
              do 70 jorbsh=1,norbshj
                jorbat = jorbat0 + jorbsh
                lj = lj + 1
                if( iorbat.eq.jorbat )then
                  dmatr = dmatwk(iorbat,jorbat) - occ
                elseif( li.eq.lj )then
                  dmatr = two*( dmatwk(iorbat,jorbat) - occ )
                else
                  dmatr = two*dmatwk(iorbat,jorbat)
                endif
c
C               read(irh1orb)  (cnrho(nr),nr=1,nrs)
                call READBIG( irh1orb, nrs, cnrho )
                do  nr=1,nrs
                  rho(nr0+nr) = rho(nr0+nr) - dmatr*cnrho(nr)
                enddo
c
c    Close orbital loops:
c
   70         continue
   75       continue
c
c    Close radial function loops:
c
   80     jorbat0 = jorbat0 + norbshj
   85   iorbat0 = iorbat0 + norbshi
c
c    Close center loops:
c
  100 continue
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                 two atom contributions
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      i1next = 1
      do 200 iatm=1,natm
        ityp = itypa(iatm)
        nshl = numshl(ityp)
        iorb1 = i1next
        do  ishl=1,nshl
          i1next = i1next + 2*lshel(ishl,ityp) + 1
        enddo
        if( lmx1ctr(ityp).lt.0 ) goto 200
c
        iorbat0 = 0
        do 180 ishl=1,nshl
          lshl = lshel(ishl,ityp)
          nali = nala(ishl,ityp)
          norbsh = 2*lshl + 1
c
          nrs = ngr(iorb1+iorbat0)
          imin3 = mngr3(iorb1+iorbat0)
          nr0 = n1r*n2r*(imin3-1)
c
          iorbat = iorbat0
          iorbat0 = iorbat0 + norbsh
c
          alimax = ala(nali,ishl,ityp)
          do  ial=1,nali
            ali = ala(ial,ishl,ityp)
            if( ali.gt.alimax ) alimax = ali
          enddo
          if( lshl.gt.lmx1ctr(ityp).or.alimax.lt.almnv1c(ityp) )goto 180
c
          do 170 iorbsh=1,norbsh
            iorbat = iorbat + 1
c
c      orbofk contribution; read i-th orbital
c
C           read(icpctfl)  (cnrho(nr),nr=1,nrs)
            call READBIG( icpctfl, nrs, cnrho )
c
c      compute contributions to delta rho ...
c
c       ... from orbitals at neighboring sites
c
            dmijwk = two*rh1coef(1,iorbat,iatm)
            do  nr=1,nrs
              rho(nr0+nr) = rho(nr0+nr) - dmijwk*cnrho(nr)
            enddo
c
            if( lshl+1 .gt. lmx1ctr(ityp) ) goto 170
c
c       ... from grad orbital j at siteiatm
c
            do 150 lgr=1,3
C             read(icpctfl)  (cnrho(nr),nr=1,nrs)
              call READBIG( icpctfl, nrs, cnrho )
              dmijwk = two*rh1coef(1+lgr,iorbat,iatm)
              do  nr=1,nrs
                rho(nr0+nr) = rho(nr0+nr) - dmijwk*cnrho(nr)
              enddo
  150       continue
c
            if( lshl+2 .gt. lmx1ctr(ityp) ) goto 170
c
c       ... from grad(grad orbital j) at site i
c
            lcoef = 4
            do 162 lgr=1,3
              do 161 llgr=1,lgr
                lcoef = lcoef + 1
C               read(icpctfl)  (cnrho(nr),nr=1,nrs)
                call READBIG( icpctfl, nrs, cnrho )
                dmijwk = two*rh1coef(lcoef,iorbat,iatm)
                do  nr=1,nrs
                  rho(nr0+nr) = rho(nr0+nr) - dmijwk*cnrho(nr)
                enddo
  161         continue
  162       continue
c
c    Close  orbital loop:
c
  170     continue
c
c    Close radial function loop:
c
  180   continue
c
c    Close center loop:
c
  200 continue
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c     Add back counter-charge associated with center i that
c     cancels the l=0,1,2 multipole moments of the 1-ctr charge
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if( lstout.gt.0 ) write(IWR,*) 'RHO1CTR:'
      iorb = 1
      do 300 iatm=1,natm
        ityp = itypa(iatm)
        nrat = ngr(iorb)
        imin3 = mngr3(iorb)
        do  ishl=1,numshl(ityp)
          if( ngr(iorb).gt.nrat )then
            nrat = ngr(iorb)
            imin3 = mngr3(iorb)
          endif
          iorb = iorb + 2*lshel(ishl,ityp) + 1
        enddo
        if( lmx1ctr(ityp).lt.0 ) goto 300
c
        nr0 = n1r*n2r*(imin3-1)
        norbsh = number(lmx1ctr(ityp)+1)
        if( lstout.gt.0 )
     $  write(IWR,9300) iatm,norbsh,(dcountr(li,iatm),li=1,norbsh)
 9300   format(1x,'iatm=',i3,'; li=1-',i2,' dcountr values:'/(1p5e15.8))
c
        do 280 iorbsh=1,norbsh
C         read(icountr)  (cnrho(nr),nr=1,nrat)
          call READBIG( icountr, nrat, cnrho )
c
          do  nr=1,nrat
            rho(nr0+nr) = rho(nr0+nr) + dcountr(iorbsh,iatm)*cnrho(nr)
          enddo
c
  280   continue
c
  300 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RHOIJ
c
c
      subroutine RHOIJ( ivecfl,idmatfl,iematfl, norb,nstate,nk,
     $ eigval,eigpop,fpop,npop, wtk,
     $ dmat,emat, eigvec )
c---------------------------------------------------------------
c Purpose: construct density matrix in orbital basis
c
c Written: Peter A. Schultz,  9-April-1999, for v2.34
c
c Revision history:
c  31Dec19-PAS/2.68b: only read/use occupied eigvecs (mem reduce)
c  18Jan02-PAS/2.51b: replace code that led to segmentation flt.
c  20Jul01-PAS/2.49: spin-polarized dft, fpop made scratch, dmat
c  10May99-PAS/2.35: eigenfunction grid density
c   9Apr99-PAS/2.34: complex lapack eigensolver implemented
c  15Feb99-PAS/2.31: routine to intercept perhaps too-big i/o
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  10Oct97-PAS/2.21: change fpop/wtk convention
c  12Aug94-PAS/2.11: cleanup/purge complex/clean args
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c
      DIMENSION  eigval(nstate,nk),eigpop(nstate,nk),wtk(nk)
c scratch arrays:
      DIMENSION  fpop(nstate)
      DIMENSION  dmat(norb,*),emat(norb,norb)
      DIMENSION  eigvec(2,npop  ,norb)
c NB: dmat used temp as 2*nstate*norb for eigvec transpose
c
c >>>> EXECUTABLE CODE:
c
      mat = norb*norb
c
c    Bloch vector loop:
c
      do 100 k=1,nk
c
c Retrieve (only occupied numpop, not all nstate) eigenvectors ...
        call READBIG( ivecfl, 2*norb*npop  , dmat )
c -->                                        2*norb*numpop-o
c NB: dmat used as 2*norb*numpop scratch space here
c
c  ... and transpose for use below:
        call TREIGVEC( norb,npop  , dmat,eigvec )
c
        numpop = npop
c
        do  n=1,numpop
          fpop(n) = eigpop(n,k)
C          do  i=1,norb
C            eigvec(1,n,i) = dmat(1,i,n)
C            eigvec(2,n,i) = dmat(2,i,n)
C          enddo
        enddo
c
c Clear out dmat, emat:
        call MKZERO( mat, dmat )
        call MKZERO( mat, emat )
c
c Done with fpop, scale by weight for use below.
        wt = wtk(k)
        do  n=1,numpop
          fpop(n) = wt*fpop(n)
        enddo
c
c Load one triangle ...
        do 32 i=1,norb
c
c         Do *off*-diagonals first ...
          do 31 j=1,i-1
            dmr = zero
            dmi = zero
            emr = zero
            emi = zero
            do 20 n=1,numpop
              occnk = fpop(n)
              tr = occnk*( eigvec(1,n,j)*eigvec(1,n,i)
     $                   + eigvec(2,n,j)*eigvec(2,n,i) )
              ti = occnk*( eigvec(2,n,j)*eigvec(1,n,i)
     $                   - eigvec(1,n,j)*eigvec(2,n,i) )
              dmr = dmr + tr
              dmi = dmi + ti
              emr = emr + tr*eigval(n,k)
              emi = emi + ti*eigval(n,k)
   20       continue
            dmat(j,i) = dmi
            dmat(i,j) = dmr
            emat(j,i) = emi
            emat(i,j) = emr
   31     continue
c
c          ... and do the diagonal element by itself:
c           (if not split off, compiler might seg-fault)
            dmr = zero
            emr = zero
            do 22 n=1,numpop
              occnk = fpop(n)
              tr = occnk*( eigvec(1,n,i)*eigvec(1,n,i)
     $                   + eigvec(2,n,i)*eigvec(2,n,i) )
              dmr = dmr + tr
              emr = emr + tr*eigval(n,k)
   22       continue
            dmat(i,i) = dmr
            emat(i,i) = emr
c
   32   continue
c
        call WRITBIG( idmatfl, mat, dmat )
        call WRITBIG( iematfl, mat, emat )
c
  100 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RINTRNL
c
c
      subroutine RINTRNL( ndim,nvec, dolvatm, rprim,orig,rscale,
     $ rextr,rintr )
c---------------------------------------------------------------
c Purpose: take atom coordinates, shift, scale to/from user input
c
c Written: Peter A. Schultz, 24-September-1997, v2.21
c
c Revision history:
c   7Jul00-PAS/2.45: unify scaling functions; lattice coords
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c Note: For lattice coordinates, I *enforce* the assumption,
c       *not* checked, that for reduced dimension systems,
c       non-periodic axes are in special directions.
c       E.g., slab normal in a 2D calculation is the z-axis
c Note: I might consider pulling ruc() up
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input declarations:
      LOGICAL    dolvatm
      DIMENSION  rprim(3,4),orig(3),rscale(3)
c input/output arrays:
      DIMENSION  rextr(3,nvec),rintr(3,nvec)
c local declarations:
      DIMENSION  ruc(3,3), vect(3)
      DATA  zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      if( dolvatm )then
c
c       Use reduced dimension unit cell vectors:
        do  j=1,3
          do  i=1,3
            ruc(i,j) = zero
          enddo
          ruc(j,j) = one
        enddo
        do  j=1,ndim
          do  i=1,ndim
            ruc(i,j) = rprim(i,j) / rprim(j,4)
          enddo
        enddo
c       I choose to install scaling factor here.
        do  i=ndim+1,3
          ruc(i,i) = ruc(i,i) * rscale(i)
        enddo
c
c       Expand the vectors into coordinate space:
        do  ivec=1,nvec
          call LVXPND( ruc, rintr(1,ivec), rextr(1,ivec) )
        enddo
c
      else
c
        do  ivec=1,nvec
          rintr(1,ivec) = rextr(1,ivec)*rscale(1)
          rintr(2,ivec) = rextr(2,ivec)*rscale(2)
          rintr(3,ivec) = rextr(3,ivec)*rscale(3)
        enddo
c
      endif
c
      do  ivec=1,nvec
        rintr(1,ivec) = rintr(1,ivec) - orig(1)
        rintr(2,ivec) = rintr(2,ivec) - orig(2)
        rintr(3,ivec) = rintr(3,ivec) - orig(3)
      enddo
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> REXTRNL
c
c
      entry REXTRNL( ndim,nvec, dolvatm, rprim,orig,rscale,
     $ rextr,rintr )
c
c >>>> EXECUTABLE CODE:
c
      do  ivec=1,nvec
        rextr(1,ivec) = rintr(1,ivec) + orig(1)
        rextr(2,ivec) = rintr(2,ivec) + orig(2)
        rextr(3,ivec) = rintr(3,ivec) + orig(3)
      enddo
c
      if( dolvatm )then
c
c       Use reduced dimension unit cell vectors:
        do  j=1,3
          do  i=1,3
            ruc(i,j) = zero
          enddo
          ruc(j,j) = one
        enddo
        do  j=1,ndim
          do  i=1,ndim
            ruc(i,j) = rprim(i,j) / rprim(j,4)
          enddo
        enddo
c       I choose to install scaling factor here.
        do  i=ndim+1,3
          ruc(i,i) = ruc(i,i) * rscale(i)
        enddo
c
c       Project coordinates onto reduced unit cell vectors:
        do  ivec=1,nvec
          call LVPROJ( ruc, rextr(1,ivec), vect )
          rextr(1,ivec) = vect(1)
          rextr(2,ivec) = vect(2)
          rextr(3,ivec) = vect(3)
        enddo
c
      else
c
        do  ivec=1,nvec
          rextr(1,ivec) = rextr(1,ivec)/rscale(1)
          rextr(2,ivec) = rextr(2,ivec)/rscale(2)
          rextr(3,ivec) = rextr(3,ivec)/rscale(3)
        enddo
c
      endif
c
      RETURN
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ROTGRP
c
c
      subroutine ROTGRP( dmatwk, nuc,jatm,rij,
     $ norb,nk, natm,ntyp,nshld, noad,
     $ itypa,numshl,lshel, ioffa, vk,rl,
     $ nsyms,dsym,naofsym,
     $ dmat,cphi )
c---------------------------------------------------------------
c Purpose: take the complex input matrix "dmat", known only in
c   irreducible part of the surface BZ, and use input info
c   concerning the rotations and reflections under which slab is
c   symmetric, determine real configuration space matrix dmatwk
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Apr97-PAS/2.17: naming conventions
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output array:
      DIMENSION  dmatwk(noad,noad)
c input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  ioffa(natm)
      DIMENSION  rij(2),vk(3,nk),rl(2), dsym(5,5,3,*),naofsym(natm,*)
      DIMENSION  dmat(2,norb,norb,nk)
c scratch array:
      DIMENSION  cphi(2,nk)
complex dmat,cphi
c local declarations:
      DIMENSION  rrot(2)
      DATA  zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      symops = one/ DBLE(nsyms)
      do 1000 isym=1,nsyms
c
c      compute phase (recall that dsym are inverse rotation matrices)
c
c  10/10/85 - the phase associated with each symmetry operator is:
c    exp(i*vk*(a lattice vector)), the lattice vector is the change
c    in rij due to action of inverse symmetry operator in question
c
        do  ir=1,2
          rrot(ir) = -(rij(ir)+rl(ir))
          do  jr=1,2
            rrot(ir) = rrot(ir) + dsym(ir,jr,2,isym)*rij(jr)
          enddo
        enddo
        do  k=1,nk
          arg = (vk(1,k)*rrot(1)+vk(2,k)*rrot(2))
c          cphi(k) = DCMPLX( COS(arg)*symops, SIN(arg)*symops )
          cphi(1,k) = symops*COS(arg)
          cphi(2,k) = symops*SIN(arg)
        enddo
c
c      specify atoms in basis
c
        nucsym = naofsym(nuc,isym)
        jatsym = naofsym(jatm,isym)
        ktyp = itypa(nuc)
        jtyp = itypa(jatm)
        nshli = numshl(ktyp)
        nshlj = numshl(jtyp)
c
        norbwki = 0
        norbi = ioffa(nucsym)
c
        do 85 ishl=1,nshli
          lorbi = lshel(ishl,ktyp)
          norbshi = 2*lorbi + 1
c
          norbwkj = 0
          norbj = ioffa(jatsym)
          do 80 jshl=1,nshlj
            lorbj = lshel(jshl,jtyp)
            norbshj = 2*lorbj + 1
c
      do 66 mmi=1,norbshi
        imm = norbi + mmi
        do 65 mmj=1,norbshj
          jmm = norbj + mmj
          arg = zero
          do 30 k=1,nk
C           arg = arg + dmat(imm,jmm,k)*cphi(k)
            arg = arg + dmat(1,imm,jmm,k)*cphi(1,k)
     $                - dmat(2,imm,jmm,k)*cphi(2,k)
   30     continue
c
          do 62 mi=1,norbshi
            im = norbwki + mi
            do 61 mj=1,norbshj
              jm= norbwkj + mj
              dmatwk(im,jm) = dmatwk(im,jm) + arg*
     $         dsym(mmi,mi,lorbi+1,isym)*dsym(mmj,mj,lorbj+1,isym)
   61       continue
   62     continue
c
   65   continue
   66 continue
c
c      note: there are cases, such as hcp(0001) and fcc(111)
c      surfaces, for which the point group operations are too
c      few to transform the "irreducible part" of the surface BZ
c      into the full SBZ. In these cases the slack is taken up
c      by the operation of time reversal, which need not take
c      atoms into atoms. Time reversal, however, requires that the
c      expression on the RHS of the preceding equation be replaced
c      by its real part. Since "dmatwk" has been defined as real in
c      this routine, the effects of time reversal are correctly
c      included here, and in the input data file, only the point
c      group operations of the film should be included.
c
c
            norbwkj = norbwkj + norbshj
            norbj = norbj + norbshj
   80     continue
          norbwki = norbwki + norbshi
          norbi = norbi + norbshi
   85   continue
c
 1000 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ROTMAT
c
c
      subroutine ROTMAT( nsymi,nsyms, isymtyp,syminfo, dsym )
c---------------------------------------------------------------
c Purpose: compute inverse rotation and reflection matrices,
c          for two-dimensional symmetries.
c
c Revision history:
c  14Jun05-PAS/2.59: File units
c  21Jun01-PAS/2.48: replace STOPs
c   9Jan99-PAS/2.30: redo symmetry scheme
c  10Dec98-PAS/2.29: promote source to explicit double precision
c   3Sep96-PAS/2.15: fix mkzero dimensions
c---------------------------------------------------------------
c
c Note: the following code adapted from PJF's original, which
c was restricted to 2D symmetries and used symmetry info saved
c in different format.  To keep the working code here, have to
c back out the original info from the current data scheme.
c At some point, it would be a good idea to retool this routine
c to use the cartesian symmetry matrices, and maybe even
c generalize to 3D calculations, but not today. - 9Jan99-PAS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c input symmetry angles:
      DIMENSION  isymtyp(*), syminfo(6,*)
c output symmetry transformation matrices:
      DIMENSION  dsym(5,5,3,*)
c local declarations:
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /
c
c >>>> EXECUTABLE CODE:
c
      radians = ASIN(one)/90.d0
      call MKZERO( 5*5*3*nsyms, dsym )
c
c     IDENTITY (isym=1)
c
      isym = 1
      do  l=1,3
        do  li=1,5
          dsym(li,li,l,isym) = one
        enddo
      enddo
c
      do 100 isymi=1,nsymi
c
c Need to back out what the operation is:
        istyp = isymtyp(isymi)
        if( istyp.gt.1 )then
c         ROTATION
          dang = two*pi / DBLE( istyp )
          ang = zero
          nrepeat = istyp - 1
        elseif( istyp.eq.-2 )then
c         REFLECTION
c         Note: the angle is based on indata assumption
          sy = -syminfo(1,isymi)
          sx =  syminfo(2,isymi)
          smag = SQRT( sx*sx + sy*sy )
          if( sy.lt.zero )then
            sy = -sy
            sx = -sx
          endif
          arg = sx/smag
c          arg = syminfo(2,isymi)
          ang = ACOS( arg )
          nrepeat = 1
        else
c         ERROR
          call STOPXERR( 'rotmat2d' )
        endif
c
   50   if( nrepeat.le.0 ) goto 100
        nrepeat = nrepeat - 1
        isym = isym + 1
c
        if( istyp.gt.1 )then
c         ROTATION
          ang = ang + dang
          cosa = COS(ang)
          sina = SIN(ang)
          cos2a = (cosa-sina)*(cosa+sina)
          sin2a = two*cosa*sina
c l=0 matrix
          dsym(1,1,1,isym) =  one
c l=1 matrix
          dsym(1,1,2,isym) =  cosa
          dsym(2,2,2,isym) =  cosa
          dsym(1,2,2,isym) = -sina
          dsym(2,1,2,isym) =  sina
          dsym(3,3,2,isym) =  one
c l=2 matrix
          dsym(1,1,3,isym) =  cos2a
          dsym(2,2,3,isym) =  cosa
          dsym(3,3,3,isym) =  cosa
          dsym(4,4,3,isym) =  cos2a
          dsym(5,5,3,isym) =  one
          dsym(1,4,3,isym) =  sin2a
          dsym(2,3,3,isym) =  sina
          dsym(3,2,3,isym) = -sina
          dsym(4,1,3,isym) = -sin2a
        elseif( istyp.eq.-2 )then
c         REFLECTION
          cos2a = COS(ang+ang)
          sin2a = SIN(ang+ang)
          cos4a = (cos2a-sin2a)*(cos2a+sin2a)
          sin4a = two*cos2a*sin2a
c l=0 matrix
          dsym(1,1,1,isym) =  one
c l=1 matrix
          dsym(1,1,2,isym) =  cos2a
          dsym(2,2,2,isym) = -cos2a
          dsym(1,2,2,isym) =  sin2a
          dsym(2,1,2,isym) =  sin2a
          dsym(3,3,2,isym) =  one
c l=2 matrix
          dsym(1,1,3,isym) = -cos4a
          dsym(2,2,3,isym) = -cos2a
          dsym(3,3,3,isym) =  cos2a
          dsym(4,4,3,isym) =  cos4a
          dsym(5,5,3,isym) =  one
          dsym(1,4,3,isym) =  sin4a
          dsym(2,3,3,isym) =  sin2a
          dsym(3,2,3,isym) =  sin2a
          dsym(4,1,3,isym) =  sin4a
        endif
c
        goto 50
c
  100 continue
c
      if( isym.ne.nsyms )then
        call FLGETIERR( IERRFL )
        write(IERRFL,*) '>>>>> must input all reflections for 2D'
        write(IERRFL,*) '>>>>> nsym(rotmat),nsym(code)=',isym,nsyms
        call STOPXERR( '2d-syms - 2D symmetry input incomplete' )
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RUNDATA
c
c
      subroutine RUNDATA( IDAT,IWR,  doflag,
     $ itstart,itstop,meth_bl,nhiste,igesopt,
     $ convgr,convs,convsl,convii, conv1c, alfast,
     $ icloseocc,
     $ edegen,etemp, scfblnd,scfbl2,scfconv, nstate,norb,nocc0k,
     $ opt_spin, meth_sp,conv_sp,nstep_sp,blend_sp,
     $ dorelax, natm,nafrc,iforce,ifdefct,
     $          atmnm, natmnm,
     $          nslics,islics,islicats,vslics,
     $          iatframe,
     $          nhistg,gblend,gconv,tstep,igstart,igstop,
     $ do_cell, do_pvcalc, ndim, iuctype, icellscheme,strsbroy,
     $          iucstep,iuciter,maxucstep,nhistuc, cellconv,strxtrnl,
     $          strnmax, ucstepfac,cellstepdecr,cellstepincr, ucblend,
     $          strlast,
     $ idosolv, scut,
     $ nbranchd,nbranch,bvl,bsymb )
c---------------------------------------------------------------
c Purpose: read in (optional) data for Quest run
c
c Revision history:
c   3Aug17-PAS/2.68: unified slics data passing (68c) 7Jan20 meth{,bl}_asd
c   5Jun15-PAS/2.67: option to select atoms by indices
c   8Apr15-PAS/2.66: e-blend options; lnwrit lines
c  24Sep13-PAS/2.65a: pass flag for enthalpy (E+PV) calc
c  03May12-ACP+AHE/2.64: Band structure input (PAS-cosmetics)
c  16Nov10-PAS/2.62: tweak diagnostic output
c  10Dec08-PAS/2.61j: fix error in read of spsteps
c  23Sep08-PAS/2.62: option to freeze atoms along vector; isotropic cell
c  21Jan08-PAS/2.61: igesopt moved to rundata
c  10Jan08-PAS/2.61: silence SLIC unless active; spin optimization
c  11Jul07-PAS/2.60: disable/replace "last iter"/"percent" keywords
c   4Oct05-RPM/2.59: idosolv and parameters set from input file
c  14Feb05-PAS/2.59: defect k-sampling
c   7May04-RPM/2.58: add MD input stuff
c  25Apr04-PAS/2.58: purge "igtype" variable
c  25Nov03-PAS/2.58: remove scf blend reset feature
c  11Sep03-PAS/2.57: remove itmaxd-dependence
c  14Jan03-PAS/2.55: limited-history into elec, geom, and cell
c  28Jan02-PAS/2.54: pass fixed-frame atom data
c  16May02-PAS/2.53: cutoff param input moved out of "setdata"
c   3May02-PAS/2.53: install cell optimization option input
c   2Oct01-PAS/2.50: damped dynamics params
c  21Jun01-PAS/2.48: replace STOPs
c   5May01-PAS/2.47: clean echo, transfer out defaults/initialize
c   3May00-PAS/2.44: scf blend "scfbl2" for follow-on geometries
c                    occup temperature moved here; blend keyword
c   3Mar00-PAS/2.43: full branching options list
c  31Mar99-PAS/2.33: clean out green fcn stuff
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  26Oct98-PAS/2.27: restart geometry run, and end iter restart.
c  14Jul98-PAS/2.23: blend chol option; optionalize iter nums.
c  31Mar98-PAS/2.22: fix bug - passing natm into geomdat, ges
c  17Sep97-PAS/2.21: blend restart iteration, input formats
c  14Apr94-PAS/2.10
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c currently, the doflag option is unassigned
      LOGICAL    doflag
c geometry parameter stuff:
      LOGICAL    dorelax
      CHARACTER*(*)  atmnm
      DIMENSION  atmnm(*)
      DIMENSION  iforce(*)
cRMV slic projected coordinate stuff
      DIMENSION  islics(*),islicats(*),vslics(*)
      DIMENSION  iatframe(3)
c cell parameter stuff
      LOGICAL    do_cell, do_pvcalc
      DIMENSION  strxtrnl(*), strlast(3,3),ucstepfac(3,3)
c spin optimization stuff
      LOGICAL    opt_spin
c cutoff info:
      DIMENSION  convs(8)
c band structure data
      CHARACTER*3  bvl
      CHARACTER*2  bsymb(nbranchd)
c
c Local declarations:
      PARAMETER  ( nline = 128 )
      CHARACTER    label*(128), readlbl*6, wantlbl*6
      EQUIVALENCE  (label,readlbl)
      DIMENSION    vtmp(4)
      DATA         zero / 0.d0 /
c Defines blending type
      DATA    methbl_broy,methbl_asd / 1,2 /
c
c >>>> EXECUTABLE CODE:
c
c Input/output data formats:
 8000 format(a72)
 9000 format(1x,a)
 9010 format(1x,3f12.8)
 9030 format(1x,1p4d16.8)
 9130 format(1x,'***** Format change:',
     $ /5x,'Keyword >',a,'< disabled, replaced by',
     $ /5x,'keyword >',a,'<',
     $ /5x,'Modify/update input file and submit again')
 9210 format(1x,2i4)
c
      wantlbl = 'run ph'
      read(IDAT,8000)  label
      call LNWRIT( IWR, label, nline )
      if( readlbl.ne.wantlbl ) goto 1300
c
  100 continue
c
      read(IDAT,8000,err=999,end=999)  label
      call LNWRIT( IWR, label, nline )
c
      if    ( readlbl.eq. 'end ru' .or.
     $        readlbl.eq. 'end_ru' .or.
     $        readlbl.eq. 'end of' )then
c       Finished with run phase data:
        goto 999
c
      elseif( readlbl.eq. 'do fla' )then
c       Set free flag ON
        doflag = .true.
      elseif( readlbl.eq. 'no fla' )then
c       Set free flag OFF
        doflag = .false.
c
      elseif( readlbl.eq. 'first ' )then
c       Set initial iteration number
        read(IDAT,*   )  itstart
        write(IWR,9210)  itstart
c
      elseif( readlbl.eq. 'iterat' )then
c       Set final iteration number
        read(IDAT,*   )  itstop
        write(IWR,9210)  itstop
c
      elseif( readlbl.eq. 'last i' )then
c       Disabled - catch and notify
        write(IWR,9130) 'last iteration','iterations'
        call STOPXERR( 'Outdated keyword, use >iterations<' )
c
      elseif( readlbl.eq. 'blmeth' )then
c       Select a Method for Blending
        read(IDAT,8000,err=999,end=999)  label
        call LNWRIT( IWR, label, nline )
        call STRPARS( label, 1,60, il1,il2 )
c       We assume here that method is a 6-char string
        wantlbl = label(il1:il1+5)
        if( wantlbl.eq.'BROYDE' .or. wantlbl.eq.'Broyde' .or.
     $      wantlbl.eq.'broyde' )then
          meth_bl = methbl_broy
        elseif( wantlbl.eq.'ASD' .or. wantlbl.eq.'asd' )then
          meth_bl = methbl_asd
          nhiste = 0
        endif
c
      elseif( readlbl.eq. 'histor' )then
c       Number of steps to keep in scf blending history
        read(IDAT,*   )  nhiste
        if( meth_bl .eq. methbl_asd )then
          write(IWR,*) '# For ASD blend, nhiste set to 0'
          nhiste = 0
        endif
        write(IWR,9210)  nhiste
c
      elseif( readlbl.eq. 'restar' )then
c       Restart blend scheme at specified iteration number
        write(IWR,*) '***** restart blend feature removed'
        write(IWR,*) '***** use history feature instead'
        call STOPXERR( 'restart blend feature removed' )
c
      elseif( readlbl.eq. 'states' )then
c       Number of states for eigensolve/density computation
        read(IDAT,*   )  nstate
        write(IWR,9210)  nstate
c
      elseif( readlbl.eq. 'temper' )then
c       Temperature for level occupations
        read(IDAT,*   )  etemp
        write(IWR,9010)  etemp
c
      elseif( readlbl.eq. 'kclose' )then
c       Set almost closed occs - fixed e-count within k-pt
        icloseocc = 1
      elseif( readlbl.eq. 'closed' )then
c       Set closed occs  - 0K, fixed e-count within k-pt
        icloseocc = 2
c
      elseif( readlbl.eq. 'edegen' )then
c       Energy difference criterion for degeneracy of states
        read(IDAT,*   )  edegen
        write(IWR,9010)  edegen
c
      elseif( readlbl.eq. 'no ges' )then
c       Simple overlapping atom guess for new geom scf.
        igesopt = 0
      elseif( readlbl.eq. 'do ges' )then
c       Use full dHam guess for scf ges for new geom scf.
        igesopt = 2
      elseif( readlbl.eq. 'guess ' )then
c       Specify type of scf guess for new geometry
        read(IDAT,*)  igesopt
        write(IWR,'(1x,i4,5x,a)')  igesopt,' = option for scf ges'

      elseif( readlbl.eq. 'blend ' )then
c       Blend ratio for initial scf step
        read(IDAT,*   )  scfblnd
        write(IWR,9010)  scfblnd
      elseif( readlbl.eq. 'percen' )then
c       Disable - catch and notify
        write(IWR,9130) 'percent blend','blend ratio'
        call STOPXERR( 'Outdated keyword, use >blend ratio<' )
c
      elseif( readlbl.eq. 'scfbl2' )then
c       Blend ratio for initial scf step, for subsequent geoms
        read(IDAT,*   )  scfbl2
        write(IWR,9010)  scfbl2
c
      elseif( readlbl.eq. 'conver' )then
c       Convergence criterion for scf (del-Ham)
        read(IDAT,*   )  scfconv
        write(IWR,9010)  scfconv
c
      elseif( readlbl.eq. 'alfast' )then
c       Boundary between slow/fast gaussians
        read(IDAT,*   )  alfast
        write(IWR,9010)  alfast
      elseif( readlbl.eq. 'idosol' )then
c       idosolv controls which solver is used in the eigensolver
        read(IDAT,* ) idosolv
        write(IWR,9210) idosolv
      elseif( readlbl(1:4).eq. 'scut')then
c       scut is the value below which eigenvalues of S are discarded
c        when idosolv=3
        read(IDAT,* ) scut
        write(IWR,9010) scut
c
      elseif( readlbl(1:3).eq.'cut' )then
c       Various cutoffs for integrals
c
        if(     readlbl .eq. 'cutii ' )then
          read(IDAT,*   )  convii
          write(IWR,9030)  convii
        elseif( readlbl .eq. 'cutslo' )then
          read(IDAT,*   )  convsl
          write(IWR,9030)  convsl
        elseif( readlbl .eq. 'cut2s ' )then
          read(IDAT,*   )  conv2s
          write(IWR,9030)  conv2s
        elseif( readlbl .eq. 'cutset' )then
          read(IDAT,*   )  cutfac
          write(IWR,9030)  cutfac
          do  ic=1,4
            convs(ic) = cutfac*convs(ic)
          enddo
        elseif( readlbl .eq. 'cutfrc' )then
          read(IDAT,*   )  cutfac
          write(IWR,9030)  cutfac
          do  ic=5,8
            convs(ic) = cutfac*convs(ic)
          enddo
        elseif( readlbl .eq. 'cutfac' )then
          read(IDAT,*   )  cutfac
          write(IWR,9030)  cutfac
          do  ic=1,8
            convs(ic) = cutfac*convs(ic)
          enddo
        elseif( readlbl .eq. 'cutall' )then
C          read(IDAT,*   )  (convs(ic),ic=1,8)
          read(IDAT,*   )  (vtmp(i),i=1,4)
          write(IWR,9030)  (vtmp(i),i=1,4)
          do  i=1,4
            if( vtmp(i).gt.zero ) convs(i) = vtmp(i)
          enddo
          read(IDAT,*    )  (vtmp(i),i=1,4)
          write(IWR,9030)  (vtmp(i),i=1,4)
          do  i=1,4
            if( vtmp(i).gt.zero ) convs(i+4) = vtmp(i)
          enddo
        elseif( readlbl .eq. 'cutgrd' )then
          read(IDAT,*   )  convgr
          write(IWR,9030)  convgr
        elseif( readlbl .eq. 'cut1c ' )then
          read(IDAT,*   )  conv1c
          write(IWR,9030)  conv1c
        else
c         Do not recognize cut option
          goto 1399
        endif
c
c ***************************
c  Spin optimization options
c ***************************
c
      elseif( readlbl.eq. 'spconv' )then
c       Convergence criterion (polorization, in e) for spin opt
        read(IDAT,*   ) rdat
        write(IWR,9010) rdat
        if( rdat .gt. zero ) conv_sp = rdat
c
      elseif( readlbl.eq. 'spblen' )then
c       Number of steps allowed for spin optimization
        read(IDAT,*   ) rdat
        write(IWR,9010) rdat
        if( rdat .gt. zero .and. rdat .lt. 10.d0 ) blend_sp = rdat
c
      elseif( readlbl.eq. 'spstep' )then
c       Step limit for spin optimization
        read(IDAT,*   ) itmp
        write(IWR,9210) itmp
        if( itmp .gt. 0 ) nstep_sp = itmp
c
      elseif( readlbl.eq. 'spmeth' )then
c       Select a Method for spin optimization
        read(IDAT,8000,err=999,end=999)  label
        call LNWRIT( IWR, label, nline )
        call STRPARS( label, 1,60, il1,il2 )
c       We assume here that method is a 6-char string
        wantlbl = label(il1:il1+5)
        if( wantlbl.eq.'LINEAR' .or. wantlbl.eq.'linear' .or.
     $   wantlbl.eq.'Linear' )then
          meth_sp = 1
        else
c         Safest is to default to "SIMPLE" method
          meth_sp = 0
        endif
c
c ***************************
c  Geometry update options
c ***************************
c
      elseif( readlbl.eq. 'geomet' )then
c       Geometry relaxation parameter specifications:
        call GEOMDAT( IWR,IDAT, dorelax,
     $   natm,nafrc,iforce,ifdefct,
     $   atmnm, natmnm,
     $   nhistg,gblend,gconv,tstep,igstart,igstop,
     $   nslics,islics,islicats,vslics,   iatframe )
c
      elseif( readlbl .eq. 'md dat' .or.
     $        readlbl .eq. 'dynami' )then
c       Molecular dynamics input (either "md data" or "dynamics":
        call QMDDAT( IWR,IDAT )
c
c ***************************
c  Cell optimization options
c ***************************
c
      elseif( readlbl(1:5).eq. 'cell ' )then
c       Cell optimization parameter specifications:
        call CELLDAT( IWR,IDAT,
     $   do_cell, do_pvcalc, ndim, iuctype, icellscheme,strsbroy,
     $   iucstep,iuciter,maxucstep,nhistuc, cellconv,strxtrnl,
     $   strnmax, ucstepfac,cellstepdecr,cellstepincr, ucblend,
     $   strlast )
c
      elseif( readlbl(1:5).eq.'bands') then
c       Band structure data
        call BANDDATA( IDAT,IWR, nbranchd,nbranch,bvl,bsymb )
c
c ***************************
c  And the alternative ...
c ***************************
c
      else
c       Do not know what is happening:
        call STOPXERR( 'rundata - unknown input command' )
c
      endif
c
      goto 100
c
  999 continue
c
c ***************************
c  Finished, do checks
c ***************************
c
c Prevent stupidities, 21jan93-PAS:
      if( nstate.gt.norb ) nstate = MIN( nocc0k+10, norb )
      if( nstate.lt.nocc0k )then
        write(IWR,*) '>>>>> electron pairs, states=',nocc0k,nstate
        call STOPXERR( 'nstate-m - too few occupied states' )
      endif
c
c Record the cutoffs to the output file:
      write(IWR,'(a)') 'cutXXX for code (grd,slo,ii,1c)'
      write(IWR,9030)   convgr,convsl,convii,conv1c
      write(IWR,'(a)') 'cutall for code (s,t,nl,loc;frc)'
      write(IWR,9030)  (convs(ic),ic=1,8)
      if( icloseocc.eq.2 )
     $write(IWR,'(a,f12.6)') 'etemperature(Ry)=',etemp
c
      write(IWR,*)
      write(IWR,*)  '##### output #####'
      write(IWR,*)
c
      RETURN
c
c >>>>>> ERROR HANDLING:
c
 1300 continue
      write(IWR,*) 'Want label >',wantlbl,'<, found >',readlbl,'<'
 1399 continue
      call STOPXERR( 'rundata - bad input' )
c
c    That's all Folks!
c
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RUNOPT
c
c
      subroutine RUNOPT( IDAT,IWR, lvlout,mkrhopt, kparopt,
     $ dotests, dosetup,doiters,doforce,dorelax,do_cell,do_pvcalc,
     $ opt_spin, do_md, do_neb, do_post,
     $ do_bands, do_optic, do_nonscf,
     $ dosplit,doblas3, redusym, dolocxc,
     $ dospars,doeigen,doprjct,dorspsy,dodefct,
     $ do_kppsolve, do_psolv )
c---------------------------------------------------------------
c Purpose: options read in for setup phase, bulk code
c
c Revision history:
c  24Sep13-PAS/2.65a: offer flag for enthalpy (E+PV) calculation
c  01May12-ACP/2.63: kppsolve (parallel-parallel) flag (do_kppsolve)
c  01May12-ACP+AHE/2.63: non-SCF calc flags (do_bands, do_optic)
c  22Nov08-PAS/2.63: k-parallelism flag; 05Dec12-PAS: psolv flag
c  10Jan08-PAS/2.61: spin optimization
c  11Jul07-PAS/2.60: disable/replace "input data" keyword
c   7May04-RPM/2.58: add MD flag
c  23Jul03-PAS/2.56: add option to set record length
c   4Jan03-PAS/2.55: add "setup data" = "input data"
c   5Jan02-PAS/2.52: do_cell flag input
c  21JUn01-PAS/2.48: replace STOPs
c   2May01-PAS/2.47: echo output level control, add do_neb
c   4May00-PAS/2.44: added Raczkowski's flags for real/recip
c                    space sym and linear scaling defect calc.
c  10Jun99-PAS/2.36: flags for blas3,lin scaling
c  14May99-PAS/2.35: option force dm/ef grid density build
c  31Mar99-PAS/2.33: purge green fcn, pass locxc and madel
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  29Jun98-PAS/2.23: flags for split basis and eigen/linscale
c  23Jun98-PAS/2.23: output level control
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      LOGICAL   dotests
      LOGICAL   dosetup,doiters,doforce,dorelax,do_cell,do_pvcalc
      LOGICAL   opt_spin, do_md, do_neb, do_post
      LOGICAL   do_bands, do_optic, do_nonscf
      LOGICAL   dosplit,doeigen,doblas3, redusym, dolocxc
      LOGICAL   dospars,doprjct,dorspsy,dodefct
      LOGICAL   do_kppsolve, do_psolv
c
c local declarations:
      CHARACTER  label*80, readlbl*8
      EQUIVALENCE  (label,readlbl)
c
c >>>> EXECUTABLE CODE:
c
 8000 format(a)
 9000 format(1x,a)
 9130 format(1x,'***** Format change:'
     $ /5x,'The keyword >',a,'< has been replaced by'
     $ /5x,'the keyword >',a,'<'
     $ /5x,'Modify/update input file and submit again')
c
      write(IWR,'(a)') '##### Run options:'
c
  100 read(IDAT,8000)  label
      write(IWR,9000)  label
c
      if(     readlbl .eq. 'setup da' )then
        goto 990
c
      elseif( readlbl .eq. 'input da' )then
c       Disable - catch and notify
        write(IWR,9130) 'input data','setup data'
        call STOPXERR( 'Outdated keyword, use >setup data<' )
c
      elseif( readlbl .eq. 'set reco' )then
c       Change maximum record length in i/o
        read(IDAT,*)  maxrecl
        write(IWR,'(i10)')  maxrecl
        call IOSETRECL( maxrecl )
c
      elseif( readlbl .eq. 'output l' )then
        read(IDAT,*)  lvlout
        write(IWR,'(i5)')  lvlout
c
c  Compel type of grid density build?
      elseif( readlbl .eq. 'do dmrho' )then
        mkrhopt = 1
      elseif( readlbl .eq. 'no dmrho' )then
        mkrhopt = 2
      elseif( readlbl .eq. 'do efrho' )then
        mkrhopt = 2
      elseif( readlbl .eq. 'no efrho' )then
        mkrhopt = 1
c
c  Compel or forbid k-parallelism:
      elseif( readlbl .eq. 'do kpara' )then
        kparopt = -2
C        call KPFLAG_SET( kparopt )
      elseif( readlbl .eq. 'no kpara' )then
        kparopt = -1
C        call KPFLAG_SET( kparopt )
c
c  Choose to compel series of parallel solves?
      elseif( readlbl .eq. 'do psolv' )then
        do_psolv = .true.
      elseif( readlbl .eq. 'no psolv' )then
        do_psolv = .false.
c
      elseif( readlbl .eq. 'do tests' )then
        dotests = .true.
      elseif( readlbl .eq. 'no tests' )then
        dotests = .false.
c
      elseif( readlbl .eq. 'do setup' )then
        dosetup = .true.
      elseif( readlbl .eq. 'no setup' )then
        dosetup = .false.
c
      elseif( readlbl .eq. 'do iters' )then
        doiters = .true.
      elseif( readlbl .eq. 'no iters' )then
        doiters = .false.
c
      elseif( readlbl .eq. 'do force' )then
        doforce = .true.
      elseif( readlbl .eq. 'no force' )then
        doforce = .false.
c
      elseif( readlbl .eq. 'do relax' )then
        dorelax = .true.
      elseif( readlbl .eq. 'no relax' )then
        dorelax = .false.
c
      elseif( readlbl .eq. 'do cell ' )then
        do_cell = .true.
      elseif( readlbl .eq. 'no cell ' )then
        do_cell = .false.
c
      elseif( readlbl .eq. 'do entha' )then
        do_pvcalc = .true.
      elseif( readlbl .eq. 'no entha' )then
        do_pvcalc = .false.
c
      elseif( readlbl .eq. 'do neb  ' )then
        do_neb  = .true.
      elseif( readlbl .eq. 'no neb  ' )then
        do_neb  = .false.
c
      elseif( readlbl .eq. 'do spino' )then
        opt_spin = .true.
      elseif( readlbl .eq. 'no spino' )then
        opt_spin = .false.
c
cqmd: do md OR do dynamics?
      elseif( readlbl .eq. 'do md   ' .or.
     $        readlbl .eq. 'do dynam' )then
        do_md = .true.
        if (.not. doforce)
     $          write(IWR,*) "Turning on doforce because of dynamics"
        doforce = .true.
        doiters = .true. 
        dosetup = .true.
      elseif( readlbl .eq. 'no md   ' .or.
     $        readlbl .eq. 'no dynam' )then
        do_md = .false.
c
      elseif( readlbl .eq. 'do post ' )then
        do_post = .true.
      elseif( readlbl .eq. 'no post ' )then
        do_post = .false.
c
      elseif(readlbl .eq. 'do bands') then
           do_bands=.true.
           do_nonscf=.true.
      elseif(readlbl .eq. 'no bands') then
           do_bands=.false.
c
      elseif(readlbl.eq. 'do optic')then
         do_optic=.true.
         do_nonscf=.true.
      elseif(readlbl .eq. 'no optic') then
         do_optic=.false.
c
      elseif( readlbl .eq. 'do split' )then
        dosplit = .true.
      elseif( readlbl .eq. 'no split' )then
        dosplit = .false.
c
      elseif( readlbl .eq. 'do blas3' )then
        doblas3 = .true.
      elseif( readlbl .eq. 'no blas3' )then
        doblas3 = .false.
c
      elseif( readlbl .eq. 'do kppso' .or.
     $        readlbl .eq. 'do kpsol' )then
        do_kppsolve = .true.
      elseif( readlbl .eq. 'no kppso' .or.
     $        readlbl .eq. 'no kpsol' )then
        do_kppsolve = .false.
c
      elseif( readlbl .eq. 'redusym ' )then
        redusym = .true.
      elseif( readlbl .eq. 'keepsym ' )then
        redusym = .false.
c
      elseif( readlbl .eq. 'do locxc' )then
        dolocxc = .true.
      elseif( readlbl .eq. 'no locxc' )then
        dolocxc = .false.
c
c
      elseif( readlbl .eq. 'do spars' )then
        dospars = .true.
      elseif( readlbl .eq. 'no spars' )then
        dospars = .false.
c
      elseif( readlbl .eq. 'do eigen' )then
        doeigen = .true.
      elseif( readlbl .eq. 'no eigen' )then
        doeigen = .false.
c
      elseif( readlbl .eq. 'do prjct' )then
        doprjct = .true.
      elseif( readlbl .eq. 'no prjct' )then
        doprjct = .false.
c
      elseif( readlbl .eq. 'do rspsy' )then
        dorspsy = .true.
      elseif( readlbl .eq. 'no rspsy' )then
        dorspsy = .false.
c
      elseif( readlbl .eq. 'do defct' )then
        dodefct = .true.
      elseif( readlbl .eq. 'no defct' )then
        dodefct = .false.
c
      else
        write(IWR,*) '>>>>> Wanted: [do|no] [setup|iters|force|relax]'
        write(IWR,*) '>>>>> or [setup data], but got instead: ',readlbl
        call STOPXERR( 'optlabel/ bad runopt command option' )
      endif
c
c Go back and try to find more command options ...
      goto 100
c
  990 continue
c
      write(IWR,*) '>>>>> Options (set/scf/frc/relax/cell/neb/md)=',
     $  dosetup,doiters,doforce,dorelax,do_cell,do_neb,do_md
      write(IWR,*) '>>>>> use blas3=',doblas3
      write(IWR,*) '>>>>> split basis =',dosplit
      write(IWR,*) '>>>>> Output level set =',lvlout
c
c     For now, we will assure that if there are no band-structure
c     or optical properties requested, that do_nonscf is false
c
      if(.not.do_bands .and. .not. do_optic) do_nonscf=.false.
      write(IWR,*) '>>>> do_bands, do_optic, do_nonscf=',
     $  do_bands, do_optic, do_nonscf

      RETURN
c
c    That's all Folks!
c
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SCHROED
c
c
      subroutine SCHROED( do_eigvecs,
     $ idhamfl,iham0fl,iovlpfl,ivecfl, idosolv,
     $ norb,nstate,nk, eigval, rwork, seval, scut,
     $ vmat, wmat, iwork )
c---------------------------------------------------------------
c Purpose: solve Schroedinger equation given input ham and ovlp
c
c Written: Peter A. Schultz,  8-April-1999, for v2.34
c
c Revision history:
c  10Jan13-PAS/2.64: pass do_eigvecs and cosmentics
c  25Jun07-PAS/2.60: merge tp and serial
c  11Sep05-PAS/2.59: remove lin.dep.-based dynamic memory use
c  14Aug05-PAS/2.59: d-Ham from disk + reduce vmat mem req.
c  08Jun05-RPM/2.59: added ability to do a canonical orthogonalization
c                    to remove linear dependence in the basis set
c   8Aug03-PAS/2.56: cosmetics; k-vector cleanup
c  24Jul01-PAS/2.49: spin-polarized dft
c  21Jun01-PAS/2.48: replace STOPs
c  17May01-PAS/2.47: extract writes
c  23Aug99-PAS/2.38: install zhegvx expert driver eigensolve
c  10May99-PAS/2.35: eigvals cut from ivecfl output
c   9Apr99-PAS/2.34: complex lapack eigensolver installed
c  15Feb99-PAS/2.31: routine to intercept perhaps too-big i/o
c  10Dec98-PAS/2.29: promote source to explicit double precision
c   5Sep98-PAS/2.25: print out spectral limits
c  14Jul98-PAS/2.23: option to use unchol'd delta-Ham
c  12Aug94-PAS/2.11: cleanup
c---------------------------------------------------------------
c
c When this routine is done
c   (1) it writes out eigenvectors to ivecfl
c   (2) it returns eigenvalues in "eigval()"
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input flags:
      LOGICAL    do_eigvecs
c Output: eigenvalue spectrum
      DIMENSION  eigval(nstate,nk)
c Scratch arrays:
      DIMENSION  rwork(7*norb)
      DIMENSION  seval(norb)
      DIMENSION  iwork(norb,*)
      DIMENSION  vmat(norb*norb)
      DIMENSION  wmat(norb*norb,*)
c
c Local declarations:
      CHARACTER  jobz*1,uplo*1
      COMPLEX*16 cone,czero
      DOUBLE PRECISION  small,scut
c
c >>>> EXECUTABLE CODE:
c
      mat = norb*norb
c
c Do eigenvectors with jobz='V' (jobz="N" turns off eigenvectors):
      if( do_eigvecs )then
c       Compute eigenvalues and eigenvectors
        jobz = 'V'
      else
c       Non-scf, compute eigenvalues only
        jobz = 'N'
        if( idosolv.eq.3 )
     $   call STOPXERR( 'idosolv=3 incompatible with non-scf' )
      endif
      uplo = 'L'
c
      REWIND( unit=iham0fl )
      REWIND( unit=iovlpfl )
c
c    Bloch vector loop:
c
      do 1000 k=1,nk
c
c       Assemble Hamiltonian(spin,k)
c
c       Retrieve delta-Hamiltonian from idhamfl
        call READBIG( idhamfl, mat, vmat )
c       Retrieve reference Hamiltonian from iham0fl
        call READBIG( iham0fl, mat, wmat(1,1) )
c       Add del-Ham to ref-Ham to get total Ham
        do  ij=1,mat
          vmat(ij) = wmat(ij,1) + vmat(ij)
        enddo
c
c       Retrieve overlap matrix from iovlpfl
        call READBIG( iovlpfl , mat, wmat(1,2) )
c
c       Load overlap into lower triangle full complex matrix wmat(3:4)
        call C16LOW( norb, wmat(1,2), wmat(1,3) )
c       Load Ham into lower triangle of full complex matrix wmat(1:2)
        call C16LOW( norb, vmat     , wmat(1,1) )
c
c       Need 3*norb-2 for r*8 workspace "rwork"
c       lwork is (complex) length for workspace "l"
        lwzwork = MAX( 4*norb, mat )
        lwork = lwzwork / 2
C        lwork = mat / 2
c
c       Ham is in wmat(,1:2), overlap in wmat(,3:4)
c       Eigenvectors will be returned in wmat(,1:2)
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                  Solve Schroedinger equation
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
        if( idosolv .eq. 1 )then
c
c         ***** Full Hermitian eigenproblem *****
c
          call ZHEGV( 1,jobz, 'L',
     $     norb, wmat(1,1),norb,         wmat(1,3),norb,
c -->            H(2,n,n)-i/vec(2,n,n)-o S(2,n,n)-i
     $     eigval(1,k), vmat     ,lwork, rwork, INFO )
c -->                   work(2,lwork)    (3n-2)
c
        elseif( idosolv .eq. 2 )then
c
c         *****  Selected eigenvalue Hermitian eigenproblem *****
c
          call ZHEGVX( 1,jobz, 'I', 'L',
     $     norb, wmat(1,1),norb,         wmat(1,3),norb,
c -->            H(2,n,n)-i              S(2,n,n)-i
     $     -100d0,-20d0, 1,nstate, 2*DLAMCH('S'), nstout,eigval(1,k),
     $     wmat(1,5),norb,    vmat     ,lwork, rwork,
c -->      eigvec(2,n,nstate) work(2,lwork)    (7n)
     $     iwork(1,2),iwork, INFO )
c -->      int(5n)    int(n)
c
c         Put eigenvectors in the right place:
          if( do_eigvecs )then
            call DCOPY( 2*norb*nstate, wmat(1,5),1, wmat(1,1),1 )
          endif
c
        elseif( idosolv .eq. 3 )then
c
c         ***** Deal with linear dependence issues *****
c
c         Parameters that should be soft-coded
c         small - cutoff for filtering small vals (HARDWIRE)
c         scut - cutoff for eigenvalues of S (from input)
          small = 1d-12
c          scut = 1d-6
c
c         Form eigenvectors/vals of S, and from these form
c         orthogonal transformation matrix X. Overwrites wmat(1,3:4)
          cone = DCMPLX( 1d0,0d0 )
          czero = DCMPLX( 0d0,0d0 )
          call FILTERZMAT( wmat(1,3),norb,norb,small )
          call ZHEEV( 'V','L',norb,wmat(1,3),norb,
     $         seval,vmat     ,lwork,rwork,info )
c          print*, 'lowest few S evs'
c          write(*,'(8f10.4)') (seval(i),i=1,8)
          call CANON_XMAT( wmat(1,3),norb,norb,neff,seval,scut,small )
c
c         Square out the upper triangle of H
          call SYMZMAT( wmat(1,1),norb,norb,small )
          call ZGEMM( 'N','N',norb,neff,norb,cone,wmat(1,1),norb,
     $         wmat(1,3),norb,czero,wmat(1,5),norb )
          call ZGEMM( 'C','N',neff,neff,norb,cone,wmat(1,3),norb,
     $         wmat(1,5),norb,czero,wmat(1,1),norb )
c
c          Now solve the transformed matrix
c          print*, 'H',k,nk
c          call printmat( norb,wmat(1,1),3,3 )
           call ZHEEV( 'V','L',neff,wmat(1,1),norb,
     $         eigval(1,k),vmat     ,lwork,rwork,info )
c          print*, 'cprime'
c          call printmat(norb,wmat(1,1),3,3)
c          print*, "eigvals "
c          write(*,'(8f10.4)') (eigval(j,k),j=1,norb)
c
c         The evals are correct, but we need to mult the evecs by
c         X to get the right values
          call DCOPY( 2*norb*norb, wmat(1,1),1, wmat(1,5),1 )
          call ZGEMM( 'N','N',norb,neff,neff,cone,wmat(1,3),norb,
     $         wmat(1,5),norb,czero,wmat(1,1),norb )
c          print*, 'c'
c          call printmat( norb,wmat(1,1),3,3 )
c
        else
c
          call STOPXERR( 'solvopt /invalid SCHROED eigensolver option' )
c
        endif
c
        if( INFO .ne. 0 )then
          call STOPXERR( 'diag-err/ SCHROED diagonalization error' )
        endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c              Record eigenvalues and eigenvectors
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
        if( do_eigvecs )then
c         Save eigenfunction coefficients:
          call WRITBIG( ivecfl, 2*norb*nstate, wmat(1,1) )
        endif
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c===============================================================
c    Utility routines
c===============================================================
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> CANON_XMAT
c
      subroutine CANON_XMAT( u,lda,n,neff,seval,scut,small )
c
c     Form the canonical orthogonalization transformation 
c     matrix from the eigenvalues (seval) and eigenvectors
c     (u) of the overlap matrix.
c
c     We also need to insure that there aren't any very small
c     values that result from this
c
c     Also returns neff, the number of effective states, i.e.
c     the states with a stable S eigenvalue
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      INTEGER  lda,n,i,j,neff
      COMPLEX*16  u(lda,n)
      DOUBLE PRECISION  seval(n),scut,small
c
      neff = 0
      do  j=1,n
        if( seval(j) .gt. scut )then
          neff = neff + 1
          do  i=1,n
            u(i,neff) = u(i,j) / DSQRT( seval(j) )
          enddo
        endif
      enddo
      call FILTERZMAT( u,lda,n,small )
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMZMAT
c
      subroutine SYMZMAT( a,lda,n,small )
c
c     symmetrize the upper triangle of complex*16 matrix a
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      INTEGER  lda,n,i,j
      COMPLEX*16  a(lda,n)
      DOUBLE PRECISION  small
c
      call FILTERZMAT( a,lda,n,small )
      do  i=1,n
        do  j=1,i
          a(j,i) = DCONJG( a(i,j) )
        enddo
      enddo
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> FILTERZMAT
c
      subroutine FILTERZMAT( a,lda,n,small )
c
c     Set all values in complex matrix *a* below *small* to zero
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero = 0.d0 )
c
      INTEGER  lda,n,i,j
      COMPLEX*16  a(lda,n)
      DOUBLE PRECISION  a_re, a_im, small
c
      do  j=1,n
        do  i=1,n
          a_re = DBLE( a(i,j) )
          a_im = DIMAG( a(i,j) )
          if( DABS( a_re ) .lt. small ) a_re = zero
          if( DABS( a_im ) .lt. small ) a_im = zero
          a(i,j) = DCMPLX( a_re, a_im )
        enddo
      enddo
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000
characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SETDATA
c
c
      subroutine SETDATA( IDAT,IWR, do_gga,do_spin,
     $ c6vdw,r0vdw, c6ijvdw,r0ijvdw,
     $ do_field, efield, dielec,
     $ dokdefct, nedefct,
     $ ndim, n1r,n2r,n3r, nearopt,near2c,
     $ iatmfmt, natmnm,typnm,atmnm,
     $ natm,natmd,ntyp,ntypd,nshld,nald, noad,
     $ itypa, numshl,lshel,nala,ala,cala,  occsh, norba, znuc,
     $ atmass,atengy,
     $ dolvatm, ratm, rprim,dorig,rscale,
     $ nk,nkd, veckg,wtk,wtkscal,nku,iktype,dokgrid,
     $ nsymd,nsymi,ndimsy, rsym,isymtyp,syminfo,
     $ spinpol, elchrg,rchrg,ion_opt,
     $ any1ctr, lmx1ctr,almnv1c,lmxnlp1,almnnl,
     $ nrd,nrad,nrps,radmsh,radwt,vpsrad,
     $ anycore, nrcor,corden,cordrv,
     $ anyxc1c,nfityp,alxcmin,nalfxc,nrxcfit,nalfxcd,alfxc,alsq,ipvt,
     $ wkrd )
c---------------------------------------------------------------
c Purpose: get all data necessary for setup phase of lcao code
c
c Written: Peter A. Schultz, 15-January-2001,  for SeqQ 2.46
c
c Revision history:
c   8Apr15-PAS/2.66: character limited line-writes; lcao.geom_in!!!
c   6Apr13-PAS/2.65: add vdW options
c  12May11-PAS/2.62: add flags for slab double-layer countercharge
c  23Sep08-PAS/2.62: cell volume optimization
c   5Dec07-PAS/2.60c: to_lattice->rsym,dorig uninit fixed
c  30Jun06-PAS/2.60: expand format for data echo
c  14Feb05-PAS/2.59: defect k-sampling
c  20Oct03-PAS/2.58: cosmetic change; 19Feb04: clean-up hex vectors
c  17Aug03-JTK+PAS/2.57: add external electric field; dielectric
c   8Aug03-PAS/2.56: add special offset hexagonal grid;
c                    k-vectors renamed and put in lattice units
c   5Aug03-PAS/2.55a: fix k-vector/lattice-units input
c   5Jan02-PAS/2.54: call to "configwr" altered
c  24May02-PAS/2.53e: hack: cartesian<->lattice atom conversion
c  16May02-PAS/2.53: cutoff input moved to "rundata"
c   4Apr02-PAS/2.52b: more string handling modifications
c   7Mar02-PAS/2.52: N/U occij cleaned out/isymi init
c  26Nov01-PAS/2.51: configuration files; file/unit mgr
c   3Oct01-PAS/2.50: input atom masses and reference energies
c  24Jul01-PAS/2.49: spin-polarized dft/input polarization/wtk
c  21JUn01-PAS/2.48: replace STOPs
c   5May01-PAS/2.47: fix error handling for file open, clean echo
c  15Jan01-PAS/2.46: adapted from old "indata" routine
c---------------------------------------------------------------
c
c Notes:
c  This routine reads the data which defines the problem - dimension,
c  lattice parameters, atoms and positions, BZ sampling, etc.  The
c  input is driven by six-letter "labels".  This aids several things.
c  Checks that input file is correctly assembled, allows for the input
c  of optional data, and allows the input file to be self-documenting
c  for the user.  Most of the data is read in free-format, and then
c  (almost) perfectly echoed (formatted) as it comes in to aid in
c  debugging.  For the most part, the input of data is in a very
c  strict order (the input of run phase, geometry phase, and neb input
c  in "rundata", "geomdat", and "nebdat"), with optional data.
c  There is required input (latvecs, atoms and positions, etc.), and
c  optional input.  Some of the optional input involves required
c  data but for which hopefully sensible defaults are in place, and
c  cutoffs), and others which fuel capabilities (e.g. BZ samples,
c  and others which simply make input easier (scaling).
c  Some of the key optional inputs are echoed even if not in input
c  deck, simply to illustrate their use to a user.  The trickiest
c  part of the input is keeping track of where the last read was
c  done so that you know whether to read a new label, or check one
c  you have already read previously.  This should get cleaned up.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
c flags to evaluate gga gradients, and spin-polarized:
      LOGICAL    do_gga, do_spin
      LOGICAL    do_field
c flag to select k-sampling for defect states
      LOGICAL    dokdefct
c flags for auto-kgrid, lattice coordinates, clean up vectors
      LOGICAL    dokgrid, dolvatm, do_clean
cvdw vdw-defining information
      LOGICAL    DO_VDW
      DIMENSION  c6vdw(*),r0vdw(*)
      DIMENSION  c6ijvdw(*),r0ijvdw(*)
c electric field
      DIMENSION  efield(3)
c number of defect states of up and of dn spin
      DIMENSION  nedefct(2)
c scaling parameters, primitive lattice vectors, origin offset
      DIMENSION  rscale(3),rprim(3,4),dorig(3)
c atom coordinates, charge/wigner-seitz coordinates, center of symmetry
      DIMENSION  ratm(3,natmd), rchrg(3,*), rsym(3)
c
c symmetry definitions
      DIMENSION  isymtyp(*),syminfo(6,*)
c Bloch vectors, wts, and defining params for auto-kgrid
      DIMENSION  veckg(3,nkd),wtk(nkd),nku(3)
c
c basis and potential information for atoms:
      CHARACTER*(*)  typnm(ntypd), atmnm(natmd)
      DIMENSION  itypa(natmd), numshl(ntypd),lshel(nshld,ntypd),
     $ nala(nshld,ntypd),ala(nald,nshld,ntypd),cala(nald,nshld,ntypd)
      DIMENSION  norba(ntypd)
      DIMENSION  znuc(ntypd),occsh(nshld,ntypd)
      DIMENSION  atmass(ntypd),atengy(ntypd)
      DIMENSION  lmxnlp1(ntypd),almnnl(ntypd)
      DIMENSION  nrad(ntypd),nrps(ntypd),
     $ radmsh(nrd,ntypd),radwt(nrd,ntypd),vpsrad(nrd,4,ntypd)
      LOGICAL    anycore
      DIMENSION  nrcor(ntypd), corden(nrd,ntypd),cordrv(nrd,ntypd)
c dynamic 1-center definitions(non-standard):
      LOGICAL    any1ctr
      DIMENSION  lmx1ctr(ntypd),almnv1c(ntypd)
c xc-fit variables (nonstandard/non-functional developmental code):
      LOGICAL    anyxc1c
      DIMENSION  nfityp(ntypd),alxcmin(ntypd)
      DIMENSION  nalfxc(ntypd),nrxcfit(ntypd),alfxc(nalfxcd,ntypd),
     $ alsq(nalfxcd,nalfxcd,3,ntypd),ipvt(nalfxcd,3,ntypd)
c
c Scratch space:
      DIMENSION  wkrd(*)
c
c Local declarations:
      PARAMETER  ( nline = 128 )
      CHARACTER*(nline)  label
      CHARACTER*128 atmfil,filenm
      CHARACTER*6  wantlbl,readlbl
      CHARACTER*1  ktype
      EQUIVALENCE  (label,readlbl),(label,atmfil)
      DIMENSION    vtmp(4)
      DIMENSION    gvec(3,3), strain(3,3),tmp(3,3)
c
      DATA  toev / 13.605805d0 /, toang / 0.5291771d0 /
      DATA  zero,half,one,two,three / 0.d0,0.5d0,1.d0,2.d0,3.d0 /
      DATA  vsmall / 1.d-9 /
      DATA  degpi / 180.d0 /
c
c >>>> EXECUTABLE CODE:
c
      do_clean = .true.
      rtpid2 = rtpi/two
c
      write(IWR,'(a)') 'setup data:'
c
c >>>>>> TITLE LINES/NOTES
c (optional)
      read(IDAT,8000)  label
c
      if( readlbl(1:5) .eq. 'title' )then
        call LNWRIT( IWR, label, nline )
        read( readlbl(6:6), '(i1)' )  ntitl
        if( ntitl.eq.0 ) ntitl = 1
        write(IWR,*) 'Title line(s) for this run:'
        if( ntitl.gt.0 )then
          do  ititl=1,ntitl
            read(IDAT,8000)  label
            call LNWRIT( IWR, label, nline )
          enddo
        endif
        read(IDAT,8000)  label
      endif
c
      if( readlbl(1:5) .eq. 'notes' )then
        call LNWRIT( IWR, label, nline )
        ntitl = 20
        do 100 ititl=1,ntitl
          read(IDAT,8000)  label
          call LNWRIT( IWR, label, nline )
          if( readlbl .eq. 'end_no' ) goto 101
  100   continue
        write(IWR,*) 'end_notes not found after line limit=',ntitl
        write(IWR,9013) 'endnotes - need end tag for notes: end_notes'
        goto 1310
  101   continue
        read(IDAT,8000)  label
      endif
c
c >>>>>> DFT FCNAL TYPE (capz=lda,pw91=gga,pbe,blyp)
c (optional, default=lda)
      wantlbl = 'functi'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
c
        read(IDAT,8000)  label
        call LNWRIT( IWR, label, nline )
c
        call STRPARS( label, 1,nline, n1,n2 )
        if( n1 .eq. 0 )then
           write(IWR,9013) 'nofcnal - functional label is blank'
           goto 1310
        endif
        wantlbl = '      '
        nlbl = MIN( n2-n1+1, 6 )
        wantlbl(1:nlbl) = label(n1:n2)
c
        read(IDAT,8000)  label
      else
        write(IWR,*) 'functional type, default=CAPZ'
        wantlbl = 'LDA   '
        write(IWR,*)  '  ',wantlbl
      endif
c
c Set functional type:
      call DFTSET( wantlbl )
      call DFTGETGGA( do_gga )
      call DFTGETSPIN( do_spin )
c
c >>>>>> SPIN POLARIZATION (net spin, strictly non-negative)
c (required, iff we have spin polarized calculation)
      spinpol = zero
      if( do_spin )then
        wantlbl = 'spin p'
        if( readlbl.eq.wantlbl )then
          call LNWRIT( IWR, label, nline )
          read(IDAT,*   )  spinpol
          write(IWR,9010)  spinpol
          if( spinpol .lt. zero )then
            write(IWR,9013) 'negspin - spinpol must be non-negative'
            goto 1310
           endif
c
          read(IDAT,8000)  label
        else
          write(IWR,*) 'spin polarization (strictly non-negative)'
          write(IWR,*   )  ' X.XXXXXX - free format'
          write(IWR,9013) 'nospin - provide spin polarization'
          goto 1310
        endif
      endif
c
c >>>>>> VDW TYPE (default=OFF, ulg=ulg12,dftd2=D2)
c (optional, default=lda)
      wantlbl = 'vdw_po'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
c
        read(IDAT,8000)  label
        call LNWRIT( IWR, label, nline )
c
        call STRPARS( label, 1,nline, n1,n2 )
        if( n1 .eq. 0 )then
           write(IWR,9013) 'no vdw - vdw label input is blank'
           goto 1310
        endif
        wantlbl = '      '
        nlbl = MIN( n2-n1+1, 6 )
        wantlbl(1:nlbl) = label(n1:n2)
c
        read(IDAT,8000)  label
      else
        write(IWR,*) 'vdw_potential type, default=OFF '
        wantlbl = 'OFF   '
        write(IWR,*)  '  ',wantlbl
      endif
c     Set vdW type:
      call VDWSET( wantlbl )
c
c >>>>>> DEFECT STATES FOR GAMM_POINT SAMPLING
c (optional) AND experimental - method deemed inappropriate
      wantlbl = 'defect'
      if( readlbl.eq.wantlbl )then
        dokdefct = .true.
        call LNWRIT( IWR, label, nline )
c       Get number of states, of each spin, to treat at gamma:
        if( do_spin)then
          read(IDAT,*)     nedefct
          write(IWR,9020)  nedefct
        else
          read(IDAT,*)     nedefct(1)
          write(IWR,9020)  nedefct(1)
        endif
c
        read(IDAT,8000)  label
      else
        dokdefct = .false.
        nedefct(1) = 0
        nedefct(2) = 0
      endif
c
c >>>>>> EXTERNAL APPLIED ELECTRIC FIELD
c (optional)
      wantlbl = 'efield'
      if( readlbl.eq.wantlbl )then
c       Get external field, in Ry/au
        call LNWRIT( IWR, label, nline )
        read(IDAT,*   )  (efield(id),id=1,3)
        toRy = ( 1.0d+06 * toang) / (toev * 1.0d+08)
        do  id=1,3
          vtmp(id) = efield(id) / toRy
        enddo
        write(IWR,'(1x,3f10.6,a,3f10.3,a)')
     $   ( efield(id), id=1,3 ), ' Ry/au =' ,
     $   ( vtmp(id)  , id=1,3 ), ' MV/cm'
        do_field = .true.
c
        read(IDAT,8000)  label
      else
        call MKZERO( 3, efield )
        do_field = .false.
      endif
c
c >>>>>> BULK DIELECTRIC CONSTANT (for defect bulk polarization)
c (optional)
      wantlbl = 'dielec'
      if( readlbl.eq.wantlbl )then
c       Get external dielectric constant
        call LNWRIT( IWR, label, nline )
        read(IDAT,*   )  dielec
        write(IWR,9010)  dielec
c
        read(IDAT,8000)  label
      else
c       Default to turn off: set to negative value:
        dielec = -1.d0
      endif
c
c >>>>>> PROBLEM DIMENSION (0=cluster thru 3=bulk):
c (required)
      wantlbl = 'dimens'
      call LNWRIT( IWR, label, nline )
      if( readlbl.eq.wantlbl )then
c       Retired "lattice dimension" as alternative keyword - 21Jun11
        read(IDAT,*   )  ndim
        write(IWR,9020)  ndim
        if( ndim.lt.0 .or. ndim.gt.3 )then
          write(IWR,9013) 'badndim - ndim must be 0,1,2,or 3'
          goto 1310
        endif
c
        read(IDAT,8000)  label
      else
        write(IWR,*) 'dimension of problem (0=cluster thru 3=bulk)?'
        goto 1300
      endif
c
c >>>>>> COORDINATES: cartesian or lattice
c (optional)
c  Set default to be Cartesian, not lattice vector, coordinates:
      dolvatm = .false.
c
      if( readlbl .eq. 'coordi' )then
        call LNWRIT( IWR, label, nline )
c
        read(IDAT,8000)  label
        call LNWRIT( IWR, label, nline )
c
c       Parse out the type of atomic coordinates
        call STRPARS( label, 1,nline, n1,n2 )
        if( n1 .eq. 0 )then
          write(IWR,9013) 'coordtyp - choose units: LATTICE/CARTESIAN'
          goto 1310
        endif
        wantlbl = '      '
        nlbl = MIN( n2-n1+1, 6 )
        wantlbl(1:nlbl) = label(n1:n2)
c
        if( wantlbl .eq. 'lattic' .or. wantlbl .eq. 'Lattic' .or.
     $      wantlbl .eq. 'LATTIC' )then
          dolvatm = .true.
c
          read(IDAT,8000)  label
c
          if( readlbl.eq.'lvscal' )then
            call LNWRIT( IWR, label, nline )
            read(IDAT,*   )  (rprim(i,4),i=1,3)
            write(IWR,9010)  (rprim(i,4),i=1,3)
            read(IDAT,8000)  label
          else
            rprim(1,4) = one
            rprim(2,4) = one
            rprim(3,4) = one
          endif
          do  i=1,3
            if( rprim(i,4).le.zero ) rprim(i,4) = one
          enddo
c
        elseif( wantlbl .eq. 'cartes' .or. wantlbl .eq. 'Cartes' .or.
     $          wantlbl .eq. 'CARTES' )then
          dolvatm = .false.
c
          read(IDAT,8000)  label
        else
c         At some point, we might have a Z-matrix option
          write(IWR,9013) 'badcoord - must be LATTICE or CARTESIAN'
          goto 1310
        endif
c
      else
        dolvatm = .false.
        write(IWR,9001)  'coordinates given in (lattice,cartesian):'
        write(IWR,9001)  ' cartesian'
      endif
c
c >>>>>> SCALING FACTORS
c (optional)
c  set up defaults
      do  id=1,3
        rscale(id) = one
      enddo
      scalep = one
      scaleu = one
      scalex = one
      scaley = one
      scalez = one
c
c  scalep = Global problem scaling factor:
      wantlbl = 'scalep'
      if( readlbl.eq.wantlbl .or. readlbl.eq.'scale ' )then
        call LNWRIT( IWR, label, nline )
        read(IDAT,*   )  scalep
        write(IWR,9010)  scalep
        read(IDAT,8000)  label
      else
        write(IWR,9001) 'scalep: scale factor for problem'
        write(IWR,9010)  scalep
      endif
c
c  scaleu = Global scaling factor, in periodic directions:
c    NB: using "scaleu" (periodic directions) makes major assumption
c    about directions of unit cell vectors, an assumption that is
c    *not* checked in this code.  Use at own risk.
      wantlbl = 'scaleu'
      if( readlbl.eq.wantlbl .or. readlbl.eq.'uc sca' )then
        call LNWRIT( IWR, label, nline )
        read(IDAT,*   )  scaleu
        write(IWR,9010)  scaleu
        read(IDAT,8000)  label
C      else
C        write(IWR,9001) 'scaleu factor: scale periodic directions'
C        write(IWR,9010)  scaleu
      endif
c
c  scalex = Global scaling fector in x-direction:
      wantlbl = 'scalex'
      if( readlbl.eq.wantlbl .or. readlbl.eq.'xscale' )then
        call LNWRIT( IWR, label, nline )
        read(IDAT,*   )  scalex
        write(IWR,9010)  scalex
        read(IDAT,8000)  label
C      else
C        write(IWR,9001) 'scalex factor: scale x-direction'
C        write(IWR,9010)  scalex
      endif
c
c  scaley = Global scaling fector in y-direction:
      wantlbl = 'scaley'
      if( readlbl.eq.wantlbl .or. readlbl.eq.'yscale' )then
        call LNWRIT( IWR, label, nline )
        read(IDAT,*   )  scaley
        write(IWR,9010)  scaley
        read(IDAT,8000)  label
C      else
C        write(IWR,9001) 'scaley factor: scale y-direction'
C        write(IWR,9010)  scaley
      endif
c
c  scalez = Global scaling fector in z-direction:
      wantlbl = 'scalez'
      if( readlbl.eq.wantlbl .or. readlbl.eq.'zscale' )then
        call LNWRIT( IWR, label, nline )
        read(IDAT,*   )  scalez
        write(IWR,9010)  scalez
        read(IDAT,8000)  label
      else
        write(IWR,9001) 'scalez factor: scale z-direction'
        write(IWR,9010)  scalez
      endif
c
c Unify scaling factors:
c
      do  id=1,3
        rscale(id) = scalep*rscale(id)
      enddo
      do  id=1,ndim
        rscale(id) = scaleu*rscale(id)
      enddo
      rscale(1) = scalex*rscale(1)
      rscale(2) = scaley*rscale(2)
      rscale(3) = scalez*rscale(3)
c
c >>>>>> STRAIN
c (optional)
      istrain = 0
      wantlbl = 'strain'
      if( readlbl.eq.wantlbl )then
        if( .not. dolvatm )then
          write(IWR,9013) 'str-nolv/strain only with lattice coords'
          goto 1310
        endif
        istrain = 1
        call LNWRIT( IWR, label, nline )
        do  j=1,3
          read(IDAT,*   )  (strain(i,j),i=1,3)
          write(IWR,9010)  (strain(i,j),i=1,3)
        enddo
c
        read(IDAT,8000)  label
c
        strfac = one
        wantlbl = 'strfac'
        if( readlbl.eq.wantlbl )then
          call LNWRIT( IWR, label, nline )
          read(IDAT,*   )  strfac
          do  j=1,3
            do  i=1,3
              strain(i,j) = strfac*strain(i,j)
            enddo
          enddo
c
          read(IDAT,8000)  label
        else
          write(IWR,*   )  'strfac: scale factor for strain'
        endif
        write(IWR,9010)  strfac
c
      endif
c
c >>>>>> PRIMITIVE LATTICE VECTORS FOR UNIT CELL
c (required)
      wantlbl = 'primit'
      call LNWRIT( IWR, label, nline )
      if( readlbl.eq.wantlbl )then
        do  idim=1,3
          read(IDAT,*   )  (rprim(i,idim), i=1,3)
C          write(IWR,9010)  (rprim(i,idim), i=1,3)
          mdim = idim
        enddo
        if( do_clean ) call LVCLEAN( rprim )
        do  idim=1,3
          write(IWR,9010)  (rprim(i,idim), i=1,3)
        enddo
c Scale primitive lattice vectors, periodic directions *ONLY*:
c This needs to be done here since k-vectors will depend on
c rprim() if input for k-vectors done in lattice coordinates.
        do  j=1,ndim
          rprim(j,1) = rscale(j)*rprim(j,1)
          rprim(j,2) = rscale(j)*rprim(j,2)
          rprim(j,3) = rscale(j)*rprim(j,3)
        enddo
        if( istrain.eq.1 )then
c         Install strain into lattice vectors
          do  j=1,3
            do  i=1,3
              tmp(i,j) = strain(1,i)*rprim(1,j)
     $                 + strain(2,i)*rprim(2,j)
     $                 + strain(3,i)*rprim(3,j)
            enddo
          enddo
          do  j=1,3
            rprim(1,j) = rprim(1,j) + tmp(1,j)
            rprim(2,j) = rprim(2,j) + tmp(2,j)
            rprim(3,j) = rprim(3,j) + tmp(3,j)
          enddo
c         Leave record of modified rprim:
          write(IWR,*) 'Strained primitive lattice vectors:'
          do  idim=1,3
            write(IWR,9010)  (rprim(i,idim),i=1,3)
            tmp(1,idim) = rprim(1,idim)
            tmp(2,idim) = rprim(2,idim)
            tmp(3,idim) = rprim(3,idim)
          enddo
          do  j=1,ndim
            tmp(j,1) = tmp(j,1) / rscale(j)
            tmp(j,2) = tmp(j,2) / rscale(j)
            tmp(j,3) = tmp(j,3) / rscale(j)
          enddo
          write(IWR,*) 'Descaled primitive lattice vectors:'
          do  idim=1,3
            write(IWR,9010)  (tmp(i,idim),i=1,3)
          enddo
        endif
      else
        write(IWR,*) 'primitive vectors?'
        goto 1300
      endif
c
c     Leave a record of the cell volume as given:
      call CROSS( rprim(1,2),rprim(1,3), vtmp )
      volum = ABS( rprim(1,1)*vtmp(1) + rprim(2,1)*vtmp(2)
     $           + rprim(3,1)*vtmp(3) )
      write(IWR,'(1x,a,f16.6)') '> Input Cell volume{bohr^3)=',volum
c
c >>>>>> GRID DIMENSIONS ALONG UNIT CELL SIDES
c (required)
      wantlbl = 'grid d'
      read(IDAT,8000) label
      call LNWRIT( IWR, label, nline )
      if( readlbl.eq.wantlbl .or. readlbl.eq.'points' )then
        read(IDAT,*   )  n1r, n2r, n3r
        write(IWR,9120)  n1r, n2r, n3r
      else
        write(IWR,*) 'grid dimensions?'
        goto 1300
      endif
c
c >>>>>> NEARBY FUNCTION TYPE
c (optional) - expert only
c  Options: nearopt=(0=none; 1=near pt; 2=weighted sampling):
c      <0 => 2ctr and 1ctr;  >0 => 1ctr corrections only
c      Default = 2/weighted sampling, 1ctr ONLY (no 2ctr)
c
      nearopt = 2
      near2c = 1
      wantlbl = 'nearby'
      read(IDAT,8000)  label
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
        read(IDAT,*   )  nropt
        if( IABS(nropt).lt.3 ) nearopt = nropt
c
        read(IDAT,8000)  label
      else
        write(IWR,9001)  'nearby option: 0=0,1=pt,2=wt'
      endif
      write(IWR,9020)  nearopt
      if( nearopt.lt.0 )then
        near2c = 2
        nearopt = -nearopt
      elseif( nearopt.eq.0 )then
        near2c = 0
      endif
c
c >>>>>> READ NUMBER OF ATOM TYPES
c (required)
      wantlbl = 'atom t'
      call LNWRIT( IWR, label, nline )
      if( readlbl.eq.wantlbl )then
        read(IDAT,*   )  ntyp
        write(IWR,9020)  ntyp
        if( ntyp.gt.ntypd )then
          write(IWR,*) '>>>>> atom types=',ntyp,', but max ntypd=',ntypd
          write(IWR,9013) 'typ#2big/ max number of atom types exceeded'
          goto 1310
        endif
      else
        write(IWR,*) 'atom types (number of)?'
        goto 1300
      endif
c
c  Initialize number of types for which xc-fit to be done:
      itypxc = 0
c
      do 2000 ityp=1,ntyp
c
c >>>>>> ATOM TYPE NUMBER/LABEL
c
c (one or the other is required)
        wantlbl = 'atom f'
        read(IDAT,8000)  label
        call LNWRIT( IWR, label, nline )
        if( readlbl.eq.wantlbl )then
          read(IDAT,8000)     atmfil
          call LNWRIT( IWR, atmfil, nline )
c         Parse an atom name along with the atom file name:
          call ATOMNM( atmfil,nline, filenm, typnm(ityp),natmnm )
C          print*, atmfil
C          print*, filenm
C          print*, typnm(ityp)
C          print*, natmnm
          write(IWR,'(a,a)') '>>>>> atom type name=',typnm(ityp)
c         Try open as fully qualified path (e.g. in remote library):
          call FLOPEN( IATMFL, filenm, 'OLD', 'FOR', iflerr )
c         If we failed, try to open in working directory:
          if( iflerr.ne.0 ) call FLOPENF( IATMFL, filenm, 'OLD', 'FOR' )
          IPOT = IATMFL
          IBAS = IATMFL
        else
          typnm(ityp) = ' '
          IPOT = IDAT
          IBAS = IDAT
          wantlbl = 'type n'
          goto 210
        endif
c
        wantlbl = 'type n'
        read(IPOT,8000)  label
        call LNWRIT( IWR, label, nline )
  210   continue
        if( readlbl.ne.wantlbl ) goto 1300
        read(IPOT,8040)  jtyp, label(1:24)
        write(IWR,9040)  ityp, label(1:24)
        if( jtyp.ne.ityp .and. IPOT.eq.IDAT )then
          write(IWR,9013) 'typ-ordr/ atom type out of sequence'
          goto 1310
        endif
c
        call ATMDAT1( IWR, IPOT,IBAS,
     $   ityp, ntyp,nshld,nald, noad,
     $   numshl,lshel,nala,ala,cala, occsh,  norba, znuc,
     $   atmass,atengy,
     $   lmx1ctr,almnv1c,lmxnlp1,almnnl,
     $   nrd,nrad,nrps,radmsh,radwt,vpsrad, nrcor,corden,cordrv,
     $   itypxc,nfityp,alxcmin,nalfxc,nrxcfit,nalfxcd,alfxc,alsq,ipvt,
     $   wkrd )
c
        if( IBAS.ne.IDAT )then
          call FLCLOSE( IATMFL )
          IPOT = IDAT
          IBAS = IDAT
        endif
c
 2000 continue
c
      read(IDAT,8000)  label
c
c >>>>>> VDW pair potential corrections
c (optional)
      if( DO_VDW() )then
c       Attempt to load vdw parameter from internal atom type data
        call LNWRIT( IWR, label, nline )
        write(IWR,'(a)') '# DEV/SET/VDW: load internal Z-based c_vdw'
        call VDWNULL( ntyp, c6vdw,r0vdw, c6ijvdw,r0ijvdw )
        IWRF = -1
        call VDWLOADZ( IWRF, ntyp, znuc,typnm,natmnm, c6vdw,r0vdw )
        do  ityp=1,ntyp
          write(IWR,'(a,i5,5x,a,5x,2f16.5)')
     $     '# vdwloadz: ityp,c6(Ry),r0(Bohr)=',
     $      ityp,typnm(ityp),c6vdw(ityp),r0vdw(ityp)
        enddo
c
        wantlbl = 'vdw_da'
        if( readlbl.eq.wantlbl )then
c         Obtain vdW specifications from user input
          call LNWRIT( IWR, label, nline )
          IDATV = IDAT
          call VDWDATA( IWR ,IDATV, ntyp, typnm,natmnm, c6vdw,r0vdw,
     $                  c6ijvdw,r0ijvdw )
c
          read(IDAT,8000)  label
        else
c         Use internal vdW specifications according to vdW-ff selected
          call VDWCHECK( IWR, ntyp, typnm, c6vdw,r0vdw, ierr )
          if( ierr .ne. 0 )then
            write(IWR,*) 'Total atom types lacking vdW parameters=',ierr
            call STOPXERR( 'Some atoms missing vdW parameters' )
          endif
          call VDWCROSS( ntyp, c6vdw,r0vdw, c6ijvdw,r0ijvdw )
        endif
      endif
c
c >>>>>> ATOM MASSES
c (optional)
      wantlbl = 'masses'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
        do  ityp=1,ntyp
          read(IDAT,*)  atmassi
          if( atmassi .gt. zero ) atmass(ityp) = atmassi
          write(IWR,9011)  atmass(ityp)
        enddo
        read(IDAT,8000)  label
      endif
c
c >>>>>> ATOM REFERENCE ENERGIES
c (optional)
      wantlbl = 'energi'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
        do  ityp=1,ntyp
          read(IDAT,*)  atengyi
          if( atengyi .le. zero ) atengy(ityp) = atengyi
          write(IWR,9011)  atengy(ityp)
        enddo
        read(IDAT,8000)  label
      endif
c
c >>>>>> READ CHARGE STATE INFORMATION
c (optional)
cpas: ion_opt default needs to be thought out more
      ion_opt = 0
      if( ndim.lt.3 ) ion_opt = 2
      wantlbl = 'ionopt'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
c
        read(IDAT,*   )  iopt
        if( IABS( iopt ).le.3 )then
          ion_opt = iopt
        else
          write(IWR,*) 'Charge option is not valid: ',iopt
          write(IWR,9013) 'ionopterr: invalid ion option'
          goto1310
        endif
        write(IWR,'(i3,a)') ion_opt,
     $   ' = ion/dipole option: 1=flat,2=gaus,3=qslab,<0=no dipole'
c
        read(IDAT,8000) label
      else
        write(IWR,9001)  'ionopt (0=none,2=gaussian lmcc,3=dble layer):'
        write(IWR,9120)  ion_opt
      endif
c
      wantlbl = 'charge'
      elchrg = zero
      call MKZERO( 3, rchrg )
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
c
        read(IDAT,*   )  elchrg
        write(IWR,9010)  elchrg
        if( ndim.gt.0 .and. elchrg.ne.zero )then
          if( IABS( ion_opt ).eq.1 )then
c           If charged *periodic* system and jellium,
c           must use uniform jellium potl, not spherical flat potential
            ion_opt = 0
          elseif( IABS( ion_opt ) .gt. 1 )then
            read(IDAT,8000)  label
            call LNWRIT( IWR, label, nline )
            wantlbl = 'locati'
            if( readlbl.ne.wantlbl )then
              write(IWR,*) '>>>>> periodic countercharge needs location'
              goto 1300
            endif
c           *** NB ***: rchrg is used as Wigner-Seitz origin
            if( IABS( ion_opt ) .eq. 3 )then
              nchrg = 2
            else
              nchrg = 1
            endif
            read(IDAT,*   )  ((rchrg(i,ichrg),i=1,3), ichrg=1,nchrg)
            write(IWR,9010)  ((rchrg(i,ichrg),i=1,3), ichrg=1,nchrg)
          endif
        endif
        read(IDAT,8000)  label
      else
        write(IWR,9001) 'charge state for system'
        write(IWR,9010)  elchrg
      endif
c
c >>>>>> NUMBER OF ATOMS
c (required)
      wantlbl = 'number'
      call LNWRIT( IWR, label, nline )
      if( readlbl.eq.wantlbl )then
        read(IDAT,*   )  natm
        write(IWR,9120)  natm
        if( natm.gt.natmd )then
          write(IWR,*) '>>>>> # of atoms=',natm,', but max natmd=',natmd
          write(IWR,9013) 'natm2big/max number of atoms exceeded'
          goto 1310
        endif
      else
        write(IWR,*) 'number of centers/atoms in system?'
        goto 1300
      endif
c
      IDATG = IDAT
  300 continue
      read(IDATG,8000)  label
c
c >>>>>> ATOM TYPES AND POSITIONS
c (required)
      wantlbl = 'atom, '
      call LNWRIT( IWR, label, nline )
      if( readlbl.eq.wantlbl )then
        iatmfmt = 2
      elseif( IDAT.eq.IDATG .and. readlbl .eq. 'geomfi' )then
c       (NB: needed to ensure that geom file does not point to a file)
        call FLOPEN( IDATG, 'lcao.geom_in', 'OLD', 'FOR', ierror )
        if( ierror .ne. 0 )
     $   call STOPXERR( 'geometry input (lcao.geom_in) not found' )
c       We found an input geometry file, go get the data
        goto 300
c      elseif( readlbl.eq.'poscar' )then
cc       Read a VASP poacar
c        call FLOPEN( IDATG, 'lcao.poscar', 'OLD', 'FOR', ierror )
c        if( ierror .ne. 0 )
c     $   call STOPXERR( 'error opening lcao.poscar file' )
c        iatmfmt = (poscar format)
c        
      else
        wantlbl = 'atom t'
        if( readlbl.ne.wantlbl )then
          write(IWR,*) 'atom, types, and positions?'
          goto 1300
        endif
      endif
      call CONFIGRD( IDATG,IWR, iatmfmt, natmnm, ntyp,typnm,
     $ natm, atmnm, itypa, ratm )
c
      read(IDAT,8000)  label
c
c >>>>>> TO_LATTICE/TO_CARTESIAN - convert to lattice/cartesian units
c (optional) ... and dangerous; expert only
      wantlbl = 'to_lat'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
        if( ndim.ne.3 .or. .not. dolvatm )then
          write(IWR,9013) 'to_lattice - only for bulk + lattice units'
          goto 1310
        endif
c       Install the scaling factors:
        do  iatm=1,natm
          ratm(1,iatm) = ratm(1,iatm)*rscale(1)
          ratm(2,iatm) = ratm(2,iatm)*rscale(2)
          ratm(3,iatm) = ratm(3,iatm)*rscale(3)
        enddo
c       Eliminate scale factors (this is really weird and dangerous):
        rscale(1) = one
        rscale(2) = one
        rscale(3) = one
c       Project coordinates onto primitive lattice vectors:
        do  iatm=1,natm
          call LVPROJ( rprim, ratm(1,iatm), vtmp )
          ratm(1,iatm) = vtmp(1)
          ratm(2,iatm) = vtmp(2)
          ratm(3,iatm) = vtmp(3)
        enddo
c
        read(IDAT,8000)  label
c       Skip origins, since do not do correct conversion with this hack
c       but need to initialize origins to something!!!!! 4dec07-pas
        call MKZERO( 3, dorig )
        call MKZERO( 3, rsym  )
        goto 400
      endif
c
      wantlbl = 'to_car'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
        if( ndim.ne.3 .or. dolvatm )then
          write(IWR,9013) 'to_cartesian - only for bulk + NOT lattice'
          goto 1310
        endif
c
c       Expand coordinates from primitive lattice vector units:
        do  iatm=1,natm
          call LVXPND( rprim, vtmp, ratm(1,iatm) )
          ratm(1,iatm) = vtmp(1)
          ratm(2,iatm) = vtmp(2)
          ratm(3,iatm) = vtmp(3)
        enddo
c
c       Extract the scaling factors:
        do  iatm=1,natm
          ratm(1,iatm) = ratm(1,iatm)/rscale(1)
          ratm(2,iatm) = ratm(2,iatm)/rscale(2)
          ratm(3,iatm) = ratm(3,iatm)/rscale(3)
        enddo
c
        read(IDAT,8000)  label
c       Skip origins, since do not do correct conversion with this hack
c       but need to initialize origins to something!!!!! 4dec07-pas
        call MKZERO( 3, dorig )
        call MKZERO( 3, rsym  )
        goto 400
      endif
c
c     call CONFIGWR( IWR ,     iatmfmt, natmnm, ntyp,typnm,
c    $ natm, atmnm, itypa, ratm )
c
c >>>>>> ORIGIN OFFSET OF SUPERCELL
c (optional)
      wantlbl = 'origin'
      if( readlbl.eq.wantlbl )then
c       Input origin (corner) of unit cell
        call LNWRIT( IWR, label, nline )
        read(IDAT,*   )  dorig
        write(IWR,9010)  dorig
        read(IDAT,8000)  label
      else
        write(IWR,9001) 'origin offset for unit cell'
c       Shift to -1/2*rprim in non-periodic dimensions
        call MKZERO( 3, dorig )
        write(IWR,9010)  dorig
      endif
c
c >>>>>> WIGNER-SEITZ ORIGIN
c (optional)
      if( elchrg.eq.zero )then
c
        wantlbl = 'wigner'
        if( readlbl.eq.wantlbl )then
c         Input Wigner-Seitz origin (for moments calculation)
          call LNWRIT( IWR, label, nline )
          read(IDAT,*   )  (rchrg(i,1),i=1,3)
          write(IWR,9010)  (rchrg(i,1),i=1,3)
c
          read(IDAT,8000)  label
        endif
      endif
c
c >>>>>> CENTER OF SYMMETRY
c (optional)
cpas: default rsym needs to be rethought.
      wantlbl = 'symmet'
      if( readlbl.eq.wantlbl )then
c       Input center of symmetry coordinate:
        call LNWRIT( IWR, label, nline )
        read(IDAT,*   )  rsym
        write(IWR,9010)  rsym
        read(IDAT,8000)  label
      else
        write(IWR,9001) 'symmetry center'
        rsym(1) = dorig(1)
        rsym(2) = dorig(2)
        rsym(3) = dorig(3)
        write(IWR,9010)  rsym
      endif
c
  400 continue
c
c >>>>>> READ BLOCH VECTOR INFORMATION, IF PERIODIC
c (optional)
      dokgrid = .false.
      if( ndim.eq.0 )then
        nk = 1
        wtk(1) = one
        wtkscal = one
        veckg(1,1) = zero
        veckg(2,1) = zero
        veckg(3,1) = zero
      else
        call LNWRIT( IWR, label, nline )
c
        nk = 0
        if( readlbl(1:5).eq.'kgrid' )then
          ktype = readlbl(6:6)
          read(IDAT,*   )  nku(1),nku(2),nku(3)
          write(IWR,9120)  nku(1),nku(2),nku(3)
          if( ktype.eq.' ' .or. ktype.eq.'0' )then
            iktype = 0
          elseif( ktype.eq.'1' )then
            iktype = 1
          elseif( ktype.eq.'2' .or. ktype.eq.'h' )then
            iktype = 2
          elseif( ktype.eq.'3' )then
            iktype = 3
          endif
          dokgrid = .true.
          goto 431
        elseif( readlbl(1:4).eq.'khex' )then
          ktype = readlbl(5:5)
          read(IDAT,*   )  nku(1),nku(2),nku(3)
          write(IWR,9120)  nku(1),nku(2),nku(3)
c         First, trivial check if this makes sense.
          alen = SQRT( rprim(1,1)**2 + rprim(2,1)**2 + rprim(3,1)**2 )
          blen = SQRT( rprim(1,2)**2 + rprim(2,2)**2 + rprim(3,2)**2 )
          adotb = rprim(1,1)*rprim(1,2) + rprim(2,1)*rprim(2,2)
     $          + rprim(3,1)*rprim(3,2)
          diflen = ABS( DBLE( nku(1) ) - DBLE( nku(2) )*blen/alen )
          difdot = ABS( one - two*ABS( adotb ) / (alen*blen) )
          if( diflen  .gt. (1.d-6) .or. difdot .gt. (1.d-6) )then
c           This is not hexagonal.
            write(IWR,*) 'Cell vectors A and B are not hexagonal'
            write(IWR,*) 'tests (should be<1d-6):',diflen,difdot
            write(IWR,*) 'Cannot use a hexagonal k-grid'
            write(IWR,9013) 'khex - not hex cell vectors'
            goto 1310
          endif
c         Right now, provide for single simple 1x1 hex option:
          iktype = 20
          dokgrid = .true.
          goto 431
        endif
c
c >>>>>> READ BLOCH VECTOR (K-POINT) SAMPLING POINTS (weight, vectors)
c
        wantlbl = 'n bloc'
        if( readlbl.ne.wantlbl ) goto 1300
        read(IDAT,*   )  nk
        write(IWR,9120)  nk
        if( nk.gt.nkd )then
          write(IWR,*) '>>>>> have ',nk,' k-points, but max nkd =',nkd
          write(IWR,9013) 'nk2big - max number of k-points exceeded'
          goto 1310
        endif
c
        wantlbl = 'scalin'
        read(IDAT,8000)  label
        kscale = 0
        wtkscal = one
        scalekx = one
        scaleky = one
        scalekz = one
        if( readlbl.eq.wantlbl )then
c         Read scaling factors for k-pt weights and vectors
          call LNWRIT( IWR, label, nline )
          read(IDAT,*   )  wtkscal,scalekx,scaleky,scalekz
          write(IWR,9030)  wtkscal,scalekx,scaleky,scalekz
          if( wtkscal.le.zero ) wtkscal = one
          if( scalekx.le.zero ) scalekx = one
          if( scaleky.le.zero ) scaleky = one
          if( scalekz.le.zero ) scalekz = one
          read(IDAT,8000)  label
          kscale = 1
        endif
c
        lvkvec = 0
        wantlbl = 'lattic'
        if( readlbl.eq.wantlbl )then
          lvkvec = 1
          call LNWRIT( IWR, label, nline )
          read(IDAT,8000)  label
c
        elseif( readlbl .eq. 'cartes' )then
          lvkvec = 0
          call LNWRIT( IWR, label, nline )
          read(IDAT,8000)  label
        endif
c
c       Generate the BZ primitive cell in gvec() (approp. to ndim):
        call KCELL( ndim, rprim, gvec )
c
        wantlbl = 'bloch '
        call LNWRIT( IWR, label, nline )
        if( readlbl.ne.wantlbl ) goto 1300
        wtksum = zero
        do  k=1,nk
          read(IDAT,*   )  kk, wtk(k), (veckg(j,k), j=1,3)
          write(IWR,9080)  kk, wtk(k), (veckg(j,k), j=1,3)
          if( kk.ne.k )then
            write(IWR,9013) 'kvecordr/k-vectors out of order'
            goto 1310
          endif
          wtk(k) = wtk(k) / wtkscal
          wtksum = wtksum + wtk(k)
c
c         Install local scaling factors into input k-vectors
          veckg(1,k) = scalekx*veckg(1,k)
          veckg(2,k) = scaleky*veckg(2,k)
          veckg(3,k) = scalekz*veckg(3,k)
          if( lvkvec .eq. 0 )then
c           Install global scaling into Cartesian input:
            vtmp(1) = veckg(1,k) / rscale(1)
            vtmp(2) = veckg(2,k) / rscale(2)
            vtmp(3) = veckg(3,k) / rscale(3)
c           Convert k-vectors from Cartesian to lattice units:
            call LVPROJ( gvec, vtmp, veckg(1,k) )
C          else
Cc           Got vectors in lattice, expand into Cartesian vecs:
C            call LVXPND( gvec, vtmp, veckg(1,k) )
C            veckg(1,k) = vtmp(1)
C            veckg(2,k) = vtmp(2)
C            veckg(3,k) = vtmp(3)
          endif
        enddo
c       At this point, all k-points should be in lattice units.
c
c       Check that k-point sampling weights add up to one.
        if( ABS( wtksum-one ) .gt. vsmall )then
          write(IWR,*) '>>>>> sum of kvec weights=',wtksum
          write(IWR,9013) 'kvec-wts/sum of wts must be one'
          goto 1310
        endif
c
  431   continue
c
        read(IDAT,8000)  label
c
      endif
c
c >>>>>> SYMMETRY INFORMATION
c (optional)
      ndimsy = 0
      nsymi = 0
c
      wantlbl = 'symops'
      call LNWRIT( IWR, label, nline )
c
      if( readlbl.eq. wantlbl )then
c       3D-SYMMETRY DEFINITIONS
        ndimsy = 3
        read(IDAT,*   )  nsymi
        write(IWR,9020)  nsymi
        if( nsymi.gt.(nsymd-1) )then
          write(IWR,*) '>>>>> have ',nsymi,' but max nsymd=',nsymd-1
          write(IWR,9013) 'sym#3def/max num sym definitions exceeded'
          goto 1310
        endif
c
        wantlbl = 'defini'
        read(IDAT,8000)  label
        call LNWRIT( IWR, label, nline )
        if( readlbl.ne.wantlbl ) goto 1300
c
c Format for symmetry definitions:
c
c      isymtyp  syminfo(1-3)  syminfo(4-6)
c
c  isymtyp = order of rotation(+inversion if less than 0)
c     Valid inputs: -6,-4,-3,-2,-1,1,2,3,4,6
c     NB: 1=reflection ... i.e., equivalent to "-2"= 2-fold rotation+inv
c  syminfo(1-3) = axis of rotation (Cartesian)
c  syminfo(4-6) = translation vector (lattice units)
c
        do  isymi=1,nsymi
          read(IDAT,*   )  isymtyp(isymi),(syminfo(i,isymi),i=1,6)
          if( do_clean ) call SYMCLEAN( syminfo(1,isymi) )
          write(IWR,9071)  isymtyp(isymi),(syminfo(i,isymi),i=1,6)
          istyp = isymtyp(isymi)
          jstyp = IABS(istyp)
          if( jstyp.gt.6 .or. jstyp.eq.5 .or. jstyp.eq.0 )then
            write(IWR,9013) '3dsymtyp/bad 3D symmetry type'
            goto 1310
          endif
          if( istyp .ne. -1 )then
c           Normalize axis (if not inversion which needs no axis):
            snorm = syminfo(1,isymi)**2 + syminfo(2,isymi)**2
     $            + syminfo(3,isymi)**2
            if( snorm.le.zero )then
              write(IWR,9013) 'symmetry axis has zero length'
              goto 1310
            endif
            snorm = one / SQRT( snorm )
            syminfo(1,isymi) = snorm*syminfo(1,isymi)
            syminfo(2,isymi) = snorm*syminfo(2,isymi)
            syminfo(3,isymi) = snorm*syminfo(3,isymi)
          endif
        enddo
c
      elseif( readlbl.eq. 'symmet' )then
c       2D-SYMMETRY DEFINITIONS
        ndimsy = 2
c
c Need to step carefully here as the 2D symmetry input is a casualty
c of the reworking of the symmetry in v2.30. I have to guarantee the
c new convention is solid, which means killing the old input, but must
c leave a clean diagnostic of change.  Over time this can be dropped,
c especially if total input is completely reengineered.
c
        read(IDAT,8020)  nrot, nref
        write(IWR,9020)  nrot, nref
c
        nsymi = 0
        if( nrot.gt.0 ) nsymi = nsymi + 1
        if( nref.gt.0 ) nsymi = nsymi + nref
c
        if( nsymi.lt.1 .or. nsymi.gt.(nsymd-1) )then
          write(IWR,*) '>>>>> have ',nsymi,' but min,max =',1,nsymd-1
          write(IWR,9013) 'sym#2def/max num sym definitions exceeded'
          goto 1310
        endif
c
        isymi = 0
c
        if( nrot.gt.0 )then
c         ROTATIONS
c         Check that order of rotation is reasonable
          if( nrot.eq.1 .or. nrot.eq.5 .or. nrot.gt.6 )then
            write(IWR,9013) 'bad2Drot/only 2,3,4,6-fold rotations'
            goto 1310
          endif
c         Load into symmetry convention format:
          isymi = isymi + 1
          isymtyp(isymi) = nrot
c          ... z-axis is symmetry axis, zero translation
          call MKZERO( 6, syminfo(1,isymi) )
          syminfo(3,isymi) = one
        endif
c
        if( nref.gt.0 )then
c         REFLECTIONS
c         Read angles of reflection planes with z-x plane:
          read(IDAT,*   ,err=1302)  (wkrd(iref), iref=1,nref)
          write(IWR,9030)           (wkrd(iref), iref=1,nref)
c         Check that angles are reasonable:
          do  iref=1,nref
            ang = wkrd(iref)
            if( ang.lt.zero ) ang = ang + 360.
            if( ang.lt.zero .or. ang.gt.180. )then
              write(IWR,9013) 'bad-refl - allowed angle range 0 to 180'
              goto 1310
            endif
c           Load into symmetry convention format ...
            isymi = isymi + 1
c            ... as a two-fold rotation plus inversion ...
            isymtyp(isymi) = -2
c            ... with a rotation axis normal to the reflection plane:
            call MKZERO( 6, syminfo(1,isymi) )
            ang = ang*pi/degpi
            syminfo(1,isymi) = - SIN( ang )
            syminfo(2,isymi) =   COS( ang )
          enddo
        endif
c
      else
c
        goto 470
c
      endif
c
      read(IDAT,8000)  label
c
  470 continue
c
c >>>>>> END OF SETUP SECTION OF INPUT
c
      wantlbl = 'end se'
      if( readlbl.ne.wantlbl ) goto 1300
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c              Do some processing for non-standard usages
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      anycore = .false.
      any1ctr = .false.
      anyxc1c = .false.
      do  iatm=1,natm
        ityp = itypa(iatm)
        if( nrcor(ityp).ne.0 ) anycore = .true.
        if( lmx1ctr(ityp).ge.0 ) any1ctr = .true.
        if( nfityp(ityp).gt.0 ) anyxc1c = .true.
      enddo
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      RETURN
c
c >>>>>> ERROR HANDLING:
c
 9013 format(1x,'ERROR: ',a)
 1300 continue
      write(IWR,*) '>>>>> Want label >',wantlbl,'<, found >',readlbl,'<'
      call STOPXERR( 'inputlbl:  format error in input file' )
c
 1301 continue
      write(IWR,*) '>>>>> atom file not found: ',atmfil
      call STOPXERR( 'atom file not found' )
c
 1302 continue
      write(IWR,*) '>>>>> Note: 2D symmetry input changed as of v2.30'
      write(IWR,*) 'New format (keyword line + one or two data lines:'
      write(IWR,*) 'symmetry [keyword]'
      write(IWR,*) 'nrot nref [order of rotation,# of reflections]'
      write(IWR,*) '(ang(iref),iref=1,nref) [reflection plane angles]'
      call STOPXERR( '2d-syms:  2D symmetry input failure' )
c
 1310 continue
      call STOPXERR( 'inputval: input error in input file' )
c
c  Data input formats
c
 8000 format(a128)
 8010 format(3f12.8)
 8020 format(4(i2,1x))
 8040 format(i2,a)
 8080 format(i2,4x,4f12.8)
c
c  Data output formats
c
 9000 format(1x,a)
 9001 format(1x,a)
 9010 format(1x,3f12.8)
 9011 format(1x,3f16.8)
 9020 format(1x,4(i2,1x))
 9030 format(1x,1p4d16.8)
 9040 format(1x,i2,a)
 9050 format(1x,2(i4,4x),3f15.8)
 9071 format(1x,i2,1x,6f12.8)
 9080 format(1x,i3,4x,f12.8,4x,3f12.8)
 9120 format(1x,3i4)
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LVCLEAN
c
c
      subroutine LVCLEAN( rprim )
c----------------------------------------------------------------
c Purpose: numerical clean up lattice vectors, esp hex.
c Written: Peter A. Schultz, 23-February-2004, for v2.58
c Revision history:
c  none
c----------------------------------------------------------------
c
c  I will clean up only strictly canonical vectors, i.e.,
c  where the first vector A is X,0,0, and the other vectors B,C
c  are rotated 60 or 120 degrees from it.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  (zero=0.d0, one=1.d0, two=2.d0, three=3.d0 )
c
c Input/output primitive vectors:
      DIMENSION  rprim(3,3)
c Local declarations:
      DIMENSION  abc(3,3)
c
c >>>> EXECUTABLE CODE:
c
      rt3 = SQRT( three )
      rt3d2 = rt3 / two
c
      do  idim=1,3
        do  i=1,3
          abc(i,idim) = rprim(i,idim)
        enddo
      enddo
c
c     Check that A = (X,0,Z)
      if( ABS( abc(1,1) ) .lt. 1.d-1 .or.
     $    ABS( abc(2,1) ) .gt. 1.d-6 ) goto 999
c
      do 200 idim=2,3
        alen = SQRT( abc(1,1)**2 + abc(2,1)**2 )
c
c       Check that |B| = |A|  (in x-y plane)
        blen = SQRT( abc(1,idim)**2 + abc(2,idim)**2 )
        btest = blen / alen
        if( ABS( btest - one ) .gt. 1.d-5 ) goto 200
c
c       Check that A.B = 1/2  (i.e., w/above, implies have hex)
        adotb = ABS( abc(1,1)*abc(1,idim) + abc(2,1)*abc(2,idim) )
        btest = adotb * two / (alen*blen)
        if( ABS( btest - one ) .gt. 1.d-6 ) goto 200
c
c       Got it, but confirm that B2 = A1*rt3/2 anyway
        b2 = abc(2,idim)
        btest =  ABS( b2 ) / ( rt3d2 * alen )
        if(  ABS( btest - one ) .gt. 3.d-5 ) goto 200
c
c       We have identified a hex vector, put in the rt3/2:
        if( abc(2,idim) .gt. 0 )then
          abc(2,idim) =  rt3d2*alen
        else
          abc(2,idim) = -rt3d2*alen
        endif
  200 continue
c
      do  idim=1,3
        do  i=1,3
          rprim(i,idim) = abc(i,idim)
        enddo
      enddo
c
  999 continue
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMCLEAN
c
c
      subroutine SYMCLEAN( svec )
c----------------------------------------------------------------
c Purpose: clean up numerics of vectors with rt3 in them
c Written: Peter A. Schultz, 23-February-2004, for v2.58
c Revision history:
c  none
c----------------------------------------------------------------
c
c  I will clean up only strictly canonical vectors, i.e.,
c  where the first vector A is X,0,0, and the other vectors B,C
c  are rotated 60 or 120 degrees from it.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  (zero=0.d0, one=1.d0, two=2.d0, three=3.d0 )
c
c Input/output symmetry vector:
      DIMENSION  svec(6)
c Local declarations:
      DIMENSION  smagic(4)
c
c >>>> EXECUTABLE CODE:
c
      rt3 = SQRT( three )
      rt3d2 = rt3 / two
      smagic(1) = rt3
      smagic(2) = rt3d2
      smagic(3) = one / rt3
      smagic(4) = one / rt3d2
c
c     Clean up axis vectors (rt3-related):
c
      slen = svec(1)**2 + svec(2)**2 + svec(3)**2
      if( slen .lt. 1.d-2 ) goto 500
      slen = SQRT( slen )
c
      do 100 i=1,3
        symi = ABS( svec(i) )
        do 50 im=1,4
          stest = symi / smagic(im)
          if( ABS( stest - one ) .lt. 3.d-5 )then
c           Found a magic number!
            if( svec(i) .gt. zero )then
              svec(i) =  smagic(im)
            else
              svec(i) = -smagic(im)
            endif
            goto 100
          endif
   50   continue
  100 continue
c
c     Clean up offset vector (thirds)
c
  500 continue
      do  i=4,6
        symi = svec(i)
        if( ABS( symi ) .gt. 0.32d0 .and.
     $      ABS( symi ) .lt. 0.34d0 )then
c         Set to a clean 1/3:
          if( symi .gt. zero )then
            svec(i) =  one/three
          else
            svec(i) = -one/three
          endif
        elseif( ABS( symi ) .gt. 0.65d0 .and.
     $          ABS( symi ) .lt. 0.68d0 )then
c         Set to a clean 2/3:
          if( symi .gt. zero )then
            svec(i) =  two/three
          else
            svec(i) = -two/three
          endif
        endif
      enddo
c
  999 continue
      RETURN
c
c    That's all Folks!
c
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SETGR1C
c
c
      subroutine SETGR1C( i1ctrfl,
     $ natm,ntyp,nshld,nald, n1r,n2r,n3r,nptr,nlat1c,mxwf,
     $ itypa, numshl,lshel,nala,ala,cala, ratm,hh,rlat,
     $ lmx1ctr,almnv1c,  mngr3,mxgr3,ngr,
     $ wk, wk2 )
c---------------------------------------------------------------
c Purpose: manage (non-standard) fast grid atom terms for
c          dynamic 1-center scheme.
c
c Written: Peter A. Schultz, 7-May-2001, for v2.47
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  ratm(3,natm),hh(3), rlat(3,*)
      DIMENSION  lmx1ctr(ntyp),almnv1c(ntyp)
      DIMENSION  mngr3(*),mxgr3(*),ngr(*)
c scratch arrays:
      DIMENSION  wk(nptr,10), wk2(*)
c
c >>>> EXECUTABLE CODE:
c
      REWIND( unit=i1ctrfl )
c
c  Compute products of 1-center orbitals on mesh for rho1ctr:
c
      call RH1ORB( i1ctrfl,
     $ natm,ntyp,nshld,nald, n1r,n2r,n3r,nptr,nlat1c,mxwf,
     $ itypa, numshl,lshel,nala,ala,cala, ratm,hh,rlat,
     $ lmx1ctr,almnv1c,  mngr3,mxgr3,ngr,
     $ wk(1,1), wk(1,4), wk(1,9), wk(1,10), wk2 )
c -->  r-3o     dfn-5s   rsq-s    gsum-s    wf-25s
c
c  Compute short range (compact) parts of basis orbs:
c
      call CMPTORB( i1ctrfl,
     $ natm,ntyp,nshld,nald, n1r,n2r,n3r,nptr,nlat1c,mxwf,
     $ itypa, numshl,lshel,nala,ala,cala, ratm,hh,rlat,
     $ lmx1ctr,almnv1c,  mngr3,mxgr3,ngr,
     $ wk(1,1), wk(1,4), wk(1,7), wk(1,8), wk2 )
c -->  r-3io    rv-3s    rsq-s    gsum-s   wf-5s
c
c  Compute "fictitious" gaussians for counter-density
c  subtraction of multipole moments in rho1ctr:
c
      call CNTRRHO( i1ctrfl,
     $ natm,ntyp,nshld,      n1r,n2r,n3r,nptr,nlat1c,mxwf,
     $ itypa, numshl,lshel,               ratm,hh,rlat,
     $ lmx1ctr,almnv1c,  mngr3,mxgr3,ngr,
     $ wk(1,1), wk(1,4), wk2 )
c -->  r-3i     rv-3s    rho-s
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SETORIG
c
c
      subroutine SETORIG( dorig,orig,rsym, origws,rchrg,
     $ ndim, dolvatm,rprim,rscale )
c---------------------------------------------------------------
c Purpose: initialize the various origins we have
c
c Written: Peter A. Schultz, 23-May-2001, for v2.47
c
c Revision history:
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      LOGICAL    dolvatm
      DIMENSION  rprim(3,3),rscale(3)
      DIMENSION  dorig(3),orig(3),rsym(3)
      DIMENSION  origws(3),rchrg(3)
c
c local declarations
      DIMENSION  dorig0(3),rsym0(3)
      DIMENSION  vec0(3)
      DATA       vec0 / 0.d0,0.d0,0.d0 /
      DATA       half / 0.5d0 /
c
c >>>> EXECUTABLE CODE:
c
c  Transform supercell origin offset into internal coordinates
c  NB: do NOT shift by orig(), i.e., itself: pass zero offset vector
      call RINTRNL( ndim,  1 , dolvatm, rprim,vec0,rscale,
     $ dorig,dorig0 )
      do  i=1,3
        dorig(i) = dorig0(i)
        orig(i) = dorig(i)
      enddo
c  Offset origin by half lattice vectors in non-periodic directions:
      do  id=ndim+1,3
        orig(1) = orig(1) - half*rprim(1,id)
        orig(2) = orig(2) - half*rprim(2,id)
        orig(3) = orig(3) - half*rprim(3,id)
      enddo
c  Transform center of symmetry into internal coordinates
      call RINTRNL( ndim,  1 , dolvatm, rprim,orig,rscale,
     $ rsym,rsym0 )
      do  i=1,3
        rsym(i) = rsym0(i)
      enddo
c
c  Set wigner-seitz origin to initial charge location
c    (or center of unit cell if not charged)
c    Note that we will convert to internal units another time ...
      origws(1) = rchrg(1)
      origws(2) = rchrg(2)
      origws(3) = rchrg(3)
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SETXC1C
c
c
      subroutine SETXC1C( ilocrho,
     $ natm,ntyp,nshld,nald, noad,nrd,nfitd, nlat1c, nang,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ occsh,nfityp, nrad,radmsh, angpts,angylm, radwf,  ratm,rlat,
     $ wk, wksm )
c---------------------------------------------------------------
c Purpose: setup portion of xc 1-center dynamic corrections.
c          This is development code only.
c
c Written: Peter A. Schultz, 7-May-2001, for v2.47
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $ nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  occsh(nshld,ntyp)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp)
      DIMENSION  ratm(3,natm),rlat(3,*)
      DIMENSION  nfityp(ntyp), angpts(3,nang)
c output arrays:
      DIMENSION  radwf(nang,nrd,noad,nfitd)
      DIMENSION  angylm(nang,9)
c scratch arrays:
      DIMENSION  wk(nrd*nang,9), wksm(nrd,2)
c
c >>>> EXECUTABLE CODE:
c
c  Compute and store density at atom from tails of other atoms
c  Used to get decent density for xc-fits in v1ctrij/blkvofn
c
      call ATMRHO( ilocrho,
     $ natm,ntyp, nshld,nald, noad, nrd, nlat1c, nang,
     $ itypa, nocc,locc,nalsh,alsh,calsh, occsh,nfityp, nrad,radmsh,
     $ ratm,rlat, angpts,
     $ wk(1,1), wk(1,2),wk(1,5),wk(1,8),wk(1,9) )
c -->  rhorad-s rsph-3s rpt-3s  rsq-s   rsqtol-s
c
c  Generate orbitals on radial mesh, for purpose of later xc fitting
c
      call XCORB( nang,nrd,noad,nfitd,
     $ natm,ntyp,nshld,nald, itypa, numshl,lshel,nala,ala,cala,
     $ nrad,radmsh, angpts, nfityp, radwf,
     $ wksm(1,1), wksm(1,2) )
c
c  Generate spherical harmonics on angular grid
c
      call STORYLM( nang, angpts,angylm )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SIJ
c
c
      subroutine SIJ( norb,nk,ncplx, natm,ntyp,nshld,nald, nlat,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba,
     $ ratm, rlat,coskr,sinkr, wksm,
     $ smat )
c---------------------------------------------------------------
c Purpose: compute overlap matrix for a band structure
c          calculation. The real part is stored in the lower
c          triangle of matrix, the imaginary part in the upper
c
c Written: P.A. Schultz, based on P.J. Feibelman's original
c
c Revision history:
c  17Oct08-PAS/2.62: stripe-distributed-parallel
c   7Mar02-PAS/2.52: ang constants extracted
c  14May01-PAS/2.47: extract s1atom
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  13Aug98-PAS/2.24: cutoffs, names, restructure
c  16Jul98-PAS/2.23: fix label problem (thx D.Raczkowski)
c  28Apr97-PAS/2.17: naming conventions
c  12Apr95-PAS/2.12: stretched alpha cutoffs installed
c  18Jan94-PAS/2.04: full cleanup, match sij,tij,enij,ennloc
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, two=2.d0, half=0.5d0 )
c
c Output array:
      DIMENSION  smat(nk,*)
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
c Scratch space:
      DIMENSION  wksm(*)
c
c Local declarations:
      LOGICAL    diagshl
      DIMENSION  rij(3), p(3), ci(10,9),cj(10,9)
c
      DIMENSION  vnorm(9)
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'SDEV/SIJ: stripe-parallel'
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxf = cutgwfn
      emaxsl = cutslow
      fourpi = pi + pi + pi + pi
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
c  Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmatstr = ncplx*nk*matstr
c
c  Figure out how much belongs on local processor:
      call MATLOCSTR( iproc,nprocs,nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmatpr = mymatpr*ncplx*nk
c
c  Clear overlap matrix
c
      call MKZERO( nmatpr, smat )
c
c     Atom j loop:
c
      nlatmx = 0
c
      jjnext = 0
      jnext = myj0
      do 2000 jatm=myatm1,myatm2
        jtyp = itypa(jatm)
        nshlj = numshl(jtyp)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        njstripe = norb - jstart
        matjstr = norbatj*njstripe
        jjstart = jjnext
        jjnext = jjstart + matjstr*ncplx
c
        alaminj = alamin(jtyp)
        call CINIT( cj )
c
c       Atom j shell loop:
c
        jorbatnxt = 0
        j = jstart
        do 1800 jshl=1,nshlj
          nalj = nala(jshl,jtyp)
          lshlj = lshel(jshl,jtyp)
          norbshj = 2*lshlj + 1
          lj0 = lshlj*lshlj
c
          j0 = j
          jorbat0 = jorbatnxt
          jorbatnxt = jorbat0 + norbshj
c
          alminj = ala(1,jshl,jtyp)
          almaxj = ala(nalj,jshl,jtyp)
          do  jal=1,nalj
            alj = ala(jal,jshl,jtyp)
            if( alj.lt.alminj ) alminj = alj
            if( alj.gt.almaxj ) almaxj = alj
          enddo
          alaminj = alminj
c
          emaxij = emaxf
          if( alminj.lt.alfast ) emaxij = emaxsl
c
c         Atom i loop:
c
          ijnext = jjstart
          inext = jstart
          do 1000 iatm=jatm,natm
            ityp = itypa(iatm)
            nshli = numshl(ityp)
            norbati = norba(ityp)
            istart = inext
            inext = istart + norbati
c
            matij = norbati*norbatj
            ijstart = ijnext
            ijnext = ijstart + matij*ncplx
c
c           Following helps ensure only i.ge.j done:
            iorbatn0 = 0
            ishl1 = 1
            if( iatm.eq.jatm )then
              ishl1 = jshl
              do  ishl=1,ishl1-1
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                istart = istart + norbshi
                iorbat0 = iorbatn0
                iorbatn0 = iorbat0 + norbshi
              enddo
            endif
c
            alamini = alamin(ityp)
            emax = emaxij
            rijmax = emax*(alamini+alaminj) / (alamini*alaminj)
c
c           Lattice vector loop for Atom i:
c
            do 900 ilat=1,nlat
c
              rijsq = zero
              do  ir=1,3
                rij(ir) =  ratm(ir,jatm) - ratm(ir,iatm) - rlat(ir,ilat)
                rijsq = rijsq + rij(ir)*rij(ir)
              enddo
              if( rijsq.gt.rijmax ) goto 900
c
              call CINIT( ci )
              call COFR( cj,rij )
c
c             Atom i shell loop:
c
              iorbatnxt = iorbatn0
              i = istart
              do 800 ishl=ishl1,nshli
                nali = nala(ishl,ityp)
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                li0 = lshli*lshli
c
                i0 = i
                iorbat0 = iorbatnxt
                iorbatnxt = iorbat0 + norbshi
c
                diagshl = .false.
                if( i0.eq.j0 ) diagshl = .true.
c
                almini = ala(1,ishl,ityp)
                almaxi = ala(nali,ishl,ityp)
                do  ial=1,nali
                  ali = ala(ial,ishl,ityp)
                  if( ali.lt.almini ) almini = ali
                  if( ali.gt.almaxi ) almaxi = ali
                enddo
c
                emax = emaxf
                if( almaxi.lt.alfast .and. almaxj.lt.alfast )
     $           emax = emaxsl
                rijmx = emax*(alaminj+almini) / (alaminj*almini)
                if( rijsq.gt.rijmx ) goto 799
c
c               Angular loops:
c
                ij0 = ijstart + jorbat0*norbati + iorbat0
                ij0 = ij0 - norbati
                mli1 = 1
                do 420 mlj=1,norbshj
c                 lj=1,....,9   is orbital symmetry index of orbital j
                  lj = lj0 + mlj
                  jorbat = jorbat0 + mlj
                  j = j0 + mlj
c
                  ij0 = ij0 + norbati
                  if( diagshl ) mli1 = mlj
                  do 410 mli=mli1,norbshi
c                   li=1,....,9   is orbital symmetry index of orbital i
                    li = li0 + mli
                    iorbat = iorbat0 + mli
                    i = i0 + mli
                    ij = ij0 + mli
c
c                   Alpha loops:
c
                    nx = 0
                    ssum = zero
c
                    do 320 jal=1,nalj
                      alj = ala(jal,jshl,jtyp)
c
                      do 310 ial=1,nali
                        ali = ala(ial,ishl,ityp)
c
                        rijmx = emax*(ali+alj) / (ali*alj)
                        if( rijsq.gt.rijmx ) goto 310
c
                        nx = nx + 1
                        alsum = ali + alj
                        do  ir=1,3
                          p(ir) = two*alj*rij(ir)
                        enddo
                        pmag = SQRT( p(1)*p(1)+p(2)*p(2)+p(3)*p(3) )
c
c                       Evaluate contribution to matrix element
                        call INTSUM( selem, p,lj,li,cj(1,lj),ci(1,li),
     $                               alsum )
                        ssum = ssum + EXP( -ali*alj*rijsq/alsum )*
     $                   selem*cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
c
c                       Close alpha loops:
  310                 continue
  320               continue
                    ssum = fourpi*ssum / ( vnorm(li)*vnorm(lj) )
c
c                   Multiply by Bloch phase factors and load output array
c
                    do  k=1,nk
C                      smat(i,j,k) = smat(i,j,k) + ssum*coskr(k,ilat)
                      smat(k,ij) = smat(k,ij) + ssum*coskr(k,ilat)
                    enddo
                    if( ncplx.eq.2 .and. i.ne.j )then
                      ijc = ij + matij
                      do  k=1,nk
C                        smat(j,i,k) = smat(j,i,k) + ssum*sinkr(k,ilat)
                        smat(k,ijc) = smat(k,ijc) + ssum*sinkr(k,ilat)
                      enddo
                    endif
c
                    if( ilat.gt.nlatmx ) nlatmx = ilat
c
c                   Close orbital loops:
  410             continue
  420           continue
c
  799           continue
c               Close Atom i shell loop:
                i = i0 + norbshi
  800         continue
c
c             Close Atom i lattice loop:
  900       continue
c
c           Close Atom i loop:
 1000     continue
c
c         Close Atom j shell loop:
          j = j0 + norbshj
 1800   continue
c
c       Close Atom j loop:
 2000 continue
c
      if( nprocs .gt. 1 )then
        call TIMER('  sij compute    ')
        if( iproc.eq.master )then
          do  jproc=1,nprocstr-1
            lenmsg = 1
            call MPRECVI( jproc, lenmsg, nlatpr, icomm )
            if( nlatpr.gt.nlatmx ) nlatmx = nlatpr
          enddo
        elseif( iproc.lt.nprocstr )then
          lenmsg = 1
          call MPSENDI( master, lenmsg, nlatmx, icomm )
        endif
c
c       Broadcast the result to everyone:
c       (do not use openmpi Bcast cuz of interconnect init cost)
        if( iproc.eq.master )then
          do  jproc=1,nprocs-1
            lenmsg = 1
            call MPSENDI( jproc, lenmsg, nlatmx, icomm )
          enddo
        else
          lenmsg = 1
          call MPRECVI( master, lenmsg, nlatmx, icomm )
        endif
        call TIMER('  sij/nlat-bcast ')
        nlat = nlatmx
      endif
c
c  Shrink nlat if list end not used (ie, unit cells not interact):
      nlat = nlatmx
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SIJ1
c
c
      subroutine SIJ1( norb,nk,ncplx, natm,ntyp,nshld,nald, nlat,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba,
     $ ratm, rlat,coskr,sinkr,
     $ smat )
c---------------------------------------------------------------
c Purpose: compute overlap matrix for a band structure
c          calculation. The real part is stored in the lower
c          triangle of matrix, the imaginary part in the upper
c
c Written: P.A. Schultz, based on P.J. Feibelman's original
c
c Revision history:
c   6Sep08-PAS/2.62: switched ij-ji
c   7Mar02-PAS/2.52: ang constants extracted
c  14May01-PAS/2.47: extract s1atom
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  13Aug98-PAS/2.24: cutoffs, names, restructure
c  16Jul98-PAS/2.23: fix label problem (thx D.Raczkowski)
c  28Apr97-PAS/2.17: naming conventions
c  12Apr95-PAS/2.12: stretched alpha cutoffs installed
c  18Jan94-PAS/2.04: full cleanup, match sij,tij,enij,ennloc
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, two=2.d0, half=0.5d0 )
c
c Output array:
      DIMENSION  smat(norb,norb,nk)
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
c Local declarations:
      LOGICAL    diagshl
      DIMENSION  rij(3), p(3), ci(10,9),cj(10,9)
c
      DIMENSION  vnorm(9)
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'SDEV/SIJ1: ijkmat'
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxf = cutgwfn
      emaxsl = cutslow
      fourpi = pi + pi + pi + pi
      nlatmx = 0
c
c  Clear overlap matrix
c
      call MKZERO( norb*norb*nk, smat )
c
c     Atom j loop:
c
      jnext = 0
      do 2000 jatm=1,natm
        jtyp = itypa(jatm)
        nshlj = numshl(jtyp)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        alaminj = alamin(jtyp)
        call CINIT( cj )
c
c       Atom j shell loop:
c
        j = jstart
        do 1800 jshl=1,nshlj
          nalj = nala(jshl,jtyp)
          lshlj = lshel(jshl,jtyp)
          norbshj = 2*lshlj + 1
          lj0 = lshlj*lshlj
c
          j0 = j
c
          alminj = ala(1,jshl,jtyp)
          almaxj = ala(nalj,jshl,jtyp)
          do  jal=1,nalj
            alj = ala(jal,jshl,jtyp)
            if( alj.lt.alminj ) alminj = alj
            if( alj.gt.almaxj ) almaxj = alj
          enddo
          alaminj = alminj
c
          emaxij = emaxf
          if( alminj.lt.alfast ) emaxij = emaxsl
c
c         Atom i loop:
c
          inext = jstart
          do 1000 iatm=jatm,natm
            ityp = itypa(iatm)
            nshli = numshl(ityp)
            norbati = norba(ityp)
            istart = inext
            inext = istart + norbati
c
c           Following helps ensure only i.ge.j done:
            ishl1 = 1
            if( iatm.eq.jatm )then
              ishl1 = jshl
              do  ishl=1,ishl1-1
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                istart = istart + norbshi
              enddo
            endif
c
            alamini = alamin(ityp)
            emax = emaxij
            rijmax = emax*(alamini+alaminj) / (alamini*alaminj)
c
c           Lattice vector loop for Atom i:
c
            do 900 ilat=1,nlat
c
              rijsq = zero
              do  ir=1,3
                rij(ir) =  ratm(ir,jatm) - ratm(ir,iatm) - rlat(ir,ilat)
                rijsq = rijsq + rij(ir)*rij(ir)
              enddo
              if( rijsq.gt.rijmax ) goto 900
c
              call CINIT( ci )
              call COFR( cj,rij )
c
c             Atom i shell loop:
c
              i = istart
              do 800 ishl=ishl1,nshli
                nali = nala(ishl,ityp)
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                li0 = lshli*lshli
c
                i0 = i
c
                diagshl = .false.
                if( i0.eq.j0 ) diagshl = .true.
c
                almini = ala(1,ishl,ityp)
                almaxi = ala(nali,ishl,ityp)
                do  ial=1,nali
                  ali = ala(ial,ishl,ityp)
                  if( ali.lt.almini ) almini = ali
                  if( ali.gt.almaxi ) almaxi = ali
                enddo
c
                emax = emaxf
                if( almaxi.lt.alfast .and. almaxj.lt.alfast )
     $           emax = emaxsl
                rijmx = emax*(alaminj+almini) / (alaminj*almini)
                if( rijsq.gt.rijmx ) goto 799
c
c               Angular loops:
c
                mli1 = 1
                do 420 mlj=1,norbshj
c                 lj=1,....,9   is orbital symmetry index of orbital j
                  lj = lj0 + mlj
                  j = j0 + mlj
c
                  if( diagshl ) mli1 = mlj
                  do 410 mli=mli1,norbshi
c                   li=1,....,9   is orbital symmetry index of orbital i
                    li = li0 + mli
                    i = i0 + mli
c
c                   Alpha loops:
c
                    nx = 0
                    ssum = zero
c
                    do 320 jal=1,nalj
                      alj = ala(jal,jshl,jtyp)
c
                      do 310 ial=1,nali
                        ali = ala(ial,ishl,ityp)
c
                        rijmx = emax*(ali+alj) / (ali*alj)
                        if( rijsq.gt.rijmx ) goto 310
c
                        nx = nx + 1
                        alsum = ali + alj
                        do  ir=1,3
                          p(ir) = two*alj*rij(ir)
                        enddo
                        pmag = SQRT( p(1)*p(1)+p(2)*p(2)+p(3)*p(3) )
c
c                       Evaluate contribution to matrix element
                        call INTSUM( selem, p,lj,li,cj(1,lj),ci(1,li),
     $                               alsum )
                        ssum = ssum + EXP( -ali*alj*rijsq/alsum )*
     $                   selem*cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
c
c                       Close alpha loops:
  310                 continue
  320               continue
                    ssum = fourpi*ssum / ( vnorm(li)*vnorm(lj) )
c
c                   Multiply by Bloch phase factors and load output array
c
                    do  k=1,nk
                      smat(i,j,k) = smat(i,j,k) + ssum*coskr(k,ilat)
                    enddo
                    if( ncplx.eq.2 .and. i.ne.j )then
                      do  k=1,nk
                        smat(j,i,k) = smat(j,i,k) + ssum*sinkr(k,ilat)
                      enddo
                    endif
c
                    if( ilat.gt.nlatmx ) nlatmx = ilat
c
c                   Close orbital loops:
  410             continue
  420           continue
c
  799           continue
c               Close Atom i shell loop:
                i = i0 + norbshi
  800         continue
c
c             Close Atom i lattice loop:
  900       continue
c
c           Close Atom i loop:
 1000     continue
c
c         Close Atom j shell loop:
          j = j0 + norbshj
 1800   continue
c
c       Close Atom j loop:
 2000 continue
c
c  Shrink nlat if list end not used (ie, unit cells not interact):
      nlat = nlatmx
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SRINT
c
c
      subroutine SRINT( vradsr1,v1ctr1,vradsr2,v1ctr2,vradsr3,v1ctr3,
     $ alsum,pmag,exparg, lmx1ctr,ltop,  na,nuc,neq,ieqn,
     $ nrs,nr0,nrd, radmsh,rwght,
     $ besstor,radfac,w1,w2,w3,w4,w5,w6 )
c---------------------------------------------------------------
c Written: P.J. Feibelman
c
c Revision history:
c   7Dec99-PAS/2.42: cosmetic loop cleanup
c  10Dec98-PAS/2.29: promote source to explicit double precision
c    Aug94-PAS/2.11: reopt, clean, rationalize
c   2Feb93-PAS: put in cutoff control
c  14May89-PAS: install optimized bsiall/opt code
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output arrays:
      DIMENSION  vradsr1(7*10,neq+1)
      DIMENSION  vradsr2(7*10,neq+1)
      DIMENSION  vradsr3(7*10,neq+1)
c input arrays:
      DIMENSION  v1ctr1(nrd,10,na)
      DIMENSION  v1ctr2(nrd,10,na)
      DIMENSION  v1ctr3(nrd,10,na)
      DIMENSION  radmsh(nrs),rwght(nrs), ieqn(*)
c scratch arrays:
      DIMENSION  besstor(nrs,7),radfac(nrs,7),
     $ w1(nrs),w2(nrs),w3(nrs),w4(nrs),w5(nrs),w6(nrs)
c local declarations:
      DIMENSION  number(3),lang(10)
      DATA  number / 1,4,10 /
      DATA  lang / 0, 1,1,1, 2,2,2,2,2,2 /
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /
c
c >>>> EXECUTABLE CODE:
c
      llmax = ltop + lmx1ctr
c
      if( pmag.gt.zero )then
        do  nr=1,nrs
          r = radmsh(nr)
          totarg = (-alsum*r+pmag)*r - exparg
          radfac(nr,1) = rwght(nr)*EXP(totarg)
        enddo
      else
        do  nr=1,nrs
          radfac(nr,1) = rwght(nr)*EXP(-alsum*radmsh(nr)**2-exparg)
        enddo
      endif
c
c    Compute bessel functions on radial mesh
c
      if( pmag.gt.zero )then
c
        call BSIALL( nrs, llmax, pmag, besstor, radmsh,
     $   w1,w2,w3,w4,w5,w6 )
c
        if( llmax.gt.1 )then
          denom = one/pmag
          do 40 ll=2,llmax
            do  nr=1,nrs
              radfac(nr,ll) = radfac(nr,ll-1)*radmsh(nr)*denom
              radfac(nr,ll-1) = radfac(nr,ll-1)*besstor(nr,ll-1)
            enddo
   40     continue
        endif
        do  nr=1,nrs
          radfac(nr,llmax) = radfac(nr,llmax)*besstor(nr,llmax)
        enddo
c
      else
c
        if( llmax.gt.1 )then
          denom = one
          do 140 ll=2,llmax
            denom = one/ DBLE(2*ll-1)
            do  nr=1,nrs
              radfac(nr,ll) = radfac(nr,ll-1)*radmsh(nr)**2*denom
            enddo
  140     continue
        endif
c
      endif
c
c    Compute integrals
c
      llp0 = 0
      do 240 lpot=1,number(lmx1ctr+1)
c
        llp = llp0
        do 180 ll=1,ltop+lang(lpot)
          llp = llp + 1
          sum1 = zero
          sum2 = zero
          sum3 = zero
          do  nr=1,nrs
            sum1 = sum1 + v1ctr1(nr0+nr,lpot,nuc)*radfac(nr,ll)
            sum2 = sum2 + v1ctr2(nr0+nr,lpot,nuc)*radfac(nr,ll)
            sum3 = sum3 + v1ctr3(nr0+nr,lpot,nuc)*radfac(nr,ll)
          enddo
          vradsr1(llp,1) = vradsr1(llp,1) + sum1
          vradsr2(llp,1) = vradsr2(llp,1) + sum2
          vradsr3(llp,1) = vradsr3(llp,1) + sum3
  180   continue
c
c    Obtain vradsr for equivalent atom triples, if any
c
        if( neq.gt.0 )then
c
          do 190 ieq=1,neq
            jeq = ieqn(ieq)
c
            llp = llp0
            do 185 ll=1,ltop+lang(lpot)
              llp = llp + 1
              sum1 = zero
              sum2 = zero
              sum3 = zero
              do  nr=1,nrs
                sum1 = sum1 + v1ctr1(nr0+nr,lpot,jeq)*radfac(nr,ll)
                sum2 = sum2 + v1ctr2(nr0+nr,lpot,jeq)*radfac(nr,ll)
                sum3 = sum3 + v1ctr3(nr0+nr,lpot,jeq)*radfac(nr,ll)
              enddo
              vradsr1(llp,ieq+1) = vradsr1(llp,ieq+1) + sum1
              vradsr2(llp,ieq+1) = vradsr2(llp,ieq+1) + sum2
              vradsr3(llp,ieq+1) = vradsr3(llp,ieq+1) + sum3
  185       continue
c
  190     continue
c
        endif
c
        llp0 = llp
  240 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> STORYLM
c
c
      subroutine STORYLM( nang, angsamp,sphharm )
c---------------------------------------------------------------
c Purpose: calculates real spherical harmonics on the
c          McLaren 72-points on the unit sphere
c          and stores them for use in the xc-potential fit.
c
c Written: PJF
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  21Apr93-PAS: general angle dimension/pretty up code
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input array - angular sampling
      DIMENSION  angsamp(3,nang)
c output array - real spherical harmonics on sphere
      DIMENSION  sphharm(nang,9)
c local declarations:
      DIMENSION  ylm(2,6)
c
c      Loop over all nang points:
c
      do 10 iang=1,nang
c
        call YLMREAL( ylm,2,angsamp(1,iang) )
c
c  Rearrange order of ylm's and store
c
c > Y(0,0), proportional to 1
        sphharm(iang,1) = ylm(1,1)
c > Real [ Y(1,1) ], proportional to x
        sphharm(iang,2) = ylm(1,4)
c > Imag [ Y(1,1) ], proportional to y
        sphharm(iang,3) = ylm(2,4)
c > Y(1,0), proportional to z
        sphharm(iang,4) = ylm(1,2)
c > Imag [ Y(2,2) ], proportional to xy
        sphharm(iang,5) = ylm(2,6)
c > Imag [ Y(2,1) ], proportional to yz
        sphharm(iang,6) = ylm(2,5)
c > Real [ Y(2,1) ], proportional to zx
        sphharm(iang,7) = ylm(1,5)
c > Real [ Y(2,2) ], proportional to x**2-y**2
        sphharm(iang,8) = ylm(1,6)
c > Y(2,0), proportional to 2.*z**2-x**2-y**2
        sphharm(iang,9) = ylm(1,3)
c
   10 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>STR2GPA
c
c
      subroutine STR2GPA( ndim, rprim, stress, strgpa, strlabel )
c---------------------------------------------------------------
c Purpose: convert stress from Ry/bohr^3 to "standard" unit: GPa
c
c Written: Peter A. Schultz, 1-May-2002, v2.53 (cell opt)
c
c Revision history:
c  14Oct02-PAS/2.53g: fix 2D conversion to SI stress
c  19May02-PAS/2.53b: 1D stress units fixed and changed
c   1May02-PAS/2.53: pushed down from "symfrc"
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
      DIMENSION  rprim(3,3), stress(3,3)
c Output:
      DIMENSION  strgpa(3,3)
      CHARACTER*8  strlabel
c Local:
      DIMENSION    v(3)
c
c   Units conversion from (Ry/au**ndim) for output ...
c     (1 GPa =1x10d10 N/m^2)
c     (Rydberg/bohr^3 = 1.471078x10d4 GPa = 147.1078x10d12 N/m^2)
c     (Rydberg/bohr^2 = 77.8461x10+2 N/m)
c     (Rydberg/bohr   = 41.1944x10-8 N)
      DIMENSION  strunits(3)
      DATA  strunits / 41.11944d1 , 77.8461d0 , 1.471078d4 /
      CHARACTER*8  strlbl(3)
c      ... and name of output units for N-dimensional stress
      DATA  strlbl / '10-7 N  ','10+2 N/m','GPa     ' /
c
c >>>> EXECUTABLE CODE:
c
      if( ndim.eq.0 ) RETURN
c
c Output stress result ...
c  ... work out "volume" factor for stress units conversion
      if( ndim.eq.1 )then
        vol = rprim(1,1)
      elseif( ndim.eq.2 )then
        call CROSS( rprim(1,1),rprim(1,2), v(1) )
        vol = SQRT( v(1)**2 + v(2)**2 + v(3)**2 )
      elseif( ndim.eq.3 )then
        call CROSS( rprim(1,2),rprim(1,3), v(1) )
        vol = ABS( rprim(1,1)*v(1) + rprim(2,1)*v(2) +
     $             rprim(3,1)*v(3) )
      else
        call STOPXERR( 'ndim-syf' )
      endif
c
      strlabel = strlbl(ndim)
c  ... convert stress into the appropriate units for dimension:
      strfac = strunits(ndim) / vol
      do  jd=1,ndim
        do  id=1,ndim
          strgpa(id,jd) = strfac*stress(id,jd)
        enddo
      enddo
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMAGES
c
c
      subroutine SYMAGES( IWR, subsym, rsym,rprim, natm,ratm,itypa,
     $ natmnm,atmnm,
     $ nsym,nsyma, naofsym, rmatsym )
c---------------------------------------------------------------
c Purpose: find symmetry images of atoms
c
c Written: Peter A. Schultz, 26-January-1996, for v2.15
c
c Revision history:
c  23Jun15-PAS/2.67: atom labels, and some extra cosmetics
c   1May02-PAS/2.53: reconcile sym and cell-opt; cosmetics
c  21Jun01-PAS/2.48: replace STOPs
c   6Jan99-PAS/2.30: redo symmetry scheme
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Sep98-PAS/2.27: control level for output
c  24Sep97-PAS/2.21: move commentary on atom mapping here
c  24Apr97-PAS/2.17: naming conventions
c---------------------------------------------------------------
c
c  Use tranformation matrices to produce images of each atom,
c  and map onto original atoms
c
c  Variables:
c   subsym    - true  = ok to reduce symmetry
c               false = trigger error upon symmetry failure
c   nsym      - # input non-identity symmetry operations
c   nsyma     - # non-identity symmetries obeyed by atoms
c   rsym()    - offset from origin of center of symmetry
c   naofsym() - mapping of atoms to other atoms by symmetry
c   rmatsym() - cartesian representations of symmetry operators
c
c  Note: that naofsym begins with the identity, while the
c  cartesian symmetry operations skip the identity, so that
c  the indexing for naofsym and rmatsym differ by 1.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
c input arrays:
      LOGICAL    subsym
      DIMENSION  rsym(3),rprim(3,3), ratm(3,*), itypa(*)
      CHARACTER*(*)  atmnm
      DIMENSION  atmnm(*)
      DIMENSION  rmatsym(3,4,*)
c output array:
      DIMENSION  naofsym(natm,*)
c local declarations:
      DIMENSION  rsymctr(3),rsyveci(3)
      DIMENSION  ri(3),sri(3),tri(3),vij(3),clat(3)
      LOGICAL  outuc,shift, badgrp,goodsym
      DATA  rngtol / 0.0001d0 /
      DATA  zero,one / 0.d0,1.d0 /
      DATA  lstout / 0 /
c
c >>>> EXECUTABLE CODE
c
      badgrp = .false.
c  All atoms map to self under identity:
      do  iatm=1,natm
        naofsym(iatm,1) = iatm
      enddo
      if( nsym.le.0 ) RETURN
c
c Symmetry center offset:
      rsymctr(1) = rsym(1)
      rsymctr(2) = rsym(2)
      rsymctr(3) = rsym(3)
c
      nsyma = nsym
      isyma = 0
      do 300 isym=1,nsym
c
        goodsym = .true.
        do  iatm=1,natm
          naofsym(iatm,isym+1) = -1
        enddo
c
c       Convert symmetry element translation to Cartesian coords:
        call LVXPND( rprim, rsyveci, rmatsym(1,4,isym) )
        rsymag = rsyveci(1)**2 + rsyveci(2)**2 + rsyveci(3)**2
c
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
c         Do transformations about center of symmetry:
          ri(1) = ratm(1,iatm) - rsymctr(1)
          ri(2) = ratm(2,iatm) - rsymctr(2)
          ri(3) = ratm(3,iatm) - rsymctr(3)
c
c         Transform coords of this atom by this symmetry operation
          sri(1) = rmatsym(1,1,isym)*ri(1) + rmatsym(2,1,isym)*ri(2)
     $           + rmatsym(3,1,isym)*ri(3) + rsyveci(1)
     $           + rsymctr(1)
          sri(2) = rmatsym(1,2,isym)*ri(1) + rmatsym(2,2,isym)*ri(2)
     $           + rmatsym(3,2,isym)*ri(3) + rsyveci(2)
     $           + rsymctr(2)
          sri(3) = rmatsym(1,3,isym)*ri(1) + rmatsym(2,3,isym)*ri(2)
     $           + rmatsym(3,3,isym)*ri(3) + rsyveci(3)
     $           + rsymctr(3)
c
c         Project image atom coordinates into primary unit cell ...
          call PROJUC( outuc,shift, 3, sri,tri, rprim )
c
c          ... and match against atom list, checking first against
c         itself (most common), and then against all atoms.
c         If this fails, try local search by lattice vector as we
c         are guaranteed to be close.
c
          itry = 1
   90     jatm = iatm
          jnext = 1
  100     jtyp = itypa(jatm)
c
c         Check against atom type first
          if( jtyp.ne.ityp) goto 140
c
          vij(1) = ratm(1,jatm) - tri(1)
          vij(2) = ratm(2,jatm) - tri(2)
          vij(3) = ratm(3,jatm) - tri(3)
          if( itry.eq.1 )then
            rij = SQRT( vij(1)**2 + vij(2)**2 + vij(3)**2 )
          else
c           Try a local more expensive search on second go-round
            call LVPROJ( rprim, vij, clat )
            rij = zero
            do  idim=1,3
              cl0 = ABS( clat(idim) )
              cl1 = ABS( cl0-one )
              rij = rij + MIN( cl0, cl1 )
            enddo
          endif
c
          if( rij.lt.rngtol )then
c           Have jatm = S(iatm), or iatm=(S**-1)(jatm)
            naofsym(jatm,isyma+2) = iatm
            goto 190
          endif
c
  140     jatm = jnext
          jnext = jnext + 1
          if( jatm.le.natm ) goto 100
c
c         Failed to find symmetry image, try alternate search ...
          itry = itry + 1
          if( itry.eq.2 ) goto 90
c
c          ... and alternate search failed, too:
          if( .not. subsym .or. lstout.gt.2 )then
c           Have hard check, trigger error.
 9131       format(1x,a,3f15.8)
            if( goodsym )then
c             First failure found in this symmetry, describe operator:
              write(IWR,*) '***** NOTE: Atomic symmetry failure'
              write(IWR,*)'Cartesian representation of failed symmetry:'
              write(IWR,'(5x,3f12.8)') ((rmatsym(i,j,isym),i=1,3),j=1,3)
              if( rsymag .gt. 0.00001d0 )then
                write(IWR,*) ' ... and translation vector:'
                write(IWR,'(5x,3f12.8)') rsyveci
              endif
              write(IWR,9131) 'Symmetry center offset = ', rsymctr
              if(  .not. subsym .or. lstout.gt.4 )
     $        write(IWR,*) 'Coords (internal - scaled and shifted):'
            endif
c
            write(IWR,9130)  iatm,  atmnm(iatm)
 9130       format(1x,'>>>>> Atom#',i6,' = ',a,' fails to have image')
            if( .not. subsym .or. lstout.gt.4 )then
              write(IWR,9131) '    Internal coords   =',
     $                        ratm(1,iatm),ratm(2,iatm),ratm(3,iatm)
              write(IWR,9131) '    Symmetry center   =', rsymctr
              write(IWR,9131) '    Coordinates       =', ri
              write(IWR,9131) '    Sym transformation=',sri
              write(IWR,9131) '    Map into unit cell=',tri
              write(IWR,*)   '     ... for which there is no match'
            endif
          endif
c         Mark this symmetry as failed, so do not repeat operator
          goodsym = .false.
c
  190     continue
c
c         Close loop over atoms:
c
  200   continue
c
        if( goodsym )then
          isyma = isyma + 1
          if( isyma.ne.isym )then
c           Reorder matrix ops to put active ops to front:
            do  j=1,4
              do  i=1,3
                tmp = rmatsym(i,j,isyma)
                rmatsym(i,j,isyma) = rmatsym(i,j,isym)
                rmatsym(i,j,isym)  = tmp
              enddo
            enddo
          endif
        else
          if( .not. subsym )then
            isyma = isyma + 1
            badgrp = .true.
          endif
          nsyma = nsyma - 1
        endif
c
c       Close symmetry operation loop:
c
  300 continue
c
      if( nsyma.ne.nsym )then
        write(IWR,*) '***** NOTE: atomic symmetry is reduced'
        write(IWR,*) '  # of input symmetry operations (w/id)=',nsym+1
        write(IWR,*) '  # of valid atomic symmetries (w/id)  =',nsyma+1
      endif
c
c  Use isyma rather than nsyma as it puts out full mapping, even
c  with an error condition
      if( isyma.gt.0 .and. ( lstout.gt.4 .or. badgrp ) )then
        write(IWR,'(1h0,a)')'atom, atom mapping under inverse sym ops'
        do  iatm=1,natm
          write(IWR,'(1x,24(i4))')  (naofsym(iatm,isym),isym=1,isyma)
        enddo
      endif
c
      if( badgrp ) call STOPXERR( 'bad-sym - SYMAGES atom map fails' )
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMBUILD
c
c
      subroutine SYMBUILD( IWR, nsym, nsymi,nsymd,  ndimsy,
     $ isymtyp,syminfo,  rprim, rmatsym )
c---------------------------------------------------------------
c Purpose: build symmetry stuff
c
c Written: Peter A. Schultz, 30-May-2001, for 2.47
c
c Revision history:
c   1May02-PAS/2.53: reconcile sym and cell-opt
c  21Jun01-PAS/2.48: replace STOPs
c  30May01-PAS/2.47: extracted from main routine
c---------------------------------------------------------------
c
c  nsymi = number of input symmetry elements
c  nsym  = number of (non-identity) symmetry elements in group
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  isymtyp(*), syminfo(*)
      DIMENSION  rprim(3,3)
c output array:
      DIMENSION  rmatsym(*)
c local declaration:
      DATA       zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      if( nsymi.gt.0 )then
c        ... cast symmetry operations in cartesian matrix form:
        call SYMRMAT( nsymi,isymtyp,syminfo,
     $   nsymd, nsymj, rmatsym, rprim )
c        ... generate group from these elements:
        call SYMGRP( nsymd, nsymj,nsym, rmatsym, rprim )
c        ... put translations back into lattice units:
        call SYMLAT( nsym, rmatsym, rprim )
c
        write(IWR,*) 'Number of symmetry generators       =',nsymi
        write(IWR,*) 'Expands to number of elements(w/id) =',nsymj+1
        write(IWR,*) 'Size of output symmetry group (w/id)=',nsym+1
        if( ndimsy.eq.2 )then
c          ... check for requirement that slab be x-y + z-axis
          if( rprim(1,3).ne.zero .or. rprim(2,3).ne.zero .or.
     $        rprim(3,1).ne.zero .or. rprim(3,2).ne.zero )then
            write(IWR,*) '>>>>> slab normal must be z-axis for 2D'
            call STOPXERR( '2D sym workable iff z-axis is normal' )
          endif
        endif
      else
        nsym = 0
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMFRC
c
c
      subroutine SYMFRC( IWRX, rtnlbl, stress, frcsym, frctmp, fdefct,
     $ ndim, natm, nsym, rprim, rmatsym, naofsym )
c---------------------------------------------------------------
c Purpose: symmetrize forces
c
c Written: Peter A. Schultz, 4-November-1994
c
c Revision history:
c  14Mar13-PAS/2.64: write format for 1000+ atoms
c   4Oct04-PAS/2.59: add grep-able pressure output diagnostic
c  26Jun02-PAS/2.54: cosmetic - to emphasize IWRX can be zero
c   1May02-PAS/2.53: push stress units conversion to subroutine
c  21Jun01-PAS/2.48: replace STOPs
c   2May01-PAS/2.47: convert stress units into standard
c  12Apr00-PAS/2.43: specify units in stress output
c  28Sep99-PAS/2.40: full three-dimensional stress tensor;
c                    change output formats.
c   5Jan99-PAS/2.30: redo symmetry scheme
c  17Dec98-PAS/2.30: clean force/stress arrays
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  26Sep97-PAS/2.21: force defect calculation
c  28Apr97-PAS/2.17: naming conventions
c   3Sep96-PAS/2.15: fix rotmat indice bug
c---------------------------------------------------------------
c
c ***** Note: IWRX that is passed in can be passed in as zero!
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input/output arrays:
      CHARACTER  rtnlbl*(*)
      DIMENSION  frcsym(3,natm), frctmp(3,natm), fdefct(3)
      DIMENSION  stress(3,3)
c  ... primitive unit cell vectors
      DIMENSION  rprim(3,3)
c  ... cartesian representations of non-identity symmetry ops
      DIMENSION  rmatsym(3,4,*)
c  ... atom images under inverse symmetry ops
      DIMENSION  naofsym(natm,*)
c local declarations
      DIMENSION  fi(3),sfi(3), strgpa(3,3)
      CHARACTER*8  strlbl

crpm  Create a common block to save the pressure for reference later
c     We are probably going to want to tear this code out and replace
c     with a subroutine at some point.
      COMMON /savepress/ presssave,prgpasave
c
      DATA  zero,one / 0.d0,1.d0 /
      DATA  vsmall / 1.d-6 /
c
c >>>> EXECUTABLE CODE:
c
c copy identity first:
      do  iatm=1,natm
        frctmp(1,iatm) = frcsym(1,iatm)
        frctmp(2,iatm) = frcsym(2,iatm)
        frctmp(3,iatm) = frcsym(3,iatm)
      enddo
c
      if( nsym.le.0 ) goto 500
c
c  Loop over all atoms, accumulate symmetry force
c
      do  iatm=1,natm
        do  isym=1,nsym
          jatm = naofsym(iatm,isym+1)
          fi(1) = frcsym(1,jatm)
          fi(2) = frcsym(2,jatm)
          fi(3) = frcsym(3,jatm)
c compute symmetry force:
          sfi(1) = rmatsym(1,1,isym)*fi(1) + rmatsym(2,1,isym)*fi(2)
     $           + rmatsym(3,1,isym)*fi(3)
          sfi(2) = rmatsym(1,2,isym)*fi(1) + rmatsym(2,2,isym)*fi(2)
     $           + rmatsym(3,2,isym)*fi(3)
          sfi(3) = rmatsym(1,3,isym)*fi(1) + rmatsym(2,3,isym)*fi(2)
     $           + rmatsym(3,3,isym)*fi(3)
c have jatm = S(iatm) or iatm=S**-1(jatm)
          frctmp(1,iatm) = frctmp(1,iatm) + sfi(1)
          frctmp(2,iatm) = frctmp(2,iatm) + sfi(2)
          frctmp(3,iatm) = frctmp(3,iatm) + sfi(3)
        enddo
      enddo
c
      symscal = one/ DBLE( nsym+1 )
      do  iatm=1,natm
        frctmp(1,iatm) = symscal*frctmp(1,iatm)
        frctmp(2,iatm) = symscal*frctmp(2,iatm)
        frctmp(3,iatm) = symscal*frctmp(3,iatm)
      enddo
c
c Symmetrize stress tensor:
      call SYMSTR( ndim, stress, nsym, rmatsym )
c
c  Summarize results:
c
  500 continue
      fdefct(1) = zero
      fdefct(2) = zero
      fdefct(3) = zero
      do  iatm=1,natm
c if negligible, set to zero:
        if( ABS(frctmp(1,iatm)).lt.vsmall ) frctmp(1,iatm) = zero
        if( ABS(frctmp(2,iatm)).lt.vsmall ) frctmp(2,iatm) = zero
        if( ABS(frctmp(3,iatm)).lt.vsmall ) frctmp(3,iatm) = zero
c put into right place:
        frcsym(1,iatm) = frctmp(1,iatm)
        frcsym(2,iatm) = frctmp(2,iatm)
        frcsym(3,iatm) = frctmp(3,iatm)
c accumulate defect:
        fdefct(1) = fdefct(1) + frctmp(1,iatm)
        fdefct(2) = fdefct(2) + frctmp(2,iatm)
        fdefct(3) = fdefct(3) + frctmp(3,iatm)
      enddo
c
      if( IWRX.gt.0 )then
c
        write(IWRX,*) ' '
c
        if( ndim.gt.0 )then
c
c Output stress result ...
c
c  ... convert stress into the appropriate units for dimension:
          call STR2GPA( ndim, rprim, stress, strgpa, strlbl )
c
c  ... and output the stress, both raw, and converted:
          write(IWRX,9550)
     $     rtnlbl,' stress tensor, in Rydberg and in ',strlbl
          do  jd=1,ndim
            if( ndim.eq.1 )then
              write(IWRX,9551)  (stress(id,jd),id=1,ndim),
     $                          (strgpa(id,jd),id=1,ndim)
            elseif( ndim.eq.2 )then
              write(IWRX,9552)  (stress(id,jd),id=1,ndim),
     $                          (strgpa(id,jd),id=1,ndim)
            elseif( ndim.eq.3 )then
              write(IWRX,9553)  (stress(id,jd),id=1,ndim),
     $                          (strgpa(id,jd),id=1,ndim)
            endif
          enddo
          press = zero
          prgpa = zero
          do  jd=1,ndim
            press = press + stress(jd,jd)
            prgpa = prgpa + strgpa(jd,jd)
          enddo
          press = press / DBLE( ndim )
          prgpa = prgpa / DBLE( ndim )
          write(IWRX,9555) press, prgpa,  strlbl
crpm  Here are the explicit save statements for the Pressure
c     and the GPA pressure.
          presssave = press
          prgpasave = prgpa
c
 9550     format(1x,a,a,a)
 9551     format(1x,2(4x, f14.6))
 9552     format(1x,2(4x,2f14.6))
 9553     format(1x,2(4x,3f14.6))
 9555     format(1x,'pressure=Tr(stress)/ndim=',f14.6,' Ry=',f14.6,1x,a)
c
        endif
c
c Output force results:
c
        write(IWRX,*) rtnlbl,' force contributions(Ry/bohr):'
        write(IWRX,9560)
        do  iatm=1,natm
          write(IWRX,9561)  iatm, ( frcsym(i,iatm), i=1,3 )
        enddo
        write(IWRX,9562)  fdefct
c
 9560   format(8x,'atom',7x,'x force',10x,'y force',10x,'z force')
 9561   format(6x, i5,1x,        3f17.10 )
 9562   format(6x,'f-defect',3x, 3f17.10 )
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMGRP
c
c
      subroutine SYMGRP( nsymd,nsym0,nsym, rmatsym, rprim )
c---------------------------------------------------------------
c Purpose: produce a set of symmetry elements that form a group
c          from a given collection of symmetry elements, all
c          represented in cartesian form.
c          (i.e., compute all products, eliminate duplicates)
c
c Written: Peter A. Schultz, 4-January-1999, for v2.30
c
c Revision history:
c  21Jun01-PAS/2.48: replace STOPs
c---------------------------------------------------------------
c
c  Variables:
c   nsymd - maximum number of allowed symmetry elements
c   nsym0 - # of non-identity (e) symmetry elements on input
c   nsym  - # of output (non-e) symmetry elements in group
c   rmatsym() - cartesian representations of symmetry elements
c   rprim(3,3) - primitive lattice vectors
c
c  Note:
c   The algorithm employed to generate and validate the group
c   is gruesomely wasteful, but it is not worth the effort to
c   cook up something more clever.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input/output array:
      DIMENSION  rmatsym(3,4,*)
c input array:
      DIMENSION  rprim(3,3)
c local declarations:
      DIMENSION  ematsym(3,4), tmatsym(3,4)
c  set symmetry identity:
      DATA  ematsym / 1.d0, 0.d0, 0.d0,
     $                0.d0, 1.d0, 0.d0,
     $                0.d0, 0.d0, 1.d0,
     $                0.d0, 0.d0, 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      nsym = 0
      if( nsym0.lt.1 ) goto 999
c
c  Clean out duplicates from input set of symmetry elements:
c
      do 100 isym=1,nsym0
c       Check that candidate is not identity ...
        call DUPEMAT( 12, ksym0, rmatsym(1,1,isym), 1,ematsym )
c          ... and not the same as earlier element:
        ksym1 = 0
        if( ksym0.eq.0 .and. nsym.gt.0 )
     $   call DUPEMAT( 12, ksym1, rmatsym(1,1,isym), nsym,rmatsym )
c
        if( ksym0.le.0 .and. ksym1.le.0 )then
          nsym = nsym + 1
          if( nsym.ne.isym )then
            do  j=1,4
              rmatsym(1,j,nsym) = rmatsym(1,j,isym)
              rmatsym(2,j,nsym) = rmatsym(2,j,isym)
              rmatsym(3,j,nsym) = rmatsym(3,j,isym)
            enddo
          endif
        endif
  100 continue
c
c  Now have nsym = # unique non-identity symmetry elements from input
c  set.  Want to expand this into a full group of symmetry elements.
c  I take all possible products (both sides), and check against the
c  identity and all existing elements, and keep the unique elements.
c  Can do much smarter than this pairwise products with full check,
c  but that would require tedious preprocessing and bookkeeping, and
c  I have forgotten too much of my group theory (sigh).  The current
c  scheme is simpler to code and, even though order nsym**3, is good
c  enough because the number of elements nsym will always be small.
c
      isym = 0
  200 isym = isym + 1
      if( isym.gt.nsym ) goto 999
c
      do 300 jsym=1,isym
c
        js = jsym
        is = isym
c      Compute product of symmetry elements:
  210   call SYMPROD( rmatsym(1,1,js),rmatsym(1,1,is), tmatsym, rprim )
c
c      Check that product is not identity ...
        call DUPEMAT( 12, ksym, tmatsym, 1,ematsym )
        if( ksym.gt.0 ) goto 300
c
c       ... and not the same as existing group element:
        call DUPEMAT( 12, ksym, tmatsym, nsym,rmatsym )
        if( ksym.gt.0 ) goto 290
c
c  We have a unique new group element, add it to set:
        if( nsym.gt.nsymd )then
          call STOPXERR( 'symgrp-d/too many sym elements in group' )
        endif
c
        nsym = nsym + 1
        do  j=1,4
          rmatsym(1,j,nsym) = tmatsym(1,j)
          rmatsym(2,j,nsym) = tmatsym(2,j)
          rmatsym(3,j,nsym) = tmatsym(3,j)
        enddo
c
  290   continue
        if( js.lt.isym )then
c         Check reverse product (could be non-commutative group)
          js = isym
          is = jsym
          goto 210
        endif
c
  300 continue
      goto 200
c
  999 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMIBZ
c
c
      subroutine SYMIBZ( ndim, nk0,vk0,wtk0, nkd,nk,vk,wtk,wtkscal,
     $ rvec, nsym, rmatsym )
c---------------------------------------------------------------
c Purpose: reduce k-points to IBZ using symmetry
c
c Written: Peter A. Schultz, 19-October-1999, for v2.40
c
c Revision history:
c   1Aug07-PAS/2.60: another little dimension thing
c   6Aug03-PAS/2.55a: extract k-write; install kcell generate
c  25Jul01-PAS/2.49: wtk norm convention
c  21Jun01-PAS/2.48: replace STOPs
c---------------------------------------------------------------
c
c Variables:
c   rvec(3,3) - primitive lattice vectors
c   nk0       - number of input k-points
c   vk0(3,*)  - input k-points
c   wtk0(3,*) - weights for input k-points (not used right now)
c   nk       - number of output k-points
c   vk(3,*)  - output k-points
c   wtk(3,*) - weights for output k-points
c   nsym     - number of (non-identity) symmetries
c   rmatsym  - cartesian representations of symmetries
c
c Note: must add time reversal/inversion to list of symmetries
c       to check against.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  rvec(3,3)
      DIMENSION  vk0(3,nk0), wtk0(nk0)
      DIMENSION  rmatsym(3,4,*)
c output arrays:
      DIMENSION  vk(3,*), wtk(*)
c local declarations:
      DIMENSION  ri(3),sri(3)
      DIMENSION  gvec(3,3), dk(3),cg(3)
      DATA  zero,one / 0.d0,1.d0 /
      DATA  extra / 1.d-6 /, bigdif / 1.d-10 /
c
c >>>> EXECUTABLE CODE:
c
c Produce primitive reciprocal vectors:
      call KCELL( ndim, rvec, gvec )
c
c Take the first k-point for sure:
      nk = 1
      wtk(1) = one
      vk(1,1) = vk0(1,1)
      vk(2,1) = vk0(2,1)
      vk(3,1) = vk0(3,1)
c
c Now cycle through rest of k-points ...
c
      do 1000 ik0=2,nk0
        ri(1) = vk0(1,ik0)
        ri(2) = vk0(2,ik0)
        ri(3) = vk0(3,ik0)
c
c  ... transform under symmetry operations ...
c (... adding a time-reversal/inversion ...)
c
        do 300 inv=1,2
c
          do 200 isym=0,nsym
c
c Compute transformed vector:
            if( isym.eq.0 )then
              sri(1) = ri(1)
              sri(2) = ri(2)
              sri(3) = ri(3)
            else
              sri(1) = rmatsym(1,1,isym)*ri(1) + rmatsym(2,1,isym)*ri(2)
     $               + rmatsym(3,1,isym)*ri(3)
              sri(2) = rmatsym(1,2,isym)*ri(1) + rmatsym(2,2,isym)*ri(2)
     $               + rmatsym(3,2,isym)*ri(3)
              sri(3) = rmatsym(1,3,isym)*ri(1) + rmatsym(2,3,isym)*ri(2)
     $               + rmatsym(3,3,isym)*ri(3)
            endif
c
c  ... and try to match to vectors already in set, modulo the gvecs
            do 100 ik=1,nk
              dk(1) = vk(1,ik) - sri(1)
              dk(2) = vk(2,ik) - sri(2)
              dk(3) = vk(3,ik) - sri(3)
              call PROJLV( dk, gvec(1,1),gvec(1,2),gvec(1,3), cg )
              difsq = zero
              do  jd=1,3
                if( cg(jd).lt.zero ) cg(jd) = -cg(jd)
                cg(jd) = cg(jd) + extra
                igfac = cg(jd)
                difsq = difsq + (cg(jd)-DBLE(igfac))**2
              enddo
              if( difsq.lt.bigdif )then
c               We have a match
                wtk(ik) = wtk(ik) + one
                goto 1000
              endif
  100       continue
c
  200     continue
c
c         Install time reversal:
          ri(1) = -ri(1)
          ri(2) = -ri(2)
          ri(3) = -ri(3)
c
  300   continue
c
c No match, hence new symmetry-unique k-point
        nk = nk + 1
        if( nk.gt.nkd ) goto 1301
        wtk(nk) = one
        vk(1,nk) = vk0(1,ik0)
        vk(2,nk) = vk0(2,ik0)
        vk(3,nk) = vk0(3,ik0)
 1000 continue
c
c Scale k-points weights to internal conventions:
      wtkscal = zero
      do  k=1,nk
        wtkscal = wtkscal + wtk(k)
      enddo
      scalek = one/wtkscal
      do  k=1,nk
        wtk(k) = scalek*wtk(k)
      enddo
c
      RETURN
c
 1301 continue
      call STOPXERR( 'k#ibz-d - max number kpt/ibz exceeded' )
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMLAT
c
c
      subroutine SYMLAT( nsym, rmatsym, rprim )
c---------------------------------------------------------------
c Purpose: convert translation part of symmetry matrix operators
c          into lattice units.
c
c Written: Peter A. Schultz, 1-May-2002, for v2.53 (cell opt)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c  Variables:
c   nsym  - # (non-e) symmetry elements in group
c   rmatsym() - cartesian representations of symmetry elements
c   rprim(3,3) - primitive lattice vectors
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input/output array:
      DIMENSION  rmatsym(3,4,*)
c input array:
      DIMENSION  rprim(3,3)
c local declarations:
      DIMENSION  off(3), offlat(3)
c
c >>>> EXECUTABLE CODE:
c
      if( nsym.lt.1 ) RETURN
c
      do  isym=1,nsym
c
        do  i=1,3
          off(i) = rmatsym(i,4,isym)
        enddo
c
        call LVPROJ( rprim, off, offlat )
c
        do  i=1,3
          rmatsym(i,4,isym) = offlat(i)
        enddo
c
      enddo
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMMAP2
c
c
      subroutine SYMMAP2( badsym, nsym, n1r,n2r, isymctr,matsym,
     $ isymv,nsymv )
c---------------------------------------------------------------
c Purpose: find mesh points related by 2D symmetry operations.
c
c Written: Peter A. Schultz, 20-February-1990
c
c Revision history:
c   6Jan98-PAS/2.30: redo symmetry scheme
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Sep98-PAS/2.27: treat non-origin center of symmetry
c  22Jul94-PAS/catch incomplete-sym bug
c---------------------------------------------------------------
c
c  The "nsym" symmetry operators, represented as mesh index
c  transformation matrices, are given in matsym.  Note, however,
c  that the (m',n') = S(m,n) obtained by performing the symmetry
c  operation S on point (m,n) will, in general, lie outside the
c  unit cell.  To get it back in the unit cell, one must add
c  a lattice vector.  I do this by using the MOD operation on
c  (m',n') to get the (m",n") that lies within the unit cell.
c  Note that for this transformation, the mesh points are indexed
c  starting with 0 rather than 1 [so that the origin lies at (0,0)
c  rather than (1,1)].
c
c  Variables:
c    nsym      - number of symmetry operations
c    isymctr() - grid index of center of symmetry
c    matsym()  - array containing symmetry operations
c    isymv()   - index of first of symmetry-related mesh points
c    nsymv()   - number of symmetry related mesh points in that set
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input array:
      DIMENSION  matsym(3,4,nsym), isymctr(3)
c output arrays:
      DIMENSION  isymv(*),nsymv(*)
      LOGICAL    badsym
c
c >>>> EXECUTABLE CODE:
c
      badsym = .false.
c
      do  ir=1,n1r*n2r
        isymv(ir) = 0
        nsymv(ir) = 0
      enddo
c
c  Determine the symmetry-related sets of points:
c
      ir = 0
      do 102 i2s=0,n2r-1
        i2 = i2s - isymctr(2)
        do 101 i1s=0,n1r-1
          i1 = i1s - isymctr(1)
          ir = ir + 1
c
          if( isymv(ir).eq.0 )then
c           we have ourselves a virgin point
            isymv(ir) = ir
c           generate all of the symmetry-related points:
            do 50 isym=1,nsym
c             generate symmetry point ...
              j1 = matsym(1,1,isym)*i1 + matsym(2,1,isym)*i2
     $           + isymctr(1)
              j2 = matsym(1,2,isym)*i1 + matsym(2,2,isym)*i2
     $           + isymctr(2)
c              ... bring into primary unit cell:
              j1 = MOD( j1, n1r )
              j2 = MOD( j2, n2r )
c              ... 'cause MOD gives negative numbers:
              if( j1.lt.0 ) j1 = j1 + n1r
              if( j2.lt.0 ) j2 = j2 + n2r
              jr = n1r*j2 + j1 + 1
              if( isymv(jr).ne.0 .and. isymv(jr).ne.ir )then
                badsym = .true.
                RETURN
              endif
              isymv(jr) = ir
   50       continue
          endif
c
  101   continue
  102 continue
c
c  Count up the number of points in each symmetry set:
c
      do  ir=1,n1r*n2r
        ifst = isymv(ir)
        nsymv(ifst) = nsymv(ifst) + 1
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMMAP3
c
c
      subroutine SYMMAP3( badsym, nsym, n1r,n2r,n3r, isymctr,matsym,
     $ isymv,nsymv )
c---------------------------------------------------------------
c Purpose: generate image map of 3D symmetries
c
c Written: Peter A. Schultz, 3-November-1994
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Sep98-PAS/2.27: treat non-origin center of symmetry
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input array:
      DIMENSION  matsym(3,4,nsym), isymctr(3)
c output arrays:
      DIMENSION  isymv(*),nsymv(*)
      LOGICAL    badsym
c
c >>>> EXECUTABLE CODE:
c
      badsym = .false.
c
      do  ir=1,n1r*n2r*n3r
        isymv(ir) = 0
        nsymv(ir) = 0
      enddo
c
c  Determine the symmetry-related sets of points:
c
      ir = 0
      do 103 i3s=0,n3r-1
        i3 = i3s - isymctr(3)
        do 102 i2s=0,n2r-1
          i2 = i2s - isymctr(2)
          do 101 i1s=0,n1r-1
            i1 = i1s - isymctr(1)
            ir = ir + 1
c
            if( isymv(ir).eq.0 )then
c             we have ourselves a virgin point
              isymv(ir) = ir
c             generate all of the symmetry-related points:
              do 50 isym=1,nsym
c               generate symmetry point ...
                j1 = matsym(1,1,isym)*i1 + matsym(2,1,isym)*i2
     $             + matsym(3,1,isym)*i3 + matsym(1,4,isym)
     $             + isymctr(1)
                j2 = matsym(1,2,isym)*i1 + matsym(2,2,isym)*i2
     $             + matsym(3,2,isym)*i3 + matsym(2,4,isym)
     $             + isymctr(2)
                j3 = matsym(1,3,isym)*i1 + matsym(2,3,isym)*i2
     $             + matsym(3,3,isym)*i3 + matsym(3,4,isym)
     $             + isymctr(3)
c                ... bring into primary unit cell:
                j1 = MOD( j1, n1r )
                j2 = MOD( j2, n2r )
                j3 = MOD( j3, n3r )
c                ... 'cause MOD gives negative numbers:
                if( j1.lt.0 ) j1 = j1 + n1r
                if( j2.lt.0 ) j2 = j2 + n2r
                if( j3.lt.0 ) j3 = j3 + n3r
                jr = n1r*( n2r*j3 + j2 ) + j1 + 1
                if( isymv(jr).ne.0 .and. isymv(jr).ne.ir )then
                  badsym = .true.
                  RETURN
                endif
                isymv(jr) = ir
   50         continue
            endif
c
  101     continue
  102   continue
  103 continue
c
c  Count up the number of points in each symmetry set:
c
      do  ir=1,n1r*n2r*n3r
        ifst = isymv(ir)
        nsymv(ifst) = nsymv(ifst) + 1
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMMAT
c
c
      subroutine SYMMAT( subsym, ibadsym, nsym,nsymg,
     $ rprim, n1r,n2r,n3r, hh, rsym, rmatsym,isymgrd,
     $ isymctr,matsym )
c---------------------------------------------------------------
c Purpose: generate matrix reps of 3D symmetry operations
c
c Written: Peter A. Schultz, 6-January-1999
c          Adapted from symmat3, and also replacing symmat2
c
c Revision history:
c   1May02-PAS/2.53: reconcile sym and cell-opt
c   5Jan99-PAS/2.30: redo symmetry scheme
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Sep98-PAS/2.27: treat non-origin center of symmetry
c---------------------------------------------------------------
c
c  Variables:
c   subsym    - true  = ok to reduce symmetry
c               false = trigger error upon symmetry failure
c   nsym      - # input non-identity symmetry operations
c   nsymg     - # non-identity symmetry operations used by grid
c   hh()      - the mesh lattice point basis vectors
c   rsym()    - cartesian coordinates of symmetry center
c   rmatsym() - the symmetry operations in cartesian form
c   isymctr() - output grid index of symmetry center
c   matsym()  - the output mesh index transformation matrix
c   isymgrd() - list of which of all symmetries ok on grid
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c input symmetry data:
      LOGICAL    subsym
      DIMENSION  rsym(3), rmatsym(3,4,*)
c grid-generating primitive vectors:
      DIMENSION  hh(3,3)
      DIMENSION  rprim(3,*)
c matrix reps of symmetry ops:
      DIMENSION  isymctr(3), matsym(3,4,*)
      DIMENSION  isymgrd(*)
c local declarations:
      DIMENSION  rsymctr(3)
      DIMENSION  a(3),b(3),c(3)
      DIMENSION  u(3), off(3),of2(3)
      DIMENSION  sa(3),sb(3),sc(3), sa2(3),sb2(3),sc2(3)
c
      DATA  zero,one,two, extra,dmax / 0.d0,1.d0,2.d0, 1.0001,1.d-7 /
c
c >>>> EXECUTABLE CODE:
c
      ibadsym = 0
c
      do  i=1,3
        a(i) = hh(i,1)
        b(i) = hh(i,2)
        c(i) = hh(i,3)
      enddo
c
c Copy symmetry center:
      do  i=1,3
        rsymctr(i) = rsym(i)
      enddo
c
      isymg = 1
      nsymg = nsym
      do 100 isym=1,nsym
c
c       Transform grid generating vectors by this symmetry operation:
        do  i=1,3
          sa(i) = rmatsym(1,i,isym)*a(1) + rmatsym(2,i,isym)*a(2)
     $          + rmatsym(3,i,isym)*a(3)
          sb(i) = rmatsym(1,i,isym)*b(1) + rmatsym(2,i,isym)*b(2)
     $          + rmatsym(3,i,isym)*b(3)
          sc(i) = rmatsym(1,i,isym)*c(1) + rmatsym(2,i,isym)*c(2)
     $          + rmatsym(3,i,isym)*c(3)
        enddo
        call LVXPND( rprim, off, rmatsym(1,4,isym) )
c
c       Project these vectors onto original primitive vectors:
c        (multiplied by "extra" to prevent truncation error)
c
        call PROJLV( sa, a,b,c, sa2 )
        matsym(1,1,isymg) = extra*sa2(1)
        matsym(1,2,isymg) = extra*sa2(2)
        matsym(1,3,isymg) = extra*sa2(3)
        call PROJLV( sb, a,b,c, sb2 )
        matsym(2,1,isymg) = extra*sb2(1)
        matsym(2,2,isymg) = extra*sb2(2)
        matsym(2,3,isymg) = extra*sb2(3)
        call PROJLV( sc, a,b,c, sc2 )
        matsym(3,1,isymg) = extra*sc2(1)
        matsym(3,2,isymg) = extra*sc2(2)
        matsym(3,3,isymg) = extra*sc2(3)
c        ... and load offset vector:
        call PROJLV( off, a,b,c, of2 )
        matsym(1,4,isymg) = extra*of2(1)
        matsym(2,4,isymg) = extra*of2(2)
        matsym(3,4,isymg) = extra*of2(3)
c
c       Check to be sure they have the right symmetries:
c
        do  j=1,3
          sa2(j) = a(j)*matsym(1,1,isymg) + b(j)*matsym(1,2,isymg)
     $           + c(j)*matsym(1,3,isymg)
          sb2(j) = a(j)*matsym(2,1,isymg) + b(j)*matsym(2,2,isymg)
     $           + c(j)*matsym(2,3,isymg)
          sc2(j) = a(j)*matsym(3,1,isymg) + b(j)*matsym(3,2,isymg)
     $           + c(j)*matsym(3,3,isymg)
          of2(j) = a(j)*matsym(1,4,isymg) + b(j)*matsym(2,4,isymg)
     $           + c(j)*matsym(3,4,isymg)
        enddo
c
        difa = SQRT( (sa(1)-sa2(1))**2 + (sa(2)-sa2(2))**2
     $             + (sa(3)-sa2(3))**2 )
        difb = SQRT( (sb(1)-sb2(1))**2 + (sb(2)-sb2(2))**2
     $             + (sb(3)-sb2(3))**2 )
        difc = SQRT( (sc(1)-sc2(1))**2 + (sc(2)-sc2(2))**2
     $             + (sc(3)-sc2(3))**2 )
        difo = SQRT( (off(1)-of2(1))**2 +
     $               (off(2)-of2(2))**2 +
     $               (off(3)-of2(3))**2 )
c
        if( difa .gt. dmax .or. difb .gt. dmax .or. difc .gt. dmax
     $     .or. difo .gt. dmax )then
          nsymg = nsymg - 1
          if( .not. subsym )then
c           We have a hard check, and this symmetry failed
            ibadsym = isym
            RETURN
          endif
        else
c         Have a good new symmetry element
          isymgrd(isymg) = isym
          isymg = isymg + 1
        endif
c
  100 continue
c
c And take care of symmetry center vector:
c
      call PROJLV( rsymctr, a,b,c, u )
      isymctr(1) = extra*u(1)
      isymctr(2) = extra*u(2)
      isymctr(3) = extra*u(3)
      do  j=1,3
        of2(j) = a(j)*isymctr(1) + b(j)*isymctr(2)
     $         + c(j)*isymctr(3)
      enddo
      difs = SQRT( (rsymctr(1)-of2(1))**2 +
     $             (rsymctr(2)-of2(2))**2 +
     $             (rsymctr(3)-of2(3))**2 )
      if( difs.gt.dmax ) ibadsym = -1
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMORDR
c
c
      subroutine SYMORDR( natm,nsyma,nsymg, isymgrd,rmatsym,naofsym )
c---------------------------------------------------------------
c Purpose: reorder symmetries to put symmetries in reduced grid
c          symmetry group at start of full atomic symmetry group
c
c Written: Peter A. Schultz, 6-January-1999, for v2.30(redo sym)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c  Variables:
c   natm  - # of atoms
c   nsyma - # of (non-id) elements in atomic symmetry group
c   nsymg - # of (non-id) elements in grid symmetry group
c   isymgrd() - list of elements in grid symmetry group
c   rmatsym() - cartesian representations of symmetry operators
c   naofsym() - mapping of atoms to other atoms by symmetry
c
c  Note: that naofsym begins with the identity, while the
c  cartesian symmetry operations skip the identity, so that
c  the indexing for naofsym and rmatsym differ by 1.
c  Also note that the location of the grid symmetry elements
c  in the total list is strictly increasing, and the scheme
c  used here depends on this fact.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
c input/output arrays:
      DIMENSION  isymgrd(*)
      DIMENSION  rmatsym(12,*), naofsym(natm,*)
c
c >>>> EXECUTABLE CODE
c
      if( nsymg.lt.1 ) RETURN
c
      do 100 isymg=1,nsymg
        isyma = isymgrd(isymg)
        if( isyma.ne.isymg )then
          do  iatm=1,natm
            itmp = naofsym(iatm,isymg+1)
            naofsym(iatm,isymg+1) = naofsym(iatm,isyma+1)
            naofsym(iatm,isyma+1) = itmp
          enddo
          do  ij=1,12
            tmp = rmatsym(ij,isymg)
            rmatsym(ij,isymg) = rmatsym(ij,isyma)
            rmatsym(ij,isyma) = tmp
          enddo
        endif
  100 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMPROD
c
c
      subroutine SYMPROD( rmata, rmatb, rmatab, rprim )
c---------------------------------------------------------------
c Purpose: take product of symmetry elements
c
c Written: Peter A. Schultz, 4-January-1999, for v2.30
c
c Revision history:
c  21Jul99-DBR/2.37: bug fix - properly rotate translation
c---------------------------------------------------------------
c
c  Note:
c   We are actually computing the product BA, not AB
c  Variables:
c   rmata(),rmatb() - input symmetry elements
c   rmatab()   - output product of symmetry elements
c   rprim(3,3) - primitive lattice vectors
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output array:
      DIMENSION  rmatab(3,4)
c input arrays:
      DIMENSION  rmata(3,4),rmatb(3,4)
      DIMENSION  rprim(3,3)
c local declarations:
      LOGICAL    outuc, shift
      DIMENSION  t1(3)
c
c >>>> EXECUTABLE CODE:
c
c  Operate on symmetry operation a with operation b
      do  j=1,3
        do  i=1,3
          rmatab(i,j) = rmata(i,1)*rmatb(1,j)
     $                + rmata(i,2)*rmatb(2,j)
     $                + rmata(i,3)*rmatb(3,j)
        enddo
      enddo
c
c  Transform the translation vector as well:
      do  i=1,3
        rmatab(i,4) = rmatb(1,i)*rmata(1,4)
     $              + rmatb(2,i)*rmata(2,4)
     $              + rmatb(3,i)*rmata(3,4)
      enddo
c
c  Complete translation vector:
      t1(1) = rmatab(1,4) + rmatb(1,4)
      t1(2) = rmatab(2,4) + rmatb(2,4)
      t1(3) = rmatab(3,4) + rmatb(3,4)
c
c  Project translation vector into unit cell:
      call PROJUC( outuc,shift, 3, t1,rmatab(1,4), rprim )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMRHO2
c
c
      subroutine SYMRHO2( n1r,n2r,n3r, isymv,nsymv, rho )
c---------------------------------------------------------------
c Purpose: 2D-symmetrize charge density (in real space)
c
c Written: Peter A. Schultz, 20-February-1990
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c  Note: symmetrization of rho() is done in-place, the
c        density of the symmetry-related mesh points
c        being accumulated in the first mesh point of
c        a symmetry set and then being broadcast to
c        the other members of that set afterwards.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  isymv(*),nsymv(*)
c input/output arrays:
      DIMENSION  rho(n1r*n2r,n3r)
c local declarations:
      DATA  one / 1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      do 100 ir=1,n1r*n2r
        ifst = isymv(ir)
        symnum = one/ DBLE(nsymv(ifst))
c
        if( ifst.eq.ir )then
          do  i3=1,n3r
            rho(ifst,i3) = rho(ifst,i3)*symnum
          enddo
        else
          do  i3=1,n3r
            rho(ifst,i3) = rho(ifst,i3) + rho(ir,i3)*symnum
          enddo
        endif
c
  100 continue
c
c  Have average density in first of each symmetry set,
c  now broadcast to other members of symmetry sets:
c
      do  ir=1,n1r*n2r
        ifst = isymv(ir)
        do  i3=1,n3r
          rho(ir,i3) = rho(ifst,i3)
        enddo
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMRHO3
c
c
      subroutine SYMRHO3( n1r,n2r,n3r, isymv,nsymv, rho )
c---------------------------------------------------------------
c Purpose: 3D-symmetrize density, done in-place in real space
c
c Written: Peter A. Schultz, 3-November-1994
c
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c symmetry point mapping arrays:
      DIMENSION  isymv(*),nsymv(*)
c density on grid
      DIMENSION  rho(*)
c local declarations:
      DATA  one / 1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      do  ir=1,n1r*n2r*n3r
        ifst = isymv(ir)
        symnum = one/DBLE(nsymv(ifst))
        if( ifst.eq.ir )then
          rho(ifst) = rho(ifst)*symnum
        else
          rho(ifst) = rho(ifst) + rho(ir)*symnum
        endif
      enddo
c
c  Have average density in first of each symmetry set,
c  now broadcast to other members of symmetry sets:
c
      do  ir=1,n1r*n2r*n3r
        ifst = isymv(ir)
        rho(ir) = rho(ifst)
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMRHO
c
c
      subroutine SYMRHO( IWR, subsym,ndimsy, nsym,nsymg,
     $ rsym, rmatsym, isymgrd,  rprim, n1r,n2r,n3r, hh,
     $ rho, iwrk )
c---------------------------------------------------------------
c Purpose: driving routine to symmetrize density on the grid
c
c Written: Peter A. Schultz, 3-November-1994
c
c Revision history:
c   1May02-PAS/2.53: reconcile sym and cell-opt
c  21Jun01-PAS/2.48: replace STOPs
c   6Jan98-PAS/2.30: redo symmetry scheme
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Sep98-PAS/2.27: treat non-origin center of symmetry
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c symmetry information:
      LOGICAL    subsym
      DIMENSION  rsym(3), rmatsym(12,*), isymgrd(*)
      DIMENSION  rprim(3,*)
c grid-lattice primitive vectors:
      DIMENSION  hh(3,3)
c density to be symmetrized and work space:
      DIMENSION  rho(*), iwrk(*)
c local:
      DIMENSION  isymctr(3)
      LOGICAL  badsym
c
c >>>> EXECUTABLE CODE:
c
c skip if nothing to symmetrize:
      if( nsym.le.0 ) RETURN
c
c Allocate storage for symmetry operations:
      isymops = 1
      is1 = isymops + 12*nsym
c
c  Generate index symmetry operations from cartesian operations:
c
      call SYMMAT( subsym, ibadsym, nsym,nsymg,
     $ rprim, n1r,n2r,n3r, hh, rsym, rmatsym, isymgrd,
     $ isymctr,iwrk(isymops) )
c
      if( nsym.ne.nsymg )then
        write(IWR,*) '***** NOTE: symmetry of grid is reduced'
        write(IWR,*) '  # of system symmetry operations(w/id)=',nsym+1
        write(IWR,*) '  # of viable symmetries on grid(w/id)=',nsymg+1
      endif
c
      if( ibadsym.gt.0 )then
        write(IWR,*) '>>>>> grid does not transform by sym#',ibadsym
        write(IWR,*) 'Cartesian representation of symmetry operation:'
        write(IWR,'(10x,3f15.10)') (rmatsym(ij,ibadsym),ij=1,12)
        call STOPXERR( 'symrho-r/grid does not xform by symmetry' )
      elseif( ibadsym.lt.0 )then
        call STOPXERR( 'symctrgr/sym center not on grid point' )
      endif
c
      if( ndimsy.ne.2 )then
c
c >>>> 3D SYMMETRIZATION (general case)
c
        is2 = is1 + n1r*n2r*n3r
c
        call SYMMAP3( badsym, nsymg,n1r,n2r,n3r,isymctr,iwrk(isymops),
     $   iwrk(is1),iwrk(is2) )
c
        if( badsym )then
          call STOPXERR( 'symset3d/ bad 3D symmetry group' )
        endif
c
        call SYMRHO3( n1r,n2r,n3r, iwrk(is1),iwrk(is2), rho )
c
      else
c
c >>>> 2D SYMMETRIZATION (special case)
c
        is2 = is1 + n1r*n2r
c
        call SYMMAP2( badsym, nsymg, n1r,n2r, isymctr,iwrk(isymops),
     $   iwrk(is1),iwrk(is2) )
c
        if( badsym )then
          call STOPXERR( 'symset2d/ bad 2D symmetry group' )
        endif
c
        call SYMRHO2( n1r,n2r,n3r, iwrk(is1),iwrk(is2), rho )
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMRMAT
c
c
      subroutine SYMRMAT( nsymi, isymtyp,syminfo,
     $ nsymd, nsym, rmatsym,  rprim )
c---------------------------------------------------------------
c Purpose: generate cartesian reps of 3D symmetry operations
c
c Written: Peter A. Schultz, 6-January-1998, for v2.30
c          Adapted from symr3mat, and also replacing symr2mat
c
c Revision history:
c  21Jun01-PAS/2.48: replace STOPs, writes
c  21Jul99-PAS/2.37: project translation vector+right handedness
c  26Apr99-PAS/2.34: fix rotation+inversion generation
c---------------------------------------------------------------
c
c  Variables:
c   nsymi - number of input non-identity symmetry definitions
c   nsym  - number of output non-identity symmetry operations
c   isymtyp() - type of symmetry operation
c     order of rotation(+inversion if less than 0)
c     Valid inputs: -6,-4,-3,-2,-1,1,2,3,4,6
c     NB: 1=reflection equivalent to "-2" 2-fold rotation+inv
c   syminfo() - defining axis of those operations (normalized)
c     syminfo(1-3) = normalized axis of rotation (Cartesian)
c     syminfo(4-6) = translation vector (lattice units)
c   rmatsym() - output matrix of cartesian reps of symmetries
c   rprim()   - primitive lattice vectors
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
c input arrays:
      DIMENSION  rprim(3,3)
      DIMENSION  isymtyp(*), syminfo(6,*)
c output array:
      DIMENSION  rmatsym(3,4,*)
c local declarations:
      LOGICAL  doinvrs
      DIMENSION  u(3),off(3)
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /
c
c >>>> EXECUTABLE CODE:
c
      nsym = 0
      if( nsymi.lt.1 ) RETURN
c
      isym = 0
      do 100 isymi=1,nsymi
c
        doinvrs = .false.
        istyp = isymtyp(isymi)
c
c  Load rotation axis:
        u(1) = syminfo(1,isymi)
        u(2) = syminfo(2,isymi)
        u(3) = syminfo(3,isymi)
c
c  Project translation vector into primary unit cell:
c  (thanks to Dave Raczkowski for pointing out that
c   translation vectors of the input generators need to be
c   projected into the primary unit cell, or the group
c   generation code might fail - 21Jul99-PAS)
        do 20 j=4,6
c  I want the lattice projection to be 0.le.x.lt.1
          tr = syminfo(j,isymi)
          if( tr.ge.one )then
            itr = tr
            ishift = -itr
          elseif( tr.lt.zero )then
            trm = -tr + 0.999
            ishift = trm
          else
            goto 20
          endif
          syminfo(j,isymi) = syminfo(j,isymi) + ishift
   20   continue
c
c  Generate translation vector:
        do  j=1,3
          off(j) = syminfo(4,isymi)*rprim(j,1)
     $           + syminfo(5,isymi)*rprim(j,2)
     $           + syminfo(6,isymi)*rprim(j,3)
        enddo
        offsq = off(1)**2 + off(2)**2 + off(3)**2
c
        rotang = zero
c I will generate all rotations of a generator ...
        nrepeat = IABS(istyp) - 1
c  ... unless it has a translation, then let group code do it elsewhere
        if( offsq .gt. 1.d-4 ) nrepeat = 1
c
   40   isym = isym + 1
        if( isym.gt.nsymd ) goto 90
c
c Load translation vector:
c
        rmatsym(1,4,isym) = off(1)
        rmatsym(2,4,isym) = off(2)
        rmatsym(3,4,isym) = off(3)
c
c Compute transformation matrices:
c
        if( istyp .eq. 1 )then
c
c         REFLECTION
          do  j=1,3
            do  i=1,3
              rmatsym(i,j,isym) = -two*u(i)*u(j)
            enddo
          enddo
          rmatsym(1,1,isym) = rmatsym(1,1,isym) + one
          rmatsym(2,2,isym) = rmatsym(2,2,isym) + one
          rmatsym(3,3,isym) = rmatsym(3,3,isym) + one
c
        elseif( IABS(istyp) .gt. 1 )then
c
c         ROTATION
          nrot = IABS(istyp)
          rotang = rotang + two*pi/DBLE(nrot)
          cosa = COS(rotang)
          sina = SIN(rotang)
          fac = one - cosa
          do  j=1,3
            do  i=1,3
              rmatsym(i,j,isym) = rmatsym(i,j,isym) + fac*u(i)*u(j)
            enddo
          enddo
          rmatsym(1,1,isym) = rmatsym(1,1,isym) + cosa
          rmatsym(2,2,isym) = rmatsym(2,2,isym) + cosa
          rmatsym(3,3,isym) = rmatsym(3,3,isym) + cosa
          rmatsym(1,2,isym) = rmatsym(1,2,isym) + sina*u(3)
          rmatsym(2,1,isym) = rmatsym(2,1,isym) - sina*u(3)
          rmatsym(2,3,isym) = rmatsym(2,3,isym) + sina*u(1)
          rmatsym(3,2,isym) = rmatsym(3,2,isym) - sina*u(1)
          rmatsym(3,1,isym) = rmatsym(3,1,isym) + sina*u(2)
          rmatsym(1,3,isym) = rmatsym(1,3,isym) - sina*u(2)
c
c decide whether to toggle inversion:
          if( istyp.lt.0 ) doinvrs = .not. doinvrs
c
        elseif( istyp .eq. -1 .or. istyp.eq.0 )then
c
          doinvrs = .true.
c         INVERSION - wait, install identity
          do  j=1,3
            do  i=1,3
              rmatsym(i,j,isym) = zero
            enddo
          enddo
          rmatsym(1,1,isym) = one
          rmatsym(2,2,isym) = one
          rmatsym(3,3,isym) = one
c
        endif
c
        if( doinvrs )then
c         INVERSION - actually do it
          do  j=1,3
            do  i=1,3
              rmatsym(i,j,isym) = -rmatsym(i,j,isym)
            enddo
          enddo
        endif
c
   90   continue
        nrepeat = nrepeat - 1
c Go back and generate next rotation in this set:
        if( nrepeat .gt. 0 ) goto 40
c
  100 continue
c
c  Record number of symmetry operations generated here:
c
      nsym = isym
      if( nsym.gt.nsymd )then
        call FLGETIERR( IERRFL )
        write(IERRFL,*) '>>>>> total so far=',nsym,', max=',nsymd
        call STOPXERR( 'symrmatd/ too many sym ops in group' )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMSTR
c
c
      subroutine SYMSTR( ndim, str1, nsym, rmatsym )
c---------------------------------------------------------------
c Purpose: symmetrize stress tensor
c
c Written: Peter A. Schultz, 28-September-1999, v2.40(3dstress)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input/output arrays:
      DIMENSION  str1(3,3),str2(3,3),str3(3,3)
      DIMENSION  rmatsym(3,4,*)
c local declarations
      DIMENSION  vi(3),svi(3)
      DATA  zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      if( nsym.le.0 ) RETURN
c
c Load identity:
      do  jd=1,3
        do  id=1,3
          str2(id,jd) = str1(id,jd)
        enddo
      enddo
c
c  Cycle over non-ident syms, and accumulate transformed tensors:
c
      do 300 isym=1,nsym
c
        do  jdim=1,3
          vi(1) = str1(1,jdim)
          vi(2) = str1(2,jdim)
          vi(3) = str1(3,jdim)
c
          svi(1) = rmatsym(1,1,isym)*vi(1) + rmatsym(2,1,isym)*vi(2)
     $           + rmatsym(3,1,isym)*vi(3)
          svi(2) = rmatsym(1,2,isym)*vi(1) + rmatsym(2,2,isym)*vi(2)
     $           + rmatsym(3,2,isym)*vi(3)
          svi(3) = rmatsym(1,3,isym)*vi(1) + rmatsym(2,3,isym)*vi(2)
     $           + rmatsym(3,3,isym)*vi(3)
c
          str3(1,jdim) = svi(1)
          str3(2,jdim) = svi(2)
          str3(3,jdim) = svi(3)
        enddo
c
        do  idim=1,3
          vi(1) = str3(idim,1)
          vi(2) = str3(idim,2)
          vi(3) = str3(idim,3)
c
          svi(1) = rmatsym(1,1,isym)*vi(1) + rmatsym(2,1,isym)*vi(2)
     $           + rmatsym(3,1,isym)*vi(3)
          svi(2) = rmatsym(1,2,isym)*vi(1) + rmatsym(2,2,isym)*vi(2)
     $           + rmatsym(3,2,isym)*vi(3)
          svi(3) = rmatsym(1,3,isym)*vi(1) + rmatsym(2,3,isym)*vi(2)
     $           + rmatsym(3,3,isym)*vi(3)
c
          str2(idim,1) = str2(idim,1) + svi(1)
          str2(idim,2) = str2(idim,2) + svi(2)
          str2(idim,3) = str2(idim,3) + svi(3)
        enddo
c
  300 continue
c
c Load symmetrized stress tensor back in original space:
      symscal = one/ DBLE( nsym+1 )
      do  jd=1,3
        do  id=1,3
          str1(id,jd) = symscal*str2(id,jd)
        enddo
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SYMVEC
c
c
      subroutine SYMVEC( nvec, vec, rsym, nsym, rmatsym )
c---------------------------------------------------------------
c Purpose: symmetrize vectors
c
c Written: Peter A. Schultz, 28-September-1999, v2.40
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input/output arrays:
      DIMENSION  vec(3,nvec)
      DIMENSION  rsym(3), rmatsym(3,4,*)
c local declarations
      DIMENSION  vi(3),svi(3),vis(3)
      DATA  zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      if( nsym.le.0 ) RETURN
c
c  Loop over all vectors, accumulate symmetry vector
c
      symscal = one/ DBLE( nsym+1 )
      do 300 ivec=1,nvec
        vi(1) = vec(1,ivec) - rsym(1)
        vi(2) = vec(2,ivec) - rsym(2)
        vi(3) = vec(3,ivec) - rsym(3)
        vis(1) = vi(1)
        vis(2) = vi(2)
        vis(3) = vi(3)
        do  isym=1,nsym
c
          svi(1) = rmatsym(1,1,isym)*vi(1) + rmatsym(2,1,isym)*vi(2)
     $           + rmatsym(3,1,isym)*vi(3)
          svi(2) = rmatsym(1,2,isym)*vi(1) + rmatsym(2,2,isym)*vi(2)
     $           + rmatsym(3,2,isym)*vi(3)
          svi(3) = rmatsym(1,3,isym)*vi(1) + rmatsym(2,3,isym)*vi(2)
     $           + rmatsym(3,3,isym)*vi(3)
c
          vis(1) = vis(1) + svi(1)
          vis(2) = vis(2) + svi(2)
          vis(3) = vis(3) + svi(3)
        enddo
        vec(1,ivec) = rsym(1) + symscal*vis(1)
        vec(2,ivec) = rsym(2) + symscal*vis(2)
        vec(3,ivec) = rsym(3) + symscal*vis(3)
c
  300 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TANGENT
c
c
      subroutine TANGENT( IWRNEB,
     $     natom,riminus,ri,riplus,ti,driminus,driplus,
     $     sumdrisqplus,sumdrisqminus,Lantikink,
     $     energy_lo,energy_image,energy_hi,
     $      dprev, dnext )
c---------------------------------------------------------------
c
c     This subroutine calculates tangents and segment lengths
c     This subroutine calculate displacemnt vectors and
c     unit tangent vectors for each image.
c
c Written: Aidan P. Thompson, Fall 2001
c
c Revision history:
c   7Oct02-PAS/2.54: adapted for SeqQuest 2.54(NEB)
c  11May05-RMV/2.59 add pass of dprev, dnext
c---------------------------------------------------------------
c
      IMPLICIT  NONE
c
c     --- variables passed to and from subroutine
      real*8 ti(3,*),riminus(3,*),ri(3,*),riplus(3,*)
      real*8 driminus(3,*),driplus(3,*)
c
      real*8 sumdrisqplus,sumdrisqminus, dprev,dnext
      real*8 energy_lo,energy_image,energy_hi
      integer  natom
      INTEGER  IWRNEB
c
      LOGICAL  Lantikink
c
c     --- local variables
      real*8 drinorminvplus,drinorminvminus
      real*8 sumtsq,tnorminv,dotprod
      real*8 delumin,delumax,deluminus,deluplus
      integer iatom, i
      real*8  zero,one
      real*8  rsmall
c
      DATA  zero,one / 0.d0,1.d0 /
      DATA  rsmall  / 1.d-4 /
c
c >>>> EXECUTABLE CODE:
c
c Calculate displacement vectors:
c     driplus is defined as the vector from iimg to iimg+1,
c         ie R(iimg+1) - Ri(iimg)
c     driminus is defined as the vector from iimg-1 to iimg,
c         ie R(iimg) - Ri(iimg-1)
c
      sumdrisqplus = zero
      sumdrisqminus = zero
      do  iatom=1,natom
         driminus(1,iatom) = ri(1,iatom) - riminus(1,iatom)
         driminus(2,iatom) = ri(2,iatom) - riminus(2,iatom)
         driminus(3,iatom) = ri(3,iatom) - riminus(3,iatom)
         driplus(1,iatom) = riplus(1,iatom) - ri(1,iatom)
         driplus(2,iatom) = riplus(2,iatom) - ri(2,iatom)
         driplus(3,iatom) = riplus(3,iatom) - ri(3,iatom)
         sumdrisqminus = sumdrisqminus +
     $          driminus(1,iatom)*driminus(1,iatom) +
     $          driminus(2,iatom)*driminus(2,iatom) +
     $          driminus(3,iatom)*driminus(3,iatom)
         sumdrisqplus = sumdrisqplus +
     $          driplus(1,iatom)*driplus(1,iatom) +
     $          driplus(2,iatom)*driplus(2,iatom) +
     $          driplus(3,iatom)*driplus(3,iatom)
      enddo
c
c Check that neighboring images are not identical
c
  913 format(5x,3f15.6)
      if( sumdrisqplus .lt. rsmall )then
         write(IWRNEB,*)'***** ERROR: R(image+1) = R(image) *****'
         write(IWRNEB,*) 'SUM |R(I+1) - R(I)|^2 = ',sumdrisqplus
         do  iatom=1,natom
            write(IWRNEB,*)  'Atom/R(I)/R(I+1) = ',iatom
            write(IWRNEB,913)  ( ri    (i,iatom), i=1,3 )
            write(IWRNEB,913)  ( riplus(i,iatom), i=1,3 )
         enddo
         call STOPXERR( 'NEB TANGENT: R(image+1) = R(image)' )
      endif
      if( sumdrisqminus .lt. rsmall )then
         write(IWRNEB,*)'***** ERROR: R(image-1) = R(image) *****'
         write(IWRNEB,*) 'SUM |R(I-1) - R(I)|^2 = ',sumdrisqminus
         do  iatom=1,natom
            write(IWRNEB,*)  'Atom/R(I)/R(I-1) = ',iatom
            write(IWRNEB,913)  ( ri     (i,iatom), i=1,3 )
            write(IWRNEB,913)  ( riminus(i,iatom), i=1,3 )
         enddo
         call STOPXERR( 'NEB TANGENT: R(image-1) = R(image)' )
      endif
c
      dprev = SQRT( sumdrisqminus )
      dnext = SQRT( sumdrisqplus )
      drinorminvminus = one / SQRT( sumdrisqminus )
      drinorminvplus = one / SQRT( sumdrisqplus )
c
c Check for sharp angles
c
      dotprod = zero
      do  iatom=1,natom
         dotprod = dotprod + driplus(1,iatom)*driminus(1,iatom) +
     $                       driplus(2,iatom)*driminus(2,iatom) +
     $                       driplus(3,iatom)*driminus(3,iatom)
      enddo
c
      if( dotprod .le. zero )then
         write(IWRNEB,*)
         write(IWRNEB,*) '*************************************'
         write(IWRNEB,*) 'WARNING: NEB (I+1):(I):(I-1) Sharp angle'
         write(IWRNEB,*) 'Dotprod = ',dotprod
         do  iatom=1,natom
            write(IWRNEB,*)  'Atom/R(I-1)/R(I)/R(I+1) = ',iatom
            write(IWRNEB,913)  ( riminus(i,iatom), i=1,3 )
            write(IWRNEB,913)  ( ri     (i,iatom), i=1,3 )
            write(IWRNEB,913)  ( riplus (i,iatom), i=1,3 )
         enddo
         write(IWRNEB,*) '*************************************'
         write(IWRNEB,*)
      endif
c
c Calculate the unit tangent vector for each image.
c This is tau in Jonnson (1998)
c
      if( .not. Lantikink )then
c
c        This is the "bisector" method.
         do  iatom=1,natom
            ti(1,iatom) = driplus(1,iatom)*drinorminvplus +
     $                    driminus(1,iatom)*drinorminvminus
            ti(2,iatom) = driplus(2,iatom)*drinorminvplus +
     $                    driminus(2,iatom)*drinorminvminus
            ti(3,iatom) = driplus(3,iatom)*drinorminvplus +
     $                    driminus(3,iatom)*drinorminvminus
         enddo
c
      elseif( Lantikink )then
c
c        Use energy-biased tangent estimate of Henkelman&Jonsson (2000)
c        Vector Tminus refers to R(iimg) - R(iimg-1).
c        Vector Tplus refers to R(iimg+1) - R(iimg).
c
         deluminus = energy_image - energy_lo
         deluplus = energy_hi - energy_image
c
         if( deluminus.ge.zero .and. deluplus.ge.zero )then
c
c           We are on the uphill side, use Tplus as tangent
            do  iatom=1,natom
               ti(1,iatom) = driplus(1,iatom)
               ti(2,iatom) = driplus(2,iatom)
               ti(3,iatom) = driplus(3,iatom)
            enddo
c
         elseif( deluminus.le.zero .and. deluplus.le.zero )then
c
c           We are on the downhill side, use Tminus as tangent
            do  iatom=1,natom
               ti(1,iatom) = driminus(1,iatom)
               ti(2,iatom) = driminus(2,iatom)
               ti(3,iatom) = driminus(3,iatom)
            enddo
c
         else
c
c           We have a local maximum or local minimum,
c           use weighted average of Tminus and Tplus as tangent.
c
            delumax = MAX( ABS(deluminus), ABS(deluplus) )
            delumin = MIN( ABS(deluminus), ABS(deluplus) )
c
            if( energy_hi .ge. energy_lo )then
c              Weight Tplus higher
               do  iatom=1,natom
                  ti(1,iatom) = delumax*driplus(1,iatom) +
     $                          delumin*driminus(1,iatom)
                  ti(2,iatom) = delumax*driplus(2,iatom) +
     $                          delumin*driminus(2,iatom)
                  ti(3,iatom) = delumax*driplus(3,iatom) +
     $                          delumin*driminus(3,iatom)
               enddo
            else
c              Weight Tminus higher
               do  iatom=1,natom
                  ti(1,iatom) = delumin*driplus(1,iatom) +
     $                          delumax*driminus(1,iatom)
                  ti(2,iatom) = delumin*driplus(2,iatom) +
     $                          delumax*driminus(2,iatom)
                  ti(3,iatom) = delumin*driplus(3,iatom) +
     $                          delumax*driminus(3,iatom)
               enddo
            endif
c
         endif
c
c        End Lantikink branch
      endif
c
c Finally, we need to normalize the tangent.
c
      sumtsq = zero
      do  iatom=1,natom
         sumtsq = sumtsq + ti(1,iatom)**2
     $                   + ti(2,iatom)**2
     $                   + ti(3,iatom)**2
      enddo
c
      if( sumtsq .eq. zero )then
         call STOPXERR( 'NEB TANGENT: R(i+1) - R(i-1) = 0' )
      endif
c
      tnorminv = one / SQRT( sumtsq )
c
      do  iatom=1,natom
         ti(1,iatom) = ti(1,iatom)*tnorminv
         ti(2,iatom) = ti(2,iatom)*tnorminv
         ti(3,iatom) = ti(3,iatom)*tnorminv
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TIJ
c
c
      subroutine TIJ( norb,nk,ncplx, natm,ntyp,nshld,nald, nlat,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba,
     $ ratm, rlat,coskr,sinkr, wksm,
     $ tmat )
c---------------------------------------------------------------
c Purpose: compute kinetic energy matrix for a band structure
c          calculation. The real part is stored in the lower
c          triangle of matrix, the imaginary part in the upper
c
c Written: P.A. Schultz, based on P.J. Feibelman's original
c
c Revision history:
c  19Oct08-PAS/2.62: stripe-distributed-parallel
c   7Mar02-PAS/2.52: ang constants extracted
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c   2Sep98-PAS/2.25: clean out equivalences
c  13Aug98-PAS/2.24: cutoffs, names, restructure
c  16Jul98-PAS/2.23: fix label problem (thx D.Raczkowski)
c  28Apr97-PAS/2.17: naming conventions
c  12Apr95-PAS/2.12: stretched alpha cutoffs installed
c  18Jan94-PAS/2.04: full cleanup, match sij,tij,enij,ennloc
c---------------------------------------------------------------
c
c  Calculates kinetic energy matrix analytically
c
c  Radial wave functions are assumed to have been normalized (this is
c  done in routine "orbbulk", where the cala coefficients have been
c  rescaled). Normalization of the angular wave functions is done in
c  the present routine via the division by the quantities "vnorm"
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, two=2.d0, half=0.5d0 )
c
c Output array:
      DIMENSION  tmat(nk,*)
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
c Scratch space:
      DIMENSION  wksm(*)
c
c Local declarations:
      LOGICAL    diagshl
      DIMENSION  rij(3), p(3), ci(10,9),cj(10,9)
c
      DIMENSION  vnorm(9)
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'SDEV/TIJ: stripe-parallel'
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxf = cutgwfn
      emaxsl = cutslow
      fourpi = pi + pi + pi + pi
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
c  Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmatstr = ncplx*nk*matstr
c
c  Figure out how much belongs on local processor:
      call MATLOCSTR( iproc,nprocs,nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmatpr = mymatpr*ncplx*nk
c
c  Clear kinetic matrix
c
      call MKZERO( nmatpr, tmat )
c
c     Atom j loop:
c
      nlatmx = 0
c
      jjnext = 0
      jnext = myj0
      do 2000 jatm=myatm1,myatm2
        jtyp = itypa(jatm)
        nshlj = numshl(jtyp)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        njstripe = norb - jstart
        matjstr = norbatj*njstripe
        jjstart = jjnext
        jjnext = jjstart + matjstr*ncplx
c
        alaminj = alamin(jtyp)
        call CINIT( cj )
c
c       Atom j shell loop:
c
        jorbatnxt = 0
        j = jstart
        do 1800 jshl=1,nshlj
          nalj = nala(jshl,jtyp)
          lshlj = lshel(jshl,jtyp)
          norbshj = 2*lshlj + 1
          lj0 = lshlj*lshlj
c
          j0 = j
          jorbat0 = jorbatnxt
          jorbatnxt = jorbat0 + norbshj
c
          alminj = ala(1,jshl,jtyp)
          almaxj = ala(nalj,jshl,jtyp)
          do  jal=1,nalj
            alj = ala(jal,jshl,jtyp)
            if( alj.lt.alminj ) alminj = alj
            if( alj.gt.almaxj ) almaxj = alj
          enddo
          alaminj = alminj
c
          emaxij = emaxf
          if( alminj.lt.alfast ) emaxij = emaxsl
c
c         Atom i loop:
c
          ijnext = jjstart
          inext = jstart
          do 1000 iatm=jatm,natm
            ityp = itypa(iatm)
            nshli = numshl(ityp)
            norbati = norba(ityp)
            istart = inext
            inext = istart + norbati
c
            matij = norbati*norbatj
            ijstart = ijnext
            ijnext = ijstart + matij*ncplx
c
c           Following helps ensure only i.ge.j done:
            iorbatn0 = 0
            ishl1 = 1
            if( iatm.eq.jatm )then
              ishl1 = jshl
              do  ishl=1,ishl1-1
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                istart = istart + norbshi
                iorbat0 = iorbatn0
                iorbatn0 = iorbat0 + norbshi
              enddo
            endif
c
            alamini = alamin(ityp)
            emax = emaxij
            rijmax = emax*(alamini+alaminj) / (alamini*alaminj)
c
c           Lattice vector loop for Atom i:
c
            do 900 ilat=1,nlat
c
              rijsq = zero
              do  ir=1,3
                rij(ir) =  ratm(ir,jatm) - ratm(ir,iatm) - rlat(ir,ilat)
                rijsq = rijsq + rij(ir)*rij(ir)
              enddo
              if( rijsq.gt.rijmax ) goto 900
c
              call CINIT( ci )
              call COFR( cj,rij )
c
c             Atom i shell loop:
c
              iorbatnxt = iorbatn0
              i = istart
              do 800 ishl=ishl1,nshli
                nali = nala(ishl,ityp)
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                li0 = lshli*lshli
c
                i0 = i
                iorbat0 = iorbatnxt
                iorbatnxt = iorbat0 + norbshi
c
                diagshl = .false.
                if( i0.eq.j0 ) diagshl = .true.
c
                almini = ala(1,ishl,ityp)
                almaxi = ala(nali,ishl,ityp)
                do  ial=1,nali
                  ali = ala(ial,ishl,ityp)
                  if( ali.lt.almini ) almini = ali
                  if( ali.gt.almaxi ) almaxi = ali
                enddo
c
                emax = emaxf
                if( almaxi.lt.alfast .and. almaxj.lt.alfast )
     $           emax = emaxsl
                rijmx = emax*(alaminj+almini) / (alaminj*almini)
                if( rijsq.gt.rijmx ) goto 799
c
c               Angular loops:
c
                ij0 = ijstart + jorbat0*norbati + iorbat0
                ij0 = ij0 - norbati
                mli1 = 1
                do 420 mlj=1,norbshj
c                 lj=1,....,9   is orbital symmetry index of orbital j
                  lj = lj0 + mlj
                  jorbat = jorbat0 + mlj
                  j = j0 + mlj
c
                  ij0 = ij0 + norbati
                  if( diagshl ) mli1 = mlj
                  do 410 mli=mli1,norbshi
c                   li=1,....,9   is orbital symmetry index of orbital i
                    li = li0 + mli
                    iorbat = iorbat0 + mli
                    i = i0 + mli
                    ij = ij0 + mli
c
c                   Alpha loops:
c
                    nx = 0
                    tsum = zero
c
                    do 320 jal=1,nalj
                      alj = ala(jal,jshl,jtyp)
c
                      do 310 ial=1,nali
                        ali = ala(ial,ishl,ityp)
c
                        rijmx = emax*(ali+alj) / (ali*alj)
                        if( rijsq.gt.rijmx ) goto 310
c
                        nx = nx + 1
                        alsum = ali + alj
                        do  ir=1,3
                          p(ir) = two*alj*rij(ir)
                        enddo
                        pmag = SQRT( p(1)*p(1)+p(2)*p(2)+p(3)*p(3) )
c
c                       Evaluate contribution to matrix element
                        call TINTSUM( telem, p,lj,li,cj(1,lj),ci(1,li),
     $                                alj,ali,alsum,pmag )
                        tsum = tsum + EXP( -ali*alj*rijsq/alsum )*
     $                   telem*cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
c
c                       Close alpha loops:
  310                 continue
  320               continue
                    tsum = fourpi*tsum / ( vnorm(li)*vnorm(lj) )
c
c                   Multiply by Bloch phase factors and load output array
c
                    do  k=1,nk
C                      tmat(i,j,k) = tmat(i,j,k) + tsum*coskr(k,ilat)
                      tmat(k,ij) = tmat(k,ij) + tsum*coskr(k,ilat)
                    enddo
                    if( ncplx.eq.2 .and. i.ne.j )then
                      ijc = ij + matij
                      do  k=1,nk
C                        tmat(j,i,k) = tmat(j,i,k) + tsum*sinkr(k,ilat)
                        tmat(k,ijc) = tmat(k,ijc) + tsum*sinkr(k,ilat)
                      enddo
                    endif
c
                    if( ilat.gt.nlatmx ) nlatmx = ilat
c
c                   Close orbital loops:
  410             continue
  420           continue
c
  799           continue
c               Close Atom i shell loop:
                i = i0 + norbshi
  800         continue
c
c             Close Atom i lattice loop:
  900       continue
c
c           Close Atom i loop:
 1000     continue
c
c         Close Atom j shell loop:
          j = j0 + norbshj
 1800   continue
c
c       Close Atom j loop:
 2000 continue
c
      if( nprocs .gt. 1 )then
c       A hack to communicate max required nlat:
c       NB: only assemble over active local procs, some could be idle
c       NB2: unlike in sij, this Bcast does not incur init connect cost.
        call MKZERO( nprocstr, wksm )
        wksm(1) = DBLE( nlatmx ) + 0.1
        if( iproc .lt. nprocstr )
     $   call MPMERGER8( nprocstr, master, iproc,
     $                   nprocstr,1,1, wksm, icomm )
        if( iproc .eq. master )then
          rnlatmx = wksm(1)
          do  jproc=2,nprocstr
            if( wksm(jproc) .gt. rnlatmx ) rnlatmx = wksm(jproc)
          enddo
        endif
c       Broadcast max nlat to everyone, even the locally idle procs:
        call MPBCAST8( master, 1,rnlatmx, icomm )
        nlatmx = rnlatmx
        nlat = nlatmx
      endif
c
c  Shrink nlat if list end not used (ie, unit cells not interact):
      nlat = nlatmx
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TIJ1
c
c
      subroutine TIJ1( norb,nk,ncplx, natm,ntyp,nshld,nald, nlat,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba,
     $ ratm, rlat,coskr,sinkr,
     $ tmat )
c---------------------------------------------------------------
c Purpose: compute kinetic energy matrix for a band structure
c          calculation. The real part is stored in the lower
c          triangle of matrix, the imaginary part in the upper
c
c Written: P.A. Schultz, based on P.J. Feibelman's original
c
c Revision history:
c   6Sep08-PAS/2.62: switched ij-ji
c   7Mar02-PAS/2.52: ang constants extracted
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c   2Sep98-PAS/2.25: clean out equivalences
c  13Aug98-PAS/2.24: cutoffs, names, restructure
c  16Jul98-PAS/2.23: fix label problem (thx D.Raczkowski)
c  28Apr97-PAS/2.17: naming conventions
c  12Apr95-PAS/2.12: stretched alpha cutoffs installed
c  18Jan94-PAS/2.04: full cleanup, match sij,tij,enij,ennloc
c---------------------------------------------------------------
c
c  Calculates kinetic energy matrix analytically
c
c  Radial wave functions are assumed to have been normalized (this is
c  done in routine "orbbulk", where the cala coefficients have been
c  rescaled). Normalization of the angular wave functions is done in
c  the present routine via the division by the quantities "vnorm"
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, two=2.d0, half=0.5d0 )
c
c Output array:
      DIMENSION  tmat(norb,norb,nk)
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
c
c Local declarations:
      LOGICAL    diagshl
      DIMENSION  rij(3), p(3), ci(10,9),cj(10,9)
c
      DIMENSION  vnorm(9)
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'SDEV/TIJ1: ijkmat'
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxf = cutgwfn
      emaxsl = cutslow
      fourpi = pi + pi + pi + pi
      nlatmx = 0
c
c  Clear kinetic matrix
c
      call MKZERO( norb*norb*nk, tmat )
c
c     Atom j loop:
c
      jnext = 0
      do 2000 jatm=1,natm
        jtyp = itypa(jatm)
        nshlj = numshl(jtyp)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        alaminj = alamin(jtyp)
        call CINIT( cj )
c
c       Atom j shell loop:
c
        j = jstart
        do 1800 jshl=1,nshlj
          nalj = nala(jshl,jtyp)
          lshlj = lshel(jshl,jtyp)
          norbshj = 2*lshlj + 1
          lj0 = lshlj*lshlj
c
          j0 = j
c
          alminj = ala(1,jshl,jtyp)
          almaxj = ala(nalj,jshl,jtyp)
          do  jal=1,nalj
            alj = ala(jal,jshl,jtyp)
            if( alj.lt.alminj ) alminj = alj
            if( alj.gt.almaxj ) almaxj = alj
          enddo
          alaminj = alminj
c
          emaxij = emaxf
          if( alminj.lt.alfast ) emaxij = emaxsl
c
c         Atom i loop:
c
          inext = jstart
          do 1000 iatm=jatm,natm
            ityp = itypa(iatm)
            nshli = numshl(ityp)
            norbati = norba(ityp)
            istart = inext
            inext = istart + norbati
c
c           Following helps ensure only i.ge.j done:
            ishl1 = 1
            if( iatm.eq.jatm )then
              ishl1 = jshl
              do  ishl=1,ishl1-1
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                istart = istart + norbshi
              enddo
            endif
c
            alamini = alamin(ityp)
            emax = emaxij
            rijmax = emax*(alamini+alaminj) / (alamini*alaminj)
c
c           Lattice vector loop for Atom i:
c
            do 900 ilat=1,nlat
c
              rijsq = zero
              do  ir=1,3
                rij(ir) =  ratm(ir,jatm) - ratm(ir,iatm) - rlat(ir,ilat)
                rijsq = rijsq + rij(ir)*rij(ir)
              enddo
              if( rijsq.gt.rijmax ) goto 900
c
              call CINIT( ci )
              call COFR( cj,rij )
c
c             Atom i shell loop:
c
              i = istart
              do 800 ishl=ishl1,nshli
                nali = nala(ishl,ityp)
                lshli = lshel(ishl,ityp)
                norbshi = 2*lshli + 1
                li0 = lshli*lshli
c
                i0 = i
c
                diagshl = .false.
                if( i0.eq.j0 ) diagshl = .true.
c
                almini = ala(1,ishl,ityp)
                almaxi = ala(nali,ishl,ityp)
                do  ial=1,nali
                  ali = ala(ial,ishl,ityp)
                  if( ali.lt.almini ) almini = ali
                  if( ali.gt.almaxi ) almaxi = ali
                enddo
c
                emax = emaxf
                if( almaxi.lt.alfast .and. almaxj.lt.alfast )
     $           emax = emaxsl
                rijmx = emax*(alaminj+almini) / (alaminj*almini)
                if( rijsq.gt.rijmx ) goto 799
c
c               Angular loops:
c
                mli1 = 1
                do 420 mlj=1,norbshj
c                 lj=1,....,9   is orbital symmetry index of orbital j
                  lj = lj0 + mlj
                  j = j0 + mlj
c
                  if( diagshl ) mli1 = mlj
                  do 410 mli=mli1,norbshi
c                   li=1,....,9   is orbital symmetry index of orbital i
                    li = li0 + mli
                    i = i0 + mli
c
c                   Alpha loops:
c
                    nx = 0
                    tsum = zero
c
                    do 320 jal=1,nalj
                      alj = ala(jal,jshl,jtyp)
c
                      do 310 ial=1,nali
                        ali = ala(ial,ishl,ityp)
c
                        rijmx = emax*(ali+alj) / (ali*alj)
                        if( rijsq.gt.rijmx ) goto 310
c
                        nx = nx + 1
                        alsum = ali + alj
                        do  ir=1,3
                          p(ir) = two*alj*rij(ir)
                        enddo
                        pmag = SQRT( p(1)*p(1)+p(2)*p(2)+p(3)*p(3) )
c
c                       Evaluate contribution to matrix element
                        call TINTSUM( telem, p,lj,li,cj(1,lj),ci(1,li),
     $                                alj,ali,alsum,pmag )
                        tsum = tsum + EXP( -ali*alj*rijsq/alsum )*
     $                   telem*cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
c
c                       Close alpha loops:
  310                 continue
  320               continue
                    tsum = fourpi*tsum / ( vnorm(li)*vnorm(lj) )
c
c                   Multiply by Bloch phase factors and load output array
c
                    do  k=1,nk
                      tmat(i,j,k) = tmat(i,j,k) + tsum*coskr(k,ilat)
                    enddo
                    if( ncplx.eq.2 .and. i.ne.j )then
                      do  k=1,nk
                        tmat(j,i,k) = tmat(j,i,k) + tsum*sinkr(k,ilat)
                      enddo
                    endif
c
                    if( ilat.gt.nlatmx ) nlatmx = ilat
c
c                   Close orbital loops:
  410             continue
  420           continue
c
  799           continue
c               Close Atom i shell loop:
                i = i0 + norbshi
  800         continue
c
c             Close Atom i lattice loop:
  900       continue
c
c           Close Atom i loop:
 1000     continue
c
c         Close Atom j shell loop:
          j = j0 + norbshj
 1800   continue
c
c       Close Atom j loop:
 2000 continue
c
c  Shrink nlat if list end not used (ie, unit cells not interact):
      nlat = nlatmx
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TINTSUM
c
c
      subroutine TINTSUM( telem, p,li,lj,ci,cj,ali,alj,alsum,pmag )
c---------------------------------------------------------------
c Purpose: compute quintuple sum of symmetry coefficients
c          times the radial integrals for the kinetic matrix
c
c Revision history:
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
      DIMENSION  p(3), ci(10),cj(10)
c local declarations:
      EQUIVALENCE  (nq(1),nq1),(nqmn(1),nqmn1),(psq(1),psq1)
      COMMON  /nqs/   nq1,nq2,nq3
      COMMON  /nqmns/ nqmn1,nqmn2,nqmn3
      COMMON  /psqs/  psq1,psq2,psq3
      DIMENSION  nq(3),nqmn(3),psq(3)
c
      LOGICAL    EVEN
      DIMENSION  trad(5,3),lang(10)
      DATA  lang / 0, 1,1,1, 2,2,2,2,2,2 /
c
      DIMENSION  ns(9),np(10,3),bpq(5,5),nqmin(5)
      DATA  ns / 1, 2,3,4, 5,6,7,9,10 /
      DATA  np / 0, 1,0,0, 1,0,1,2,0,0,
     $           0, 0,1,0, 1,1,0,0,2,0,
     $           0, 0,0,1, 0,1,1,0,0,2 /
      DATA  bpq / 1.d0, 0.d0, 0.d0, 0.d0, 0.d0,
     $            0.d0, 1.d0, 1.d0, 0.d0, 0.d0,
     $            0.d0, 0.d0, 1.d0, 3.d0, 3.d0,
     $            0.d0, 0.d0, 0.d0, 1.d0, 6.d0,
     $            0.d0, 0.d0, 0.d0, 0.d0, 1.d0 /
      DATA  nqmin / 1,2,2,3,3 /
c
      DATA  zero,one,two,three / 0.d0,1.d0,2.d0,3.d0 /
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      trc = two*rtpi*alj*alj/(alsum*SQRT(alsum))
      cl = (three*ali/alj + two - pmag*pmag/(two*alsum))/two
C      do  lp1=1,3
      do  lp1=1,lang(lj)+1
        cliq = cl
        fiq = trc
C        do  iqs=1,lang(li)+lang(lj)+1
        do  iqs=1,5
          fiq = fiq/(alsum+alsum)
          cliq = cliq - one
          trad(iqs,lp1) = fiq*cliq
        enddo
        cl = cl + alsum/alj
      enddo
      do  j=1,3
        psq(j) = p(j)*p(j)
      enddo
c
      nsimx = ns(li)
      nsjmx = ns(lj)
c
      telem = zero
      nsjmn = lj
      if( lj.eq.9 ) nsjmn = 8
c
      do 102 nsi=1,nsimx
        if( ci(nsi).eq.zero ) goto 102
c
        do 101 nsj=nsjmn,nsjmx
          if( cj(nsj).eq.zero ) goto 101
c
          pr1 = ci(nsi)*cj(nsj)
          lp1 = lang(nsj) + 1
          do 20 j=1,3
            nq(j) = np(nsi,j) + np(nsj,j) + 1
            nqmn(j) = nqmin(nq(j))
            if( EVEN(nq(j)) ) pr1 = pr1*p(j)
   20     continue
c     cdir$ novector
          do 50 iq1=nqmn1,nq1
            pr12 = pr1
            do 40 iq2=nqmn2,nq2
              pr123 = pr12
              do 30 iq3=nqmn3,nq3
                telem = telem + trad(iq1+iq2+iq3-2,lp1)*
     $           pr123*bpq(nq1,iq1)*bpq(nq2,iq2)*bpq(nq3,iq3)
                pr123 = pr123*psq3
   30         continue
              pr12 = pr12*psq2
   40       continue
            pr1 = pr1*psq1
   50     continue
c     cdir$ vector
  101   continue
  102 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> TREIGVEC
c
c
      subroutine TREIGVEC( norb,nstate, veceig,eigvec )
c---------------------------------------------------------------
c Purpose: transpose complex eigenvector array.
c
c Written: Peter A. Schultz, 23-July-2001, for v2.49 (spin)
c
c Revision history:
c  23Jul01-PAS/2.49: push down from rhoij
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input array:
      DIMENSION  veceig(2,norb,nstate)
c output arrays:
      DIMENSION  eigvec(2,nstate,norb)
c
c >>>> EXECUTABLE CODE:
c
      do  n=1,nstate
        do  i=1,norb
          eigvec(1,n,i) = veceig(1,i,n)
          eigvec(2,n,i) = veceig(2,i,n)
        enddo
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> UCATCHK
c
c
      subroutine UCATCHK( IWR, ndim,natm, dolvatm, itypa,znuc,
     $ rprim,orig,rscale,
     $ ratm0,ratm )
c---------------------------------------------------------------
c Purpose: project atom coordinates into the primary unit cell
c
c Written: Peter A. Schultz, 24-September-1997, v2.21
c
c Revision history:
c  29Oct09-PAS/2.62: enforce error when atoms too close; cosmetics
c  23Nov04-PAS/2.58a: fix proximity checks (thx Andy Pineda)
c  20Oct03-PAS?2.58: proximity checks for atoms
c  21Jun01-PAS/2.48: replace STOPs
c   7Jul00-PAS/2.45: unified scaling
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c  ratm0() = coordinates of atoms as input
c  ratm()  = coordinates of atoms inside primary unit cell
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero = 0.d0 )
c
c Input:
      LOGICAL    dolvatm
      DIMENSION  itypa(natm),znuc(*)
      DIMENSION  rprim(3,4),orig(3),rscale(3)
c Input (raw) atomic coordinates
      DIMENSION  ratm0(3,natm)
c Output atomic coordinates (projected into unit cell)
      DIMENSION  ratm(3,natm)
c
c Local declarations:
      DIMENSION  tr(3),ttr(3)
      LOGICAL  outuc,shift
c Set warning at 1/3 less than H-H molecule, kill at less than 1/2 H-H bond
      DATA     vclose, tooclose / 0.4999, 0.2999d0 /
      DATA     lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
      ioutuc = 0
      ijflag = 0
c
      do 100 iatm=1,natm
c       Project atoms into primary unit cell in periodic directions
        call PROJUC( outuc,shift, ndim, ratm0(1,iatm),tr, rprim )
c
        if( outuc )then
c         Atom is outside uc in non-periodic direction - fatal
          ioutuc = ioutuc + 1
c         Get coordinates in original input units/frame of reference
          call REXTRNL( ndim,  1 , dolvatm, rprim,orig,rscale,
     $     ttr, ratm0(1,iatm) )
          write(IWR,*) '***** ERROR: Atom outside unit cell:',iatm
          write(IWR,9010) ttr
 9010     format('>>>>> Coordinates:',3f12.8)
c
        elseif( shift )then
c         Atom is outside uc in periodic direction - safe to shift
          ratm(1,iatm) = tr(1)
          ratm(2,iatm) = tr(2)
          ratm(3,iatm) = tr(3)
c
c         Get coordinates in original input units/frame of reference
          call REXTRNL( ndim,  1 , dolvatm, rprim,orig,rscale,
     $     ttr,tr )
          call REXTRNL( ndim,  1 , dolvatm, rprim,orig,rscale,
     $     tr, ratm0(1,iatm) )
c
          if( lstout.gt.1 )then
            write(IWR,*) '***** NOTE: atom outside unit cell:',iatm
            write(IWR,9011)  tr,ttr
 9011       format(6x,'Old coords:',3f12.8/6x,'Shifted to:',3f12.8)
          endif
c
        else
c         Atom safely within primary unit cell to begin with, copy
          ratm(1,iatm) = ratm0(1,iatm)
          ratm(2,iatm) = ratm0(2,iatm)
          ratm(3,iatm) = ratm0(3,iatm)
        endif
c
c       Check for fatal overlap of atoms
c
  913   format(1x,a,' R(#',i4,'--#',i4,')=',f12.8)
        ityp = itypa(iatm)
        if( znuc(ityp) .ne. zero )then
c
          nda = 0
          ndb = 0
          ndc = 0
          if( ndim.gt.0 ) nda = 1
          if( ndim.gt.1 ) ndb = 1
          if( ndim.gt.2 ) ndc = 1
          do  jatm=1,iatm-1
            jtyp = itypa(jatm)
c
            if( znuc(jtyp) .ne. zero )then
              rijmin = 9999.
c
              do  idc=-ndc,ndc
                do  idb=-ndb,ndb
                  do  ida=-nda,nda
                    do  ir=1,3
                      tr(ir) = ratm(ir,iatm) - ratm(ir,jatm)
     $                      - DBLE(ida)*rprim(ir,1)
     $                      - DBLE(idb)*rprim(ir,2)
     $                      - DBLE(idc)*rprim(ir,3)
                    enddo
                    rij = SQRT( tr(1)**2 + tr(2)**2 + tr(3)**2 )
                    if( rij .lt. rijmin ) rijmin = rij
                  enddo
                enddo
              enddo
              if( rijmin .lt. vclose )then
                if( ijflag .eq. 0 )then
c                 First instance, give generic warning
                  write(IWR,*) '>>>>> WARNING: atoms very close'
                endif
c               Assess seriousness, give specific notice
                if( rijmin .lt. tooclose )then
                  ijflag = 2
                  write(IWR,913) '***** ERROR: ',iatm,jatm, rijmin
                else
                  ijflag = MAX( ijflag, 1 )
                  write(IWR,913) '>>>>> CAUTION: ',iatm,jatm, rijmin
                endif
              endif
c
            endif
c
          enddo
c
        endif
c
c       Close loop over atoms
  100 continue
c
      if( ijflag.gt.1 ) call STOPXERR( 'atoms on top of each other' )
      if( ioutuc.gt.0 ) call STOPXERR( 'uc-atom - atom outside cell' )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> V1CTRIJ
c
c
      subroutine V1CTRIJ( idmatfl,ilocfl, conv,
     $ norb,nk, natm,ntyp,nshld,nald, noad, nlat,
c output quantities
     $ v,  xp,   dmatrd,   dcountr,rh1coef,
     $ exc1c, cv,ce,
     $ itypa, numshl,lshel,nala,ala,cala, alamin, norba,ioffa, occij,
     $ lmx1ctr,almnv1c, nrad,nrd, radmsh,radwt,
     $ ratm,rlat, vk, coskr,sinkr,
     $ neq3d,ieqn,ieqi,ieqj,ipermut,
     $ vradsr,v1csum,velem, pradsr,p1csum,pelem,xradsr,x1csum,xelem,
     $ besstor,radfac,w1,w2,w3,w4,w5,w6,
     $ ves1c, pot1c,xen1c,
     $ nsyms,dsym,naofsym,
     $ alxcmin,nalfxc,nalfxcd,alfxc,alsq,ipvt, nrxcfit,vxcrad,excrad,
     $ nang, angylm,angpts,angwts, nfitd,nfityp,radwf,
     $ rholoc,vxcloc,excloc, vlm,elm,rfac, vg,eg,
     $ orb,grorb,grgrorb, wf1cwk1,wf1cwk2,wf1cwk3,wf1cwk4,wf1cwk5,
     $ orbj,grorbj,grgrorj, gofac,ggofac,
     $ eswork, dmatwk )
c---------------------------------------------------------------
c Purpose: compute matrix elements off of local 1-center pots.
c
c Written: Peter J. Feibelman
c
c Revision history:
c  14Jun05-PAS/2.59: File units
c   7Mar02-PAS/2.52: ang constants extracted
c  24Jul01-PAS/2.49: packed dmat
c   2Jul01-PAS/2.48: replace writes
c   1Mar00-PAS/2.43: bugfix for non-xcfit
c  21Dec99-PAS/2.42: cosmetic clean-up
c  15Feb99-PAS/2.31: routine to intercept perhaps too-big i/o
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  29Jun98-PAS/2.23: split basis
c  28Apr97-PAS/2.17: naming conventions
c  22Feb93-PAS
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
c      DATA ARRAYS:
c
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  occij(*), alamin(ntyp), norba(ntyp),ioffa(natm)
      DIMENSION  lmx1ctr(ntyp),almnv1c(ntyp)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp),radwt(nrd,ntyp)
      DIMENSION  ratm(3,natm),rlat(3,nlat)
c ... only used in blkvofn
      DIMENSION  vk(3,nk)
c ... only used in v1ctrij
      DIMENSION  coskr(nk,nlat),sinkr(nk,nlat)
c
c atom symmetry data
c ... only in v1ctrij:
      DIMENSION  ieqn(neq3d),ieqi(neq3d),ieqj(neq3d),ipermut(*)
c ... only in blkvofn:
      DIMENSION  dsym(5,5,3,*),naofsym(natm,*)
c
c ... used in blkvofn for xc-fit:
      DIMENSION  alxcmin(ntyp),nalfxc(ntyp),alfxc(nalfxcd,ntyp)
      DIMENSION  alsq(nalfxcd,nalfxcd,3,ntyp),ipvt(nalfxcd,3,ntyp)
      DIMENSION  nrxcfit(ntyp),vxcrad(nrd,ntyp),excrad(nrd,ntyp)
      DIMENSION  angylm(nang,9),angpts(3,nang),angwts(nang)
      DIMENSION  nfityp(ntyp),radwf(nang,nrd,noad,nfitd)
c ... from blkvofn into v1ctrij:
      DIMENSION  ves1c(nrd,10,natm)
c ... from blkvofn into v1ctrij, xc-fit:
      DIMENSION  pot1c(nrd,10,natm),xen1c(nrd,10,natm)
c
c---------------------------------------------------------------
c
c      OUTPUT ARRAYS:
c
c ... out of v1ctrij
      DIMENSION  v(norb,norb,nk),xp(norb,norb,nk)
      DIMENSION  dmatrd(2,norb,norb,nk)
complex dmatrd
c ... out of blkvofn
      DIMENSION  dcountr(10,natm),rh1coef(10,noad,natm)
c ... out of blkvofn, xc-fit
      DIMENSION  cv(10,nalfxcd,natm),ce(10,nalfxcd,natm)
c
c---------------------------------------------------------------
c
c      SCRATCH ARRAYS:
c
c ... only in v1ctrij
      DIMENSION  vradsr(7,10,neq3d),v1csum(neq3d,49),velem(neq3d)
      DIMENSION  besstor(nrd,7),radfac(nrd,7)
      DIMENSION  w1(nrd),w2(nrd),w3(nrd),w4(nrd),w5(nrd),w6(nrd)
c ... only in v1ctrij, for xc-fit:
      DIMENSION  pradsr(7,10,neq3d),p1csum(neq3d,49),pelem(neq3d)
      DIMENSION  xradsr(7,10,neq3d),x1csum(neq3d,49),xelem(neq3d)
c ... used only in blkvofn:
      DIMENSION  orb(nlat),grorb(3,nlat),grgrorb(3,3,nlat)
      DIMENSION  wf1cwk1(3,nlat),wf1cwk2(3,3,nlat),
     $           wf1cwk3(3,nlat),wf1cwk4(nlat),wf1cwk5(nlat)
      DIMENSION  eswork(nrd), dmatwk(noad,noad,nlat)
c ... only in blkvofn, for xc-fit:
      DIMENSION  rholoc(nrd,nang),vxcloc(nrd,nang),excloc(nrd,nang)
      DIMENSION  orbj(noad),grorbj(3,noad),grgrorj(3,3,noad)
      DIMENSION  gofac(nang),ggofac(nang)
      DIMENSION  vlm(nrd),elm(nrd),rfac(nrd,nalfxcd)
      DIMENSION  vg(nalfxcd,9),eg(nalfxcd,9)
c---------------------------------------------------------------
c
c      LOCAL DECLARATIONS:
c
      LOGICAL    pjfsrc
      DATA  pjfsrc / .true. /
      LOGICAL    ntest
      DIMENSION  rnuc(3),ri(3),rj(3)
      DIMENSION  p(3), ci(10,9),cj(10,9),cigrgr(10,3,3)
c
      DIMENSION  vnorm(9)
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
c---------------------------------------------------------------
c
c      this program calculates the matrix elements of 1-center
c      local potentials of the form v(r)* an angular factor
c      which may be 1, x, y, z, xy, yz, zx, x**2, y**2, z**2,
c      depending on the value of lnuc, which varies from 1 through 10.
c
c      these local potentials are evaluated, given the delta
c      density matrix "dmat" as input. in order to guarantee
c      convergence of the lattice sums, the local potentials are
c      constructed so as to have no long-ranged part.
c
c      the radial wave functions are assumed to have been
c      normalized (this is done in routine orbtl, where
c      the cala coefficients have been rescaled). the normali-
c      zation of the angular wave functions is done in the present
c      routine via the division by the quantities "vnorm"
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c >>>> EXECUTABLE CODE:
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c Get angular normalizations:
      call VNORMS9( vnorm )
      emax = - LOG( conv )
      argmx = half*cutexp
      fourpi = pi + pi + pi + pi
c
      call MKZERO( 10*noad*natm, rh1coef )
c
c    Read momentum space complex density matrix
c
      REWIND( unit=idmatfl )
cpas: temp work-around/expand new packed dmat into old local usage
      do  k=1,nk
        call READBIG( idmatfl, norb*norb, v )
        do  j=1,norb
          do  i=1,j-1
            dmatrd(1,i,j,k) = v(j,i,1)
            dmatrd(2,i,j,k) = v(i,j,1)
          enddo
            dmatrd(1,j,j,k) = v(j,j,1)
            dmatrd(2,j,j,k) = zero
          do  i=j+1,norb
            dmatrd(1,i,j,k) = v(i,j,1)
            dmatrd(2,i,j,k) = -v(j,i,1)
          enddo
        enddo
      enddo
      call MKZERO( norb*norb, v )
c
c     Check if have local density file
      if( ilocfl.ne.0 ) REWIND( unit=ilocfl )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c   Compute short-range local potentials:
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c    Nucleus loop:
c
      do 5 nuc=1,natm
        ktyp = itypa(nuc)
        if( lmx1ctr(ktyp).lt.0 ) goto 5
c
c      Construct 1-center potentials from nucleus "nuc"
c
        nrxc = nrxcfit(ktyp)
        nrho = nrxc
        if( ilocfl.gt.0 )then
          read(ilocfl)  nrho,mang
          if( nrho.lt.0 .or. nrho.gt.nrd .or. mang.ne.nang )then
c           We have a problem - kill this one.
            call FLGETIWR( IWR )
            write(IWR,*)'ilocfl problem, nuc=',nuc,nrho,mang,nrd,nang
            read(ilocfl) dum
            ilocfl = -ilocfl
            nrho = nrxc
          endif
        endif
c
c      update of 1/90:
c
c      BLKVOFN now also determines the density in the neighborhood
c      of atom nuc on a spherical mesh, in order to compute the
c      exchange-correlation potential and energy density on that mesh.
c      The l,m components of these functions of position are
c      then projected out, for l=0,1 and 2. Then, the radial
c      functions that result from the projection are fit to
c      linear combinations of Gaussians, and the fitted quantities
c      are used to account for rapid variation in x-c
c      quantities more accurately than previously.
c
        itypxc = nfityp(ktyp)
        ktypxc = MAX( 1, itypxc )
        call BLKVOFN( ilocfl, nuc,ktyp, lmx1ctr(ktyp),almnv1c,
     $   norb,nk, natm,ntyp,nshld,nald, noad, nlat,
     $   itypa, numshl,lshel,nala,ala,cala,  norba,ioffa, occij,
     $   nrad(ktyp),nrd,radmsh(1,ktyp),radwt(1,ktyp),
     $   ratm,rlat,vk, nsyms,dsym,naofsym,
     $   dmatrd,
     $   dcountr(1,nuc),rh1coef(1,1,nuc), cv(1,1,nuc),ce(1,1,nuc),
     $    ves1c(1,1,nuc), pot1c(1,1,nuc),xen1c(1,1,nuc),
     $   alxcmin(ktyp),nalfxc(ktyp),nalfxcd,alfxc(1,ktyp),
     $    alsq(1,1,1,ktyp),ipvt(1,1,ktyp),
     $   nrxc, vxcrad(1,ktyp),excrad(1,ktyp),
     $   itypxc, nang, angylm,angpts,angwts, radwf(1,1,1,ktypxc),
     $   nrho, rholoc,vxcloc,excloc, vlm,elm,rfac, vg,eg,
     $   orb,grorb,grgrorb, wf1cwk1,wf1cwk2,wf1cwk3,wf1cwk4,wf1cwk5,
     $   orbj,grorbj,grgrorj, gofac,ggofac,
     $   eswork, dmatwk, v )
c
        if( ilocfl.lt.0 ) ilocfl = -ilocfl
c
    5 continue
c
      call MKZERO( 2*nk , v )
c
cpas      call TIMER('After blkvofn    ')
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c   Compute matrix elements off of short-range local potentials
c   indexed by atom "nuc"
c       ves1c() - delta-electrostatic potential
c       pot1c() - fast delta xc-potential
c       xen1c() - fast delta xc energy density
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c    Nucleus loop:
c
      do 3000 nuc=1,natm
c
      ktyp = itypa(nuc)
      if( lmx1ctr(ktyp).lt.0 ) goto 3000
c
c    Evaluate the 1-center potentials from nucleus "nuc"
c    It is assumed that vofn is the same for all nuclei
c      equivalent to nuc within a lattice translation
c
      alaminn = almnv1c(ktyp)
c
c    Nuclear lattice loop:
c
      do 2900 klat=1,nlat
c
      do  ir=1,3
        rnuc(ir) = ratm(ir,nuc) + rlat(ir,klat)
      enddo
c
c    Atom i loop:
c
      inext = 0
      do 2000 iatm=1,natm
      ityp = itypa(iatm)
      nshli = numshl(ityp)
      istart = inext
      inext = istart + norba(ityp)
c
      do  ir=1,3
        ri(ir) = ratm(ir,iatm) - rnuc(ir)
      enddo
      risquar = ri(1)*ri(1) + ri(2)*ri(2) + ri(3)*ri(3)
      alamini = alamin(ityp)
      rinmax = emax*(alamini+alaminn) / (alamini*alaminn)
c
c    Test overlap of atom i and short-range pot due to "nuc"
c
      if( risquar.gt.rinmax ) goto 2000
c
      call CINIT( ci )
      call COFR( ci,ri )
      if( lmx1ctr(ityp).eq.2 ) call GRCOFR( cigrgr,ri )
c
      iorbat0 = 0
      do 1800 ishl=1,nshli
      nali = nala(ishl,ityp)
      lorbi = lshel(ishl,ityp)
      norbshi = 2*lorbi + 1
      li0 = lorbi*lorbi
      i0 = istart + iorbat0
c find min alpha for this radial function:
      almini = ala(1,ishl,ityp)
      do  ial=1,nali
        ali = ala(ial,ishl,ityp)
        if( ali.lt.almini ) almini = ali
      enddo
      rinmax = emax*(almini+alaminn) / (almini*alaminn)
      if( .not. pjfsrc )then
        alamini = almini
        if( risquar .gt.rinmax ) goto 1800
      endif
c
c    Atom j loop:
c
      jnext = 0
      do 1000 jatm=1,iatm
        jtyp = itypa(jatm)
        jstart = jnext
        jnext = jstart + norba(jtyp)
        nshlj = numshl(jtyp)
c following helps ensure only j.le.i done:
        if( jatm.eq.iatm ) nshlj = ishl
c
c  If any previous "equivalent" triplets, v1cij has already
c  been computed. accordingly, skip this triple of atoms
c
        call EQTRIP( ntest, iateq,jateq,iatm,jatm,nuc,
     $   natm, itypa,ratm )
        if( .not. ntest )then
c         See if jatm,iatm,nuc is equivalent to an earlier triple
c          - again iateq must be greater than or equal to jateq
          call EQTRIP( ntest, iateq,jateq,jatm,iatm,nuc,
     $     natm, itypa,ratm )
        endif
        if( ntest ) goto 1000
c
c    Compile list of equivalent atom triplets
c
        ipoint = 0
        if( nuc.lt.natm )then
          do 50 nuceq=nuc+1,natm
            call GTTRIP( ntest, iateq,jateq,nuceq,iatm,jatm,nuc,
     $       natm, itypa,ratm )
            if( ntest )then
              ipoint = ipoint + 1
              ipermut(ipoint) = 0
            else
            call GTTRIP( ntest, iateq,jateq,nuceq,jatm,iatm,nuc,
     $       natm, itypa,ratm )
              if( ntest )then
                ipoint = ipoint + 1
                ipermut(ipoint) = 1
              endif
            endif
            if( ntest )then
c   (iateq,jateq,nuceq) equivalent to (iatm,jatm,nuc)
              ieqi(ipoint) = iateq
              ieqj(ipoint) = jateq
              ieqn(ipoint) = nuceq
            endif
   50     continue
        endif
c
c  Criterion for including contribution of atom j:
        alaminj = alamin(jtyp)
        ex = risquar*alamini*alaminn / (alamini+alaminn)
        rijnmax = (emax-ex)*(alamini+alaminj+alaminn) /
     $                ((alamini+alaminn)*alaminj)
c
c    Lattice vector loop:
c
        do 900 jlat=1,nlat
c
          do  jr=1,3
            rj(jr) = ratm(jr,jatm) + rlat(jr,jlat) - rnuc(jr)
          enddo
          rjsquar = rj(1)*rj(1) + rj(2)*rj(2) + rj(3)*rj(3)
c
c    Test for significant overlap of this atom j with i and nuc
c
          f1 = alamini/(alaminn+alamini)
          rijn = zero
          do  jr=1,3
            rijn = rijn + (f1*ri(jr)-rj(jr))**2
          enddo
          if( rijn.gt.rijnmax ) goto 900
c
          call CINIT( cj )
          call COFR( cj,rj )
c
          jorbat0 = 0
          do 800 jshl=1,nshlj
            nalj = nala(jshl,jtyp)
            lorbj = lshel(jshl,jtyp)
            lj0 = lorbj*lorbj
            norbshj = 2*lorbj+1
            norbshj0 = norbshj
            joff = 0
            j0 = jstart + jorbat0
            if( j0.eq.i0 )then
              norbshj0 = 0
              joff = 1
            endif
c
            lmx = lorbi + lorbj + 1
c
            call MKZERO( neq3d*norbshi*norbshj, v1csum )
            call MKZERO( neq3d*norbshi*norbshj, p1csum )
            call MKZERO( neq3d*norbshi*norbshj, x1csum )
c
c    Alpha loops:
c
            do 320 ial=1,nali
              ali = ala(ial,ishl,ityp)
c      test whether this alpha contributes
              rinmx = emax*(ali+alaminn) / (ali*alaminn)
              if( risquar.gt.rinmx ) goto 320
c
              fi1 = ali/(ali+alaminn)
              rijn = zero
              do  jr=1,3
                rijn = rijn + (fi1*ri(jr)-rj(jr))**2
              enddo
c
              do 310 jal=1,nalj
                alj = ala(jal,jshl,jtyp)
c          test whether this alpha contributes
                ex = risquar*ali*alaminn / (ali+alaminn)
                rijnmx = (emax-ex)*(ali+alj+alaminn) /
     $                ((ali+alaminn)*alj)
                if( rijn.gt.rijnmx ) goto 310
c
                alsum = ali + alj
                exparg = ali*risquar + alj*rjsquar
                do  ir=1,3
                  p(ir) = two*(ali*ri(ir)+alj*rj(ir))
                enddo
                pmag = SQRT( p(1)*p(1)+p(2)*p(2)+p(3)*p(3) )
c
                call NRSCUT( nrmn,nrmx,nrad(ktyp),argmx,
     $                       exparg,pmag,alsum, radmsh(1,ktyp),w1 )
                if( nrmx.eq.0 ) goto 310
c
                nr0 = nrmn - 1
                nrlen = nrmx - nrmn + 1
c
c     Evaluate radial integrals
c
                call MKZERO( 70*neq3d, vradsr )
                call MKZERO( 70*neq3d, pradsr )
                call MKZERO( 70*neq3d, xradsr )
c
                call SRINT( vradsr,ves1c,pradsr,pot1c,xradsr,xen1c,
     $           alsum,pmag,exparg, lmx1ctr(ktyp),lmx,
     $           natm,nuc,ipoint,ieqn,
     $           nrlen,nr0,nrd, radmsh(nrmn,ktyp),radwt(nrmn,ktyp),
     $           besstor,radfac,w1,w2,w3,w4,w5,w6 )
c
c    Evaluate contribution to delta hamiltonian
c
                efac0 = fourpi*cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
                lij = 0
                norbshj = norbshj0
                do 420 li=li0+1,li0+norbshi
                  norbshj = norbshj + joff
                  do 410 lj=lj0+1,lj0+norbshj
                    lij = lij + 1
c
                    call ONECTR( velem,vradsr,pelem,pradsr,xelem,xradsr,
     $               ipoint,neq3d,lmx1ctr(ktyp),
     $               alsum,p,li,lj,ci(1,li),cj(1,lj) )
c
                    fac = efac0/(vnorm(li)*vnorm(lj))
                    do  ieq=1,ipoint+1
                      v1csum(ieq,lij) = v1csum(ieq,lij) + fac*velem(ieq)
                      p1csum(ieq,lij) = p1csum(ieq,lij) + fac*pelem(ieq)
                      x1csum(ieq,lij) = x1csum(ieq,lij) + fac*xelem(ieq)
                    enddo
c
  410             continue
  420           continue
c
  310         continue
  320       continue
c
c    Multiply v1csum by bloch phase factor and stuff hamiltonian
c
            norbshj = norbshj0
            i = i0
            lij = 0
            do 520 iorbat=iorbat0+1,iorbat0+norbshi
              i = i + 1
              norbshj = norbshj + joff
              j = j0
              do 510 jorbat=jorbat0+1,jorbat0+norbshj
                lij = lij + 1
                j = j + 1
c
                istuff = i
                jstuff = j
                sign = one
c
                do 500 ieq=1,ipoint+1
                  if( istuff.eq.jstuff )then
                    dmfac = one
                  else
                    dmfac = two
                  endif
                  do  k=1,nk
                    dmatr = dmfac*dmatrd(1,istuff,jstuff,k)
                    exc1c = exc1c + dmatr*x1csum(ieq,lij)*coskr(k,jlat)
                    xp(istuff,jstuff,k) = xp(istuff,jstuff,k) +
     $               p1csum(ieq,lij)*coskr(k,jlat)
                    v(istuff,jstuff,k) = v(istuff,jstuff,k) +
     $               v1csum(ieq,lij)*coskr(k,jlat)
                  enddo
                  if( i.ne.j )then
                    do  k=1,nk
                      dmfac = sign*two*dmatrd(2,jstuff,istuff,k)
                      exc1c = exc1c-dmfac*x1csum(ieq,lij)*sinkr(k,jlat)
                      xp(jstuff,istuff,k) = xp(jstuff,istuff,k) -
     $                 sign*p1csum(ieq,lij)*sinkr(k,jlat)
                      v(jstuff,istuff,k) = v(jstuff,istuff,k) -
     $                 sign*v1csum(ieq,lij)*sinkr(k,jlat)
                    enddo
                  endif
                  if( ieq.le.ipoint )then
                    if( ipermut(ieq).eq.0 )then
                      istuff = ioffa(ieqi(ieq)) + iorbat
                      jstuff = ioffa(ieqj(ieq)) + jorbat
                      sign = one
                    else
                      istuff = ioffa(ieqi(ieq)) + jorbat
                      jstuff = ioffa(ieqj(ieq)) + iorbat
                      sign = -one
                    endif
                  endif
  500           continue
c
  510         continue
  520       continue
c
  800     jorbat0 = jorbat0 + norbshj
c
c    Close center j lattice loop:
c
  900   continue
c
c    Close center j loop:
c
 1000 continue
c
c    Close shell, center i loops:
c
 1800 iorbat0 = iorbat0 + norbshi
 2000 continue
c
c    Close nucleus loops:
c
 2900 continue
 3000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VESSLO
c
c
      subroutine VESSLO( IWR, ndim, n1r,n2r,n3r,nptr, weight,
     $ ws1,ws2,ws3,ftarray,
     $ rhoslo, espot, gvecsq )
c---------------------------------------------------------------
c Purpose: compute real-space es potential from slow density
c
c Written: P.A. Schultz, based on PJF's old routines
c
c Revision history:
c  26Jan11-PAS/2.62: tweaks for output (for solvation coupling)
c  30Mar99-PAS/2.32: additional diagnostics, change b.c.
c   9Dec98-PAS/2.29: promote source to explicit double precision
c  22Oct98-PAS/2.27: boundary condition options
c  23Jun98-PAS/2.23: extend graded output controls
c---------------------------------------------------------------
c
cdev262: bulk es pot offset
c To-do: should offset bulk es potential rather than by zero,
c   as is currently being done for ibndopt = 1.
c   The fft library does this automatically, but best to make
c   this explicit here rather than count on outside function.
c
c Atomic units: distance in bohr, energy in Rydberg
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
c Input arrays: density(unchanged), G-vectors(destroyed)
      DIMENSION  rhoslo(nptr), gvecsq(nptr)
c Output arrays: electrostatic potential
      DIMENSION  espot(2,nptr)
c
c Scratch arrays:
      DIMENSION  ws1(*),ws2(*),ws3(*), ftarray(2,*)
c
c Local declarations:
      DIMENSION  ave(2)
c
c Set default for type of boundary condition
c  For ibndopt = 0, use fft potential unshifted
c              = 1, use z-edge potential as (non-bulk) vacuum zero
c              = 2, use average pot as zero
      DATA  ibndopt / 1 /
      DATA  zero, eight / 0.d0, 8.d0 /
      DATA  lstout / 0 /
      DATA  IWRT / 0 /
c
c >>>> EXECUTABLE CODE:
c
      eightpi = eight*pi
c
      if( lstout.gt.3 ) IWRT = IWR
      if( lstout.gt.3 )
     $ call GRIDAVE(IWR,n1r,n2r,n3r,1,rhoslo,ave,ftarray,'slow density')
c
c Load (real*8) density into (complex*16) workspace for fft
      call MKZERO( 2*nptr, espot )
      call DCOPY( nptr, rhoslo,1, espot,2 )
c
c  Fourier transform density:
c
      call CFFT3D( espot, n1r,n2r,n3r, ws1,ws2,ws3, ftarray )
c
c  Set rho(g=0), ie. net charge, to zero:
c
      indexg0 = (n1r+2)/2 + n1r*(n2r/2) + n1r*n2r*(n3r/2)
      defect = weight*DBLE(nptr)*espot(1,indexg0)
c
      if( lstout.gt.0 .and. IWR.ge.0 )then
        if( lstout.gt.2 )
     $  write(IWR,900) indexg0, espot(1,indexg0),espot(2,indexg0)
  900   format(/1x,'indexg0=',i12,'; rho(g=0)=',1p2d18.8)
c
        write(IWR,910) 'delta-charge defect (electrons)=',defect
      endif
  910 format(1x,a,1p2d18.8)
c
c  Compute Coulomb potential (screening eliminated)
c
      espot(1,indexg0) = zero
      espot(2,indexg0) = zero
      ave1 = zero
      ave2 = zero
c Set G=0 to small number to prevent divide-by-zero error in loop
      gvecsq(indexg0) = 1.d-15
      do  ng=1,nptr
        espot(1,ng) = eightpi*espot(1,ng) / gvecsq(ng)
        espot(2,ng) = eightpi*espot(2,ng) / gvecsq(ng)
      enddo
c
c  Fourier transform es potential back to coordinate space
c
      call CFFT3DB( espot, n1r,n2r,n3r, ws1,ws2,ws3, ftarray )
c
      call GRIDAVE( IWRT, n1r,n2r,n3r,2,espot,ave,ftarray, 'slow Ves' )
c
      if( lstout.ge.1 .and. IWR.ge.0 )then
c       Print out boundary values:
        write(IWR,910) 'global average fft es-potential(Ry)=', ave(1)
        if( ndim .lt. 3)
     $  write(IWR,910) 'z-edge average fft es-potential(Ry)=',
     $                  ftarray(1,1)
      endif
c
c  Shift electrostatic potential (e.g. to rescale vacuum to zero)
c
      if( ibndopt.gt.0 )then
c
        if( ibndopt.eq.1 )then
          if( ndim.lt.3 )then
c           Use z=zmax planar edge average as vacuum zero
            n3vac = 1
C            n3vac = n3r
C            if( (n3r/2).eq.((n3r+1)/2) ) n3vac = 1
            ave1 = ftarray(1,n3vac)
            ave2 = ftarray(2,n3vac)
          else
cpas        Bulk 3D, no boundary, use raw electrostatic potential
cpas         (dev262 - should be altered to global-average-offset)
            ave1 = zero
            ave2 = zero
          endif
        else
c         Offset potential by global average, new global average is zero
          ave1 = ave(1)
          ave2 = ave(2)
        endif
c
        do  nr=1,nptr
          espot(1,nr) = espot(1,nr) - ave1
          espot(2,nr) = espot(2,nr) - ave2
        enddo
c
c       Leave record of vacuum shift, will be very important for tracking b.c.
        if( lstout.ge.1 .and. IWR.ge.0 )then
          write(IWR,*)
          write(IWR,910) 'Vacuum shift for fft es-potential(Ry)=', ave1
        endif
c
      endif
c
c  Compact the es pot array to keep only the real part
C      iq = 2
C      id = -1
C      ir = 0
C      do  nr=1,nptr
C        ir = ir + iq - 1
C        iq = iq + id
C        id = -id
C        espot(iq,ir) = espot(1,nr)
C      enddo
      call DCOPY( nptr, espot,2, gvecsq,1 )
      call DCOPY( nptr, gvecsq,1, espot,1 )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLANG
c
c
      subroutine VLANG( vij1,vint1,vij2,vint2,vij3,vint3,vij4,vint4,
     $ p,li,lj,ci,cj )
c---------------------------------------------------------------
c Purpose: compute quintuple sum of symmetry coefficients times
c          the radial integrals in "venint"
c
c Revision history:
c   6Mar00-PAS/2.43: rename "engaus" to "vlang"
c  18Nov99-PAS/2.42: cosmetic cleanup
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  21Jun89-PAS: (1) EVEN fcn (2) fold over nsi,nsj sums
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  vint1(*),vint2(*),vint3(*),vint4(*)
      DIMENSION  p(3),ci(10),cj(10)
c local declarations:
      EQUIVALENCE  (nq(1),nq1),(nqmn(1),nqmn1),(psq(1),psq1)
      COMMON  /nqs/   nq1,nq2,nq3
      COMMON  /nqmns/ nqmn1,nqmn2,nqmn3
      COMMON  /psqs/  psq1,psq2,psq3
      DIMENSION  nq(3),nqmn(3),psq(3)
      DIMENSION  nsx(2)
      EQUIVALENCE  (nsx(1),nsi), (nsx(2),nsj)
      LOGICAL    EVEN
c
      DIMENSION  t(5)
      DIMENSION  ns(9),np(10,3),bpq(5,5),nqmin(5)
      DATA  ns / 1, 2,3,4, 5,6,7,9,10 /
      DATA  np / 0, 1,0,0, 1,0,1,2,0,0,
     $           0, 0,1,0, 1,1,0,0,2,0,
     $           0, 0,0,1, 0,1,1,0,0,2 /
      DATA  bpq / 1.d0, 0.d0, 0.d0, 0.d0, 0.d0,
     $            0.d0, 1.d0, 1.d0, 0.d0, 0.d0,
     $            0.d0, 0.d0, 1.d0, 3.d0, 3.d0,
     $            0.d0, 0.d0, 0.d0, 1.d0, 6.d0,
     $            0.d0, 0.d0, 0.d0, 0.d0, 1.d0 /
      DATA  nqmin / 1,2,2,3,3 /
c
      DATA  zero / 0.d0 /
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      nsimx = ns(li)
      nsjmx = ns(lj)
      if( nsimx.le.nsjmx )then
        ki = 1
        kj = 2
      else
        ki = 2
        kj = 1
        itmp = nsimx
        nsimx = nsjmx
        nsjmx = itmp
      endif
c
      do  j=1,3
        psq(j) = p(j)*p(j)
      enddo
c
      do  i=1,5
        t(i) = zero
      enddo
c
      vij1 = zero
      vij2 = zero
      vij3 = zero
      vij4 = zero
      do 102 nsi=1,nsimx
        do 101 nsj=nsi,nsjmx
c
          if( nsj.ne.nsi .and. nsj.le.nsimx )then
            pr1 = ci(nsi)*cj(nsj) + ci(nsj)*cj(nsi)
          else
            pr1 = ci(nsx(ki))*cj(nsx(kj))
          endif
          if( pr1.eq.zero ) goto 101
c
          do  j=1,3
            nq(j) = np(nsi,j) + np(nsj,j) + 1
            nqmn(j) = nqmin(nq(j))
            if( EVEN(nq(j)) ) pr1 = pr1*p(j)
          enddo
c
c     cdir$ novector
          do 50 iq1=nqmn1,nq1
            pr12 = pr1*bpq(nq1,iq1)
            do 40 iq2=nqmn2,nq2
              pr123 = pr12*bpq(nq2,iq2)
              do 30 iq3=nqmn3,nq3
                t(iq1+iq2+iq3-2) = t(iq1+iq2+iq3-2) + pr123*bpq(nq3,iq3)
                pr123 = pr123*psq3
   30         continue
              pr12 = pr12*psq2
   40       continue
            pr1 = pr1*psq1
   50     continue
c     cdir$ vector
c
  101   continue
  102 continue
c
      do  i=1,5
        vij1 = vij1 + t(i)*vint1(i)
        vij2 = vij2 + t(i)*vint2(i)
        vij3 = vij3 + t(i)*vint3(i)
        vij4 = vij4 + t(i)*vint4(i)
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLJISRT
c
c
      subroutine VLJISRT( norb,nk, vto, vfrom )
c---------------------------------------------------------------
c Purpose: copy matrices from k-first to k-last form
c          Not very efficient, but I do not care.
c
c Written: Peter A. Schultz, 15-September-1999, for v2.39
c
c Revision History:
c  27Mar00-PAS/2.43: rename "enjisrt" to "vljisrt"
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output array:
      DIMENSION  vto(norb,norb,nk)
c input array:
      DIMENSION  vfrom(nk,norb,norb)
c
c >>>> EXECUTABLE CODE:
c
      do  k=1,nk
        do  j=1,norb
          do  i=1,norb
            vto(i,j,k) = vfrom(k,j,i)
          enddo
        enddo
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLOCF0
c
c
      subroutine VLOCF0( fxez,fyez,fzez,
     $ li,lj, ci,cj, gradci,gradcj,
     $ nx, vlocez, twoals, p,
     $ pr0, dpr0,pr0dp,
     $ psq1,psq2,psq3, b1,b12,b123,bfac )
c---------------------------------------------------------------
c Purpose: compute quintuple sum of symmetry coefficients times
c          the radial integrals "vlocez" to get es force integrals
c          for reference atom occupations
c
c Written: Peter A. Schultz, 30-September-1998 (for v2.27)
c          based on PJF's original "engausf" routine
c
c Revision history:
c   9Nov99-PAS/2.42: bugfix/cleanup
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input arrays:
      DIMENSION  ci(10),cj(10), gradci(3,10),gradcj(3,10)
c
      DIMENSION  vlocez(6,nx)
      DIMENSION  twoals(nx), p(3,nx)
c scratch arrays:
      DIMENSION  pr0(nx),dpr0(3,nx),pr0dp(3,nx)
      DIMENSION  psq1(nx),psq2(nx),psq3(nx)
      DIMENSION  b1(49),b12(49),b123(49), bfac(49)
c local declarations:
      EQUIVALENCE  (nq(1),nq1),(nqmn(1),nqmn1)
      COMMON  /nqs/   nq1,nq2,nq3
      COMMON  /nqmns/ nqmn1,nqmn2,nqmn3
      DIMENSION  nq(3),nqmn(3)
      LOGICAL    EVEN
c
      DIMENSION  pow(3),powzer(3)
      DIMENSION  ns(9),np(10,3),bpq(5,5),nqmin(5)
      DATA  ns / 1, 2,3,4, 5,6,7,9,10 /
      DATA  np / 0, 1,0,0, 1,0,1,2,0,0,
     $           0, 0,1,0, 1,1,0,0,2,0,
     $           0, 0,0,1, 0,1,1,0,0,2 /
      DATA  bpq / 1.d0, 0.d0, 0.d0, 0.d0, 0.d0,
     $            0.d0, 1.d0, 1.d0, 0.d0, 0.d0,
     $            0.d0, 0.d0, 1.d0, 3.d0, 3.d0,
     $            0.d0, 0.d0, 0.d0, 1.d0, 6.d0,
     $            0.d0, 0.d0, 0.d0, 0.d0, 1.d0 /
      DATA  nqmin / 1,2,2,3,3 /
c
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      nsimx = ns(li)
      nsjmx = ns(lj)
c
      fxez = zero
      fyez = zero
      fzez = zero
      do  ix=1,nx
        psq1(ix) = p(1,ix)**2
        psq2(ix) = p(2,ix)**2
        psq3(ix) = p(3,ix)**2
      enddo
c
      do 102 nsi=1,nsimx
       do 101 nsj=1,nsjmx
c
        cicj = ci(nsi)*cj(nsj)
        do  ix=1,nx
          pr0(ix) = cicj
          pr0dp(1,ix) = -twoals(ix)*pr0(ix)
          pr0dp(2,ix) = -twoals(ix)*pr0(ix)
          pr0dp(3,ix) = -twoals(ix)*pr0(ix)
          dpr0(1,ix) = pr0(ix)*p(1,ix)
     $     - gradci(1,nsi)*cj(nsj) - ci(nsi)*gradcj(1,nsj)
          dpr0(2,ix) = pr0(ix)*p(2,ix)
     $     - gradci(2,nsi)*cj(nsj) - ci(nsi)*gradcj(2,nsj)
          dpr0(3,ix) = pr0(ix)*p(3,ix)
     $     - gradci(3,nsi)*cj(nsj) - ci(nsi)*gradcj(3,nsj)
        enddo
c
c  "pr0dp" is used for the case that pow(n)=1. and p(n)=0.  In this
c  case we have to be careful in taking derivative wrt p(n), since
c  have function equal zero whose derivative isn't.  In original code,
c  the zero/zero that arises in this case was evaluated incorrectly.
c
        do 20 n=1,3
          powzer(n) = zero
          nq(n) = np(nsi,n) + np(nsj,n) + 1
          nqmn(n) = nqmin(nq(n))
          if( EVEN(nq(n)) )then
            do  ix=1,nx
              pr0(ix) = pr0(ix)*p(n,ix)
            enddo
            do 18 nn=1,3
              do  ix=1,nx
                dpr0(nn,ix) = dpr0(nn,ix)*p(n,ix)
              enddo
              if( nn.ne.n )then
                do  ix=1,nx
                  pr0dp(nn,ix) = pr0dp(nn,ix)*p(n,ix)
                enddo
              endif
   18       continue
            powzer(n) = powzer(n) + one
          endif
   20   continue
c
        pow(1) = powzer(1)
        pow(2) = powzer(2)
        pow(3) = powzer(3)
c
        do  ix=1,nx
          b1(ix) = one
        enddo
c
        do 50 iq1=nqmn1,nq1
          do  ix=1,nx
            b12(ix) = b1(ix)*bpq(nq1,iq1)
          enddo
c
          do 40 iq2=nqmn2,nq2
            do  ix=1,nx
              b123(ix) = b12(ix)*bpq(nq2,iq2)
            enddo
c
            do 30 iq3=nqmn3,nq3
              iqsum = iq1 + iq2 + iq3 - 2
              do  ix=1,nx
                bfac(ix) = b123(ix)*bpq(nq3,iq3)
              enddo
c
              do  ix=1,nx
                vezfac = bfac(ix)*vlocez(iqsum,ix)
                tfac = bfac(ix)*twoals(ix)*pr0(ix)
                dvezfac = vlocez(iqsum+1,ix)*tfac
                fxez = fxez + vezfac*dpr0(1,ix) - dvezfac*p(1,ix)
                fyez = fyez + vezfac*dpr0(2,ix) - dvezfac*p(2,ix)
                fzez = fzez + vezfac*dpr0(3,ix) - dvezfac*p(3,ix)
              enddo
              do  ix=1,nx
                vezfac = bfac(ix)*vlocez(iqsum,ix)
                if( pow(1).eq.one .and. p(1,ix).eq.zero )
     $            fxez = fxez + vezfac*pr0dp(1,ix)
                if( pow(2).eq.one .and. p(2,ix).eq.zero )
     $            fyez = fyez + vezfac*pr0dp(2,ix)
                if( pow(3).eq.one .and. p(3,ix).eq.zero )
     $            fzez = fzez + vezfac*pr0dp(3,ix)
                if( pr0(ix).ne.zero )then
                  vezfac = vezfac*twoals(ix)*pr0(ix)
                  if( p(1,ix).ne.zero .and. pow(1).ne.zero )
     $              fxez = fxez - vezfac*pow(1)/p(1,ix)
                  if( p(2,ix).ne.zero .and. pow(2).ne.zero )
     $              fyez = fyez - vezfac*pow(2)/p(2,ix)
                  if( p(3,ix).ne.zero .and. pow(3).ne.zero )
     $              fzez = fzez - vezfac*pow(3)/p(3,ix)
                endif
              enddo
c
              pow(3) = pow(3) + two
              do  ix=1,nx
                b123(ix) = b123(ix)*psq3(ix)
              enddo
   30       continue
c
            pow(3) = powzer(3)
            pow(2) = pow(2) + two
            do  ix=1,nx
              b12(ix) = b12(ix)*psq2(ix)
            enddo
   40     continue
c
          pow(2) = powzer(2)
          pow(1) = pow(1) + two
          do  ix=1,nx
            b1(ix) = b1(ix)*psq1(ix)
          enddo
   50   continue
c
  101  continue
  102 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLOCF1
c
c
      subroutine VLOCF1(
     $ fesi0,fesi, fesj0,fesj,
     $ li,lj, ci,cj, gradci,gradcj,
     $ nx, vloces, twoali,twoalj, p,
     $ tves,dpr,   xx1,xx2,   tdves,pridp,prjdp,
     $ psq1,psq2,psq3,  b1,b12,b123,bfac )
c---------------------------------------------------------------
c Purpose: compute quintuple sum of symmetry coefficients times
c          the radial integrals "vloces" to
c          computed derivatives at the orbital sites.
c
c Written: Peter A. Schultz, 30-September-1998 (for v2.27)
c          based on PJF's original "engausb" routine
c
c Revision history:
c  11Feb00-PAS/2.43: some simple optimizations
c   9Nov99-PAS/2.42: bugfix/cleanup
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c Notes:
c  This routine is just the vlocf2 routine with the xc stuff
c  ripped out of it.  Fully identical otherwise.
c  NB: vlocf1 tuned for performance, but same tuning NOT carried
c  over to vlocf0 and vlocf2. PAS/14Feb00
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output arrays:
      DIMENSION  fesi(3),fesj(3)
c input arrays:
      DIMENSION  ci(10),cj(10), gradci(3,10),gradcj(3,10)
c
      DIMENSION  vloces(6,nx)
      DIMENSION  twoali(nx),twoalj(nx), p(3,nx)
c scratch arrays:
      DIMENSION  tves(nx), dpr(nx)
      DIMENSION  xx1(3,nx),xx2(3,nx)
      DIMENSION  tdves(nx), pridp(3,nx),prjdp(3,nx)
      DIMENSION  psq1(nx),psq2(nx),psq3(nx)
      DIMENSION  b1(nx),b12(nx),b123(nx),bfac(nx)
c local declarations:
      EQUIVALENCE  (nq(1),nq1),(nqmn(1),nqmn1)
      COMMON  /nqs/   nq1,nq2,nq3
      COMMON  /nqmns/ nqmn1,nqmn2,nqmn3
      DIMENSION  nq(3),nqmn(3)
      LOGICAL    ci_eq_0
      LOGICAL    EVEN
c
      DIMENSION  pow(3),powzer(3)
      DIMENSION  ns(9),np(10,3),bpq(5,5),nqmin(5)
      DATA  ns / 1, 2,3,4, 5,6,7,9,10 /
      DATA  np / 0, 1,0,0, 1,0,1,2,0,0,
     $           0, 0,1,0, 1,1,0,0,2,0,
     $           0, 0,0,1, 0,1,1,0,0,2 /
      DATA  bpq / 1.d0, 0.d0, 0.d0, 0.d0, 0.d0,
     $            0.d0, 1.d0, 1.d0, 0.d0, 0.d0,
     $            0.d0, 0.d0, 1.d0, 3.d0, 3.d0,
     $            0.d0, 0.d0, 0.d0, 1.d0, 6.d0,
     $            0.d0, 0.d0, 0.d0, 0.d0, 1.d0 /
      DATA  nqmin / 1,2,2,3,3 /
c
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      nsimx = ns(li)
      nsjmx = ns(lj)
c
      do  ix=1,nx
        psq1(ix) = p(1,ix)**2
        psq2(ix) = p(2,ix)**2
        psq3(ix) = p(3,ix)**2
      enddo
c
      do 102 nsi=1,nsimx
       cii = ci(nsi)
       ci_eq_0 = .false.
       if( cii.eq.zero ) ci_eq_0 = .true.
c
       do 101 nsj=1,nsjmx
        cjj = cj(nsj)
        if( ci_eq_0 .and. cjj.eq.zero ) goto 101
c
        cicj = cii*cjj
        dci1cj = gradci(1,nsi)*cjj
        dci2cj = gradci(2,nsi)*cjj
        dci3cj = gradci(3,nsi)*cjj
        cidcj1 = cii*gradcj(1,nsj)
        cidcj2 = cii*gradcj(2,nsj)
        cidcj3 = cii*gradcj(3,nsj)
c
        if( cicj.eq.zero )then
c
          do  ix=1,nx
            dpr(ix) = one
          enddo
c
          do 20 n=1,3
            nq(n) = np(nsi,n) + np(nsj,n) + 1
            nqmn(n) = nqmin(nq(n))
            if( EVEN( nq(n) ) )then
              do  ix=1,nx
                dpr(ix) = dpr(ix)*p(n,ix)
              enddo
            endif
   20     continue
c
          do  ix=1,nx
            b1(ix) = dpr(ix)
            tves(ix) = zero
          enddo
c
          do 80 iq1=nqmn1,nq1
            do  ix=1,nx
              b12(ix) = b1(ix)*bpq(nq1,iq1)
            enddo
c
            do 60 iq2=nqmn2,nq2
              do  ix=1,nx
                b123(ix) = b12(ix)*bpq(nq2,iq2)
              enddo
c
              do 40 iq3=nqmn3,nq3
                cb = bpq(nq3,iq3)
                iqsum = iq1 + iq2 + iq3 - 2
c
                do  ix=1,nx
                  tves(ix) = tves(ix) + cb*b123(ix)*vloces(iqsum,ix)
                enddo
c
                do  ix=1,nx
                  b123(ix) = b123(ix)*psq3(ix)
                enddo
   40         continue
c
              do  ix=1,nx
                b12(ix) = b12(ix)*psq2(ix)
              enddo
   60       continue
c
            do  ix=1,nx
              b1(ix) = b1(ix)*psq1(ix)
            enddo
   80     continue
c
          fint = zero
          do  ix=1,nx
            fint = fint + tves(ix)
          enddo
          fesi(1) = fesi(1) - fint*dci1cj
          fesi(2) = fesi(2) - fint*dci2cj
          fesi(3) = fesi(3) - fint*dci3cj
          fesj(1) = fesj(1) - fint*cidcj1
          fesj(2) = fesj(2) - fint*cidcj2
          fesj(3) = fesj(3) - fint*cidcj3
c
        else
c
          do  ix=1,nx
            dpr(ix) = one
            pridp(1,ix) = -twoali(ix)*cicj
            pridp(2,ix) = -twoali(ix)*cicj
            pridp(3,ix) = -twoali(ix)*cicj
            prjdp(1,ix) = -twoalj(ix)*cicj
            prjdp(2,ix) = -twoalj(ix)*cicj
            prjdp(3,ix) = -twoalj(ix)*cicj
          enddo
c
c  "pridp" is used for the case that pow(n)=1. and p(n)=0.  In this
c  case we have to be careful in taking derivative wrt p(n), since
c  have function equal zero whose derivative isn't.  In original code,
c  the zero/zero that arises in this case was evaluated incorrectly.
c
          do 120 n=1,3
            powzer(n) = zero
            nq(n) = np(nsi,n) + np(nsj,n) + 1
            nqmn(n) = nqmin(nq(n))
            if( EVEN( nq(n) ) )then
              do  ix=1,nx
                dpr(ix) = dpr(ix)*p(n,ix)
              enddo
              do 118 nn=1,3
                if( nn.ne.n )then
                  do  ix=1,nx
                    pridp(nn,ix) = pridp(nn,ix)*p(n,ix)
                    prjdp(nn,ix) = prjdp(nn,ix)*p(n,ix)
                  enddo
                endif
  118         continue
              powzer(n) = powzer(n) + one
            else
              if( nq(n).gt.2 )then
                do  ix=1,nx
                  if( p(n,ix).ne.zero )then
                    pridp(n,ix) = pridp(n,ix)/p(n,ix)
                    prjdp(n,ix) = prjdp(n,ix)/p(n,ix)
                  endif
                enddo
              endif
            endif
  120     continue
c
          pow(1) = powzer(1)
          pow(2) = powzer(2)
          pow(3) = powzer(3)
c
          do  ix=1,nx
            b1(ix) = one
            tves(ix) = zero
            tdves(ix) = zero
          enddo
c
          do 180 iq1=nqmn1,nq1
            do  ix=1,nx
              b12(ix) = b1(ix)*bpq(nq1,iq1)
            enddo
c
            do 160 iq2=nqmn2,nq2
              do  ix=1,nx
                b123(ix) = b12(ix)*bpq(nq2,iq2)
              enddo
c
              do 140 iq3=nqmn3,nq3
                iqsum = iq1 + iq2 + iq3 - 2
c
                cb = bpq(nq3,iq3)
                do  ix=1,nx
                  bfac(ix) = b123(ix)*cb
                enddo
c
                do  ix=1,nx
                  tves(ix) = tves(ix) + bfac(ix)*vloces(iqsum,ix)
                  tdves(ix) = tdves(ix) + bfac(ix)*vloces(iqsum+1,ix)
                enddo
c
                do  ix=1,nx
                  ves = bfac(ix)*vloces(iqsum,ix)
                  fesi(1) = fesi(1) + ves*pow(1)*pridp(1,ix)
                  fesi(2) = fesi(2) + ves*pow(2)*pridp(2,ix)
                  fesi(3) = fesi(3) + ves*pow(3)*pridp(3,ix)
                  fesj(1) = fesj(1) + ves*pow(1)*prjdp(1,ix)
                  fesj(2) = fesj(2) + ves*pow(2)*prjdp(2,ix)
                  fesj(3) = fesj(3) + ves*pow(3)*prjdp(3,ix)
                enddo
c
                pow(3) = pow(3) + two
                do  ix=1,nx
                  b123(ix) = b123(ix)*psq3(ix)
                enddo
  140         continue
c
              pow(3) = powzer(3)
              pow(2) = pow(2) + two
              do  ix=1,nx
                b12(ix) = b12(ix)*psq2(ix)
              enddo
  160       continue
c
            pow(2) = powzer(2)
            pow(1) = pow(1) + two
            do  ix=1,nx
              b1(ix) = b1(ix)*psq1(ix)
            enddo
  180     continue
c
          do  ix=1,nx
            tves(ix) = tves(ix)*dpr(ix)
            tdves(ix) = tdves(ix)*dpr(ix)
          enddo
          fint   = zero
          finti0 = zero
          fintj0 = zero
          finti1 = zero
          finti2 = zero
          finti3 = zero
          fintj1 = zero
          fintj2 = zero
          fintj3 = zero
          do  ix=1,nx
            fint   = fint   - tves(ix)
            finti0 = finti0 + tves(ix)*twoali(ix)
            fintj0 = fintj0 + tves(ix)*twoalj(ix)
            finti1 = finti1 - tdves(ix)*twoali(ix)*p(1,ix)
            finti2 = finti2 - tdves(ix)*twoali(ix)*p(2,ix)
            finti3 = finti3 - tdves(ix)*twoali(ix)*p(3,ix)
            fintj1 = fintj1 - tdves(ix)*twoalj(ix)*p(1,ix)
            fintj2 = fintj2 - tdves(ix)*twoalj(ix)*p(2,ix)
            fintj3 = fintj3 - tdves(ix)*twoalj(ix)*p(3,ix)
          enddo
          fesi(1) = fesi(1) + fint*dci1cj + finti1*cicj
          fesi(2) = fesi(2) + fint*dci2cj + finti2*cicj
          fesi(3) = fesi(3) + fint*dci3cj + finti3*cicj
          fesj(1) = fesj(1) + fint*cidcj1 + fintj1*cicj
          fesj(2) = fesj(2) + fint*cidcj2 + fintj2*cicj
          fesj(3) = fesj(3) + fint*cidcj3 + fintj3*cicj
          fesi0   = fesi0   + finti0*cicj
          fesj0   = fesj0   + fintj0*cicj
c
        endif
c
  101  continue
  102 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLOCF2
c
c
      subroutine VLOCF2(
     $ fesi0,fesi, fesj0,fesj, fxci0,fxci, fxcj0,fxcj,
     $ li,lj, ci,cj, gradci,gradcj,
     $ nx, vloces,vlocxc, twoali,twoalj, p,
     $ pr0, dpri0,dpri,pridp, dprj0,dprj,prjdp,
     $ psq1,psq2,psq3,  b1,b12,b123,bfac )
c---------------------------------------------------------------
c Purpose: compute quintuple sum of symmetry coefficients times
c          the radial integrals "vloces" and "vlocxc" to
c          computed derivatives at the orbital sites.
c
c Written: Peter A. Schultz, 30-September-1998 (for v2.27)
c          based on PJF's original "engausb" routine
c
c Revision history:
c   9Nov99-PAS/2.42: bugfix/cleanup
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c Notes:
c  This routine (along with its xc-less little sister vlocf1)
c  is the most expensive part of the local three-center force
c  calculation. In a couple of tests, it amounts to up to 2/3
c  of the cost of the local force integrals. Small changes in
c  this routine can have big consequences in efficiency.  The
c  trick is that a lot of loops are *very* short, and figuring
c  out how to shift work around to reduce op count and branching
c  is tricky.  I'm going to settle for what I've already done,
c  but extra work tuning the vlocfX routines would be worthwhile.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output arrays:
      DIMENSION  fesi(3),fesj(3), fxci(3),fxcj(3)
c input arrays:
      DIMENSION  ci(10),cj(10), gradci(3,10),gradcj(3,10)
c
      DIMENSION  vloces(6,nx),vlocxc(6,nx)
      DIMENSION  twoali(nx),twoalj(nx), p(3,nx)
c scratch arrays:
      DIMENSION  pr0(nx), dpri0(nx),dpri(3,nx),pridp(3,nx)
      DIMENSION           dprj0(nx),dprj(3,nx),prjdp(3,nx)
      DIMENSION  psq1(nx),psq2(nx),psq3(nx)
      DIMENSION  b1(nx),b12(nx),b123(nx),bfac(nx)
c local declarations:
      EQUIVALENCE  (nq(1),nq1),(nqmn(1),nqmn1)
      COMMON  /nqs/   nq1,nq2,nq3
      COMMON  /nqmns/ nqmn1,nqmn2,nqmn3
      DIMENSION  nq(3),nqmn(3)
      LOGICAL    EVEN
c
      DIMENSION  pow(3),powzer(3)
      DIMENSION  ns(9),np(10,3),bpq(5,5),nqmin(5)
      DATA  ns / 1, 2,3,4, 5,6,7,9,10 /
      DATA  np / 0, 1,0,0, 1,0,1,2,0,0,
     $           0, 0,1,0, 1,1,0,0,2,0,
     $           0, 0,0,1, 0,1,1,0,0,2 /
      DATA  bpq / 1.d0, 0.d0, 0.d0, 0.d0, 0.d0,
     $            0.d0, 1.d0, 1.d0, 0.d0, 0.d0,
     $            0.d0, 0.d0, 1.d0, 3.d0, 3.d0,
     $            0.d0, 0.d0, 0.d0, 1.d0, 6.d0,
     $            0.d0, 0.d0, 0.d0, 0.d0, 1.d0 /
      DATA  nqmin / 1,2,2,3,3 /
c
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      nsimx = ns(li)
      nsjmx = ns(lj)
c
      do  ix=1,nx
        psq1(ix) = p(1,ix)**2
        psq2(ix) = p(2,ix)**2
        psq3(ix) = p(3,ix)**2
      enddo
c
      do 102 nsi=1,nsimx
       do 101 nsj=1,nsjmx
c
        cicj = ci(nsi)*cj(nsj)
        do  ix=1,nx
          pr0(ix) = cicj
          dpri(1,ix) = gradci(1,nsi)*cj(nsj)
          dpri(2,ix) = gradci(2,nsi)*cj(nsj)
          dpri(3,ix) = gradci(3,nsi)*cj(nsj)
          dprj(1,ix) = ci(nsi)*gradcj(1,nsj)
          dprj(2,ix) = ci(nsi)*gradcj(2,nsj)
          dprj(3,ix) = ci(nsi)*gradcj(3,nsj)
          dpri0(ix)   = -twoali(ix)*cicj
          dprj0(ix)   = -twoalj(ix)*cicj
          pridp(1,ix) = -twoali(ix)*cicj
          pridp(2,ix) = -twoali(ix)*cicj
          pridp(3,ix) = -twoali(ix)*cicj
          prjdp(1,ix) = -twoalj(ix)*cicj
          prjdp(2,ix) = -twoalj(ix)*cicj
          prjdp(3,ix) = -twoalj(ix)*cicj
        enddo
c
c  "pridp" is used for the case that pow(n)=1. and p(n)=0.  In this
c  case we have to be careful in taking derivative wrt p(n), since
c  have function equal zero whose derivative isn't.  In original code,
c  the zero/zero that arises in this case was evaluated incorrectly.
c
        do 20 n=1,3
          powzer(n) = zero
          nq(n) = np(nsi,n) + np(nsj,n) + 1
          nqmn(n) = nqmin(nq(n))
          if( EVEN(nq(n)) )then
            do  ix=1,nx
              pr0(ix) = pr0(ix)*p(n,ix)
              dpri0(ix) = dpri0(ix)*p(n,ix)
              dprj0(ix) = dprj0(ix)*p(n,ix)
            enddo
            do 18 nn=1,3
              do  ix=1,nx
                dpri(nn,ix) = dpri(nn,ix)*p(n,ix)
                dprj(nn,ix) = dprj(nn,ix)*p(n,ix)
              enddo
              if( nn.ne.n )then
                do  ix=1,nx
                  pridp(nn,ix) = pridp(nn,ix)*p(n,ix)
                  prjdp(nn,ix) = prjdp(nn,ix)*p(n,ix)
                enddo
              endif
   18       continue
            powzer(n) = powzer(n) + one
          else
            if( nq(n).gt.2 )then
              do  ix=1,nx
                if( p(n,ix).ne.zero )then
                  pridp(n,ix) = pridp(n,ix)/p(n,ix)
                  prjdp(n,ix) = prjdp(n,ix)/p(n,ix)
                endif
              enddo
            endif
          endif
   20   continue
c
        pow(1) = powzer(1)
        pow(2) = powzer(2)
        pow(3) = powzer(3)
c
        do  ix=1,nx
          b1(ix) = one
        enddo
c
        do 50 iq1=nqmn1,nq1
          do  ix=1,nx
            b12(ix) = b1(ix)*bpq(nq1,iq1)
          enddo
c
          do 40 iq2=nqmn2,nq2
            do  ix=1,nx
              b123(ix) = b12(ix)*bpq(nq2,iq2)
            enddo
c
            do 30 iq3=nqmn3,nq3
              do  ix=1,nx
                bfac(ix) = b123(ix)*bpq(nq3,iq3)
              enddo
              iqsum = iq1 + iq2 + iq3 - 2
c
              do  ix=1,nx
                ves = bfac(ix)*vloces(iqsum,ix)
                vxc = bfac(ix)*vlocxc(iqsum,ix)
                fesi(1) = fesi(1) - ves*dpri(1,ix)
                fesi(2) = fesi(2) - ves*dpri(2,ix)
                fesi(3) = fesi(3) - ves*dpri(3,ix)
                fxci(1) = fxci(1) - vxc*dpri(1,ix)
                fxci(2) = fxci(2) - vxc*dpri(2,ix)
                fxci(3) = fxci(3) - vxc*dpri(3,ix)
                fesj(1) = fesj(1) - ves*dprj(1,ix)
                fesj(2) = fesj(2) - ves*dprj(2,ix)
                fesj(3) = fesj(3) - ves*dprj(3,ix)
                fxcj(1) = fxcj(1) - vxc*dprj(1,ix)
                fxcj(2) = fxcj(2) - vxc*dprj(2,ix)
                fxcj(3) = fxcj(3) - vxc*dprj(3,ix)
              enddo
c
              if( cicj.ne.zero )then
                do  ix=1,nx
                  if( bfac(ix).ne.zero )then
                    ves = bfac(ix)*vloces(iqsum,ix)
                    vxc = bfac(ix)*vlocxc(iqsum,ix)
                    tfaci = bfac(ix)*dpri0(ix)
                    dvesi = vloces(iqsum+1,ix)*tfaci
                    dvxci = vlocxc(iqsum+1,ix)*tfaci
                    fesi0   = fesi0   - ves*dpri0(ix)
                    fesi(1) = fesi(1) + dvesi*p(1,ix)
                    fesi(2) = fesi(2) + dvesi*p(2,ix)
                    fesi(3) = fesi(3) + dvesi*p(3,ix)
                    fxci0   = fxci0   - vxc*dpri0(ix)
                    fxci(1) = fxci(1) + dvxci*p(1,ix)
                    fxci(2) = fxci(2) + dvxci*p(2,ix)
                    fxci(3) = fxci(3) + dvxci*p(3,ix)
                    tfacj = bfac(ix)*dprj0(ix)
                    dvesj = vloces(iqsum+1,ix)*tfacj
                    dvxcj = vlocxc(iqsum+1,ix)*tfacj
                    fesj0   = fesj0   - ves*dprj0(ix)
                    fesj(1) = fesj(1) + dvesj*p(1,ix)
                    fesj(2) = fesj(2) + dvesj*p(2,ix)
                    fesj(3) = fesj(3) + dvesj*p(3,ix)
                    fxcj0   = fxcj0   - vxc*dprj0(ix)
                    fxcj(1) = fxcj(1) + dvxcj*p(1,ix)
                    fxcj(2) = fxcj(2) + dvxcj*p(2,ix)
                    fxcj(3) = fxcj(3) + dvxcj*p(3,ix)
                    if( pow(1).ne.zero )then
                      pfaci = pow(1)*pridp(1,ix)
                      fesi(1) = fesi(1) + ves*pfaci
                      fxci(1) = fxci(1) + vxc*pfaci
                      pfacj = pow(1)*prjdp(1,ix)
                      fesj(1) = fesj(1) + ves*pfacj
                      fxcj(1) = fxcj(1) + vxc*pfacj
                    endif
                    if( pow(2).ne.zero )then
                      pfaci = pow(2)*pridp(2,ix)
                      fesi(2) = fesi(2) + ves*pfaci
                      fxci(2) = fxci(2) + vxc*pfaci
                      pfacj = pow(2)*prjdp(2,ix)
                      fesj(2) = fesj(2) + ves*pfacj
                      fxcj(2) = fxcj(2) + vxc*pfacj
                    endif
                    if( pow(3).ne.zero )then
                      pfaci = pow(3)*pridp(3,ix)
                      fesi(3) = fesi(3) + ves*pfaci
                      fxci(3) = fxci(3) + vxc*pfaci
                      pfacj = pow(3)*prjdp(3,ix)
                      fesj(3) = fesj(3) + ves*pfacj
                      fxcj(3) = fxcj(3) + vxc*pfacj
                    endif
                  endif
                enddo
              endif
c
              pow(3) = pow(3) + two
              do  ix=1,nx
                b123(ix) = b123(ix)*psq3(ix)
              enddo
   30       continue
c
            pow(3) = powzer(3)
            pow(2) = pow(2) + two
            do  ix=1,nx
              b12(ix) = b12(ix)*psq2(ix)
            enddo
   40     continue
c
          pow(2) = powzer(2)
          pow(1) = pow(1) + two
          do  ix=1,nx
            b1(ix) = b1(ix)*psq1(ix)
          enddo
   50   continue
c
  101  continue
  102 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLOCFRC
c
c
      subroutine VLOCFRC( nafrc,iforce, ndim ,frcloc,strloc,
     $ dolocxc, norb,nk,ncplx, natm,ntyp,nshld,nald, nlat,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ alamin, norba, znuc,occsh,occij,
     $ lmxnlp1, ratm, rlat,coskr,sinkr,
     $ nrd,nrad, radmsh,radwt, vpsrad, vatrad,vesrad, wkrad,
     $ naldsq, vlocez,vloces,vlocxc, twoali,twoalj,twoals, p,
     $ wksm,
     $ dmat, frctp )
c---------------------------------------------------------------
c Purpose: calculate forces&stress from spherical local potentials
c
c Written: Peter A. Schultz, based on P.J. Feibelman's original
c
c Revision history:
c  15Oct08-PAS/2.62: stripe-parallel
c  11May07-PAS/2.60: merged tp and serial
c   6Jul06-APT/2.59: merged task parallel and image parallel
c  15Jun05-PAS/2.59: File units
c  25Sep04-PAS/tp0.1: clean-up task-parallel routines.
c   6May03-DMC: Add frclocl to parameter list, to provide a local
c               copy of the frcloc array, for parallelization
c   7Mar02-PAS/2.52: ang constants extracted
c  23Jul01-PAS/2.49: compact dmat
c  22May01-PAS/2.47: condense radial scratch space
c  14Mar00-PAS/2.43: rename "vl" routines
c  21Dec99-PAS/2.42: cosmetic clean-up
c  27Sep99-PAS/2.40: full three-dimensional stress tensor
c  17Dec98-PAS/2.30: clean force/stress/arrays
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  30Sep98-PAS/2.27: rework angular integral section (including
c                    interesting legacy bug), rename
c  27Aug98-PAS/2.25: purge (N**7) equivs and condense arithmetic;
c                 use "engausf' only for reference occupied terms
c  11Aug98-PAS/2.24: match 3-center routines again
c  23Jun98-PAS/2.23: output controls + occ/slow cutoffs done right
c                    split basis
c  28Apr97-PAS/2.17: naming conventions
c   3Jan96-PAS/2.13: clean cutoffs/opt
c   6Jan95-PAS/2.11: purge explicit complex
c  17Oct94-PAS/2.10: cleanup and optimization
c---------------------------------------------------------------
c
c  Angular integrals are evaluated analytically
c  Radial integrals are evaluated numerically
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, half=0.5d0 )
c
c Output arrays:
      DIMENSION  frcloc(3,natm), strloc(3,3)
c Input arrays:
      LOGICAL    dolocxc
      DIMENSION  iforce(natm)
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $  nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp)
      DIMENSION  znuc(ntyp), occsh(nshld,ntyp),occij(nshld,nshld,ntyp)
      DIMENSION  lmxnlp1(ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp),radwt(nrd,ntyp),
     $           vpsrad(nrd,4,ntyp),vatrad(nrd,ntyp),vesrad(nrd,ntyp)
      DIMENSION  dmat(nk,*)
c Scratch arrays:
      DIMENSION  wkrad(nrd,*)
      DIMENSION  vlocez(6,naldsq),vloces(6,naldsq),vlocxc(6,naldsq)
      DIMENSION  twoali(naldsq),twoalj(*),twoals(*)
      DIMENSION  p(3,naldsq)
      DIMENSION  wksm(naldsq,*)
c parallel scratch:
      DIMENSION  frctp(3,natm)
      DIMENSION  strtp1(11),strtp2(11)
c
c Local declarations:
      LOGICAL    iatmi, diagshl
      LOGICAL    keepsh, do_es,do_ps,do_xc
      DIMENSION  vesint(6),vpsint(6),vlocint(6)
      DIMENSION  fez(3),fesi(3),fesj(3),fxci(3),fxcj(3)
c
      DIMENSION  rnuc(3),ri(3),rj(3), rij(3)
      DIMENSION  ci(10,9),cj(10,9),gradci(3*10,9),gradcj(3*10,9)
      DIMENSION  vzero(270)
c
      DIMENSION  vnorm(9)
c
      DATA  lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'FDEV/VLOCFRC: stripe-parallel'
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxf = cutgwfn
      emaxsl = cutslow
      emaxii = cutii
      emxslo = MAX( emaxsl, emaxii )
c
      fourpi = pi + pi + pi + pi
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c     
c  Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c     
c  Figure out how much belongs on local processor:
      call MATLOCSTR( iproc,nprocs,nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
c  Initialize stress and force
c
      strszz = zero
      strsnn = zero
      call MKZERO( 3*natm, frcloc )
      call MKZERO( 9, strloc )
c
      call MKZERO( 270, vzero )
c
c    Nucleus loop:
c
      do 3000 nuc=1,natm
c
Cc     Each processor will do every nprocs element in this loop.
C      if( MOD( nuc, nprocs ) .ne. iproc ) goto 3000
c
      ktyp = itypa(nuc)
      if( znuc(ktyp).eq.zero ) goto 3000
c
      alaminn = two*alamin(ktyp)
      almin = 1.d9
      do  ishl=1,nocc(ktyp)
        lshl = locc(ishl,ktyp)
        occshl = occsh(ishl,ktyp)
        if( occshl.ne.zero )then
          do  ial=1,nalsh(ishl,ktyp)
            if( alsh(ial,ishl,ktyp).lt.almin ) almin=alsh(ial,ishl,ktyp)
          enddo
        endif
      enddo
      alaminn = two*almin
c
      nmat = nk*norb*norb
c
c    Nucleus lattice loop:
c
      do 2900 klat=1,nlat
c
      do  ir=1,3
        rnuc(ir) = ratm(ir,nuc) + rlat(ir,klat)
      enddo
c
c     Atom j loop:
c
      jjnext = 0
      jnext = myj0
      do 2000 jatm=myatm1,myatm2
      jtyp = itypa(jatm)
      nshlj = numshl(jtyp)
      norbatj = norba(jtyp)
      jstart = jnext
      jnext = jstart + norbatj
c
      njstripe = norb - jstart
      matjstr = norbatj*njstripe
      jjstart = jjnext
      jjnext = jjstart + matjstr*ncplx
c
      do  ir=1,3
        rj(ir) = ratm(ir,jatm) - rnuc(ir)
      enddo
      rjsquar = rj(1)*rj(1) + rj(2)*rj(2) + rj(3)*rj(3)
c
      alaminj = alamin(jtyp)
      emax = emxslo
      rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c     Test overlap of Atom j and short-range pot due to "nuc"
      if( rjsquar.gt.rjnmax ) goto 2000
c
      if( klat.ne.1 .or. jatm.ne.nuc )then
c       Add nuc-jatm core repulsion to forces.  Note: skipped IF
c       no nuc:iatm overlap (electronic and nuclear contributions cancel).
        zj = znuc(jtyp)
        do 28 jshl=1,nshlj
c
          norbshj = 2*lshel(jshl,jtyp) + 1
          alminj = ala(1,jshl,jtyp)
          do  jal=1,nala(jshl,jtyp)
            alj = ala(jal,jshl,jtyp)
            if( alj.lt.alminj ) alminj = alj
          enddo
c
          do 26 ishl=jshl,nshlj
c
c           NOTE: (1) ishl and jshl must have same angular momentum
c            and (2) z contribution is in occij(is,js.le.is,ityp)
            occshl = norbshj*occij(jshl,ishl,jtyp)
            if( occshl.eq.zero ) goto 26
c
            almini = ala(1,ishl,jtyp)
            do  ial=1,nala(ishl,jtyp)
              ali = ala(ial,ishl,jtyp)
              if( ali.lt.almini ) almini = ali
            enddo
            alsum = almini + alminj
            emax = emaxii
            rjsmax = emax*(alsum+alaminn) / (alsum*alaminn)
            if( rjsquar.gt.rjsmax )  zj = zj - occshl
   26     continue
c
   28   continue
        zztot = znuc(ktyp)*zj
c
        engyadd = zztot / SQRT( rjsquar )
        facn = engyadd/rjsquar
        frcloc(1,nuc) = frcloc(1,nuc) - two*facn*rj(1)
        frcloc(2,nuc) = frcloc(2,nuc) - two*facn*rj(2)
        frcloc(3,nuc) = frcloc(3,nuc) - two*facn*rj(3)
        rjsqd = zero
        do  jd=1,ndim
          rjsqd = rjsqd + rj(jd)*rj(jd)
          do  id=1,ndim
            strloc(id,jd) = strloc(id,jd) - facn*rj(id)*rj(jd)
          enddo
        enddo
        strszz = strszz - facn*rjsqd
      endif
c
      call CINITF( cj,gradcj )
      call COFRF( cj,gradcj,rj )
c           
c     Atom j shell loop:
c
      jorbatnxt = 0
      j = jstart
      do 1800 jshl=1,nshlj
      nalj = nala(jshl,jtyp)
      lshlj = lshel(jshl,jtyp)
      norbshj = 2*lshlj + 1
      lj0 = lshlj*lshlj
c
      j0 = j
      jorbat0 = jorbatnxt
      jorbatnxt = jorbat0 + norbshj
c
      alminj = ala(1,jshl,jtyp)
      almaxj = ala(nalj,jshl,jtyp)
      do  jal=1,nalj
        alj = ala(jal,jshl,jtyp)
        if( alj.lt.alminj ) alminj = alj
        if( alj.gt.almaxj ) almaxj = alj
      enddo
      alaminj = alminj
c
      emax = emxslo
      rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c     Test whether this radial function will contribute:
      if( rjsquar.gt.rjnmax ) goto 1799
c
c     Atom i loop:
c
      ijnext = jjstart
      inext = jstart
      do 1000 iatm=jatm,natm
        ityp = itypa(iatm)
        nshli = numshl(ityp)
        norbati = norba(ityp)
        istart = inext
        inext = istart + norbati
c
        matij = norbati*norbatj
        ijstart = ijnext
        ijnext = ijstart + matij*ncplx
c
c       Following helps ensure only i.ge.j done:
        iorbatn0 = 0
        ilat1 = 1
        ishl1 = 1
        if( iatm.eq.jatm )then
          ishl1 = jshl
          do  ishl=1,ishl1-1
            lshli = lshel(ishl,ityp)
            norbshi = 2*lshli + 1
            istart = istart + norbshi
            iorbat0 = iorbatn0
            iorbatn0 = iorbat0 + norbshi
          enddo
        endif
c
        alamini = alamin(ityp)
c       Criterion for including contribution of Atom i:
        ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
        rijnmax = (emaxsl-ex)*(alaminj+alamini+alaminn) /
     $                      ( (alaminj+alaminn)*alamini )
        riinmax = (emaxii-ex)*(alaminj+alamini+alaminn) /
     $                      ( (alaminj+alaminn)*alamini )
c
c       Lattice vector loop for Atom i:
c
        do 900 ilat=1,nlat2c
c
          do  ir=1,3
            rij(ir) = ratm(ir,jatm) - ratm(ir,iatm) - rlat(ir,ilat)
            ri(ir) = ratm(ir,iatm) + rlat(ir,ilat) - rnuc(ir)
          enddo
          risquar = ri(1)*ri(1) + ri(2)*ri(2) + ri(3)*ri(3)
c
          f1 = alaminj / (alaminj+alaminn)
          rijn0 = zero
          do  ir=1,3
            rijn0 = rijn0 + (f1*rj(ir)-ri(ir))**2
          enddo
c
c         Test for significant overlap of Atom j with i and nuc
          if( iatm.eq.jatm .and. ilat.eq.1 )then
            iatmi = .true.
            if( rijn0.gt.riinmax ) goto 900
          else
            iatmi = .false.
            if( rijn0.gt.rijnmax ) goto 900
          endif
c
          call CINITF( ci,gradci )
          call COFRF( ci,gradci,ri )
c
c         Atom i shell loop:
c
          iorbatnxt = iorbatn0
          i = istart
          do 800 ishl=ishl1,nshli
            nali = nala(ishl,ityp)
            lshli = lshel(ishl,ityp)
            norbshi = 2*lshli + 1
            li0 = lshli*lshli
c
            i0 = i
            iorbat0 = iorbatnxt
            iorbatnxt = iorbat0 + norbshi
c
            diagshl = .false.
            if( i0.eq.j0 ) diagshl = .true.
c
            almini = ala(1,ishl,ityp)
            almaxi = ala(nali,ishl,ityp)
            do  ial=1,nali
              ali = ala(ial,ishl,ityp)
              if( ali.lt.almini ) almini = ali
              if( ali.gt.almaxi ) almaxi = ali
            enddo
c
            emax = emaxf
            if( almaxi.lt.alfast .and. almaxj.lt.alfast ) emax = emaxsl
            if( iatmi ) emax = emaxii
c
            ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
            rijnmx = (emax-ex)*(alaminj+almini+alaminn) /
     $                       ( (alaminj+alaminn)*almini )
            if( rijn0.gt.rijnmx ) goto 799
c
            keepsh = .false.
            occ = zero
c           NOTE: z contribution is in occij(is,js.le.is,ityp)
            if( iatmi )then
              if( ishl.gt.jshl )then
                occ = two*occij(ishl,jshl,jtyp)
              else
                occ = occij(jshl,ishl,jtyp)
              endif
              if( occ.ne.zero ) keepsh = .true.
            endif
c
            lmx = lshli + lshlj + 2
c
c           Alpha loops:
c
            ix = 0
            ixx = 0
            do 320 jal=1,nalj
              alj = ala(jal,jshl,jtyp)
c
c             Test whether this alpha contributes:
              rjnmx = emax*(alj+alaminn) / (alj*alaminn)
              if( rjsquar.gt.rjnmx .and. .not. keepsh ) goto 320
c
              fj1 = alj / (alj+alaminn)
              rijn = zero
              do  ir=1,3
                rijn = rijn + (fj1*rj(ir)-ri(ir))**2
              enddo
c
              do 310 ial=1,nali
                ali = ala(ial,ishl,ityp)
c
c               Test whether this pair of alphas contributes:
                ex = rjsquar*alj*alaminn / (alj+alaminn)
                rijnmx = (emax-ex)*(alj+ali+alaminn) /
     $                           ( (alj+alaminn)*ali )
                if( rijn.gt.rijnmx .and. .not. keepsh ) goto 310
c
                ix = ix + 1
c
                alsum = ali + alj
                exparg = ali*risquar + alj*rjsquar
                twoals(ix) = alsum + alsum
                tooali = ali + ali
                tooalj = alj + alj
                twoali(ix) = tooali
                twoalj(ix) = tooalj
                p(1,ix) = tooali*ri(1) + tooalj*rj(1)
                p(2,ix) = tooali*ri(2) + tooalj*rj(2)
                p(3,ix) = tooali*ri(3) + tooalj*rj(3)
                pmag = SQRT( p(1,ix)**2 + p(2,ix)**2 + p(3,ix)**2 )
c
                enfac = fourpi*cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
c
                if( keepsh )then
c
c                 Compute radial integrals, put matrix elements of -2/r in vlocez:
c                  (note: expfac is for underflow control)
                  expfac = zero
                  if( exparg.lt.argmx ) expfac =  EXP( -exparg )
                  call VLRADZ( vlocez(1,ix),lmx,alsum,pmag,-one,
     $                         exparg,expfac )
c
c                 Compute contribution to force integral from hellmann-feynmann
c                 term involving the spherical part of the density matrix
c
                  do  ladd=1,lmx
                    vlocez(ladd,ix) = vlocez(ladd,ix)*znuc(ktyp)*enfac
                  enddo
                else
c                 Blank it, since it is too hard to stop its use later ...
                  do  ladd=1,lmx
                    vlocez(ladd,ix) = zero
                  enddo
                endif
c
                do_es = .false.
                do_ps = .false.
                do_xc = .false.
                do  ladd=1,lmx
                  vesint(ladd) = zero
                  vpsint(ladd) = zero
                  vlocint(ladd) = zero
                enddo
                if( rijn.gt.rijnmx ) goto 307
c
c               Install underflow cutoffs:
                call NRSCUT( nrmn,nrmx,nrad(ktyp),argmx,
     $           exparg,pmag,alsum, radmsh(1,ktyp), wkrad )
                if( nrmx.le.0 ) goto 307
c
                ixx = ixx + 1
c               Flag to compute matrix elements of ...
c                  ... short range spherical electrostatic potential
                do_es = .true.
c                  ... hellman-feynmann contribution from local pspot
                do_ps = .false.
                if( lmxnlp1(ktyp).ge.0 ) do_ps = .true.
c                  ... all of the short range potential (to get xc piece)
                do_xc = dolocxc
c
                nrlen = nrmx - nrmn + 1
                lp = lmxnlp1(ktyp) + 1
                call VLRADF( vesint,vpsint,vlocint, do_es,do_ps,do_xc,
     $           lmx,alsum,pmag,exparg,    nrlen,
     $           radmsh(nrmn,ktyp),radwt(nrmn,ktyp), vesrad(nrmn,ktyp),
     $           vpsrad(nrmn,lp,ktyp),vatrad(nrmn,ktyp),
     $           wkrad, wkrad(1, 8),wkrad(1, 9),wkrad(1,10),
     $                  wkrad(1,11),wkrad(1,12),wkrad(1,13) )
c
  307           continue
c
                if( dolocxc )then
c                Atom reference xc potential forces computed here
                 do  ladd=1,lmx
                  vlocez(ladd,ix) = vlocez(ladd,ix) - enfac*vesint(ladd)
                  vloces(ladd,ix) = enfac*(vesint(ladd)+vpsint(ladd))
                  vlocxc(ladd,ix) = enfac*vlocint(ladd)
     $                            - vloces(ladd,ix)
                 enddo
                else
c                Atom reference xc potential forces computed on grid
                 do  ladd=1,lmx
                  vlocez(ladd,ix) = vlocez(ladd,ix) - enfac*vesint(ladd)
                  vloces(ladd,ix) = enfac*(vesint(ladd)+vpsint(ladd))
                  vlocxc(ladd,ix) = zero
                 enddo
                endif
c
c               Close alpha loops:
  310         continue
  320       continue
c
            nx = ix
            if( nx.eq.0 ) goto 799
c
c           Angular loops:
c
            ij0 = ijstart + jorbat0*norbati + iorbat0
            ij0 = ij0 - norbati
            mli1 = 1
            do 420 mlj=1,norbshj
              lj = lj0 + mlj
              jorbat = jorbat0 + mlj
              j = j0 + mlj
c
              ij0 = ij0 + norbati
              if( diagshl ) mli1=mlj
              do 410 mli=mli1,norbshi
                li = li0 + mli
                iorbat = iorbat0 + mli
                i = i0 + mli
                ij = ij0 + mli
c
                denlilj = vnorm(li)*vnorm(lj)
c
                if( keepsh .and. li.eq.lj )then
c
                  call VLOCF0( fez(1),fez(2),fez(3),
     $             lj,li, cj(1,lj),ci(1,li), gradcj(1,lj),gradci(1,li),
     $             nx, vlocez, twoals, p,
     $             wksm(1,1), wksm(1,2),wksm(1,5),
     $             wksm(1,8),wksm(1,9),wksm(1,10),
     $             wksm(1,11),wksm(1,12),wksm(1,13),wksm(1,14) )
c
                  occfac = occ/denlilj
                  fez(1) = occfac*fez(1)
                  fez(2) = occfac*fez(2)
                  fez(3) = occfac*fez(3)
c
                  frcloc(1,nuc) = frcloc(1,nuc) - fez(1)
                  frcloc(2,nuc) = frcloc(2,nuc) - fez(2)
                  frcloc(3,nuc) = frcloc(3,nuc) - fez(3)
c
                  do  jd=1,ndim
                    strsnn = strsnn - fez(jd)*rj(jd)/two
                    do  id=1,ndim
                      strloc(id,jd) = strloc(id,jd) - fez(id)*rj(jd)/two
                    enddo
                  enddo
c
                endif
c
                if( ixx.eq.0 ) goto 410
c
c               Compute density matrix k-sum:
c
                dmsum = zero
                if( i.eq.j )then
                  do  k=1,nk
C                    dmsum = dmsum + coskr(k,ilat)*dmat(i,i,k)
                    dmsum = dmsum + coskr(k,ilat)*dmat(k,ij)
                  enddo
                else
c                 i.ne.j
                  do  k=1,nk
C                    dmsum = dmsum + coskr(k,ilat)*dmat(i,j,k)
                    dmsum = dmsum + coskr(k,ilat)*dmat(k,ij)
                  enddo
                  if( ncplx.eq.2 )then
                    ijc = ij + matij
                    do  k=1,nk
C                      dmsum = dmsum + sinkr(k,ilat)*dmat(j,i,k)
                      dmsum = dmsum + sinkr(k,ilat)*dmat(k,ijc)
                    enddo
                  endif
c                 Double because only doing one triangle
                  dmsum = dmsum + dmsum
                endif
                dmsum = dmsum / denlilj
c
                fesi0 = zero
                fxci0 = zero
                fesj0 = zero
                fxcj0 = zero
                do  ir=1,3
                  fesi(ir) = zero
                  fxci(ir) = zero
                  fesj(ir) = zero
                  fxcj(ir) = zero
                enddo
c
                if( dolocxc )then
c
                  call VLOCF2(
     $             fesj0,fesj, fesi0,fesi, fxcj0,fxcj, fxci0,fxci,
     $             lj,li, cj(1,lj),ci(1,li),gradcj(1,lj),gradci(1,li),
     $             nx, vloces,vlocxc, twoalj,twoali, p,
     $             wksm(1, 1), wksm(1, 2),wksm(1, 3),wksm(1, 6),
     $                        wksm(1, 9),wksm(1,10),wksm(1,13),
     $             wksm(1,16),wksm(1,17),wksm(1,18),
     $             wksm(1,19),wksm(1,20),wksm(1,21),wksm(1,22) )
c
                else
c
                  call VLOCF1( fesj0,fesj, fesi0,fesi,
     $             lj,li, cj(1,lj),ci(1,li),gradcj(1,lj),gradci(1,li),
     $             nx, vloces, twoalj,twoali, p,
     $             wksm(1, 1), wksm(1, 2),wksm(1, 3),wksm(1, 6),
     $                        wksm(1, 9),wksm(1,10),wksm(1,13),
     $             wksm(1,16),wksm(1,17),wksm(1,18),
     $             wksm(1,19),wksm(1,20),wksm(1,21),wksm(1,22) )
c
                endif
c
                do 406 ir=1,3
                  fesi(ir) = dmsum*( fesi(ir) + fesi0*ri(ir) )
                  fxci(ir) = dmsum*( fxci(ir) + fxci0*ri(ir) )
                  fesj(ir) = dmsum*( fesj(ir) + fesj0*rj(ir) )
                  fxcj(ir) = dmsum*( fxcj(ir) + fxcj0*rj(ir) )
  406           continue
c
                frcloc(1,iatm) = frcloc(1,iatm) + fesi(1) + fxci(1)
                frcloc(2,iatm) = frcloc(2,iatm) + fesi(2) + fxci(2)
                frcloc(3,iatm) = frcloc(3,iatm) + fesi(3) + fxci(3)
c
                frcloc(1,jatm) = frcloc(1,jatm) + fesj(1) + fxcj(1)
                frcloc(2,jatm) = frcloc(2,jatm) + fesj(2) + fxcj(2)
                frcloc(3,jatm) = frcloc(3,jatm) + fesj(3) + fxcj(3)
c
                frcloc(1,nuc)  = frcloc(1,nuc)  - fesi(1) - fesj(1)
                frcloc(2,nuc)  = frcloc(2,nuc)  - fesi(2) - fesj(2)
                frcloc(3,nuc)  = frcloc(3,nuc)  - fesi(3) - fesj(3)
c
c               NOTE:
c               The factors for the xc terms in the stress calculations below
c               are suspect.  Original code was bogus, and I'm guessing about
c               the correct coordinate factors and coefficients.  Fortunately
c               this code is inactive with the xc flags set as they are.
c               At some point I'll have to clear this up. 30Sep98-PAS
c
                do  jd=1,ndim
                  do  id=1,ndim
                    strloc(id,jd) = strloc(id,jd)
     $               - fesi(id)*ri(jd) - fesj(id)*rj(jd)
     $               - fxci(id)*rij(jd)
     $               + fxcj(id)*rij(jd)
                  enddo
                enddo
c
c               Close angular loops:
  410         continue
  420       continue
c
  799       continue
c           Close Atom i shell loop:
            i = i0 + norbshi
  800     continue
c
c         Close Atom i lattice loop:
  900   continue
c
c       Close Atom i loop:
 1000 continue
c
 1799   continue
c       Close Atom j shell loop:
        j = j0 + norbshj
 1800 continue
c
c       Close Atom j loop:
c
 2000 continue
c
c       Close Nucleus lattice loop:
c
 2900 continue
c
c       Close Nucleus loop:
c
 3000 continue
c
c >>>> Collect final force/stress
c
      if( nprocs .gt. 1 )then
c       Each local processor has forces over its share of work.
c       Need to sum these to master (node 0).
c       For now, also broadcast total to all processors.
c
        nreduc = 3*natm
        call MPREDUC8( master, nreduc, frcloc, frctp , icomm )
C        call MPI_Reduce( frcloc, frctp , nreduc,
C     $   MPI_DOUBLE_PRECISION, MPI_SUM,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pvlocfrc - Reduce frcloc' )
        call DCOPY( 3*natm, frctp,1, frcloc,1 )
c
        call MPBCAST8( master, nreduc, frcloc, icomm )
C        call MPI_Bcast( frcloc, nreduc, MPI_DOUBLE_PRECISION,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pvlocfrc - Bcast frcloc' )
c
c       Want to add both strszz and strsnn to what is accumulated.
c       Will put it in as part of the strtp array for comms.
c
        call DCOPY( 9, strloc,1, strtp1,1 )
        strtp1(10) = strszz
        strtp1(11) = strsnn
        nreduc = 11
c
        call MPREDUC8( master, nreduc, strtp1, strtp2, icomm )
C        call MPI_Reduce( strtp1, strtp2, nreduc,
C     $   MPI_DOUBLE_PRECISION, MPI_SUM,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pvlocfrc - Reduce strloc' )
c
        call MPBCAST8( master, nreduc, strtp2, icomm )
C        call MPI_Bcast( strtp2, nreduc, MPI_DOUBLE_PRECISION,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pvlocfrc - Bcast strlll' )
c
        call DCOPY( 9, strtp2,1, strloc,1 )
        strszz = strtp2(10)
        strsnn = strtp2(11)
c
c       End tp
      endif
c
c  Print some results:
c
      if( lstout.gt.2 )then
        call FLGETIWR( IWR )
        write(IWR,'(4x,a,f20.8)') 'stress/zz=',strszz
        write(IWR,'(4x,a,f20.8)') 'stress/nn=',strsnn
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLOCMAT
c
c
      subroutine VLOCMAT( IWR,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat  ,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ alamin, norba, znuc,occsh,
     $ ratm, rlat,coskr,sinkr,
     $ nrd,nrad, radmsh,radwt, vatrad, vesrad,vxcrad,excrad, wkrad,
     $ vloc0,vxc0,exc0, vtmp )
c---------------------------------------------------------------
c Purpose: calculate electron-nuclear matrix elements for the
c          local part of the spherical reference potentials
c          for all but the 2-center I:N terms (done in "vlocmii")
c
c Written: P.A. Schultz, for v2.43, based on the routine "enij"
c          originally written by P.J. Feibelman
c
c Revision history:
c  17Oct08-PAS/2.62: stripe-distributed-parallel
c  18Jun07-PAS/2.60: merge tp and serial
c  29Jan07-PAS/2.60: clean up tp; put barrier between Reduces
c   6Jul06-APT/2.60: merged task parallel and image parallel
c  25Sep04-PAS/tp0.1: clean-up task-parallel routines.
c   DMC:  task parallel
c   7Mar02-PAS/2.52: ang constants extracted
c  22May01-PAS/2.47: condense radial scratch space
c   6Mar00-PAS/2.43: rename "vl" routines, "enij" to "vlocmat"
c  21Dec99-PAS/2.42: cosmetic clean-up
c  15Sep99-PAS/2.39: pack big workspace down + simple opt
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  14Sep98-PAS/2.27: compact temp orbital matrix
c  27Aug98-PAS/2.25: purge (N**7) triplet equivalences
c  11Aug98-PAS/2.24: match 3-center routines again
c  16Jul98-PAS/2.23: slow+occ cutoffs finally dealt with properly,
c                    split off I:N into separate routine (ENII),
c                    accomodate split basis
c  28Apr97-PAS/2.17: naming conventions
c  13NOv96-PAS/2.16: opt k-loops, k-first temp Ham arrays
c  29Sep95-PAS/2.13: fix F(N-II) shell-pruning, tighten cutoffs,
c                    extract k-dependent loops from bottom for opt
c   3Jun94-PAS/2.10: exc matrix install
c  18Jan94-PAS/2.04: full cleanup, match sij,tij,enij,ennloc
c  21Jun89-PAS: reorganized to extract SHTRNG out from under
c               angular loops
c---------------------------------------------------------------
c
c  Angular integrals are evaluated analytically
c  Radial integrals are evaluated numerically
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, half=0.5d0 )
c
c Output arrays:
      DIMENSION  vloc0(nk,*),vxc0(nk,*),exc0(nk,*)
      DIMENSION  vtmp(nk,*)
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $ nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp)
      DIMENSION  znuc(ntyp), occsh(nshld,ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp),radwt(nrd,ntyp)
      DIMENSION  vatrad(nrd,ntyp)
      DIMENSION  vesrad(nrd,ntyp),vxcrad(nrd,ntyp),excrad(nrd,ntyp)
c Scratch arrays:
      DIMENSION  wkrad(nrd,*)
c
c Local declarations:
c
      LOGICAL    Lmatreduce
      LOGICAL    keepsh, diagshl
      DIMENSION  vessh(5,5),vijsh(5,5),vxcsh(5,5),excsh(5,5)
      DIMENSION  rnuc(3),ri(3),rj(3), p(3), ci(10,9),cj(10,9)
      DIMENSION  vatint(5),vesint(5),vxcint(5),excint(5)
c
      DIMENSION  vnorm(9)
c lstout controls diagnostic output 0-none,1-minimal,n>1-more
      DATA  lstout  / 0 /
c---------------------------------------------------------------
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'SDEV/VLOCMAT: stripe-parallel'
      Lmatreduce = .false.
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxf = cutgwfn
      emaxsl = cutslow
c
      emxslo = emaxsl
c
      fourpi = pi + pi + pi + pi
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
c  Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmatstr = ncplx*nk*matstr
c
c  Figure out how much belongs on local processor:
      call MATLOCSTR( iproc,nprocs,nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
      nmat = nk*norb*norb
      nmatpr = mymatpr*ncplx*nk
c
      if( lstout.ne.0 )  write(IWR,9000)
 9000 format(/3x,'nuc  klat iatm',9x,'E(Z-Z)',12x,'E(E-Z)',12x,'TOT')
 9001 format(1x,'ENRI',3i3,2x,3f20.10)
 9002 format(5x,a,3i3,2x,f20.10)
 9003 format(5x,a,4i3,2x,f20.10)
c
c    Nucleus loop:
c
      do 3000 nuc=1,natm
c
c     Each processor will do every nprocs element in this loop.
      if( Lmatreduce .and. ( MOD( nuc, nprocs ) .ne. iproc ) ) goto 3000
c
      ktyp = itypa(nuc)
      if( znuc(ktyp).eq.zero ) goto 3000
c
      alaminn = two*alamin(ktyp)
      almin = 1.d9
      do  ishl=1,nocc(ktyp)
        occshl = occsh(ishl,ktyp)
        if( occshl.ne.zero )then
          do  ial=1,nalsh(ishl,ktyp)
            if( alsh(ial,ishl,ktyp).lt.almin ) almin=alsh(ial,ishl,ktyp)
          enddo
        endif
      enddo
      alaminn = two*almin
c
c    Nucleus lattice loop:
c
      do 2900 klat=1,nlat
c
      do  ir=1,3
        rnuc(ir) = ratm(ir,nuc) + rlat(ir,klat)
      enddo
c
c     Atom j loop:
c
      jjnext = 0
      jnext = myj0
      do 2000 jatm=myatm1,myatm2
      jtyp = itypa(jatm)
      nshlj = numshl(jtyp)
      norbatj = norba(jtyp)
      jstart = jnext
      jnext = jstart + norbatj
c
      njstripe = norb - jstart
      matjstr = norbatj*njstripe
      jjstart = jjnext
      jjnext = jjstart + matjstr*ncplx
c
      do  ir=1,3
        rj(ir) = ratm(ir,jatm) - rnuc(ir)
      enddo
      rjsquar = rj(1)*rj(1) + rj(2)*rj(2) + rj(3)*rj(3)
c
      alaminj = alamin(jtyp)
      emax = emxslo
      rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c     Test overlap of Atom j and short-range pot due to "nuc"
      if( rjsquar.gt.rjnmax ) goto 2000
c
      call CINIT( cj )
      call COFR( cj,rj )
c
c     Atom j shell loop:
c
      jorbatnxt = 0
      j = jstart
      do 1800 jshl=1,nshlj
      nalj = nala(jshl,jtyp)
      lshlj = lshel(jshl,jtyp)
      norbshj = 2*lshlj + 1
      lj0 = lshlj*lshlj
c
      j0 = j
      jorbat0 = jorbatnxt
      jorbatnxt = jorbat0 + norbshj
c
      alminj = ala(1,jshl,jtyp)
      almaxj = ala(nalj,jshl,jtyp)
      do  jal=1,nalj
        alj = ala(jal,jshl,jtyp)
        if( alj.lt.alminj ) alminj = alj
        if( alj.gt.almaxj ) almaxj = alj
      enddo
      alaminj = alminj
c
      emax = emaxf
      if( almaxj.lt.alfast ) emax = emaxsl
      rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c     Test whether this radial function will contribute:
      if( rjsquar.gt.rjnmax ) goto 1799
c
c     Atom i loop:
c
      ijnext = jjstart
      inext = jstart
      do 1000 iatm=jatm,natm
        ityp = itypa(iatm)
        nshli = numshl(ityp)
        norbati = norba(ityp)
        istart = inext
        inext = istart + norbati
c
        matij = norbati*norbatj
        ijstart = ijnext
        ijnext = ijstart + matij*ncplx
c
c       Following helps ensure only i.ge.j done:
        iorbatn0 = 0
        ilat1 = 1
        ishl1 = 1
        if( iatm.eq.jatm )then
          ilat1 = 2
          ishl1 = jshl
          do  ishl=1,ishl1-1
            lshli = lshel(ishl,ityp)
            norbshi = 2*lshli + 1
            istart = istart + norbshi
            iorbat0 = iorbatn0
            iorbatn0 = iorbat0 + norbshi
          enddo
        endif
c
        alamini = alamin(ityp)
c       Criterion for including contribution of Atom j:
        ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
        rijnmax = (emaxsl-ex)*(alaminj+alamini+alaminn) /
     $                      ( (alaminj+alaminn)*alamini )
c
c       Lattice vector loop for Atom i:
c
        do 900 ilat=ilat1,nlat2c
c
          do  ir=1,3
            ri(ir) = ratm(ir,iatm) + rlat(ir,ilat) - rnuc(ir)
          enddo
          risquar = ri(1)*ri(1) + ri(2)*ri(2) + ri(3)*ri(3)
c
          f1 = alaminj / (alaminj+alaminn)
          rijn0 = zero
          do  ir=1,3
            rijn0 = rijn0 + (f1*rj(ir)-ri(ir))**2
          enddo
c
c         Test for significant overlap of Atom j with i and nuc
          if( rijn0.gt.rijnmax ) goto 900
c
          call CINIT( ci )
          call COFR( ci,ri )
c
c         Atom i shell loop:
c
          iorbatnxt = iorbatn0
          i = istart
          do 800 ishl=ishl1,nshli
            nali = nala(ishl,ityp)
            lshli = lshel(ishl,ityp)
            norbshi = 2*lshli + 1
            li0 = lshli*lshli
c
            i0 = i
            iorbat0 = iorbatnxt
            iorbatnxt = iorbat0 + norbshi
c
            diagshl = .false.
            if( i0.eq.j0 ) diagshl = .true.
c
            almini = ala(1,ishl,ityp)
            almaxi = ala(nali,ishl,ityp)
            do  ial=1,nali
              ali = ala(ial,ishl,ityp)
              if( ali.lt.almini ) almini = ali
              if( ali.gt.almaxi ) almaxi = ali
            enddo
c
            emax = emaxf
            if( almaxi.lt.alfast .and. almaxj.lt.alfast ) emax = emaxsl
c
            ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
            rijnmx = (emax-ex)*(alaminj+almini+alaminn) /
     $                       ( (alaminj+alaminn)*almini )
            if( rijn0.gt.rijnmx ) goto 799
c
            lmx = lshli + lshlj + 1
            call MKZERO( 25, vessh )
            call MKZERO( 25, vijsh )
            call MKZERO( 25, vxcsh )
            call MKZERO( 25, excsh )
c
c           Alpha loops:
c
            enijsum = zero
            coulsum = zero
            do 320 jal=1,nalj
              alj = ala(jal,jshl,jtyp)
c
c             Test whether this alpha contributes:
              rjnmx = emax*(alj+alaminn) / (alj*alaminn)
              if( rjsquar.gt.rjnmx ) goto 320
c
              fj1 = alj / (alj+alaminn)
              rijn = zero
              do  ir=1,3
                rijn = rijn + (fj1*rj(ir)-ri(ir))**2
              enddo
c
              do 310 ial=1,nali
                ali = ala(ial,ishl,ityp)
c
c               Test whether this pair of alphas contributes:
                ex = rjsquar*alj*alaminn / (alj+alaminn)
                rijnmx = (emax-ex)*(ali+alj+alaminn) /
     $                           ( (alj+alaminn)*ali )
                if( rijn.gt.rijnmx ) goto 310
c
                alsum = ali + alj
                exparg = ali*risquar + alj*rjsquar
                do  ir=1,3
                  p(ir) = two*(ali*ri(ir)+alj*rj(ir))
                enddo
                pmag = SQRT( p(1)*p(1)+p(2)*p(2)+p(3)*p(3) )
c
                call MKZERO( 5, vatint )
                call MKZERO( 5, vesint )
                call MKZERO( 5, vxcint )
                call MKZERO( 5, excint )
c
                nonzer = 0
c
c               "vlrad" computes the contributions of the xc-potentials
c               associated with atom nuc, as well as the difference between
c               the actual electrostatic potential due to the electrons of
c               atom nuc and 2.*abs(znuc)/r
c
                call NRSCUT( nrmn,nrmx,nrad(ktyp),argmx,
     $           exparg,pmag,alsum,radmsh(1,ktyp),wkrad )
c
                if( nrmx.gt.0 )then
c
c                 Evaluate radial integrals
c
                  nrlen = nrmx - nrmn + 1
                  call VLRAD( vatint, vesint,vxcint,excint,
     $             lmx,alsum,pmag,exparg,
     $             nrlen, radmsh(nrmn,ktyp),radwt(nrmn,ktyp),
     $             vatrad(nrmn,ktyp),vesrad(nrmn,ktyp),
     $             vxcrad(nrmn,ktyp),excrad(nrmn,ktyp),
     $             wkrad, wkrad(1, 8),wkrad(1, 9),wkrad(1,10),
     $                    wkrad(1,11),wkrad(1,12),wkrad(1,13) )
                else
                  if( nonzer.eq.0 ) goto 310
                endif
c
c               Angular loops:
c
                shlfac = fourpi*cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
c
                mli1 = 1
                do 420 mlj=1,norbshj
                  lj = lj0 + mlj
                  j = j0 + mlj
c
                  if( diagshl ) mli1 = mlj
                  do 410 mli=mli1,norbshi
                    li = li0 + mli
                    i = i0 + mli
c
c                   Evaluate contribution to matrix element (i,j)
c
                    call VLANG( vatij,vatint,
     $               vesij,vesint, vxcij,vxcint, excij,excint,
     $               p,lj,li,cj(1,lj),ci(1,li) )
c
                    fac = shlfac / ( vnorm(li)*vnorm(lj) )
c
c                   Multiply by bf factors, increment shell-block Hamiltonian
                    vesij = fac*vesij
                    vatij = fac*vatij
                    vxcij = fac*vxcij
                    excij = fac*excij
                    vessh(mli,mlj) = vessh(mli,mlj) + vesij
                    vijsh(mli,mlj) = vijsh(mli,mlj) + vatij
                    vxcsh(mli,mlj) = vxcsh(mli,mlj) + vxcij
                    excsh(mli,mlj) = excsh(mli,mlj) + excij
c
c                   Close angular loops:
  410             continue
  420           continue
c
c               Close alpha loops:
  310         continue
  320       continue
c
c           Angular loops:
c
            ij0 = ijstart + jorbat0*norbati + iorbat0
            ij0 = ij0 - norbati
            mli1 = 1
            do 425 mlj=1,norbshj
              jorbat = jorbat0 + mlj
              j = j0 + mlj
c
              ij0 = ij0 + norbati
              if( diagshl ) mli1 = mlj
              do 415 mli=mli1,norbshi
                iorbat = iorbat0 + mli
                i = i0 + mli
                ij = ij0 + mli
c
                vesij = vessh(mli,mlj)
                vatij = vijsh(mli,mlj)
                vxcij = vxcsh(mli,mlj)
                excij = excsh(mli,mlj)
c
                do  k=1,nk
C                  vloc0(k,i,j) = vloc0(k,i,j) + vatij*coskr(k,ilat)
                  vloc0(k,ij) = vloc0(k,ij) + vatij*coskr(k,ilat)
                enddo
                do  k=1,nk
C                  vxc0(k,i,j) = vxc0(k,i,j) + vxcij*coskr(k,ilat)
                  vxc0(k,ij) = vxc0(k,ij) + vxcij*coskr(k,ilat)
                enddo
                do  k=1,nk
C                  exc0(k,i,j) = exc0(k,i,j) + excij*coskr(k,ilat)
                  exc0(k,ij) = exc0(k,ij) + excij*coskr(k,ilat)
                enddo
c               On dec&sun, sep loops faster (stride?) - 13nov96-pas
                if( ncplx.eq.2 .and. i.ne.j )then
                  ijc = ij + matij
                  do  k=1,nk
C                    vloc0(k,j,i) = vloc0(k,j,i) + vatij*sinkr(k,ilat)
                    vloc0(k,ijc) = vloc0(k,ijc) + vatij*sinkr(k,ilat)
                  enddo
                  do  k=1,nk
C                    vxc0(k,j,i) = vxc0(k,j,i) + vxcij*sinkr(k,ilat)
                    vxc0(k,ijc) = vxc0(k,ijc) + vxcij*sinkr(k,ilat)
                  enddo
                  do  k=1,nk
C                    exc0(k,j,i) = exc0(k,j,i) + excij*sinkr(k,ilat)
                    exc0(k,ijc) = exc0(k,ijc) + excij*sinkr(k,ilat)
                  enddo
                endif
c
c               Close angular loops:
  415         continue
  425       continue
c
  799       continue
c           Close Atom i shell loop:
            i = i0 + norbshi
  800     continue
c
c         Close Atom i lattice loop:
  900   continue
c
c       Close Atom i loop:
 1000 continue
c
 1799   continue
c       Close Atom j shell loop:
        j = j0 + norbshj
 1800 continue
c
c       Close Atom j loop:
c
 2000 continue
c
c       Close Nucleus lattice loop:
c
 2900 continue
c
c       Close Nucleus loop:
c
 3000 continue
c
      if( nprocs.gt.1 )  call TIMER( '  vlocmat compute' )
c
c >>>> Reassamble final matrix
c
      if( Lmatreduce .and. nprocs .gt. 1 )then
c       Each local processor has full Hamiltonian over its share
c       of atomic potentials.
c       Reduce (sum) these to master to get total Hams.
c
c       Use the vtmp() as buffer for all reduces.
c
c       Reduce full local potential matrix:
        call MPREDUC8( master, nmat, vloc0, vtmp, icomm )
        call DCOPY( nmat, vtmp,1, vloc0,1 )
c
c       Reduce Vxc0 matrix:
        call MPREDUC8( master, nmat, vxc0, vtmp, icomm )
        call DCOPY( nmat, vtmp,1, vxc0,1 )
c
c       Reduce Exc0 matrix:
        call MPREDUC8( master, nmat, exc0, vtmp, icomm )
        call DCOPY( nmat, vtmp,1, exc0,1 )
c
        call TIMER( '  vlocmat Reduce ' )
c
c       The final output matrices are only on the master processor
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLOCMAT1
c
c
      subroutine VLOCMAT1( IWR,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat  ,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ alamin, norba, znuc,occsh,
     $ ratm, rlat,coskr,sinkr,
     $ nrd,nrad, radmsh,radwt, vatrad, vesrad,vxcrad,excrad, wkrad,
     $ vloc0,vxc0,exc0, vtmp )
c---------------------------------------------------------------
c Purpose: calculate electron-nuclear matrix elements for the
c          local part of the spherical reference potentials
c          for all but the 2-center I:N terms (done in "vlocmii")
c
c Written: P.A. Schultz, for v2.43, based on the routine "enij"
c          originally written by P.J. Feibelman
c
c Revision history:
c   7Sep08-PAS/2.62: switch ij-ji to natural order
c  18Jun07-PAS/2.60: merge tp and serial
c  29Jan07-PAS/2.60: clean up tp; put barrier between Reduces
c   6Jul06-APT/2.60: merged task parallel and image parallel
c  25Sep04-PAS/tp0.1: clean-up task-parallel routines.
c   DMC:  task parallel
c   7Mar02-PAS/2.52: ang constants extracted
c  22May01-PAS/2.47: condense radial scratch space
c   6Mar00-PAS/2.43: rename "vl" routines, "enij" to "vlocmat"
c  21Dec99-PAS/2.42: cosmetic clean-up
c  15Sep99-PAS/2.39: pack big workspace down + simple opt
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  14Sep98-PAS/2.27: compact temp orbital matrix
c  27Aug98-PAS/2.25: purge (N**7) triplet equivalences
c  11Aug98-PAS/2.24: match 3-center routines again
c  16Jul98-PAS/2.23: slow+occ cutoffs finally dealt with properly,
c                    split off I:N into separate routine (ENII),
c                    accomodate split basis
c  28Apr97-PAS/2.17: naming conventions
c  13NOv96-PAS/2.16: opt k-loops, k-first temp Ham arrays
c  29Sep95-PAS/2.13: fix F(N-II) shell-pruning, tighten cutoffs,
c                    extract k-dependent loops from bottom for opt
c   3Jun94-PAS/2.10: exc matrix install
c  18Jan94-PAS/2.04: full cleanup, match sij,tij,enij,ennloc
c  21Jun89-PAS: reorganized to extract SHTRNG out from under
c               angular loops
c---------------------------------------------------------------
c
c  Angular integrals are evaluated analytically
c  Radial integrals are evaluated numerically
c
c  Note that vij() matrix is incremented while the vxc/exc arrays
c  are effectively initialized here and are put out in vloc0 and vxc0.
c  They are output in vlocN(i,j,k) order, but are used as scratch
c  space in kij order, requiring some fast stepping.  If nk=1,
c  this order is identical, and can do some shortcuts.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, half=0.5d0 )
c
c Output arrays:
      DIMENSION  vloc0(nk,norb,norb)
      DIMENSION  vxc0(nk,norb,norb),exc0(nk,norb,norb)
      DIMENSION  vtmp(norb,norb,nk)
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $ nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp)
      DIMENSION  znuc(ntyp), occsh(nshld,ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp),radwt(nrd,ntyp)
      DIMENSION  vatrad(nrd,ntyp)
      DIMENSION  vesrad(nrd,ntyp),vxcrad(nrd,ntyp),excrad(nrd,ntyp)
c Scratch arrays:
      DIMENSION  wkrad(nrd,*)
c
c Local declarations:
c
      LOGICAL    keepsh, diagshl
      DIMENSION  vessh(5,5),vijsh(5,5),vxcsh(5,5),excsh(5,5)
      DIMENSION  rnuc(3),ri(3),rj(3), p(3), ci(10,9),cj(10,9)
      DIMENSION  vatint(5),vesint(5),vxcint(5),excint(5)
c
      DIMENSION  vnorm(9)
c lstout controls diagnostic output 0-none,1-minimal,n>1-more
      DATA  lstout  / 0 /
c---------------------------------------------------------------
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'SDEV/VLOCMAT1: ijkmat'
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxf = cutgwfn
      emaxsl = cutslow
c
      emxslo = emaxsl
c
      fourpi = pi + pi + pi + pi
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
      nmat = nk*norb*norb
c
      if( lstout.ne.0 )  write(IWR,9000)
 9000 format(/3x,'nuc  klat iatm',9x,'E(Z-Z)',12x,'E(E-Z)',12x,'TOT')
 9001 format(1x,'ENRI',3i3,2x,3f20.10)
 9002 format(5x,a,3i3,2x,f20.10)
 9003 format(5x,a,4i3,2x,f20.10)
c
      call MKZERO( nmat, vloc0 )
      call MKZERO( nmat, vxc0 )
      call MKZERO( nmat, exc0 )
c
c    Nucleus loop:
c
      do 3000 nuc=1,natm
c
c     Each processor will do every nprocs element in this loop.
      if( MOD( nuc, nprocs ) .ne. iproc ) goto 3000
c
      ktyp = itypa(nuc)
      if( znuc(ktyp).eq.zero ) goto 3000
c
      alaminn = two*alamin(ktyp)
      almin = 1.d9
      do  ishl=1,nocc(ktyp)
        occshl = occsh(ishl,ktyp)
        if( occshl.ne.zero )then
          do  ial=1,nalsh(ishl,ktyp)
            if( alsh(ial,ishl,ktyp).lt.almin ) almin=alsh(ial,ishl,ktyp)
          enddo
        endif
      enddo
      alaminn = two*almin
c
c    Nucleus lattice loop:
c
      do 2900 klat=1,nlat
c
      do  ir=1,3
        rnuc(ir) = ratm(ir,nuc) + rlat(ir,klat)
      enddo
c
c     Atom j loop:
c
      jnext = 0
      do 2000 jatm=1,natm
      jtyp = itypa(jatm)
      nshlj = numshl(jtyp)
      norbatj = norba(jtyp)
      jstart = jnext
      jnext = jstart + norbatj
c
      do  ir=1,3
        rj(ir) = ratm(ir,jatm) - rnuc(ir)
      enddo
      rjsquar = rj(1)*rj(1) + rj(2)*rj(2) + rj(3)*rj(3)
c
      alaminj = alamin(jtyp)
      emax = emxslo
      rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c     Test overlap of Atom j and short-range pot due to "nuc"
      if( rjsquar.gt.rjnmax ) goto 2000
c
      call CINIT( cj )
      call COFR( cj,rj )
c
c     Atom j shell loop:
c
      j = jstart
      do 1800 jshl=1,nshlj
      nalj = nala(jshl,jtyp)
      lshlj = lshel(jshl,jtyp)
      norbshj = 2*lshlj + 1
      lj0 = lshlj*lshlj
c
      j0 = j
c
      alminj = ala(1,jshl,jtyp)
      almaxj = ala(nalj,jshl,jtyp)
      do  jal=1,nalj
        alj = ala(jal,jshl,jtyp)
        if( alj.lt.alminj ) alminj = alj
        if( alj.gt.almaxj ) almaxj = alj
      enddo
      alaminj = alminj
c
      emax = emaxf
      if( almaxj.lt.alfast ) emax = emaxsl
      rjnmax = emax*(alaminj+alaminn) / (alaminj*alaminn)
c
c     Test whether this radial function will contribute:
      if( rjsquar.gt.rjnmax ) goto 1799
c
c     Atom i loop:
c
      inext = jstart
      do 1000 iatm=jatm,natm
        ityp = itypa(iatm)
        nshli = numshl(ityp)
        norbati = norba(ityp)
        istart = inext
        inext = istart + norbati
c
c       Following helps ensure only i.ge.j done:
        ilat1 = 1
        ishl1 = 1
        if( iatm.eq.jatm )then
          ilat1 = 2
          ishl1 = jshl
          do  ishl=1,ishl1-1
            lshli = lshel(ishl,ityp)
            norbshi = 2*lshli + 1
            istart = istart + norbshi
          enddo
        endif
c
        alamini = alamin(ityp)
c       Criterion for including contribution of Atom j:
        ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
        rijnmax = (emaxsl-ex)*(alaminj+alamini+alaminn) /
     $                      ( (alaminj+alaminn)*alamini )
c
c       Lattice vector loop for Atom i:
c
        do 900 ilat=ilat1,nlat2c
c
          do  ir=1,3
            ri(ir) = ratm(ir,iatm) + rlat(ir,ilat) - rnuc(ir)
          enddo
          risquar = ri(1)*ri(1) + ri(2)*ri(2) + ri(3)*ri(3)
c
          f1 = alaminj / (alaminj+alaminn)
          rijn0 = zero
          do  ir=1,3
            rijn0 = rijn0 + (f1*rj(ir)-ri(ir))**2
          enddo
c
c         Test for significant overlap of Atom j with i and nuc
          if( rijn0.gt.rijnmax ) goto 900
c
          call CINIT( ci )
          call COFR( ci,ri )
c
c         Atom i shell loop:
c
          i = istart
          do 800 ishl=ishl1,nshli
            nali = nala(ishl,ityp)
            lshli = lshel(ishl,ityp)
            norbshi = 2*lshli + 1
            li0 = lshli*lshli
c
            i0 = i
c
            diagshl = .false.
            if( i0.eq.j0 ) diagshl = .true.
c
            almini = ala(1,ishl,ityp)
            almaxi = ala(nali,ishl,ityp)
            do  ial=1,nali
              ali = ala(ial,ishl,ityp)
              if( ali.lt.almini ) almini = ali
              if( ali.gt.almaxi ) almaxi = ali
            enddo
c
            emax = emaxf
            if( almaxi.lt.alfast .and. almaxj.lt.alfast ) emax = emaxsl
c
            ex = rjsquar*alaminj*alaminn / (alaminj+alaminn)
            rijnmx = (emax-ex)*(alaminj+almini+alaminn) /
     $                       ( (alaminj+alaminn)*almini )
            if( rijn0.gt.rijnmx ) goto 799
c
            lmx = lshli + lshlj + 1
            call MKZERO( 25, vessh )
            call MKZERO( 25, vijsh )
            call MKZERO( 25, vxcsh )
            call MKZERO( 25, excsh )
c
c           Alpha loops:
c
            enijsum = zero
            coulsum = zero
            do 320 jal=1,nalj
              alj = ala(jal,jshl,jtyp)
c
c             Test whether this alpha contributes:
              rjnmx = emax*(alj+alaminn) / (alj*alaminn)
              if( rjsquar.gt.rjnmx ) goto 320
c
              fj1 = alj / (alj+alaminn)
              rijn = zero
              do  ir=1,3
                rijn = rijn + (fj1*rj(ir)-ri(ir))**2
              enddo
c
              do 310 ial=1,nali
                ali = ala(ial,ishl,ityp)
c
c               Test whether this pair of alphas contributes:
                ex = rjsquar*alj*alaminn / (alj+alaminn)
                rijnmx = (emax-ex)*(ali+alj+alaminn) /
     $                           ( (alj+alaminn)*ali )
                if( rijn.gt.rijnmx ) goto 310
c
                alsum = ali + alj
                exparg = ali*risquar + alj*rjsquar
                do  ir=1,3
                  p(ir) = two*(ali*ri(ir)+alj*rj(ir))
                enddo
                pmag = SQRT( p(1)*p(1)+p(2)*p(2)+p(3)*p(3) )
c
                call MKZERO( 5, vatint )
                call MKZERO( 5, vesint )
                call MKZERO( 5, vxcint )
                call MKZERO( 5, excint )
c
                nonzer = 0
c
c               "vlrad" computes the contributions of the xc-potentials
c               associated with atom nuc, as well as the difference between
c               the actual electrostatic potential due to the electrons of
c               atom nuc and 2.*abs(znuc)/r
c
                call NRSCUT( nrmn,nrmx,nrad(ktyp),argmx,
     $           exparg,pmag,alsum,radmsh(1,ktyp),wkrad )
c
                if( nrmx.gt.0 )then
c
c                 Evaluate radial integrals
c
                  nrlen = nrmx - nrmn + 1
                  call VLRAD( vatint, vesint,vxcint,excint,
     $             lmx,alsum,pmag,exparg,
     $             nrlen, radmsh(nrmn,ktyp),radwt(nrmn,ktyp),
     $             vatrad(nrmn,ktyp),vesrad(nrmn,ktyp),
     $             vxcrad(nrmn,ktyp),excrad(nrmn,ktyp),
     $             wkrad, wkrad(1, 8),wkrad(1, 9),wkrad(1,10),
     $                    wkrad(1,11),wkrad(1,12),wkrad(1,13) )
                else
                  if( nonzer.eq.0 ) goto 310
                endif
c
c               Angular loops:
c
                shlfac = fourpi*cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
c
                mli1 = 1
                do 420 mlj=1,norbshj
                  lj = lj0 + mlj
                  j = j0 + mlj
c
                  if( diagshl ) mli1 = mlj
                  do 410 mli=mli1,norbshi
                    li = li0 + mli
                    i = i0 + mli
c
c                   Evaluate contribution to matrix element (i,j)
c
                    call VLANG( vatij,vatint,
     $               vesij,vesint, vxcij,vxcint, excij,excint,
     $               p,lj,li,cj(1,lj),ci(1,li) )
c
                    fac = shlfac / ( vnorm(li)*vnorm(lj) )
c
c                   Multiply by bf factors, increment shell-block Hamiltonian
                    vesij = fac*vesij
                    vatij = fac*vatij
                    vxcij = fac*vxcij
                    excij = fac*excij
                    vessh(mli,mlj) = vessh(mli,mlj) + vesij
                    vijsh(mli,mlj) = vijsh(mli,mlj) + vatij
                    vxcsh(mli,mlj) = vxcsh(mli,mlj) + vxcij
                    excsh(mli,mlj) = excsh(mli,mlj) + excij
c
c                   Close angular loops:
  410             continue
  420           continue
c
c               Close alpha loops:
  310         continue
  320       continue
c
c           Angular loops:
c
            mli1 = 1
            do 425 mlj=1,norbshj
              j = j0 + mlj
c
              if( diagshl ) mli1 = mlj
              do 415 mli=mli1,norbshi
                i = i0 + mli
c
                vesij = vessh(mli,mlj)
                vatij = vijsh(mli,mlj)
                vxcij = vxcsh(mli,mlj)
                excij = excsh(mli,mlj)
c
                do  k=1,nk
                  vloc0(k,i,j) = vloc0(k,i,j) + vatij*coskr(k,ilat)
                enddo
                do  k=1,nk
                  vxc0(k,i,j) = vxc0(k,i,j) + vxcij*coskr(k,ilat)
                enddo
                do  k=1,nk
                  exc0(k,i,j) = exc0(k,i,j) + excij*coskr(k,ilat)
                enddo
c               On dec&sun, sep loops faster (stride?) - 13nov96-pas
                if( ncplx.eq.2 .and. i.ne.j )then
                  do  k=1,nk
                    vloc0(k,j,i) = vloc0(k,j,i) + vatij*sinkr(k,ilat)
                  enddo
                  do  k=1,nk
                    vxc0(k,j,i) = vxc0(k,j,i) + vxcij*sinkr(k,ilat)
                  enddo
                  do  k=1,nk
                    exc0(k,j,i) = exc0(k,j,i) + excij*sinkr(k,ilat)
                  enddo
                endif
c
c               Close angular loops:
  415         continue
  425       continue
c
  799       continue
c           Close Atom i shell loop:
            i = i0 + norbshi
  800     continue
c
c         Close Atom i lattice loop:
  900   continue
c
c       Close Atom i loop:
 1000 continue
c
 1799   continue
c       Close Atom j shell loop:
        j = j0 + norbshj
 1800 continue
c
c       Close Atom j loop:
c
 2000 continue
c
c       Close Nucleus lattice loop:
c
 2900 continue
c
c       Close Nucleus loop:
c
 3000 continue
c
c >>>> Reassamble final matrix
c
      if( nprocs .gt. 1 )then
        call TIMER( '  vlocmat compute' )
c
c       Each local processor has full Hamiltonian over its share
c       of atomic potentials.
c       Reduce (sum) these to master to get total Hams.
c
c       Use the vtmp() as buffer for all reduces.
c
c       Reduce full local potential matrix:
        call MPREDUC8( master, nmat, vloc0, vtmp, icomm )
        call DCOPY( nmat, vtmp,1, vloc0,1 )
c
c       Reduce Vxc0 matrix:
        call MPREDUC8( master, nmat, vxc0, vtmp, icomm )
        call DCOPY( nmat, vtmp,1, vxc0,1 )
c
c       Reduce Exc0 matrix:
        call MPREDUC8( master, nmat, exc0, vtmp, icomm )
        call DCOPY( nmat, vtmp,1, exc0,1 )
c
        call TIMER( '  vlocmat Reduce ' )
c
c       The final output matrices are only on the master processor
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLOCMII
c
c
      subroutine VLOCMII( IWR, atm0engy,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat  ,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ alamin, norba, znuc,occsh,occij,
     $ ratm, rlat,coskr,sinkr,
     $ nrd,nrad, radmsh,radwt, vatrad, vesrad,vxcrad,excrad, wkrad,
     $ vloc0,vxc0,exc0, vtmp )
c---------------------------------------------------------------
c Purpose: calculate electron-nuclear matrix elements for the
c          local part of the spherical reference potentials
c          for all 2-center II:N terms.
c
c Written: Peter A. Schultz, 20-July-1988, for v2.23e
c
c Revision history:
c  17Oct08-PAS/2.62: stripe-distributed-parallel
c  20Jun07-PAS/2.60: merged tp and serial
c   6Jul06-APT/2.59: merged task parallel and image parallel
c  17Oct04-PAS/2.59: task-parallel
c   7Mar02-PAS/2.52: ang constants extracted
c  22May01-PAS/2.47: condense radial scratch space
c   4Mar00-PAS/2.43: memory bugfix; rename "vl" routines;
c                    "enii" to "vlocmii"
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  14Sep98-PAS/2.27: compact temp orbital matrix store
c  27Aug98-PAS/2.25: purge (N**7) triplet equivalences
c  11Aug98-PAS/2.24: match 3-center routines again
c  20Jul98-PAS/2.23: I:N split from ENIJ; split basis
c---------------------------------------------------------------
c
c  Angular integrals are evaluated analytically
c  Radial integrals are evaluated numerically
c
c  The temp matrix stores only really need the upper triangle,
c  but the bookkeeping gets painful given the ji loop structure
c  in this routine and the ij matrix structure.  While perhaps
c  wasteful, the current square atom block scheme is cheap and easy.
c
c  vlocmiii/tp task-parallel is different - here we parallelize
c  over atoms rather than over nuclear potentials, to reduce the
c  amount of communication needed at the end to assemble final matrix
c
cpas: Coding caution: occij() is not symmetric!!!
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, half=0.5d0 )
c
c Output arrays:
      DIMENSION  vloc0(*)
      DIMENSION  vxc0(*), exc0(*)
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $  nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp)
      DIMENSION  znuc(ntyp), occsh(nshld,ntyp),occij(nshld,nshld,ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp),radwt(nrd,ntyp)
      DIMENSION  vatrad(nrd,ntyp)
      DIMENSION  vesrad(nrd,ntyp),vxcrad(nrd,ntyp),excrad(nrd,ntyp)
c Scratch arrays:
      DIMENSION  wkrad(nrd,*)
      DIMENSION  vtmp(3,*)
c
c Local declarations:
c
      LOGICAL    Lijkmats,Lstrmats
      LOGICAL    keepsh, diagshl
      DIMENSION  vessh(5,5),vijsh(5,5),vxcsh(5,5),excsh(5,5)
      DIMENSION  rnuc(3),rj(3), p(3), cj(10,9)
      DIMENSION  vatint(5),vesint(5),vxcint(5),excint(5)
c
      DIMENSION  vnorm(9)
c lstout controls diagnostic output 0-none,1-minimal,n>1-more
      DATA  lstout  / 0 /
c---------------------------------------------------------------
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'SDEV/VLOCMII: stripe-parallel'
      atm0enii = zero
      Lijkmats = .false.
      Lstrmats = .true.
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxii = cutii
      emax = emaxii
c
      fourpi = pi + pi + pi + pi
c
c  Get local MP info:
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
c  Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
c  Figure out how much belongs on local processor:
      call MATLOCSTR( iproc,nprocs,nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c
c  Count up temp storage need (atom block diagonal):
      iv1locl = 1
      nvlocl = 0
      nvtmp = 0
      do  jatm=1,natm
        jtyp = itypa(jatm)
        norbat = norba(jtyp)
        nvtmp = nvtmp + norbat**2
c       Count up how much will sit on this local proc.
        if( jatm.ge.myatm1 .and. jatm.le.myatm2 )
     $   nvlocl = nvlocl + norbat**2
      enddo
c
c  This is how much sits on this local processor
      nvlocl = 3*nvlocl
      call MKZERO( nvlocl, vtmp )
c
      if( lstout.ne.0 )  write(IWR,9000)
 9000 format(/3x,'nuc  klat jatm',9x,'E(Z-Z)',12x,'E(E-Z)',12x,'TOT')
 9001 format(1x,'ENRI',3i3,2x,3f20.10)
 9002 format(5x,a,3i3,2x,f20.10)
 9003 format(5x,a,4i3,2x,f20.10)
c
c    Nucleus loop:
c
      do 3000 nuc=1,natm
c
      ktyp = itypa(nuc)
      if( znuc(ktyp).eq.zero ) goto 3000
c
      alaminn = two*alamin(ktyp)
      almin = 1.d9
      do  ishl=1,nocc(ktyp)
        occshl = occsh(ishl,ktyp)
        if( occshl.ne.zero )then
          do  ial=1,nalsh(ishl,ktyp)
            if( alsh(ial,ishl,ktyp).lt.almin ) almin=alsh(ial,ishl,ktyp)
          enddo
        endif
      enddo
      alaminn = two*almin
c
c    Nucleus lattice loop:
c
      do 2900 klat=1,nlat
c
      do  ir=1,3
        rnuc(ir) = ratm(ir,nuc) + rlat(ir,klat)
      enddo
c
c     Atom j loop:
c
      ijnext = 0
      jnext = 0
ctp      do 2000 jatm=1,natm
      do 2000 jatm=myatm1,myatm2
        jtyp = itypa(jatm)
        nshlj = numshl(jtyp)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
        ij00 = ijnext
        ijnext = ij00 + norbatj**2
c
        do  ir=1,3
          rj(ir) = ratm(ir,jatm) - rnuc(ir)
        enddo
        rjsquar = rj(1)*rj(1) + rj(2)*rj(2) + rj(3)*rj(3)
c
        alaminj = alamin(jtyp)
        rjnmax = emax*(alaminj+alaminj+alaminn) /
     $              ( (alaminj+alaminj)*alaminn )
        almina = alaminj
c
c       Test overlap of Atom j and short-range pot due to "nuc"
        if( rjsquar.gt.rjnmax ) goto 2000
c
        edelij = zero
        engyzz = zero
c
        if( klat.ne.1 .or. jatm.ne.nuc )then
c         Add nuc-jatm core repulsion to delta-energy.
c         Note: skipped IF no nuc:jatm overlap
c         (electronic and nuclear contributions cancel).
          zj = znuc(jtyp)
          do 28 jshl=1,nshlj
c
            norbshj = 2*lshel(jshl,jtyp) + 1
            alminj = ala(1,jshl,jtyp)
            do  jal=2,nala(jshl,jtyp)
              alj = ala(jal,jshl,jtyp)
              if( alj.lt.alminj ) alminj = alj
            enddo
c
            do 26 ishl=1,jshl
c
c             NOTE: (1) ishl and jshl must have same angular momentum
c              and (2) z contribution is in occij(is,js.le.is,ityp)
              occshl = norbshj*occij(ishl,jshl,jtyp)
              if( occshl.eq.zero ) goto 26
c
              almini = ala(1,ishl,jtyp)
              do  ial=2,nala(ishl,jtyp)
                ali = ala(ial,ishl,jtyp)
                if( ali.lt.almini ) almini = ali
              enddo
              alsum = almini + alminj
              rjsmax = emax*(alsum+alaminn) / (alsum*alaminn)
              if( rjsquar.gt.rjsmax )  zj = zj - occshl
   26       continue
c
   28     continue
          zztot = znuc(ktyp)*zj
c
          engyadd = zztot / SQRT( rjsquar )
          atm0enii = atm0enii + engyadd
          engyzz = engyadd
          if( lstout.ge.2 ) write(IWR,9002) 'nuc,klat,jatm,E(Z-Z)=',
     $                                       nuc,klat,jatm,engyzz
        endif
c
        call CINIT( cj )
        call COFR( cj,rj )
c
c       Atom shell loop:
c
        jorbatnxt = 0
        j = jstart
        do 1800 jshl=1,nshlj
          nalj = nala(jshl,jtyp)
          lshlj = lshel(jshl,jtyp)
          norbshj = 2*lshlj + 1
          lj0 = lshlj*lshlj
c
          j0 = j
          jorbat0 = jorbatnxt
          jorbatnxt = jorbat0 + norbshj
c
          alminj = ala(1,jshl,jtyp)
          almaxj = ala(nalj,jshl,jtyp)
          do  jal=1,nalj
            alj = ala(jal,jshl,jtyp)
            if( alj.lt.alminj ) alminj = alj
            if( alj.gt.almaxj ) almaxj = alj
          enddo
          alaminj = alminj
c
          alsum = alminj + almina
          rjnmax = emax*(alsum+alaminn) / (alsum*alaminn )
c
c         Test whether this radial function will contribute:
          if( rjsquar.gt.rjnmax ) goto 1799
c
          iatm = jatm
          ityp = jtyp
          istart = jstart
          ishl1 = jshl
          do  ishl=1,ishl1-1
            lshli = lshel(ishl,ityp)
            norbshi = 2*lshli + 1
            istart = istart + norbshi
          enddo
c
c         Atom shell loop-2:
c
          iorbat0 = jorbat0
          ij0 = ij00 + jorbat0*norbatj + iorbat0
          i = istart
          do 800 ishl=ishl1,nshlj
            nali = nala(ishl,ityp)
            lshli = lshel(ishl,ityp)
            norbshi = 2*lshli + 1
            li0 = lshli*lshli
c
            i0 = i
            ijstart = ij0
            ij0 = ijstart + norbshi
c
            diagshl = .false.
            if( i0.eq.j0 ) diagshl = .true.
c
            almini = ala(1,ishl,ityp)
            do  ial=2,nali
              ali = ala(ial,ishl,ityp)
              if( ali.lt.almini ) almini = ali
            enddo
c
            rijnmax = emax*(alaminj+almini+alaminn) /
     $                   ( (alaminj+almini)*alaminn )
            if( rjsquar.gt.rijnmax ) goto 799
c
            keepsh = .false.
c           NOTE: z contribution is in occij(is,js.le.is,ityp)
            occ = occij(ishl,jshl,jtyp)
            if( occij(ishl,jshl,jtyp).ne.zero )then
              keepsh = .true.
c             Double off-diags - only doing one side of triangle
              if( ishl.ne.jshl ) occ = occ + occ
            endif
c
            lmx = lshli + lshlj + 1
            call MKZERO( 25, vessh )
            call MKZERO( 25, vijsh )
            call MKZERO( 25, vxcsh )
            call MKZERO( 25, excsh )
c
c           Alpha loops:
c
            enijsum = zero
            coulsum = zero
            do 320 jal=1,nalj
              alj = ala(jal,jshl,jtyp)
c
              do 310 ial=1,nali
                ali = ala(ial,ishl,ityp)
c
c               Test whether this pair of alphas contributes:
                rijnmx = emax*(alj+ali+alaminn) /
     $                      ( (alj+ali)*alaminn )
                if( rjsquar.gt.rijnmx .and. .not. keepsh ) goto 310
c
                alsum = ali + alj
                exparg = ali*rjsquar + alj*rjsquar
                do  ir=1,3
                  p(ir) = two*(ali*rj(ir)+alj*rj(ir))
                enddo
                pmag = SQRT( p(1)*p(1)+p(2)*p(2)+p(3)*p(3) )
c
                call MKZERO( 5, vatint )
                call MKZERO( 5, vesint )
                call MKZERO( 5, vxcint )
                call MKZERO( 5, excint )
c
                nonzer = 0
                argtst = exparg - 0.25*pmag*pmag/alsum
c
                  if( argtst.gt.argmx ) goto 310
                  nonzer = 1
                  expfac = zero
                  if( exparg.lt.argmx ) expfac =  EXP( -exparg )
                  call VLRADZ( vesint,lmx,alsum,pmag,znuc(ktyp),
     $                         exparg,expfac )
c
c               "vlradz" puts the matrix element of 2.*znuc/r into vesint() for
c                self-energy correction term to vatint(), "vlrad" adds the
c                contributions of the xc-potential associated with atom nuc,
c                as well as the difference between the actual electrostatic
c                potential due to the electrons of atom nuc and 2.*abs(znuc)/r
c
                call NRSCUT( nrmn,nrmx,nrad(ktyp),argmx,
     $           exparg,pmag,alsum,radmsh(1,ktyp),wkrad )
c
                if( nrmx.gt.0 )then
c
c                 Evaluate radial integrals
c
                  nrlen = nrmx - nrmn + 1
                  call VLRAD( vatint, vesint,vxcint,excint,
     $             lmx,alsum,pmag,exparg,
     $             nrlen, radmsh(nrmn,ktyp),radwt(nrmn,ktyp),
     $             vatrad(nrmn,ktyp),vesrad(nrmn,ktyp),
     $             vxcrad(nrmn,ktyp),excrad(nrmn,ktyp),
     $             wkrad, wkrad(1, 8),wkrad(1, 9),wkrad(1,10),
     $                    wkrad(1,11),wkrad(1,12),wkrad(1,13) )
                else
                  if( nonzer.eq.0 ) goto 310
                endif
c
c               Angular loops:
c
                shlfac = fourpi*cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
c
                mli1 = 1
                do 420 mlj=1,norbshj
                  lj = lj0 + mlj
                  j = j0 + mlj
c
                  if( diagshl ) mli1 = mlj
                  do 410 mli=mli1,norbshi
                    li = li0 + mli
                    i = i0 + mli
c
c                   Evaluate contribution to matrix element (i,j)
c
                    call VLANG( vatij,vatint,
     $               vesij,vesint, vxcij,vxcint, excij,excint,
     $               p,lj,li,cj(1,lj),cj(1,li) )
c
                    fac = shlfac / ( vnorm(li)*vnorm(lj) )
c
c                   Multiply by bf factors, increment shell-block Hamiltonian
                    vesij = fac*vesij
                    vatij = fac*vatij
                    vxcij = fac*vxcij
                    excij = fac*excij
                    vessh(mli,mlj) = vessh(mli,mlj) + vesij
                    vijsh(mli,mlj) = vijsh(mli,mlj) + vatij
                    vxcsh(mli,mlj) = vxcsh(mli,mlj) + vxcij
                    excsh(mli,mlj) = excsh(mli,mlj) + excij
c
c                   Close angular loops:
  410             continue
  420           continue
c
c               Close alpha loops:
  310         continue
  320       continue
c
            ijs = ijstart
            mli1 = 1
            do 425 mlj=1,norbshj
              lj = lj0 + mlj
              j = j0 + mlj
c
              ijs0 = ijs
              ijs = ijs + norbatj
              if( diagshl ) mli1 = mlj
              do 415 mli=mli1,norbshi
                li = li0 + mli
                i = i0 + mli
                ij = ijs0 + mli
c
                vesij = vessh(mli,mlj)
                vtmp(1,ij) = vtmp(1,ij) + vijsh(mli,mlj)
                vtmp(2,ij) = vtmp(2,ij) + vxcsh(mli,mlj)
                vtmp(3,ij) = vtmp(3,ij) + excsh(mli,mlj)
c
                if( keepsh .and. li.eq.lj )then
c                 Subtract from delta-E: spherical charge times itself
                  engyadd = -half*occ*vesij
                  atm0enii = atm0enii + engyadd
                  edelij = edelij + engyadd
                  if( lstout.ge.3 ) write(IWR,9003)
     $             '    li,lj,ial,jal,E(Z-e)=',li,lj,ial,jal,engyadd
                endif
c
  415         continue
  425       continue
c
  799       continue
c           Close Atom shell loop-2:
            i = i0 + norbshi
  800     continue
c
 1799     continue
c         Close Atom shell loop-1:
          j = j0 + norbshj
 1800   continue
c
        if( lstout.gt.0 .and. (engyzz.ne.zero.or.edelij.ne.zero) )
     $    write(IWR,9001) nuc,klat,jatm,engyzz,edelij,engyzz+edelij
c
c       Close Atom j loop:
 2000 continue
c
c       Close Nucleus lattice loop:
c
 2900 continue
c
c       Close Nucleus potential loop:
c
 3000 continue
c
      if( nprocs .gt. 1 ) call TIMER( '  vlocmii compute' )
c
      if( nprocs .gt. 1 )then
c       Assemble the sum of atm0 terms:
        nreduc = 1
        call MPREDUC8( master, nreduc, atm0enii, eiitmp, icomm )
        atm0enii = eiitmp
        call MPBCAST8( master, nreduc, atm0enii, icomm )
      endif
      atm0engy = atm0engy + atm0enii
c
      if( Lijkmats )then
c       Move results into standard H(i,j,k) storage ...
        if( iproc.lt.nprocstr )then
c         Merge the results onto the master/root node
          call MPMERGER8( nprocstr, master, iproc,
     $       nvtmp,iv1locl,nvlocl, vtmp, icomm )
c          ... and broadcast it to everyone
          call MPBCAST8( master, nvtmp, vtmp, icomm )
        endif
c       Put contributions to Ham into ijk matrix:
        call IIPUTIJK( norb,nk,ncplx, natm,ntyp,itypa,norba,
     $   vloc0,vxc0,exc0, vtmp )
c
      elseif( Lstrmats )then
c       Move results into distributed stripe storage ...
        if( iproc.lt.nprocstr )
     $  call IIPUTSTR( norb,nk,ncplx, natm,ntyp,itypa,norba,
     $   myj0,myatm1,myatm2,
     $   vloc0,vxc0,exc0, vtmp )
c
      else
c       No other alternatives right now ...
        call STOPXERR( 'invalid vlocmii merge - code error' )
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> IIPUTIJK
c
c
      subroutine IIPUTIJK( norb,nk,ncplx, natm,ntyp,itypa,norba,
     $ vloc0,vxc0,exc0, vtmp )
c---------------------------------------------------------------
c Purpose: put diagonal atom block vlocmii into vloc(i,j,k) matrices
c Written: Peter A. Schultz, 8-October-2008, for 2.62
c Revision history:
c   8Oct08-PAS/2.62: pushed down from vlocmii
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Output arrays:
      DIMENSION  vloc0(norb,norb,nk)
      DIMENSION  vxc0(norb,norb,nk),exc0(norb,norb,nk)
c Input arrays:
      DIMENSION  vtmp(3,*)
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c >>>> EXECUTABLE CODE:
c
      do  k=1,nk
c
        j0 = 0
        ijnext = 0
        do 1000 jatm=1,natm
          jtyp = itypa(jatm)
          norbatj = norba(jtyp)
c
          j = j0
          ij = ijnext
          ijnext = ijnext + norbatj**2
c
          do 420 jorbat=1,norbatj
            i = j
            j = j + 1
            do 410 iorbat=jorbat,norbatj
              i = i + 1
              ij = ij + 1
c
              vloc0(i,j,k) = vloc0(i,j,k) + vtmp(1,ij)
              vxc0(i,j,k) = vxc0(i,j,k) + vtmp(2,ij)
              exc0(i,j,k) = exc0(i,j,k) + vtmp(3,ij)
c
  410       continue
            ij = ij + jorbat
  420     continue
c
          j0 = j0 + norbatj
c
 1000   continue
c
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> IIPUTKIJ
c
c
      subroutine IIPUTKIJ( norb,nk,ncplx, natm,ntyp,itypa,norba,
     $ vloc0,vxc0,exc0, vtmp )
c---------------------------------------------------------------
c Purpose: put diagonal atom block vlocmii into vloc(k,i,j) matrices
c Written: Peter A. Schultz, 8-October-2008, for 2.62
c Revision history:
c   8Oct08-PAS/2.62: pushed down from vlocmii
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Output arrays:
      DIMENSION  vloc0(nk,norb,norb)
      DIMENSION  vxc0(nk,norb,norb),exc0(nk,norb,norb)
c Input arrays:
      DIMENSION  vtmp(3,*)
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c >>>> EXECUTABLE CODE:
c
        j0 = 0
        ijnext = 0
        do 1000 jatm=1,natm
          jtyp = itypa(jatm)
          norbatj = norba(jtyp)
c
          j = j0
          ij = ijnext
          ijnext = ijnext + norbatj**2
c
          do 420 jorbat=1,norbatj
            i = j
            j = j + 1
            do 410 iorbat=jorbat,norbatj
              i = i + 1
              ij = ij + 1
c
              do  k=1,nk
                vloc0(k,i,j) = vloc0(k,i,j) + vtmp(1,ij)
                vxc0(k,i,j) = vxc0(k,i,j) + vtmp(2,ij)
                exc0(k,i,j) = exc0(k,i,j) + vtmp(3,ij)
              enddo
c
  410       continue
            ij = ij + jorbat
  420     continue
c
          j0 = j0 + norbatj
c
 1000   continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> IIPUTSTR
c
c
      subroutine IIPUTSTR( norb,nk,ncplx, natm,ntyp,itypa,norba,
     $ myj0,myatm1,myatm2,
     $ vloc0,vxc0,exc0, vtmp )
c---------------------------------------------------------------
c Purpose: put diagonal atom block vlocmii into vloc(stripe) arrays
c Written: Peter A. Schultz, 8-October-2008, for 2.62
c Revision history:
c   none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Output arrays:
      DIMENSION  vloc0(nk,*)
      DIMENSION  vxc0(nk,*), exc0(nk,*)
c Input arrays:
      DIMENSION  vtmp(3,*)
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c >>>> EXECUTABLE CODE:
c
        iivlnext = 0
        jjnext = 0
        jnext = myj0
        do 1000 jatm=myatm1,myatm2
          jtyp = itypa(jatm)
          norbatj = norba(jtyp)
          jstart = jnext
          jnext = jstart + norbatj
c
          njstripe = norb - jstart
          matjstr = norbatj*njstripe
          jjstart = jjnext
          jjnext = jjstart + matjstr*ncplx
c
          j0 = jstart
          i0 = jstart
c
          ij0 = jjstart
          ij0 = ij0 - norbatj
c
          iivl = iivlnext
          iivlnext = iivlnext + norbatj**2
c
          do 420 jorbat=1,norbatj
            j = j0 + jorbat
c
            ij0 = ij0 + norbatj
            do 410 iorbat=jorbat,norbatj
              i = i0 + iorbat
              ij = ij0 + iorbat
              iivl = iivl + 1
c
              do  k=1,nk
                vloc0(k,ij) = vloc0(k,ij) + vtmp(1,iivl)
                vxc0(k,ij) = vxc0(k,ij) + vtmp(2,iivl)
                exc0(k,ij) = exc0(k,ij) + vtmp(3,iivl)
              enddo
c
  410       continue
            iivl = iivl + jorbat
  420     continue
c
 1000   continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLOCMII1
c
c
      subroutine VLOCMII1( IWR, atm0engy,
     $ norb,nk,ncplx, natm,ntyp,nshld,nald, nlat  ,nlat2c,
     $ itypa, numshl,lshel,nala,ala,cala, nocc,locc,nalsh,alsh,calsh,
     $ alamin, norba, znuc,occsh,occij,
     $ ratm, rlat,coskr,sinkr,
     $ nrd,nrad, radmsh,radwt, vatrad, vesrad,vxcrad,excrad, wkrad,
     $ vloc0,vxc0,exc0, vtmp )
c---------------------------------------------------------------
c Purpose: calculate electron-nuclear matrix elements for the
c          local part of the spherical reference potentials
c          for all 2-center II:N terms.
c
c Written: Peter A. Schultz, 20-July-1988, for v2.23e
c
c Revision history:
c   7Sep08-PAS/2.62: switch ij-ji to natural order
c  20Jun07-PAS/2.60: merged tp and serial
c   6Jul06-APT/2.59: merged task parallel and image parallel
c  17Oct04-PAS/2.59: task-parallel
c   7Mar02-PAS/2.52: ang constants extracted
c  22May01-PAS/2.47: condense radial scratch space
c   4Mar00-PAS/2.43: memory bugfix; rename "vl" routines;
c                    "enii" to "vlocmii"
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  14Sep98-PAS/2.27: compact temp orbital matrix store
c  27Aug98-PAS/2.25: purge (N**7) triplet equivalences
c  11Aug98-PAS/2.24: match 3-center routines again
c  20Jul98-PAS/2.23: I:N split from ENIJ; split basis
c---------------------------------------------------------------
c
c  Angular integrals are evaluated analytically
c  Radial integrals are evaluated numerically
c
c  The temp matrix stores only really need the upper triangle,
c  but the bookkeeping gets painful given the ji loop structure
c  in this routine and the ij matrix structure.  While perhaps
c  wasteful, the current square atom block scheme is cheap and easy.
c
c  vlocmiii/tp task-parallel is different - here we parallelize
c  over atoms rather than over nuclear potentials, to reduce the
c  amount of communication needed at the end to assemble final matrix
c
cpas: Coding caution: occij() is not symmetric!!!
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, half=0.5d0 )
c
c Output arrays:
      DIMENSION  vloc0(nk,norb,norb)
      DIMENSION  vxc0(nk,norb,norb),exc0(nk,norb,norb)
c Input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nocc(ntyp),locc(nshld,ntyp),
     $  nalsh(nshld,ntyp),alsh(nald,nshld,ntyp),calsh(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), norba(ntyp)
      DIMENSION  znuc(ntyp), occsh(nshld,ntyp),occij(nshld,nshld,ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat),coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp),radwt(nrd,ntyp)
      DIMENSION  vatrad(nrd,ntyp)
      DIMENSION  vesrad(nrd,ntyp),vxcrad(nrd,ntyp),excrad(nrd,ntyp)
c Scratch arrays:
      DIMENSION  wkrad(nrd,*)
      DIMENSION  vtmp(3,*)
c
c Local declarations:
c
      LOGICAL    keepsh, diagshl
      DIMENSION  vessh(5,5),vijsh(5,5),vxcsh(5,5),excsh(5,5)
      DIMENSION  rnuc(3),rj(3), p(3), cj(10,9)
      DIMENSION  vatint(5),vesint(5),vxcint(5),excint(5)
c
      DIMENSION  vnorm(9)
c lstout controls diagnostic output 0-none,1-minimal,n>1-more
      DATA  lstout  / 0 /
c---------------------------------------------------------------
c
c >>>> EXECUTABLE CODE:
c
C      write(6,*) 'SDEV/VLOCMII1: ijkmat'
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutgaus
      emaxii = cutii
      emax = emaxii
c
      fourpi = pi + pi + pi + pi
c
c  Get local MP info:
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c  nprocl: number of processors in this local image
      nprocl = nprocs
c  iprocl0: master/root node of set of processors in this image
      iprocl0 = master
      iprocl = iproc - iprocl0
c
c Set up task-parallel decomposition over atoms.
c  Rather than doing MOD( jatm, nproc ), will do block-wise
c  distribution to simplify fusion of final matrix.
      natmpr = natm / nprocl
      nprocbig = natm - nprocl*natmpr
      nprocsml = nprocl - nprocbig
c     Here, I assume that iprocl is sequential beginning with 0.
      if( iprocl .ge. nprocsml ) natmpr = natmpr + 1
      jatm1 = 1 + iprocl*natmpr
      if( iprocl .ge. nprocsml ) jatm1 = jatm1 - nprocsml
      jatmn = jatm1 + natmpr - 1
      iv1locl = 1
      nvlocl = 0
c
      atm0enii = zero
c  Count up temp storage need (atom block diagonal):
      nvtmp = 0
      do  jatm=1,natm
        jtyp = itypa(jatm)
        norbat = norba(jtyp)
        nvtmp = nvtmp + norbat**2
c       Count up how much will sit on this local proc.
        if( jatm.ge.jatm1 .and. jatm.le.jatmn )
     $   nvlocl = nvlocl + norbat**2
      enddo
c
c  This is how much sits on this local processor
      nvlocl = 3*nvlocl
c
      nvtmp = 3*nvtmp
      call MKZERO( nvtmp, vtmp )
c
      if( lstout.ne.0 )  write(IWR,9000)
 9000 format(/3x,'nuc  klat jatm',9x,'E(Z-Z)',12x,'E(E-Z)',12x,'TOT')
 9001 format(1x,'ENRI',3i3,2x,3f20.10)
 9002 format(5x,a,3i3,2x,f20.10)
 9003 format(5x,a,4i3,2x,f20.10)
c
c    Nucleus loop:
c
      do 3000 nuc=1,natm
c
      ktyp = itypa(nuc)
      if( znuc(ktyp).eq.zero ) goto 3000
c
      alaminn = two*alamin(ktyp)
      almin = 1.d9
      do  ishl=1,nocc(ktyp)
        occshl = occsh(ishl,ktyp)
        if( occshl.ne.zero )then
          do  ial=1,nalsh(ishl,ktyp)
            if( alsh(ial,ishl,ktyp).lt.almin ) almin=alsh(ial,ishl,ktyp)
          enddo
        endif
      enddo
      alaminn = two*almin
c
c    Nucleus lattice loop:
c
      do 2900 klat=1,nlat
c
      do  ir=1,3
        rnuc(ir) = ratm(ir,nuc) + rlat(ir,klat)
      enddo
c
c     Atom j loop:
c
      ijnext = 0
      jnext = 0
ctp      do 2000 jatm=1,natm
      do 2000 jatm=jatm1,jatmn
        jtyp = itypa(jatm)
        nshlj = numshl(jtyp)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
        ij00 = ijnext
        ijnext = ij00 + norbatj**2
c
        do  ir=1,3
          rj(ir) = ratm(ir,jatm) - rnuc(ir)
        enddo
        rjsquar = rj(1)*rj(1) + rj(2)*rj(2) + rj(3)*rj(3)
c
        alaminj = alamin(jtyp)
        rjnmax = emax*(alaminj+alaminj+alaminn) /
     $              ( (alaminj+alaminj)*alaminn )
        almina = alaminj
c
c       Test overlap of Atom j and short-range pot due to "nuc"
        if( rjsquar.gt.rjnmax ) goto 2000
c
        edelij = zero
        engyzz = zero
c
        if( klat.ne.1 .or. jatm.ne.nuc )then
c         Add nuc-jatm core repulsion to delta-energy.
c         Note: skipped IF no nuc:jatm overlap
c         (electronic and nuclear contributions cancel).
          zj = znuc(jtyp)
          do 28 jshl=1,nshlj
c
            norbshj = 2*lshel(jshl,jtyp) + 1
            alminj = ala(1,jshl,jtyp)
            do  jal=2,nala(jshl,jtyp)
              alj = ala(jal,jshl,jtyp)
              if( alj.lt.alminj ) alminj = alj
            enddo
c
            do 26 ishl=1,jshl
c
c             NOTE: (1) ishl and jshl must have same angular momentum
c              and (2) z contribution is in occij(is,js.le.is,ityp)
              occshl = norbshj*occij(ishl,jshl,jtyp)
              if( occshl.eq.zero ) goto 26
c
              almini = ala(1,ishl,jtyp)
              do  ial=2,nala(ishl,jtyp)
                ali = ala(ial,ishl,jtyp)
                if( ali.lt.almini ) almini = ali
              enddo
              alsum = almini + alminj
              rjsmax = emax*(alsum+alaminn) / (alsum*alaminn)
              if( rjsquar.gt.rjsmax )  zj = zj - occshl
   26       continue
c
   28     continue
          zztot = znuc(ktyp)*zj
c
          engyadd = zztot / SQRT( rjsquar )
          atm0enii = atm0enii + engyadd
          engyzz = engyadd
          if( lstout.ge.2 ) write(IWR,9002) 'nuc,klat,jatm,E(Z-Z)=',
     $                                       nuc,klat,jatm,engyzz
        endif
c
        call CINIT( cj )
        call COFR( cj,rj )
c
c       Atom shell loop:
c
        jorbatnxt = 0
        j = jstart
        do 1800 jshl=1,nshlj
          nalj = nala(jshl,jtyp)
          lshlj = lshel(jshl,jtyp)
          norbshj = 2*lshlj + 1
          lj0 = lshlj*lshlj
c
          j0 = j
          jorbat0 = jorbatnxt
          jorbatnxt = jorbat0 + norbshj
c
          alminj = ala(1,jshl,jtyp)
          almaxj = ala(nalj,jshl,jtyp)
          do  jal=1,nalj
            alj = ala(jal,jshl,jtyp)
            if( alj.lt.alminj ) alminj = alj
            if( alj.gt.almaxj ) almaxj = alj
          enddo
          alaminj = alminj
c
          alsum = alminj + almina
          rjnmax = emax*(alsum+alaminn) / (alsum*alaminn )
c
c         Test whether this radial function will contribute:
          if( rjsquar.gt.rjnmax ) goto 1799
c
          iatm = jatm
          ityp = jtyp
          istart = jstart
          ishl1 = jshl
          do  ishl=1,ishl1-1
            lshli = lshel(ishl,ityp)
            norbshi = 2*lshli + 1
            istart = istart + norbshi
          enddo
c
c         Atom shell loop-2:
c
          iorbat0 = jorbat0
          ij0 = ij00 + jorbat0*norbatj + iorbat0
          i = istart
          do 800 ishl=ishl1,nshlj
            nali = nala(ishl,ityp)
            lshli = lshel(ishl,ityp)
            norbshi = 2*lshli + 1
            li0 = lshli*lshli
c
            i0 = i
            ijstart = ij0
            ij0 = ijstart + norbshi
c
            diagshl = .false.
            if( i0.eq.j0 ) diagshl = .true.
c
            almini = ala(1,ishl,ityp)
            do  ial=2,nali
              ali = ala(ial,ishl,ityp)
              if( ali.lt.almini ) almini = ali
            enddo
c
            rijnmax = emax*(alaminj+almini+alaminn) /
     $                   ( (alaminj+almini)*alaminn )
            if( rjsquar.gt.rijnmax ) goto 799
c
            keepsh = .false.
c           NOTE: z contribution is in occij(is,js.le.is,ityp)
            occ = occij(ishl,jshl,jtyp)
            if( occij(ishl,jshl,jtyp).ne.zero )then
              keepsh = .true.
c             Double off-diags - only doing one side of triangle
              if( ishl.ne.jshl ) occ = occ + occ
            endif
c
            lmx = lshli + lshlj + 1
            call MKZERO( 25, vessh )
            call MKZERO( 25, vijsh )
            call MKZERO( 25, vxcsh )
            call MKZERO( 25, excsh )
c
c           Alpha loops:
c
            enijsum = zero
            coulsum = zero
            do 320 jal=1,nalj
              alj = ala(jal,jshl,jtyp)
c
              do 310 ial=1,nali
                ali = ala(ial,ishl,ityp)
c
c               Test whether this pair of alphas contributes:
                rijnmx = emax*(alj+ali+alaminn) /
     $                      ( (alj+ali)*alaminn )
                if( rjsquar.gt.rijnmx .and. .not. keepsh ) goto 310
c
                alsum = ali + alj
                exparg = ali*rjsquar + alj*rjsquar
                do  ir=1,3
                  p(ir) = two*(ali*rj(ir)+alj*rj(ir))
                enddo
                pmag = SQRT( p(1)*p(1)+p(2)*p(2)+p(3)*p(3) )
c
                call MKZERO( 5, vatint )
                call MKZERO( 5, vesint )
                call MKZERO( 5, vxcint )
                call MKZERO( 5, excint )
c
                nonzer = 0
                argtst = exparg - 0.25*pmag*pmag/alsum
c
                  if( argtst.gt.argmx ) goto 310
                  nonzer = 1
                  expfac = zero
                  if( exparg.lt.argmx ) expfac =  EXP( -exparg )
                  call VLRADZ( vesint,lmx,alsum,pmag,znuc(ktyp),
     $                         exparg,expfac )
c
c
c               "vlradz" puts the matrix element of 2.*znuc/r into vesint() for
c                self-energy correction term to vatint(), "vlrad" adds the
c                contributions of the xc-potential associated with atom nuc,
c                as well as the difference between the actual electrostatic
c                potential due to the electrons of atom nuc and 2.*abs(znuc)/r
c
                call NRSCUT( nrmn,nrmx,nrad(ktyp),argmx,
     $           exparg,pmag,alsum,radmsh(1,ktyp),wkrad )
c
                if( nrmx.gt.0 )then
c
c                 Evaluate radial integrals
c
                  nrlen = nrmx - nrmn + 1
                  call VLRAD( vatint, vesint,vxcint,excint,
     $             lmx,alsum,pmag,exparg,
     $             nrlen, radmsh(nrmn,ktyp),radwt(nrmn,ktyp),
     $             vatrad(nrmn,ktyp),vesrad(nrmn,ktyp),
     $             vxcrad(nrmn,ktyp),excrad(nrmn,ktyp),
     $             wkrad, wkrad(1, 8),wkrad(1, 9),wkrad(1,10),
     $                    wkrad(1,11),wkrad(1,12),wkrad(1,13) )
                else
                  if( nonzer.eq.0 ) goto 310
                endif
c
c               Angular loops:
c
                shlfac = fourpi*cala(ial,ishl,ityp)*cala(jal,jshl,jtyp)
c
                mli1 = 1
                do 420 mlj=1,norbshj
                  lj = lj0 + mlj
                  j = j0 + mlj
c
                  if( diagshl ) mli1 = mlj
                  do 410 mli=mli1,norbshi
                    li = li0 + mli
                    i = i0 + mli
c
c                   Evaluate contribution to matrix element (i,j)
c
                    call VLANG( vatij,vatint,
     $               vesij,vesint, vxcij,vxcint, excij,excint,
     $               p,lj,li,cj(1,lj),cj(1,li) )
c
                    fac = shlfac / ( vnorm(li)*vnorm(lj) )
c
c                   Multiply by bf factors, increment shell-block Hamiltonian
                    vesij = fac*vesij
                    vatij = fac*vatij
                    vxcij = fac*vxcij
                    excij = fac*excij
                    vessh(mli,mlj) = vessh(mli,mlj) + vesij
                    vijsh(mli,mlj) = vijsh(mli,mlj) + vatij
                    vxcsh(mli,mlj) = vxcsh(mli,mlj) + vxcij
                    excsh(mli,mlj) = excsh(mli,mlj) + excij
c
c                   Close angular loops:
  410             continue
  420           continue
c
c               Close alpha loops:
  310         continue
  320       continue
c
            ijs = ijstart
            mli1 = 1
            do 425 mlj=1,norbshj
              lj = lj0 + mlj
              j = j0 + mlj
c
              ijs0 = ijs
              ijs = ijs + norbatj
              if( diagshl ) mli1 = mlj
              do 415 mli=mli1,norbshi
                li = li0 + mli
                i = i0 + mli
                ij = ijs0 + mli
c
                vesij = vessh(mli,mlj)
                vtmp(1,ij) = vtmp(1,ij) + vijsh(mli,mlj)
                vtmp(2,ij) = vtmp(2,ij) + vxcsh(mli,mlj)
                vtmp(3,ij) = vtmp(3,ij) + excsh(mli,mlj)
c
                if( keepsh .and. li.eq.lj )then
c                 Subtract from delta-E: spherical charge times itself
                  engyadd = -half*occ*vesij
                  atm0enii = atm0enii + engyadd
                  edelij = edelij + engyadd
                  if( lstout.ge.3 ) write(IWR,9003)
     $             '    li,lj,ial,jal,E(Z-e)=',li,lj,ial,jal,engyadd
                endif
c
  415         continue
  425       continue
c
  799       continue
c           Close Atom shell loop-2:
            i = i0 + norbshi
  800     continue
c
 1799     continue
c         Close Atom shell loop-1:
          j = j0 + norbshj
 1800   continue
c
        if( lstout.gt.0 .and. (engyzz.ne.zero.or.edelij.ne.zero) )
     $    write(IWR,9001) nuc,klat,jatm,engyzz,edelij,engyzz+edelij
c
c       Close Atom j loop:
 2000 continue
c
c       Close Nucleus lattice loop:
c
 2900 continue
c
c       Close Nucleus potential loop:
c
 3000 continue
c
      if( nprocl .gt. 1 )then
c       Merge the results onto the master/root node
        call MPMERGER8( nprocl, iprocl0, iprocl,
     $     nvtmp,iv1locl,nvlocl, vtmp, icomm )

c        ... and broadcast it to everyone
        call MPBCAST8( iprocl0, nvtmp, vtmp, icomm )
c
c       Assemble the sum of atm0 terms:
        nreduc = 1
        call MPREDUC8( iprocl0, nreduc, atm0enii, eiitmp, icomm )
        atm0enii = eiitmp
c
        call MPBCAST8( iprocl0, nreduc, atm0enii, icomm )
      endif
c
c Pack up contributions to Hams from matrix elements of potential nuc
c
      atm0engy = atm0engy + atm0enii
c
        i0 = 0
        ijnext = 0
        do  iatm=1,natm
          ityp = itypa(iatm)
          norbat = norba(ityp)
c
          j = i0
          ij = ijnext
          do  jorbat=1,norbat
            i = j
            j = j + 1
            do  iorbat=jorbat,norbat
              i = i + 1
              ij = ij + 1
              do  k=1,nk
                vloc0(k,i,j) = vloc0(k,i,j) + vtmp(1,ij)
                vxc0(k,i,j) = vxc0(k,i,j) + vtmp(2,ij)
                exc0(k,i,j) = exc0(k,i,j) + vtmp(3,ij)
              enddo
            enddo
            ij = ij + jorbat
          enddo
c
          i0 = i0 + norbat
          ijnext = ijnext + norbat**2
c
        enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLOCPOT
c
c
      subroutine VLOCPOT( IWR, do_gga, xcalcut,xcfac,xcrhocut,
     $ exc0rad,exc0slo,exccrad, strxc0,strxcc,
     $ rhoatom, excatom,excaslo,exccore, strvxc0,strxcor,
     $ natm,ntyp,nshld,nald,
     $ itypa, numshl,lshel,nala,ala,cala, znuc,occ,lmxnlp1,
     $ nrad,nrd, radmsh,radwt, nrcor, corden,
     $ vpsrad, vatrad,vesrad,vxcrad,excrad,
     $ maxwkr, wkr, y2,u )
c---------------------------------------------------------------
c Purpose: construct local electrostatic and xc-potentials for
c          spherically averaged isolated atoms, used in vlocmat
c
c Written: Peter A. Schultz, 13-November-2000, for v2.46 (gga)
c          Replacing former routine "atpot"
c
c Revision history:
c  24Sep08-PAS/2.62: r2l initialization (cosmetic)
c  27Feb07-PAS/2.60: adjust output flags
c   6Nov04-PAS/2.58a: add dGGA stress analytic-grid correction
c  11Jun03-PAS/2.55: change DFTGGA arguments
c   8Apr02-PAS/2.53: gga stress
c   7Mar02-PAS.2,52: explicit constants to d0
c  21Jun01-PAS/2.48: replace STOPs
c---------------------------------------------------------------
c
c  Notes:
c    Potentials evaluated on same radial mesh as non-local pots
c
c    The electrostatic potential may be written as:
c           2 * occat / r + delta ves(r),
c    where occat is the number of electrons on the atom
c    Only the remainder term is computed.
c
c    This routine coded to handle general shells (l=0,1,2,3,...)
c
c    Arrays vat/vxc/excrad() used for scratch before output
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
c Input arrays:
      LOGICAL    do_gga
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  occ(nshld,ntyp)
      DIMENSION  znuc(ntyp),  lmxnlp1(ntyp)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp),radwt(nrd,ntyp)
      DIMENSION  vpsrad(nrd,4,ntyp)
      DIMENSION  nrcor(ntyp), corden(nrd,ntyp)
c Output arrays:
      DIMENSION  rhoatom(natm,3), vatrad(nrd,ntyp)
      DIMENSION  vesrad(nrd,ntyp),vxcrad(nrd,ntyp),excrad(nrd,ntyp)
c Scratch arrays:
      DIMENSION  excatom(ntyp),excaslo(ntyp),exccore(ntyp)
      DIMENSION  strvxc0(ntyp), strxcor(ntyp)
      DIMENSION  wkr(maxwkr)
      DIMENSION  y2(*),u(*)
c
c Local declarations:
      LOGICAL  cntrch
      DATA  alcutfac / 1.33333333d0 /
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
      DATA  lstout / 1 /
c
c >>>> EXECUTABLE CODE:
c
      fourpi = pi + pi + pi + pi
      rtpid2 = half*rtpi
c determine largest exp argument before underflow:
      argmx = half*cutexp
c
      strxc0 = zero
      strxcc = zero
c
c  Loop over atom types:
c
      do 500 ktyp=1,ntyp
        excatom(ktyp) = zero
        excaslo(ktyp) = zero
        exccore(ktyp) = zero
        strvxc0(ktyp) = zero
        strxcor(ktyp) = zero
        if( znuc(ktyp).eq.zero ) goto 500
c
        almin = 9.d9
        do  ishl=1,numshl(ktyp)
          if( occ(ishl,ktyp).ne.zero )then
            do  ial=1,nala(ishl,ktyp)
              ali = ala(ial,ishl,ktyp)
              if( ali.lt.almin ) almin = ali
            enddo
          endif
        enddo
c
c       Set up xc cutoff function
        alminxc = two*almin
        if( xcalcut.lt.zero ) alminxc = -xcalcut*almin
        alcutxc = alcutfac*alminxc
        if( xcalcut.gt.zero ) alcutxc = xcalcut
c
c       Blank radial potential arrays
        nradk = nrad(ktyp)
        call MKZERO( nradk, vesrad(1,ktyp) )
c
c       Set up scratch space in wkr()
        ir0 = 0
        irsq  = ir0
        irngr = ir0 +  1*nradk
        iatrh = ir0 +  2*nradk
        icnrh = ir0 +  3*nradk
        icore = ir0 +  4*nradk
        idcor = ir0 +  5*nradk
        ia0e  = icore
        ia1e  = idcor
        ia2e  = ir0 +  6*nradk
        idrho = ir0 +  7*nradk
        iddrh = ir0 +  8*nradk
        inext = iddrh + nradk
        if( inext.ge.maxwkr ) call STOPXERR( 'vlp-mem' )
c
c       Clear densities and derivatives, initialize radial terms
        call MKZERO( nradk, wkr(iatrh+1) )
        call MKZERO( nradk, wkr(icnrh+1) )
        call MKZERO( nradk, wkr(idrho+1) )
        call MKZERO( nradk, wkr(iddrh+1) )
        call MKZERO( nradk, wkr(idcor+1) )
        do  nr=1,nradk
          wkr(irngr+nr) = radmsh(nr,ktyp)
          wkr(irsq+nr)  = radmsh(nr,ktyp)**2
        enddo
c
        iorbat = 0
        occat = zero
        do 70 ishl=1,numshl(ktyp)
          lshl = lshel(ishl,ktyp)
c
          occshl = occ(ishl,ktyp)
          occat = occat + occshl
          if( occshl.eq.zero ) goto 70
c
          cntrch = .false.
          if( occshl.lt.zero )  cntrch = .true.
c
c         Shell is occupied - begin alpha loops
c
c         These arrays used here for scratch to store
c          sums of ca*cb*(a+b)**n*exp(-r2*(a+b))
          call MKZERO( nradk, wkr(ia0e+1) )
          call MKZERO( nradk, wkr(ia1e+1) )
          call MKZERO( nradk, wkr(ia2e+1) )
c
          do 55 ial=1,nala(ishl,ktyp)
            ali = ala(ial,ishl,ktyp)
            cali = occshl*cala(ial,ishl,ktyp)
            cali0 = cali
c
c           Do off-diagonals once, using cali and cali0 to double.
            do 50 jal=ial,1,-1
              als = ali + ala(jal,ishl,ktyp)
              twoals = als + als
              cicj = cali*cala(jal,ishl,ktyp)
              cali = cali0 + cali0
c             Could put twoals rather than als for slight speedup
              cicja0 = cicj/fourpi
              cicja1 = cicja0*als
              cicja2 = cicja0*als*als
              rtal = SQRT( als )
              alslp1 = als**(lshl+1)
c
              do 40 nr=1,nradk
                r = radmsh(nr,ktyp)
                r2 = r*r
                rtalr = r*rtal
                ar2  = als*r2
c
                if( ar2.lt.argmx )then
                  expar2 =  EXP( -ar2 )
                  sumlt = zero
                  ar2tol = one
                  sumgt = zero
                  r2ll = one
                  erffac = rtpid2/rtal
c                 Aren't recursion relations beautiful?
                  do  l=0,lshl
                    r2l = r2ll
                    sumlt = ar2tol + l*sumlt
                    ar2tol = ar2*ar2tol
                    sumgt = ((2*l+1)*sumgt-r2ll) / twoals
                    r2ll = r2*r2ll
                    erffac = (2*l+1)*erffac / twoals
                  enddo
                  atsr0 = zero
c                 PRECISION question  ERF[single]<->DERF[double]
                  if( r.gt.1.d-9 ) atsr0 = erffac*DERF( rtalr )/r
                  atsr = expar2*(half*sumlt/alslp1+sumgt) + atsr0
                else
                  r2l = zero
                  expar2 = zero
                  atsr0 = rtpid2/rtalr
                  do  l=0,lshl
                    atsr0 = (2*l+1)*atsr0 / twoals
                  enddo
                  atsr = atsr0
                endif
c
                if( .not. cntrch )then
                  wkr(ia0e+nr) = wkr(ia0e+nr) + cicja0*expar2
                  wkr(ia1e+nr) = wkr(ia1e+nr) + cicja1*expar2
                  wkr(ia2e+nr) = wkr(ia2e+nr) + cicja2*expar2
                else
                  wkr(icnrh+nr) = wkr(icnrh+nr) + cicja0*(r2l)*expar2
                endif
                vesrad(nr,ktyp) = vesrad(nr,ktyp) + cicj*atsr
c
   40         continue
c
c             Close alpha loops:
c
   50       continue
   55     continue
c
          if( .not. cntrch )then
c
c           Assemble density and derivatives for XC potential:
c
            call MKSHL2D( lshl, nradk, radmsh(1,ktyp), wkr(irsq+1),
     $       wkr(ia0e+1),wkr(ia1e+1),wkr(ia2e+1),
     $       wkr(iatrh+1),wkr(idrho+1),wkr(iddrh+1) )
c
          endif
c
c         Close shell loop:
c
   70   continue
c
c    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c              Subtract 1/r term from es potential
c    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
        esrho = zero
        eszat = zero
        do  nr=1,nradk
          rhoes = radwt(nr,ktyp)*(wkr(iatrh+nr)+wkr(icnrh+nr))
          esrho = esrho + rhoes*vesrad(nr,ktyp)
          eszat = eszat - rhoes*occat/radmsh(nr,ktyp)
        enddo
        esrho = fourpi*esrho
        eszat = fourpi*eszat
        esat  = -esrho + eszat + eszat
        if( lstout.gt.4 ) write(IWR,*) 'esrho,z,tot=',esrho,eszat,esat
c
        do  nr=1,nradk
c         Add factor of two to convert to rydbergs
          vesrad(nr,ktyp) = two*( vesrad(nr,ktyp)-occat/radmsh(nr,ktyp))
        enddo
c
c    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c            Check if we have core density to consider
c    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
        nradc = nrcor(ktyp)
        nrsc = nradc + 1
        call MKZERO( nradk, wkr(idcor+1) )
        if( nrsc.ne.1 )then
c         Interpolate core density
          ddy0 = 1.d31
          ddy1 = 1.d31
          call SPLINE(nrsc,radmsh(1,ktyp),corden(1,ktyp),ddy0,ddy1,y2,u)
c
c         Do core 2nd deriv before 1st deriv, and use (idcor)
c         space for scratch  (do not need core 2nd deriv
c         separate from the total rho 2nd deriv).
c         Interpolate to get 2nd deriv. of core density ...
          call SPLIND2( nrsc, radmsh(1,ktyp), corden(1,ktyp),y2,
     $                  nrsc, radmsh(1,ktyp),wkr(idcor+1) )
c          ... and put into total 2nd deriv of density for GGA
          do  nr=1,nrsc
            wkr(iddrh+nr) = wkr(iddrh+nr) + wkr(idcor+nr)
          enddo
c
c         Interpolate to get deriv. of core density ...
          call SPLIND( nrsc, radmsh(1,ktyp),corden(1,ktyp),y2,
     $                 nrsc, radmsh(1,ktyp),wkr(idcor+1) )
        endif
c
c    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c            Have atom density; compute xc quantities
c    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
        call MKZERO( nradk, vatrad(1,ktyp) )
        call MKZERO( nradk, vxcrad(1,ktyp) )
        call MKZERO( nradk, excrad(1,ktyp) )
        rhoatm = zero
        rhoatx = zero
        coratm = zero
        vxcatm = zero
        vxcfst = zero
        vxcasl = zero
        excatm = zero
        excfst = zero
        excasl = zero
        exccor = zero
        corfst = zero
        strax0 = zero
        straxc = zero
        strd0 = zero
        strdc = zero
c
        do 200 nr=1,nradk
c
          rhoxc = wkr(iatrh+nr)
          rhoes = wkr(iatrh+nr) + wkr(icnrh+nr)
c
          rhopt = rhoxc
          if( nradc.ne.0 ) rhopt = rhopt + corden(nr,ktyp)
c
          if( rhopt.lt.xcrhocut ) goto 200
c
          rmag = radmsh(nr,ktyp)
          if( do_gga )then
c           Assemble derivatives for GGA pot/assume no pt at r=0
c           Remember to add core deriv to total density deriv:
            drh = wkr(idrho+nr) + wkr(idcor+nr)
            d1rhdr = drh/rmag
            d2rh = wkr(iddrh+nr) - d1rhdr
            grho = ABS( drh )
            g2rho = wkr(iddrh+nr) + two*d1rhdr
            gpggp = grho*wkr(iddrh+nr)
c
            call DFTGGA( rhopt, grho,g2rho,gpggp,
     $                   vxcpt,excpt, dxcpt,dxc2pt )
c
          else
c
            call DFTLDA( rhopt, vxcpt,excpt )
c
          endif
c
c         Construct "fast" xc-potentials, and update:
          cfac = EXP( -alcutxc*rmag**2 )
          fstfcn = cfac / ( (one-xcfac)*cfac + xcfac )
c
          vfast = vxcpt*fstfcn
          vslow = vxcpt - vfast
c
          efast = excpt*fstfcn
          eslow = excpt - efast
c
          vxcrad(nr,ktyp) = vfast
          excrad(nr,ktyp) = efast
c
c         Integrate atom electron density and xc quantities
c
c         In the following, "radwt" assumed to contain the factor r**2
c         needed in the radial integral but not the 4pi for the radial
c         integral.  This specification of radwt is more convenient
c         in the more heavily called routines "vlrad" and "vlradX"
          rwt = fourpi*radwt(nr,ktyp)
          rhoatm = rhoatm + rwt*      rhoes
          rhoatx = rhoatx + rwt*      rhoxc
          vxcatm = vxcatm + rwt*vxcpt*rhoxc
          vxcfst = vxcfst + rwt*vfast*rhoxc
          vxcasl = vxcasl + rwt*vslow*rhoxc
          excatm = excatm + rwt*excpt*rhoxc
          excfst = excfst + rwt*efast*rhoxc
          excasl = excasl + rwt*eslow*rhoxc
c         Phantom xc force "analytic" term
          strax0 = strax0 + rwt*vfast*wkr(idrho+nr)*rmag
          if( do_gga )then
c           Phantom GGA stress "analytic" term
            dxc0fast = fstfcn*dxcpt*wkr(idrho+nr)**2
     $               + fstfcn*dxc2pt*wkr(iddrh+nr)
            strd0 = strd0 - rwt*dxc0fast
          endif
          if( nradc.gt.0 .and. nr.le.nradc )then
            coratm = coratm + rwt*      corden(nr,ktyp)
            exccor = exccor + rwt*excpt*corden(nr,ktyp)
            corfst = corfst + rwt*efast*corden(nr,ktyp)
c           Phantom xc force "analytic" term (core)
            straxc = straxc + rwt*vfast*wkr(idcor+nr)*rmag
            if( do_gga )then
c             Phantom GGA stress "analytic" term (core)
c             Note: d2cor term in iddrho above
              dxccfast = fstfcn*dxcpt*wkr(idcor+nr)**2
              strdc = strdc - rwt*dxccfast
            endif
          endif
c
  200   continue
c
        excatom(ktyp) = excatm
        excaslo(ktyp) = excasl
        exccore(ktyp) = exccor
        strvxc0(ktyp) = strax0 + strd0
        strxcor(ktyp) = straxc + strdc
        if( lstout.gt.0 )then
          write(IWR,*) ' '
          write(IWR,9200) ktyp,' radial valence charge =',rhoatm
 9200     format(1x,'Atom type',i4,1x,a,f18.12)
          if( ABS(rhoatx-rhoatm) .gt. 1.d-8 )
     $    write(IWR,9200) ktyp,'     xc valence charge =',rhoatx
          if( lstout.gt.3 )then
            write(IWR,9200) ktyp,'    vxc rad energy =',vxcatm
            write(IWR,9200) ktyp,'    vxc fast enrgy =',vxcfst
            write(IWR,9200) ktyp,'    vxc slo energy =',vxcasl
            write(IWR,9200) ktyp,'    exc rad energy =',excatm
            write(IWR,9200) ktyp,'    exc fast enrgy =',excfst
            write(IWR,9200) ktyp,'    exc slo energy =',excasl
            write(IWR,9200) ktyp,'    coulomb energy =',esrho
            write(IWR,9200) ktyp,'    valence stress =',strax0
            write(IWR,9200) ktyp,'    gga stress     =',strd0
          endif
          if( nradc.gt.0 )then
            write(IWR,9200) ktyp,'   core charge =',coratm
            if( lstout.gt.3 )then
              write(IWR,9200) ktyp,'    core rad energy =',exccor
              write(IWR,9200) ktyp,'    core fast enrgy =',corfst
              write(IWR,9200) ktyp,'    core stress     =',straxc
              write(IWR,9200) ktyp,'    core gga stress =',strdc
            endif
          endif
          rhoatom(ktyp,3) = coratm
        endif
c
c    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c       use the "non-local" potential of the highest l-value
c                  as the local potential:
c    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
        locpot = lmxnlp1(ktyp) + 1
        if( locpot.le.0 )then
          do  nr=1,nradk
            vatrad(nr,ktyp) = vesrad(nr,ktyp) + vxcrad(nr,ktyp)
          enddo
        else
          do  nr=1,nradk
            vatrad(nr,ktyp) = vesrad(nr,ktyp) + vxcrad(nr,ktyp)
     $                      + vpsrad(nr,locpot,ktyp)
          enddo
        endif
c
c      Close atom loop:
c
  500 continue
c
c Assemble isolated atom correction to xc-energy
c
      exc0rad = zero
      exc0slo = zero
      exccrad = zero
      strxc0  = zero
      strxcc  = zero
      do  iatm=1,natm
        ityp = itypa(iatm)
        exc0rad = exc0rad + excatom(ityp)
        exc0slo = exc0slo + excaslo(ityp)
        exccrad = exccrad + exccore(ityp)
        strxc0  = strxc0  + strvxc0(ityp)
        strxcc  = strxcc  + strxcor(ityp)
      enddo
c
      if( lstout.gt.1 )then
c       Summarize atomic reference xc stress terms:
        write(IWR,9220) 'Total atom local valence xc stress=',strxc0
        if( strxcc .ne. zero )
     $  write(IWR,9220) 'Total atom local core xc stress   =',strxcc
 9220   format(1x,a,f20.8)
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLRAD
c
c
      subroutine VLRAD( vint1,vint2,vint3,vint4,
     $ lmx,alsum,pmag,exparg,
     $ nrs, radmsh,rwght,  pot1,pot2,pot3,pot4,
     $ besstor,w1,w2,w3,w4,w5,w6 )
c---------------------------------------------------------------
c Purpose: does necessary radial integrals for local potentials
c
c Revision history:
c   6Mar00-PAS?2.43: rename "shtrng" to "vlrad"
c   7Dec99-PAS/2.42: clean-up loops
c  10Dec98-PAS/2.29: promote source to explicit double precision
c    May89-PAS: install opted bessel routines
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output arrays:
      DIMENSION  vint1(*),vint2(*),vint3(*),vint4(*)
c input arrays:
      DIMENSION  radmsh(nrs),rwght(nrs)
      DIMENSION  pot1(nrs),pot2(nrs),pot3(nrs),pot4(nrs)
c scratch arrays:
      DIMENSION  besstor(nrs,*)
     $   ,w1(nrs),w2(nrs),w3(nrs),w4(nrs),w5(nrs),w6(nrs)
c local declarations:
      DATA  zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      ltop = lmx
c
c ***** compute spherical bessel functions *****
c
      if( pmag.gt.zero )then
c
        call BSIALL( nrs, ltop, pmag, besstor, radmsh,
     $   w1,w2,w3,w4,w5,w6 )
c
        do  nr=1,nrs
          r = radmsh(nr)
          w1(nr) = rwght(nr)*EXP(-alsum*r**2+r*pmag-exparg)
        enddo
c
        factor = one/pmag
c
      else
c
        do  nr=1,nrs
          r = radmsh(nr)
          w1(nr) = rwght(nr)*EXP(-alsum*r**2-exparg)
          besstor(nr,1) = one
        enddo
c
        do 140 ll=2,ltop
          denom = one/ DBLE(2*ll-1)
          do  nr=1,nrs
            besstor(nr,ll) = besstor(nr,ll-1)*radmsh(nr)*denom
          enddo
  140   continue
c
        factor = one
c
      endif
c
c ***** bessel functions done, evaluate radial integrals *****
c
      do 240 ll=1,ltop
        do  nr=1,nrs
          rmul = besstor(nr,ll)*w1(nr)
          vint1(ll) = vint1(ll) + rmul*pot1(nr)
          vint2(ll) = vint2(ll) + rmul*pot2(nr)
          vint3(ll) = vint3(ll) + rmul*pot3(nr)
          vint4(ll) = vint4(ll) + rmul*pot4(nr)
          w1(nr) = w1(nr)*radmsh(nr)*factor
        enddo
  240 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLRADF
c
c
      subroutine VLRADF( vint1,vint2,vint3, calc1,calc2,calc3,
     $ lmx,alsum,pmag,exparg,
     $ nrs, radmsh,rwght,  pot1,pot2,pot3,
     $ besstor, w1,w2,w3,w4,w5,w6 )
c---------------------------------------------------------------
c Purpose: integrals for n=0,ltop-1 off radial potentials of:
c       exp(-alsum*r**2) * r**(2+n) * i-sub-n(pmag*r) / pmag**n
c      "i-sub-n" is the spherical bessel function, imag argument
c
c Revision history:
c   6Mar00-PAS/2.43: rename "shtrngf" to "vlradf"; simple opt.
c  19Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c   r**2 factor needed for radial integral included in rwght
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c output arrays:
      DIMENSION  vint1(*),vint2(*),vint3(*)
c input arrays:
      LOGICAL    calc1,calc2,calc3
      DIMENSION  radmsh(nrs),rwght(nrs)
      DIMENSION  pot1(nrs),pot2(nrs),pot3(nrs)
c scratch arrays:
      DIMENSION  besstor(nrs,*)
     $   ,w1(nrs),w2(nrs),w3(nrs),w4(nrs),w5(nrs),w6(nrs)
c local declarations:
      DATA  zero,one / 0.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      ltop = lmx
c
c ***** compute spherical bessel functions *****
c
      if( pmag.gt.zero )then
c
        call BSIALL( nrs, ltop, pmag, besstor, radmsh,
     $   w1,w2,w3,w4,w5,w6 )
c
        do  nr=1,nrs
          r = radmsh(nr)
          w1(nr) = rwght(nr)*EXP(-alsum*r**2+r*pmag-exparg)
        enddo
c
        factor = one/pmag
c
      else
c
        do  nr=1,nrs
          r = radmsh(nr)
          w1(nr) = rwght(nr)*EXP(-alsum*r*r-exparg)
          besstor(nr,1) = one
        enddo
c
        do  ll=2,ltop
          denom = one/ DBLE(2*ll-1)
          do  nr=1,nrs
            besstor(nr,ll) = besstor(nr,ll-1)*radmsh(nr)*denom
          enddo
        enddo
c
        factor = one
c
      endif
c
c ***** bessel functions done, evaluate radial integrals *****
c
      do 200 ll=1,ltop
c
        do  nr=1,nrs
          w2(nr) = besstor(nr,ll)*w1(nr)
        enddo
c
        if( calc1 .and. calc2 )then
c         This is most common combination(es and pspot):
          do  nr=1,nrs
            vint1(ll) = vint1(ll) + w2(nr)*pot1(nr)
            vint2(ll) = vint2(ll) + w2(nr)*pot2(nr)
          enddo
        elseif( calc1 )then
c         This is second most common path (es only):
          do  nr=1,nrs
            vint1(ll) = vint1(ll) + w2(nr)*pot1(nr)
          enddo
        elseif( calc2 )then
          do  nr=1,nrs
            vint2(ll) = vint2(ll) + w2(nr)*pot2(nr)
          enddo
        endif
c
        if( calc3 )then
c         This is xc-local, usually inactive:
          do  nr=1,nrs
            vint3(ll) = vint3(ll) + w2(nr)*pot3(nr)
          enddo
        endif
c
        if( ll.lt.ltop )then
          do  nr=1,nrs
            w1(nr) = w1(nr)*radmsh(nr)*factor
          enddo
        endif
c
  200 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VLRADZ
c
c
      subroutine VLRADZ( venint,ltop,alsum,pmag,znuc,exparg,expfac )
c---------------------------------------------------------------
c Purpose: calculates radial integrals with znuc/r
c
c Revision history:
c  21Jun01-PAS/2.48: replace STOPs
c   6Mar00-PAS/2.43: rename "radint" to "vlradz"
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c expfac = EXP(-exparg) with underflow control
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c output array:
      DIMENSION  venint(*)
c local declarations:: ( ERF has machine/MACHINE dependence)
      DATA  tol / 1.d-14 /
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
c
c >>>> EXECUTABLE CODE:
c
      rtpid2 = rtpi/two
      twoz = two*znuc
      ltopm1 = ltop - 1
c
      arg = pmag/SQRT(alsum)
      argsq = arg*arg
      erfarg = arg/two
      phiarg = erfarg*erfarg
c
      if( ltop.gt.1 ) goto 10
      if( arg.gt.zero )then
        venint(1) = EXP( phiarg-exparg )*DERF( erfarg )*rtpid2/arg
      else
        venint(1) = expfac/two
      endif
      goto 100
c
   10 if( phiarg.lt. DBLE( ltop )-1.5 ) goto 30
c
c      do forward recursion for phiarg gt lmax-0.5
c
      venint(1) = EXP( phiarg-exparg )*DERF( erfarg )*rtpid2/arg
      venint(2) = (half-one/argsq)*venint(1) + half*expfac/argsq
      if( ltop.gt.2 )then
        do  ll=3,ltop
          l = ll - 1
          venint(ll) = (half/phiarg)*
     $     ( venint(ll-2)* DBLE( l-1 ) / two
     $     + venint(ll-1)*(phiarg- DBLE( l )+half) )
        enddo
      endif
      goto 100
c
c ---- land here if phiarg is small
c
   30 continue
c
      if( pmag.eq.zero )then
c       >>>> phiarg equals zero
        fac = half
        do  l=1,ltop
          venint(l) = fac*EXP( -exparg )
          fac = fac* DBLE( l ) / DBLE( 2*l+1 )
        enddo
        goto 100
      endif
c
c      >>>> phiarg is small, but non-zero
c      taylor series for largest l-s and do backward recursion
c
      fac = one
      do  l=1,ltopm1
        fac = fac* DBLE( l ) / DBLE( 2*l+1 )
      enddo
      ta1 = fac*EXP(phiarg-exparg)/two
      ta2 = ta1* DBLE( 2*ltopm1+1 ) / DBLE( ltopm1 )
      ltopm2 = ltopm1 - 1
      t1 = zero
      t2 = zero
      do  k=1,100
        t1 = t1 + ta1
        t2 = t2 + ta2
        ta1 = -ta1* DBLE(2*k-1)*phiarg/ DBLE(k*(2*(ltopm1+k)+1))
        ta2 = -ta2* DBLE(2*k-1)*phiarg/ DBLE(k*(2*(ltopm2+k)+1))
        if( ABS(ta1/t1).le.tol .and. ABS(ta2/t2).lt.tol ) goto 70
      enddo
      call STOPXERR( 'radint' )
c
c      back recursion
c
   70 continue
      venint(ltopm1+1) = t1
      venint(ltopm2+1) = t2
      do  l=3,ltop
        ll = ltop - l + 1
        fll =  DBLE(ll)
        venint(ll) = (two*phiarg*venint(ll+2) -
     $                        (phiarg-fll-half)*venint(ll+1) )
     $                   / (fll/two)
      enddo
c
c >>>> scale results
c
  100 continue
      alscal = alsum
      do  l=1,ltop
        venint(l) = twoz*venint(l)/alscal
        alscal = alscal*alsum
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VNORMS
c
c
      subroutine VNORMS( vnorm )
c---------------------------------------------------------------
c Purpose: initialize orbital angular normalizations
c
c Written: Peter A. Schultz, for v2.52 (linux)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c This set of constants normalizes the angular functions:
c   1,         (x,y,z),     (xy,yz,zx),   (x**2-y**2),   (3*z**2-r**2)
c They equal, respectively:
c   sqrt(4pi), sqrt(4pi/3), sqrt(4pi/15), sqrt(16pi/15), sqrt(16pi/5)
c
      PARAMETER  ( c_s    = 3.544907701811 d0,
     $             c_p    = 2.046653415893 d0,
     $             c_xy   = 0.9152912328638d0,
     $             c_x2y2 = 1.830582465728 d0,
     $             c_dz2  = 3.170661838085 d0 )
c
      DIMENSION  vnorm(*)
c
c >>>> EXECUTABLE CODE:
c
c s
      vnorm(1) = c_s
c x,y,z
      vnorm(2) = c_p
c xy,yz,zx
      vnorm(3) = c_xy
c x2-y2
      vnorm(4) = c_x2y2
c dz2: 3z2-r2
      vnorm(5) = c_dz2
c
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VNORMS9
c
      entry VNORMS9( vnorm )
c s
      vnorm(1) = c_s
c x,y,z
      vnorm(2) = c_p
      vnorm(3) = c_p
      vnorm(4) = c_p
c xy,yz,zx
      vnorm(5) = c_xy
      vnorm(6) = c_xy
      vnorm(7) = c_xy
c x2-y2
      vnorm(8) = c_x2y2
c dz2: 3z2-r2
      vnorm(9) = c_dz2
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOF1B
c
c
      subroutine VSLOF1B( ibox, ndim, frcslo,strslo,
     $ norb, natm,ntyp, nshld,nald, nlat,
     $ itypa,numshl,lshel,nala,ala,cala, alamin,
     $ ratm, rlat, coskr,sinkr,
     $ hh, nbox,nrec,inrec, nrbox,nobox,inboxs, boxrad,boxctr,
     $ wf, rmesh, vbox, wkbox,wkbi,
     $ dphix,dphiy,dphiz,  dphiuv,
     $ dmat, dmatbx )
c---------------------------------------------------------------
c Purpose: computes force/stress from grid potentials in a box
c          for real basis orbitals
c          Version using level-3 blas
c
c Written: Peter A. Schultz, 14-June-1999, for v2.36
c
c Revision history:
c  23Jan09-PAS/2.63: k-parallel
c  27Sep99-PAS/2.40: full three-dimensional stress tensor
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wf, wkbi
      REAL  dphix,dphiy,dphiz,  dphiuv
      REAL  vbox
      REAL  dmat, dmatbx
      REAL  fxint,fyint,fzint,  strbox
      REAL  r4zero,r4one
c
c output arrays:
      DIMENSION  frcslo(3,natm), strslo(3,3)
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp)
      DIMENSION  ratm(3,natm), rlat(3,nlat)
      DIMENSION  coskr(nlat),sinkr(nlat)
      DIMENSION  hh(3),inboxs(nrec,nbox)
      DIMENSION  wf(nrbox,nobox)
      DIMENSION  rmesh(3,nrbox)
      DIMENSION  vbox(nrbox)
      DIMENSION  dmat(norb,norb)
c scratch arrays:
      DIMENSION  wkbi(nrbox,nobox), wkbox(nrbox,*)
      DIMENSION  dphix(nrbox),dphiy(nrbox),dphiz(nrbox)
      DIMENSION  dphiuv(ndim,ndim,nrbox)
      DIMENSION  dmatbx(nobox,nobox)
c local declarations:
      DIMENSION  strbox(3,3)
      DIMENSION  boxctr(3)
      DATA  r4zero,r4one / 0.e0,1.e0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
      jnbox = 0
c
c Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        inext = 0
        ibnext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            ib0 = ibnext
            ibnext = ibnext + norbshi
c
            jrec = 0
            jatshl = 0
            jnext = 0
            jbnext = 0
            do 100 jatm=1,iatm
              jtyp = itypa(jatm)
              nshlj = numshl(jtyp)
              if( jatm.eq.iatm ) nshlj = ishl
c
              do 80 jshl=1,nshlj
                norbshj = 2*lshel(jshl,jtyp) + 1
c
                jnbox = jnbox/2
                if( inrec*(jatshl/inrec).eq.jatshl )then
                  jrec = jrec + 1
                  jnbox = inboxs(jrec,ibox)
                endif
                jatshl = jatshl + 1
                j0 = jnext
                jnext = jnext + norbshj
                if( EVEN(jnbox) ) goto 80
c
                jb0 = jbnext
                jbnext = jbnext + norbshj
c
                joff = 0
                if( jatm.eq.iatm .and. jshl.eq.ishl )then
                  norbshj = 0
                  joff = 1
                endif
c
                i = i0
                ib = ib0
                do 170 iorbsh=1,norbshi
                  i = i + 1
                  ib = ib + 1
c
                  norbshj = norbshj + joff
c
                  j = j0
                  jb = jb0
                  do 70 jorbsh=1,norbshj
                    j = j + 1
                    jb = jb + 1
c
                    dmatbx(jb,ib) = dmat(i,j)
                    dmatbx(ib,jb) = dmat(i,j)
c
   70             continue
  170           continue
c
   80         continue
  100       continue
c
  180     continue
  200   continue
c
c  Now have dmat in this box packed in dmatbx.
c
c Do heavy lifting inside level-3 blas routine:
        call SGEMM( 'n','n', nrbox,nobox,nobox, r4one,
     $   wf,nrbox, dmatbx,nobox, r4zero, wkbi,nrbox )
c
       inbox = 0
c
c  Complete gradient calculation: loop over atoms/shells
c
       irec = 0
       iatshl = 0
       inext = 0
       ibnext = 0
       do 1200 iatm=1,natm
         ityp = itypa(iatm)
         almina = alamin(ityp)
c
         do 1180 ishl=1,numshl(ityp)
           lshli = lshel(ishl,ityp)
           norbshi = 2*lshli + 1
           inbox = inbox/2
           if( inrec*(iatshl/inrec).eq.iatshl )then
             irec = irec + 1
             inbox = inboxs(irec,ibox)
           endif
           iatshl = iatshl + 1
           i0 = inext
           inext = inext + norbshi
           if( EVEN(inbox) ) goto 1180
c
           ib0 = ibnext
           ibnext = ibnext + norbshi
c
           almins = ala(1,ishl,ityp)
           do  ial=2,nala(ishl,ityp)
             ali = ala(ial,ishl,ityp)
             if( ali.lt.almins ) almins = ali
           enddo
           almin = almina
c
           i = i0
           ib = ib0
           do 1170 iorbsh=1,norbshi
            i = i + 1
            ib = ib + 1
c
c  For force calculation:
c   compute derivatives of i-th wave function
c  For stress calculation:
c   compute (x-X) times x-derivative of i-th wave function
c   compute (y-Y) times y-derivative of i-th wave function
c
            call GRADWF( ibox,     1, ndim, iatm,ishl,iorbsh, almin,
     $        1,0,1, natm,ntyp, nshld,nald, nlat,
     $       itypa, numshl,lshel,nala,ala,cala, ratm, rlat, coskr,sinkr,
     $       nrbox, boxrad, boxctr,
     $       rmesh,  wkbox(1,1), wkbox(1,2),wkbox(1,3),
c -->        rv-3io  rsq-s       sumg-s     sum2ag-s
     $       wkbox(1,4),wkbox(1,5),wkbox(1,6),
c -->        dpdx-s     dpdy-s     dpdz-s
     $       dphix,dphiy,dphiz,  dphiuv )
c
c  Complete force integrals ...
c
            fxint = r4zero
            fyint = r4zero
            fzint = r4zero
            call MKSZERO( 9, strbox )
c
            do  nr=1,nrbox
              wkbi(nr,ib) = vbox(nr)*wkbi(nr,ib)
            enddo
c
            do  nr=1,nrbox
              fxint = fxint + dphix(nr)*wkbi(nr,ib)
              fyint = fyint + dphiy(nr)*wkbi(nr,ib)
              fzint = fzint + dphiz(nr)*wkbi(nr,ib)
            enddo
c
            if( ndim.eq.1 )then
              do  nr=1,nrbox
                strbox(1,1) = strbox(1,1) + dphiuv(1,1,nr)*wkbi(nr,ib)
              enddo
            elseif( ndim.eq.2 )then
              do  nr=1,nrbox
                strbox(1,1) = strbox(1,1) + dphiuv(1,1,nr)*wkbi(nr,ib)
                strbox(2,1) = strbox(2,1) + dphiuv(2,1,nr)*wkbi(nr,ib)
                strbox(1,2) = strbox(1,2) + dphiuv(1,2,nr)*wkbi(nr,ib)
                strbox(2,2) = strbox(2,2) + dphiuv(2,2,nr)*wkbi(nr,ib)
              enddo
            elseif( ndim.eq.3 )then
              do  nr=1,nrbox
                strbox(1,1) = strbox(1,1) + dphiuv(1,1,nr)*wkbi(nr,ib)
                strbox(2,1) = strbox(2,1) + dphiuv(2,1,nr)*wkbi(nr,ib)
                strbox(3,1) = strbox(3,1) + dphiuv(3,1,nr)*wkbi(nr,ib)
                strbox(1,2) = strbox(1,2) + dphiuv(1,2,nr)*wkbi(nr,ib)
                strbox(2,2) = strbox(2,2) + dphiuv(2,2,nr)*wkbi(nr,ib)
                strbox(3,2) = strbox(3,2) + dphiuv(3,2,nr)*wkbi(nr,ib)
                strbox(1,3) = strbox(1,3) + dphiuv(1,3,nr)*wkbi(nr,ib)
                strbox(2,3) = strbox(2,3) + dphiuv(2,3,nr)*wkbi(nr,ib)
                strbox(3,3) = strbox(3,3) + dphiuv(3,3,nr)*wkbi(nr,ib)
              enddo
            endif
c
            frcslo(1,iatm) = frcslo(1,iatm) + fxint
            frcslo(2,iatm) = frcslo(2,iatm) + fyint
            frcslo(3,iatm) = frcslo(3,iatm) + fzint
c
            do  jd=1,ndim
              do  id=1,ndim
                strslo(id,jd) = strslo(id,jd) + strbox(id,jd)
              enddo
            enddo
c
c    Close atom i orbital, atom loops:
c
 1170      continue
 1180     continue
 1200   continue
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOF1
c
c
      subroutine VSLOF1( ibox, ndim, frcslo,strslo,
     $ norb, natm,ntyp, nshld,nald, nlat,
     $ itypa,numshl,lshel,nala,ala,cala, alamin,
     $ ratm, rlat, coskr,sinkr,
     $ hh, nbox,nrec,inrec, nrbox,nobox,inboxs, boxrad,boxctr,
     $ wf, rmesh, vbox, wkbox,wkbi,
     $ dphix,dphiy,dphiz,  dphiuv,
     $ dmat )
c---------------------------------------------------------------
c Purpose: computes force/stress from grid potentials in a box
c          for real basis orbitals
c
c Written: Peter A. Schultz, 10-June-1999, for v2.36
c
c Revision history:
c  23Jan09-PAS?2.63: k-parallel
c  27Sep99-PAS/2.40: full three-dimensional stress tensor
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wf, wkbi
      REAL  dphix,dphiy,dphiz,  dphiuv
      REAL  vbox
      REAL  dmat, dmatr
      REAL  fxint,fyint,fzint,  strbox
      REAL  r4zero
c
c output arrays:
      DIMENSION  frcslo(3,natm), strslo(3,3)
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp)
      DIMENSION  ratm(3,natm), rlat(3,nlat)
      DIMENSION  coskr(nlat),sinkr(nlat)
      DIMENSION  hh(3),inboxs(nrec,nbox)
      DIMENSION  wf(nrbox,nobox)
      DIMENSION  rmesh(3,nrbox)
      DIMENSION  vbox(nrbox)
      DIMENSION  dmat(norb,norb)
c scratch arrays:
      DIMENSION  wkbi(nrbox), wkbox(nrbox,*)
      DIMENSION  dphix(nrbox),dphiy(nrbox),dphiz(nrbox)
      DIMENSION  dphiuv(ndim,ndim,nrbox)
c local declarations:
      DIMENSION  strbox(3,3)
      DIMENSION  boxctr(3)
      DATA  r4zero / 0.e0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
      jnbox = 0
c
c Loop over atoms/shells
c
       irec = 0
       iatshl = 0
       inext = 0
       ibnext = 0
       do 200 iatm=1,natm
         ityp = itypa(iatm)
         almina = alamin(ityp)
c
         do 180 ishl=1,numshl(ityp)
           lshli = lshel(ishl,ityp)
           norbshi = 2*lshli + 1
           inbox = inbox/2
           if( inrec*(iatshl/inrec).eq.iatshl )then
             irec = irec + 1
             inbox = inboxs(irec,ibox)
           endif
           iatshl = iatshl + 1
           i0 = inext
           inext = inext + norbshi
           if( EVEN(inbox) ) goto 180
c
           ib0 = ibnext
           ibnext = ibnext + norbshi
c
           almins = ala(1,ishl,ityp)
           do  ial=2,nala(ishl,ityp)
             ali = ala(ial,ishl,ityp)
             if( ali.lt.almins ) almins = ali
           enddo
           almin = almina
c
           i = i0
           ib = ib0
           do 170 iorbsh=1,norbshi
            i = i + 1
            ib = ib + 1
c
c  For force calculation:
c   compute derivatives of i-th wave function
c  For stress calculation:
c   compute (x-X) times x-derivative of i-th wave function
c   compute (y-Y) times y-derivative of i-th wave function
c
            call GRADWF( ibox,     1, ndim, iatm,ishl,iorbsh, almin,
     $        1,0,1, natm,ntyp, nshld,nald, nlat,
     $       itypa, numshl,lshel,nala,ala,cala, ratm, rlat, coskr,sinkr,
     $       nrbox, boxrad, boxctr,
     $       rmesh,  wkbox(1,1), wkbox(1,2),wkbox(1,3),
c -->        rv-3io  rsq-s       sumg-s     sum2ag-s
     $       wkbox(1,4),wkbox(1,5),wkbox(1,6),
c -->        dpdx-s     dpdy-s     dpdz-s
     $       dphix,dphiy,dphiz,  dphiuv )
c
c    Clear SUM(j) of dmij*phi-j
c
            call MKSZERO( nrbox, wkbi )
c
c    Atom j loop:
c
            jrec = 0
            jatshl = 0
            jnext = 0
            jbnext = 0
            do 100 jatm=1,natm
              jtyp = itypa(jatm)
c
              do 80 jshl=1,numshl(jtyp)
               lshlj = lshel(jshl,jtyp)
               norbshj = 2*lshlj + 1
c
               jnbox = jnbox/2
               if( inrec*(jatshl/inrec).eq.jatshl )then
                 jrec = jrec + 1
                 jnbox = inboxs(jrec,ibox)
               endif
               jatshl = jatshl + 1
               j0 = jnext
               jnext = jnext + norbshj
               if( EVEN(jnbox) ) goto 80
c
               jb0 = jbnext
               jbnext = jbnext + norbshj
c
               j = j0
               jb = jb0
               do 70 jorbsh=1,norbshj
                j = j + 1
                jb = jb + 1
c
                dmatr = dmat(i,j)
                call SAXPY( nrbox, dmatr, wf(1,jb),1, wkbi,1)
Cc
C                do  nr=1,nrbox
C                  wkbi(nr) = wkbi(nr) + dmatr*wf(nr,jb)
C                enddo
c
c    Close atom j orbital, atom loops:
c
   70          continue
c
   80         continue
  100       continue
c
c  Complete force integrals ...
c
            fxint = r4zero
            fyint = r4zero
            fzint = r4zero
            call MKSZERO( 9, strbox )
c
            do  nr=1,nrbox
              wkbi(nr) = vbox(nr)*wkbi(nr)
            enddo
c
            do  nr=1,nrbox
              fxint = fxint + dphix(nr)*wkbi(nr)
              fyint = fyint + dphiy(nr)*wkbi(nr)
              fzint = fzint + dphiz(nr)*wkbi(nr)
            enddo
c
            if( ndim.eq.1 )then
              do  nr=1,nrbox
                strbox(1,1) = strbox(1,1) + dphiuv(1,1,nr)*wkbi(nr)
              enddo
            elseif( ndim.eq.2 )then
              do  nr=1,nrbox
                strbox(1,1) = strbox(1,1) + dphiuv(1,1,nr)*wkbi(nr)
                strbox(2,1) = strbox(2,1) + dphiuv(2,1,nr)*wkbi(nr)
                strbox(1,2) = strbox(1,2) + dphiuv(1,2,nr)*wkbi(nr)
                strbox(2,2) = strbox(2,2) + dphiuv(2,2,nr)*wkbi(nr)
              enddo
            elseif( ndim.eq.3 )then
              do  nr=1,nrbox
                strbox(1,1) = strbox(1,1) + dphiuv(1,1,nr)*wkbi(nr)
                strbox(2,1) = strbox(2,1) + dphiuv(2,1,nr)*wkbi(nr)
                strbox(3,1) = strbox(3,1) + dphiuv(3,1,nr)*wkbi(nr)
                strbox(1,2) = strbox(1,2) + dphiuv(1,2,nr)*wkbi(nr)
                strbox(2,2) = strbox(2,2) + dphiuv(2,2,nr)*wkbi(nr)
                strbox(3,2) = strbox(3,2) + dphiuv(3,2,nr)*wkbi(nr)
                strbox(1,3) = strbox(1,3) + dphiuv(1,3,nr)*wkbi(nr)
                strbox(2,3) = strbox(2,3) + dphiuv(2,3,nr)*wkbi(nr)
                strbox(3,3) = strbox(3,3) + dphiuv(3,3,nr)*wkbi(nr)
              enddo
            endif
c
            frcslo(1,iatm) = frcslo(1,iatm) + fxint
            frcslo(2,iatm) = frcslo(2,iatm) + fyint
            frcslo(3,iatm) = frcslo(3,iatm) + fzint
c
            do  jd=1,ndim
              do  id=1,ndim
                strslo(id,jd) = strslo(id,jd) + strbox(id,jd)
              enddo
            enddo
c
c    Close atom i orbital, atom loops:
c
  170      continue
  180     continue
  200   continue
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOF2B
c
c
      subroutine VSLOF2B( ibox, ndim, frcslo,strslo,
     $ norb,nk,nk0,nkloc, natm,ntyp, nshld,nald, nlat,
     $ itypa,numshl,lshel,nala,ala,cala, alamin,
     $ ratm, rlat, coskr,sinkr,
     $ hh, nbox,nrec,inrec, nrbox,nobox,inboxs, boxrad,boxctr,
     $ wvfcns, rmesh, vbox, wkbox, wkbi,
     $ dphix,dphiy,dphiz,  dphiuv,
     $ dmat, dmatbx )
c---------------------------------------------------------------
c Purpose: computes force/stress from grid potentials in a box
c          for complex basis orbitals
c          Version using level-3 blas
c
c Written: Peter A. Schultz, 10-June-1999, for v2.36
c
c Revision history:
c  23Jan09-PAS/2.63: k-parallel dmat matrices
c  27Sep99-PAS/2.40: full three-dimensional stress tensor
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  dphix,dphiy,dphiz,  dphiuv
      REAL  vbox
      REAL  dmat, dmatbx
      REAL  r4zero, c4zero,c4one
      REAL  fxint,fyint,fzint,  strbox
c
c output arrays:
      DIMENSION  frcslo(3,natm), strslo(3,3)
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp)
      DIMENSION  ratm(3,natm), rlat(3,nlat)
      DIMENSION  coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  hh(3),inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,nrbox,nkloc,nobox)
      DIMENSION  rmesh(3,nrbox)
      DIMENSION  vbox(nrbox)
      DIMENSION  dmat(2,nkloc,norb,norb)
c scratch arrays:
      DIMENSION  wkbi(2,nrbox,nobox,nkloc), wkbox(nrbox,*)
      DIMENSION  dphix(2,nrbox,nkloc),dphiy(2,nrbox,nkloc),
     $           dphiz(2,nrbox,nkloc)
      DIMENSION  dphiuv(ndim,ndim,2,nrbox,nkloc)
      DIMENSION  dmatbx(2,nobox,nobox,nkloc)
c local declarations:
      DIMENSION  strbox(3,3)
      DIMENSION  boxctr(3)
      DIMENSION  c4zero(2),c4one(2)
      DATA  c4zero / 0.e0,0.e0 /, c4one / 1.e0,0.e0 /
      DATA  r4zero / 0.e0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
      jnbox = 0
c
c Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        inext = 0
        ibnext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            ib0 = ibnext
            ibnext = ibnext + norbshi
c
            jrec = 0
            jatshl = 0
            jnext = 0
            jbnext = 0
            do 100 jatm=1,iatm
              jtyp = itypa(jatm)
              nshlj = numshl(jtyp)
              if( jatm.eq.iatm ) nshlj = ishl
c
              do 80 jshl=1,nshlj
                norbshj = 2*lshel(jshl,jtyp) + 1
c
                jnbox = jnbox/2
                if( inrec*(jatshl/inrec).eq.jatshl )then
                  jrec = jrec + 1
                  jnbox = inboxs(jrec,ibox)
                endif
                jatshl = jatshl + 1
                j0 = jnext
                jnext = jnext + norbshj
                if( EVEN(jnbox) ) goto 80
c
                jb0 = jbnext
                jbnext = jbnext + norbshj
c
                joff = 0
                if( jatm.eq.iatm .and. jshl.eq.ishl )then
                  norbshj = 0
                  joff = 1
                endif
c
                i = i0
                ib = ib0
                do 170 iorbsh=1,norbshi
                  i = i + 1
                  ib = ib + 1
c
                  norbshj = norbshj + joff
c
                  j = j0
                  jb = jb0
                  do 70 jorbsh=1,norbshj
                    j = j + 1
                    jb = jb + 1
c
                    do 60 ikloc=1,nkloc
c
                      dmatbx(1,jb,ib,ikloc) =  dmat(1,ikloc,j,i)
                      dmatbx(2,jb,ib,ikloc) =  dmat(2,ikloc,j,i)
                      dmatbx(1,ib,jb,ikloc) =  dmat(1,ikloc,i,j)
                      dmatbx(2,ib,jb,ikloc) =  dmat(2,ikloc,i,j)
c
   60               continue
c
   70             continue
  170           continue
c
   80         continue
  100       continue
c
  180     continue
  200   continue
c
c  Now have dmat in this box packed in dmatbx.
c
      do  ikloc=1,nkloc
c
c Do heavy lifting inside level-3 blas routine:
        call CGEMM( 'n','n', nrbox,nobox,nobox, c4one,
     $   wvfcns(1,1,ikloc,1), nkloc*nrbox,
     $   dmatbx(1,1,1,ikloc), nobox, c4zero,
     $   wkbi(1,1,1,ikloc), nrbox )
c
      enddo
c
      inbox = 0
c
c  Complete gradient calculation: loop over atoms/shells
c
      irec = 0
      iatshl = 0
      inext = 0
      ibnext = 0
      do 1200 iatm=1,natm
        ityp = itypa(iatm)
        almina = alamin(ityp)
c
        do 1180 ishl=1,numshl(ityp)
          lshli = lshel(ishl,ityp)
          norbshi = 2*lshli + 1
          inbox = inbox/2
          if( inrec*(iatshl/inrec).eq.iatshl )then
            irec = irec + 1
            inbox = inboxs(irec,ibox)
          endif
          iatshl = iatshl + 1
          i0 = inext
          inext = inext + norbshi
          if( EVEN(inbox) ) goto 1180
c
          ib0 = ibnext
          ibnext = ibnext + norbshi
c
          almins = ala(1,ishl,ityp)
          do  ial=2,nala(ishl,ityp)
            ali = ala(ial,ishl,ityp)
            if( ali.lt.almins ) almins = ali
          enddo
          almin = almina
c
          i = i0
          ib = ib0
          do 1170 iorbsh=1,norbshi
            i = i + 1
            ib = ib + 1
c
c  For force calculation:
c   compute derivatives of i-th wave function
c  For stress calculation:
c   compute (x-X) times x-derivative of i-th wave function
c   compute (y-Y) times y-derivative of i-th wave function
c
            call GRADWF( ibox,     2, ndim, iatm,ishl,iorbsh, almin,
     $       nk,nk0,nkloc, natm,ntyp, nshld,nald, nlat,
     $       itypa, numshl,lshel,nala,ala,cala, ratm, rlat, coskr,sinkr,
     $       nrbox, boxrad, boxctr,
     $       rmesh,  wkbox(1,1), wkbox(1,2),wkbox(1,3),
c -->        rv-3io  rsq-s       sumg-s     sum2ag-s
     $       wkbox(1,4),wkbox(1,5),wkbox(1,6),
c -->        dpdx-s     dpdy-s     dpdz-s
     $       dphix,dphiy,dphiz,  dphiuv )
c
c  Complete force integrals ...
c
            fxint = r4zero
            fyint = r4zero
            fzint = r4zero
            call MKSZERO( 9, strbox )
c
            do 1160 ikloc=1,nkloc
              do  nr=1,nrbox
                wkbi(1,nr,ib,ikloc) = vbox(nr)*wkbi(1,nr,ib,ikloc)
                wkbi(2,nr,ib,ikloc) = vbox(nr)*wkbi(2,nr,ib,ikloc)
              enddo
              do  nr=1,nrbox
                fxint = fxint + dphix(1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $                        + dphix(2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                fyint = fyint + dphiy(1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $                        + dphiy(2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                fzint = fzint + dphiz(1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $                        + dphiz(2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
              enddo
 1160       continue
c
            if( ndim.eq.1 )then
              do 1161 ikloc=1,nkloc
                do  nr=1,nrbox
                  strbox(1,1) = strbox(1,1)
     $             + dphiuv(1,1,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(1,1,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                enddo
 1161         continue
            elseif( ndim.eq.2 )then
              do 1162 ikloc=1,nkloc
                do  nr=1,nrbox
                  strbox(1,1) = strbox(1,1)
     $             + dphiuv(1,1,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(1,1,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                  strbox(2,1) = strbox(2,1)
     $             + dphiuv(2,1,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(2,1,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                  strbox(1,2) = strbox(1,2)
     $             + dphiuv(1,2,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(1,2,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                  strbox(2,2) = strbox(2,2)
     $             + dphiuv(2,2,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(2,2,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                enddo
 1162         continue
            elseif( ndim.eq.3 )then
              do 1163 ikloc=1,nkloc
                do  nr=1,nrbox
                  strbox(1,1) = strbox(1,1)
     $             + dphiuv(1,1,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(1,1,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                  strbox(2,1) = strbox(2,1)
     $             + dphiuv(2,1,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(2,1,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                  strbox(3,1) = strbox(3,1)
     $             + dphiuv(3,1,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(3,1,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                  strbox(1,2) = strbox(1,2)
     $             + dphiuv(1,2,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(1,2,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                  strbox(2,2) = strbox(2,2)
     $             + dphiuv(2,2,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(2,2,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                  strbox(3,2) = strbox(3,2)
     $             + dphiuv(3,2,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(3,2,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                  strbox(1,3) = strbox(1,3)
     $             + dphiuv(1,3,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(1,3,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                  strbox(2,3) = strbox(2,3)
     $             + dphiuv(2,3,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(2,3,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                  strbox(3,3) = strbox(3,3)
     $             + dphiuv(3,3,1,nr,ikloc)*wkbi(1,nr,ib,ikloc)
     $             + dphiuv(3,3,2,nr,ikloc)*wkbi(2,nr,ib,ikloc)
                enddo
 1163         continue
            endif
c
            frcslo(1,iatm) = frcslo(1,iatm) + fxint
            frcslo(2,iatm) = frcslo(2,iatm) + fyint
            frcslo(3,iatm) = frcslo(3,iatm) + fzint
c
            do  jd=1,ndim
              do  id=1,ndim
                strslo(id,jd) = strslo(id,jd) + strbox(id,jd)
              enddo
            enddo
c
c    Close atom i orbital, atom loops:
c
 1170     continue
 1180   continue
 1200 continue
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOF2
c
c
      subroutine VSLOF2( ibox, ndim, frcslo,strslo,
     $ norb,nk,nk0,nkloc, natm,ntyp, nshld,nald, nlat,
     $ itypa,numshl,lshel,nala,ala,cala, alamin,
     $ ratm, rlat, coskr,sinkr,
     $ hh, nbox,nrec,inrec, nrbox,nobox,inboxs, boxrad,boxctr,
     $ wvfcns, rmesh, vbox, wkbox, wkbi,
     $ dphix,dphiy,dphiz,  dphiuv,
     $ dmat )
c---------------------------------------------------------------
c Purpose: computes force/stress from grid potentials in a box
c          for complex basis orbitals
c
c Written: Peter A. Schultz, 10-June-1999, for v2.36
c
c Revision history:
c  23Jan09-PAS/2.63: k-parallel dmat matrices
c  11Nov99-PAS/2.42: stress 13/31 bugfix
c  27Sep99-PAS/2.40: full three-dimensional stress tensor
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  dphix,dphiy,dphiz,  dphiuv
      REAL  vbox
      REAL  dmat, dmatr,dmati, dmatc
      REAL  fxint,fyint,fzint,  strbox
      REAL  r4zero
c
c output arrays:
      DIMENSION  frcslo(3,natm), strslo(3,3)
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp)
      DIMENSION  ratm(3,natm), rlat(3,nlat)
      DIMENSION  coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  hh(3),inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,nrbox,nkloc,nobox)
      DIMENSION  rmesh(3,nrbox)
      DIMENSION  vbox(nrbox)
      DIMENSION  dmat(2,nkloc,norb,norb)
c scratch arrays:
      DIMENSION  wkbi(2,nrbox,nkloc), wkbox(nrbox,*)
      DIMENSION  dphix(2,nrbox,nkloc),dphiy(2,nrbox,nkloc),
     $           dphiz(2,nrbox,nkloc)
      DIMENSION  dphiuv(ndim,ndim,2,nrbox,nkloc)
c local declarations:
      DIMENSION  strbox(3,3)
      DIMENSION  dmatc(2)
      EQUIVALENCE  (dmatr,dmatc(1)),(dmati,dmatc(2))
      DIMENSION  boxctr(3)
      DATA  r4zero / 0.e0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
      jnbox = 0
c
c Loop over atoms/shells
c
      irec = 0
      iatshl = 0
      inext = 0
      ibnext = 0
      do 200 iatm=1,natm
        ityp = itypa(iatm)
        almina = alamin(ityp)
c
        do 180 ishl=1,numshl(ityp)
          lshli = lshel(ishl,ityp)
          norbshi = 2*lshli + 1
          inbox = inbox/2
          if( inrec*(iatshl/inrec).eq.iatshl )then
            irec = irec + 1
            inbox = inboxs(irec,ibox)
          endif
          iatshl = iatshl + 1
          i0 = inext
          inext = inext + norbshi
          if( EVEN(inbox) ) goto 180
c
          ib0 = ibnext
          ibnext = ibnext + norbshi
c
          almins = ala(1,ishl,ityp)
          do  ial=2,nala(ishl,ityp)
            ali = ala(ial,ishl,ityp)
            if( ali.lt.almins ) almins = ali
          enddo
          almin = almina
c
          i = i0
          ib = ib0
          do 170 iorbsh=1,norbshi
            i = i + 1
            ib = ib + 1
c
c  For force calculation:
c   compute derivatives of i-th wave function
c  For stress calculation:
c   compute (x-X) times x-derivative of i-th wave function
c   compute (y-Y) times y-derivative of i-th wave function
c
            call GRADWF( ibox,     2, ndim, iatm,ishl,iorbsh, almin,
     $       nk,nk0,nkloc, natm,ntyp, nshld,nald, nlat,
     $       itypa, numshl,lshel,nala,ala,cala, ratm, rlat, coskr,sinkr,
     $       nrbox, boxrad, boxctr,
     $       rmesh,  wkbox(1,1), wkbox(1,2),wkbox(1,3),
c -->        rv-3io  rsq-s       sumg-s     sum2ag-s
     $       wkbox(1,4),wkbox(1,5),wkbox(1,6),
c -->        dpdx-s     dpdy-s     dpdz-s
     $       dphix,dphiy,dphiz,  dphiuv )
c
c    Clear SUM(j) of dmij*phi-j
c
            call MKSZERO( 2*nkloc*nrbox, wkbi )
c
c    Atom j loop:
c
            jrec = 0
            jatshl = 0
            jnext = 0
            jbnext = 0
            do 100 jatm=1,natm
              jtyp = itypa(jatm)
c
              do 80 jshl=1,numshl(jtyp)
               lshlj = lshel(jshl,jtyp)
               norbshj = 2*lshlj + 1
c
               jnbox = jnbox/2
               if( inrec*(jatshl/inrec).eq.jatshl )then
                 jrec = jrec + 1
                 jnbox = inboxs(jrec,ibox)
               endif
               jatshl = jatshl + 1
               j0 = jnext
               jnext = jnext + norbshj
               if( EVEN(jnbox) ) goto 80
c
               jb0 = jbnext
               jbnext = jbnext + norbshj
c
               j = j0
               jb = jb0
               do 70 jorbsh=1,norbshj
                j = j + 1
                jb = jb + 1
c
                do 60 ikloc=1,nkloc
c
                  dmatr =  dmat(1,ikloc,i,j)
                  dmati = -dmat(2,ikloc,i,j)
                  call CAXPY( nrbox, dmatc, wvfcns(1,1,ikloc,jb),1,
     $               wkbi(1,1,ikloc),1 )
c
c This was the explicit code this replaces:
c                  do  nr=1,nrbox
c                    wkbi(1,nr,ikloc) = wkbi(1,nr,ikloc)
c     $                           + dmatr*wvfcns(1,nr,ikloc,jb)
c     $                           - dmati*wvfcns(2,nr,ikloc,jb)
c                    wkbi(2,nr,ikloc) = wkbi(2,nr,ikloc)
c     $                           + dmati*wvfcns(1,nr,ikloc,jb)
c     $                           + dmatr*wvfcns(2,nr,ikloc,jb)
c                  enddo
c
   60           continue
c
c    Close atom j orbital, atom loops:
c
   70          continue
c
   80         continue
  100       continue
c
c  Complete force integrals ...
c
            fxint = r4zero
            fyint = r4zero
            fzint = r4zero
            call MKSZERO( 9, strbox )
c
            do 160 ikloc=1,nkloc
              do  nr=1,nrbox
                wkbi(1,nr,ikloc) = vbox(nr)*wkbi(1,nr,ikloc)
                wkbi(2,nr,ikloc) = vbox(nr)*wkbi(2,nr,ikloc)
              enddo
              do  nr=1,nrbox
                fxint = fxint + dphix(1,nr,ikloc)*wkbi(1,nr,ikloc)
     $                        + dphix(2,nr,ikloc)*wkbi(2,nr,ikloc)
                fyint = fyint + dphiy(1,nr,ikloc)*wkbi(1,nr,ikloc)
     $                        + dphiy(2,nr,ikloc)*wkbi(2,nr,ikloc)
                fzint = fzint + dphiz(1,nr,ikloc)*wkbi(1,nr,ikloc)
     $                        + dphiz(2,nr,ikloc)*wkbi(2,nr,ikloc)
              enddo
  160       continue
c
            if( ndim.eq.1 )then
              do 161 ikloc=1,nkloc
                do  nr=1,nrbox
                  strbox(1,1) = strbox(1,1)
     $             + dphiuv(1,1,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(1,1,2,nr,ikloc)*wkbi(2,nr,ikloc)
                enddo
  161         continue
            elseif( ndim.eq.2 )then
              do 162 ikloc=1,nkloc
                do  nr=1,nrbox
                  strbox(1,1) = strbox(1,1)
     $             + dphiuv(1,1,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(1,1,2,nr,ikloc)*wkbi(2,nr,ikloc)
                  strbox(2,1) = strbox(2,1)
     $             + dphiuv(2,1,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(2,1,2,nr,ikloc)*wkbi(2,nr,ikloc)
                  strbox(1,2) = strbox(1,2)
     $             + dphiuv(1,2,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(1,2,2,nr,ikloc)*wkbi(2,nr,ikloc)
                  strbox(2,2) = strbox(2,2)
     $             + dphiuv(2,2,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(2,2,2,nr,ikloc)*wkbi(2,nr,ikloc)
                enddo
  162         continue
            elseif( ndim.eq.3 )then
              do 163 ikloc=1,nkloc
                do  nr=1,nrbox
                  strbox(1,1) = strbox(1,1)
     $             + dphiuv(1,1,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(1,1,2,nr,ikloc)*wkbi(2,nr,ikloc)
                  strbox(2,1) = strbox(2,1)
     $             + dphiuv(2,1,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(2,1,2,nr,ikloc)*wkbi(2,nr,ikloc)
                  strbox(3,1) = strbox(3,1)
     $             + dphiuv(3,1,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(3,1,2,nr,ikloc)*wkbi(2,nr,ikloc)
                  strbox(1,2) = strbox(1,2)
     $             + dphiuv(1,2,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(1,2,2,nr,ikloc)*wkbi(2,nr,ikloc)
                  strbox(2,2) = strbox(2,2)
     $             + dphiuv(2,2,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(2,2,2,nr,ikloc)*wkbi(2,nr,ikloc)
                  strbox(3,2) = strbox(3,2)
     $             + dphiuv(3,2,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(3,2,2,nr,ikloc)*wkbi(2,nr,ikloc)
                  strbox(1,3) = strbox(1,3)
     $             + dphiuv(1,3,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(1,3,2,nr,ikloc)*wkbi(2,nr,ikloc)
                  strbox(2,3) = strbox(2,3)
     $             + dphiuv(2,3,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(2,3,2,nr,ikloc)*wkbi(2,nr,ikloc)
                  strbox(3,3) = strbox(3,3)
     $             + dphiuv(3,3,1,nr,ikloc)*wkbi(1,nr,ikloc)
     $             + dphiuv(3,3,2,nr,ikloc)*wkbi(2,nr,ikloc)
                enddo
  163         continue
            endif
c
            frcslo(1,iatm) = frcslo(1,iatm) + fxint
            frcslo(2,iatm) = frcslo(2,iatm) + fyint
            frcslo(3,iatm) = frcslo(3,iatm) + fzint
c
            do  jd=1,ndim
              do  id=1,ndim
                strslo(id,jd) = strslo(id,jd) + strbox(id,jd)
              enddo
            enddo
c
c    Close atom i orbital, atom loops:
c
  170     continue
  180   continue
  200 continue
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOFIX
c
c
      subroutine VSLOFIX( near2c, s1atom, orbint,orbofk,
     $ norb,nk, natm,ntyp,nshld, noad, itypa,numshl,lshel,
     $ vslnear, ncplx,
     $ vmat )
c---------------------------------------------------------------
c Purpose: fix grid matrix elements with nearby construction
c
c Written: Peter A. Schultz, 29-April-1997, for v2.17
c
c Revision history:
c   4Dec08-PAS/2.63: k-parallel scf matrices
c  10Dec98-PAS/2.29: promote source to explicit double precision
c   9Sep98-PAS/2.25: bug fix (argh), clean and match
c    Mar98-PAS/2.22: allow option to turn off 2ctr nearby
c   3Jun97-PAS/2.20: cut old grid cutoff stuff for boxes
c---------------------------------------------------------------
c
c Notes: Checking whether atoms overlap can be skipped - it is
c        a cheap n**2 problem here.
c
c     ACP Notes: vmat is not initialized to zero here, rather if needed
c     this done in the calling routine. Work is done at the image level.
c     (Processes within the same k-point communicator should compute the
c     exact same quantities. Also processes do not communicate as part
C     of the computation here, so if no rounding errors have accumulated
c     in the inputs, the results should agree exactly with the serial
C     computation.) 
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input arrays:
      DIMENSION  s1atom(noad,noad,nk,natm)
      DIMENSION  orbint(2,norb,nk),orbofk(2,natm,norb,nk)
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  vslnear(natm)
c Input/Output arrays:
      DIMENSION  vmat(norb,norb,*)
c
c Local declarations:
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      if( near2c .eq. 0 ) RETURN
c
      call MPNODES( nprocl )
      call MPNODE( iprocl )
c
      call KPMINE( nk,nkloc,nk0 )
c     Check if there is nothing to do for this proc:
      if( nkloc .eq. 0 ) RETURN
c
      inext = 0
      do 200 iatm=1,natm
        ityp = itypa(iatm)
c
        iorbat00 = 0
        do 180 ishl=1,numshl(ityp)
          norbshi = 2*lshel(ishl,ityp) + 1
          i0 = inext
          inext = inext + norbshi
          iorbat0 = iorbat00
          iorbat00 = iorbat00 + norbshi
c
          jnext = 0
          do 100 jatm=1,iatm
            jtyp = itypa(jatm)
            nshlj = numshl(jtyp)
            if( jatm.eq.iatm ) nshlj = ishl
c
            vnri = vslnear(iatm)
            vnrj = vslnear(jatm)
c
            jorbat00 = 0
            do 80 jshl=1,nshlj
              norbshj = 2*lshel(jshl,jtyp) + 1
              j0 = jnext
              jnext = jnext + norbshj
              jorbat0 = jorbat00
              jorbat00 = jorbat00 + norbshj
c
              joff = 0
              if( jatm.eq.iatm .and. jshl.eq.ishl )then
                norbshj = 0
                joff = 1
              endif
c
              i = i0
              iorbat = iorbat0
              do 170 iorbsh=1,norbshi
                iorbat = iorbat + 1
                i = i + 1
c
                norbshj = norbshj + joff
c
                j = j0
                jorbat = jorbat0
                do 70 jorbsh=1,norbshj
                  jorbat = jorbat + 1
                  j = j + 1
c
                  do 50 ikloc=1,nkloc
                    ik = nk0 + ikloc
                    vintr = zero
                    vinti = zero
c
                    if( iatm.eq.jatm )then
                      vintr = vnri*s1atom(iorbat,jorbat,ik,iatm)
                      if( iorbat.ne.jorbat )then
                        vinti = vnri*s1atom(jorbat,iorbat,ik,iatm)
                      endif
                    elseif( near2c .eq. 2 )then
                      si2r = orbint(1,i,ik)*orbofk(1,iatm,j,ik)
     $                     + orbint(2,i,ik)*orbofk(2,iatm,j,ik)
                      si2i = orbint(2,i,ik)*orbofk(1,iatm,j,ik)
     $                     - orbint(1,i,ik)*orbofk(2,iatm,j,ik)
                      sj2r = orbofk(1,jatm,i,ik)*orbint(1,j,ik)
     $                     + orbofk(2,jatm,i,ik)*orbint(2,j,ik)
                      sj2i = orbofk(2,jatm,i,ik)*orbint(1,j,ik)
     $                     - orbofk(1,jatm,i,ik)*orbint(2,j,ik)
                      vintr = vnri*si2r + vnrj*sj2r
                      vinti = vnri*si2i + vnrj*sj2i
                    endif
c
                    vmat(i,j,ikloc) = vmat(i,j,ikloc) + vintr
                    if( j.ne.i .and. ncplx.eq.2 )then
                      vmat(j,i,ikloc) = vmat(j,i,ikloc) + vinti
                    endif
c
   50             continue
c
   70           continue
c
  170         continue
c
   80       continue
  100     continue
c
  180   continue
  200 continue
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOFRC
c
c
      subroutine VSLOFRC( idmatfl, ndim,ncplx,idwf,doblas3,
     $ nafrc,iforce, frcslo,strslo,
     $ norb,nk, natm,ntyp, nshld,nald, nlat,
     $ itypa,numshl,lshel,nala,ala,cala, alamin,
     $ ratm, rlat, wtk,coskr,sinkr,
     $ weight, hh, ndbox,nbox,nrec,inrec,noboxs,inboxs, boxrad,
     $ rmesh, vbox, wkbox, frctp,
     $ wvfcns,wf,
     $ wkbi, dphi,
     $ dmatrd, dmat,  vslo )
c      R8(mat) R4(ncplx*nkloc*mat), ncplx*nkloc*nsumnrbox
c---------------------------------------------------------------
c Purpose: compute force/stress from grid potentials
c
c Written: Peter A. Schultz,  3-June-1997, for v2.20 (boxes)
c
c Revision history:
c   4Dec08-PAS/2.63: k-parallel dmat matrices
c   4Jan08-PAS/2.61: reduced (dist) memory for grid wvfcns
c  11May07-PAS/2.60: merged tp and serial
c   6Jul06-APT/2.59: merged task parallel and image parallel
c  30Jul05-PAS/2.59: master-only matrix files
c  25Sep04-PAS/tp0.1: clean-up task-parallel routines
c   6May03-DMC: Add frctp to parameter list, to provide a local
c               copy of the frcslo array, for parallelization.
c  23Jul01-PAS/2.49: compact dmat; spin-polarized dft
c   2May01-PAS/2.47: remove disk storage of grid orbitals
c  27Sep99-PAS/2.40: full three-dimensional stress tensor
c  10Jun99-PAS/2.36: pull into blas
c  15Feb99-PAS/2.31: routine to intercept perhaps too-big i/o
c  17Dec98-PAS/2.30: clean force/stress arrays, remove grid es
c                    contribution its own routine ("eslofrc")
c   9Nov98-PAS/2.28: single precision grid orbitals/wf4
c  10Sep98-PAS/2.26: on-the-fly grid orbitals
c  23Jul98-PAS/2.23: adapted for split basis
c---------------------------------------------------------------
c
c Notes:
c  Assumes potential vslo has been shuffled into boxes on input
c
c  Nearby stuff not implemented; to do and keep efficient SUM(dmij*ph-j)
c  construction, do atom-wise sums
c
c  Can try to move twowt factor up into more useful place
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      REAL  dmat
      REAL  wvfcns,wf, wkbi
      REAL  vbox
      REAL  dphi
c
c Output arrays:
      DIMENSION  frcslo(3,natm), strslo(3,3)
c Input arrays:
      LOGICAL    doblas3
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp)
      DIMENSION  ratm(3,natm), rlat(3,nlat)
      DIMENSION  wtk(nk),coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  hh(3), ndbox(2,2,3),noboxs(nbox),inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,*),wf(*)
      DIMENSION  vslo(*)
c Scratch arrays:
      DIMENSION  wkbi(*), wkbox(*)
      DIMENSION  dmatrd(norb,norb)
      DIMENSION  dmat(*)
c                dmat(ncplx*nkloc,norb,norb)
      DIMENSION  rmesh(3,*)
      DIMENSION  vbox(*)
      DIMENSION  dphi(*)
c Scratch/parallel:
      DIMENSION  frctp(3,natm), strtp(3,3)
c
c Local declarations:
      DIMENSION  r0box(3),boxctr(3)
      DATA  zero,two / 0.d0,2.d0 /
      DATA  r4zero / 0.e0 /
c
c >>>> EXECUTABLE CODE:
c
c  Clear out force arrays
      call MKZERO( 3*natm, frcslo )
      call MKZERO( 9, strslo )
c
c  Get Local MP info
      call MPNODES( nprocl )
      call MPNODE( iprocl )
      call MPNODE0( masterl )
      call MPCOMM( icomml )
c
      call MPNODES_K( nprocs )
      call MPNODE_K( iproc )
      call MPNODE0_K( master )
      call MPCOMM_K( icomm )
c  Set up k-parallel
      call KPMINE( nk,nkloc,nk0 )
c
c  Get and sort density matrix into k-first form
c
      call KPDMATRD2( idmatfl, norb, ncplx, nk,nk0,nkloc,
     $ dmatrd,      dmat )                   
c      r8(norb^2)-s r4(ncplx*norb^2*nkloc)-o
      ipdm2 = ncplx*nkloc*norb*norb + 1
c
c  Initialize location of grid orbitals
      ir00 = 0
c
      irpot = 0
c
c Cycle over boxes of grid points
c
      do 1000 ibox=1,nbox
c
c       Get basic box info
        call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $   ira0,irb0,irc0, idra,idrb,idrc )
        nrbox = idra*idrb*idrc
c
c       Update location in global mesh potential array
        iv0 = irpot
        irpot = irpot + nrbox
c
c       Get number of orbitals in this box; skip if none
        nobox = noboxs(ibox)
        if( nobox.le.0 ) goto 1000
c
c       Each processor will do every nprocs'th box in this loop.
        if( iproc .ne. MOD( ibox, nprocs ) ) goto 1000
c
c       Generate mesh point coordinates
        call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
        call MKRBOX( hh,r0box, idra,idrb,idrc, rmesh )
c
c       Get grid orbitals:
c
        if( idwf.eq.0 )then
c         Compute orbitals on mesh in this box
c
          ir00 = 0
          iwk1 = 1
          iwk2 = 1
C          iwk2 = iwk1 + 3*nrbox
          iwk3 = iwk2 + nrbox
          iwk4 = iwk3 + nrbox
          iwk5 = iwk4 + nrbox
          iwk6 = iwk5 + nrbox
          iwk7 = iwk6 + nrbox
          iwk8 = iwk7 + nrbox
c
          call BOXWFN( ibox, ncplx,
     $     nk,nk0,nkloc, natm,ntyp, nshld,nald, nlat,
     $     itypa,numshl,lshel,nala,ala,cala,alamin,
     $     ratm,rlat,coskr,sinkr,
     $     nobox,nrbox,nrec,inrec,inboxs, boxrad,boxctr,
     $     wvfcns(1,ir00+1), wf(ir00+1),
     $     rmesh      ,wkbox(iwk2),wkbox(iwk3),wkbox(iwk4),
     $     wkbox(iwk5),wkbox(iwk6),wkbox(iwk7),wkbox(iwk8) )
c
        endif
c
c       Put r*8 potential into r*4 space for use below:
        do  nr=1,nrbox
          vbox(nr) = vslo(iv0+nr)
        enddo
c
c       Carve up space for derivatives of grid wave functions:
        nrkbox = ncplx*nkloc*nrbox
        id1 = 1
        id2 = id1 + 1*nrkbox
        id3 = id1 + 2*nrkbox
        id4 = id1 + 3*nrkbox
c
        if( ncplx.eq.1 )then
c
c         Real orbitals
c
          if( doblas3 )then
            call VSLOF1B( ibox, ndim, frcslo,strslo,
     $       norb, natm,ntyp, nshld,nald, nlat,
     $       itypa,numshl,lshel,nala,ala,cala, alamin,
     $       ratm, rlat, coskr,sinkr,
     $       hh, nbox,nrec,inrec, nrbox,nobox,inboxs, boxrad,boxctr,
     $       wf(ir00+1), rmesh, vbox, wkbox, wkbi,
     $       dphi(id1),dphi(id2),dphi(id3),  dphi(id4),
c -->        dphix-s   dphiy-s   dphiz-s     dphiuv-s
     $       dmat, dmat(ipdm2) )
          else
            call VSLOF1( ibox, ndim, frcslo,strslo,
     $       norb, natm,ntyp, nshld,nald, nlat,
     $       itypa,numshl,lshel,nala,ala,cala, alamin,
     $       ratm, rlat, coskr,sinkr,
     $       hh, nbox,nrec,inrec, nrbox,nobox,inboxs, boxrad,boxctr,
     $       wf(ir00+1), rmesh, vbox, wkbox, wkbi,
     $       dphi(id1),dphi(id2),dphi(id3),  dphi(id4),
c -->        dphix-s   dphiy-s   dphiz-s     dphiuv-s
     $       dmat )
          endif
c
        else
c
c         Complex orbitals
c
          if( doblas3 )then
            call VSLOF2B( ibox, ndim, frcslo,strslo,
     $       norb,nk,nk0,nkloc, natm,ntyp, nshld,nald, nlat,
     $       itypa,numshl,lshel,nala,ala,cala, alamin,
     $       ratm, rlat, coskr,sinkr,
     $       hh, nbox,nrec,inrec, nrbox,nobox,inboxs, boxrad,boxctr,
     $       wvfcns(1,ir00+1), rmesh, vbox, wkbox, wkbi,
     $       dphi(id1),dphi(id2),dphi(id3),  dphi(id4),
c -->        dphix-s   dphiy-s   dphiz-s     dphiuv-s
     $       dmat, dmat(ipdm2) )
          else
            call VSLOF2( ibox, ndim, frcslo,strslo,
     $       norb,nk,nk0,nkloc, natm,ntyp, nshld,nald, nlat,
     $       itypa,numshl,lshel,nala,ala,cala, alamin,
     $       ratm, rlat, coskr,sinkr,
     $       hh, nbox,nrec,inrec, nrbox,nobox,inboxs, boxrad,boxctr,
     $       wvfcns(1,ir00+1), rmesh, vbox, wkbox, wkbi,
     $       dphi(id1),dphi(id2),dphi(id3),  dphi(id4),
c -->        dphix-s   dphiy-s   dphiz-s     dphiuv-s
     $       dmat )
          endif
c
        endif
c
c       Close box loop:
  900   continue
        ir00 = ir00 + nkloc*nobox*nrbox
 1000 continue
c
c The two*weight factor had originally been installed into dmat, now here.
      twowt = two*weight
      call DSCAL( 3*natm, twowt, frcslo, 1 )
      call DSCAL( 3*3   , twowt, strslo, 1 )
c
      if( nprocl .gt. 1 )then
c       Each processor has forces/stress from its part of grid.
c       Need to sum these into a single array, on master (node 0).
c       For now, also broadcast total back to all processors.
c
        nreduc = 3*natm
        call MPREDUC8( masterl, nreduc, frcslo, frctp , icomml )
C        call MPI_Reduce( frcslo, frctp , nreduc,
C     $   MPI_DOUBLE_PRECISION, MPI_SUM,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pvslofrc - Reduce frcslo' )
        call DCOPY( nreduc, frctp,1, frcslo,1 )
c
        call MPBCAST8( masterl, nreduc, frcslo, icomml )
C        call MPI_Bcast( frcslo, nreduc, MPI_DOUBLE_PRECISION,
C     $   master, icomm, ierr )
crpm        if( ierr.ne.0 ) call STOPXERR( 'pvslofrc - Bcast frcslo' )
c
        nreduc = 9
        call MPREDUC8( masterl, nreduc, strslo, strtp , icomml )
C        call MPI_Reduce( strslo, strtp , nreduc,
C     $   MPI_DOUBLE_PRECISION, MPI_SUM,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pvslofrc - Reduce strslo' )
        call DCOPY( nreduc, strtp,1, strslo,1 )
c
        call MPBCAST8( masterl, nreduc, strslo, icomml )
C        call MPI_Bcast( strslo, nreduc, MPI_DOUBLE_PRECISION,
C     $   master, icomm, ierr )
C        if( ierr.ne.0 ) call STOPXERR( 'pvslofrc - Bcast strslo' )
c
c       End tp
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPDMATRD2
c
c
      subroutine KPDMATRD2( idmatfl, norb, ncplx, nk,nk0,nkloc,
     $ dmatrd,      dmat )                   
c---------------------------------------------------------------
c Purpose: pack complex dmat from r8 into full-c8 for vslofrc
c
c Written: Peter A. Schultz,  4-December-2008, for v2.63 (k-parallel)
c
c Revision history:
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c Input:
      INTEGER    idmatfl
      INTEGER    norb, ncplx,nk, nkloc,nk0
c Output:
      REAL       dmat
      DIMENSION  dmat(*)
c Scratch:
      DOUBLE PRECISION  dmatrd
      DIMENSION  dmatrd(*)
c
c Local declarations:
      INTEGER    nprocl ,iprocl ,masterl ,icomml
      INTEGER    nproc_k,iproc_k,master_k,icomm_k
      INTEGER    matrd,lenmsg, ik,ikloc, kmasterpr
c
c >>>> EXECUTABLE CODE:
c
c  Get Local MP info
      call MPNODES( nprocl )
      call MPNODE( iprocl )
      call MPNODE0( masterl )
      call MPCOMM( icomml )
c           
      call MPNODES_K( nproc_k )
      call MPNODE_K( iproc_k )
      call MPNODE0_K( master_k )
      call MPCOMM_K( icomm_k )
c       
      matrd = norb*norb
c
      ikloc = 0
      do 100 ik=1,nk
c
        lenmsg = matrd 
        call KPMASTER( nk,nprocl, ik,kmasterpr )
c        This might have been necessary once ...
C        if( nkloc .eq. nk ) kmasterpr = masterl
c       
        if( iprocl .eq. masterl )then
c         Image/local master reads dmat, and send to correct k-master proc
          call READBIG( idmatfl, matrd, dmatrd )
          if( kmasterpr .ne. masterl )then
c           This k-point goes off to kmasterpr
            call MPSENDR8( kmasterpr, lenmsg, dmatrd, icomml )
            goto 100
          endif 
        elseif( iprocl .eq. kmasterpr )then
c         Proc is master of this k-point, get dmatrd from masterl
          call MPRECVR8( masterl, lenmsg, dmatrd, icomml )
        else
c         This proc is not leading this k-point
          goto 100
        endif 
c  k-point master (kmasterpr) packs the data it got into its array.
        ikloc = ikloc + 1
c
        if( ncplx.eq.2 )then
c         Complex density matrices
          call VSLOFDM2( norb, nkloc, ikloc, dmatrd, dmat )
        else
c         Real density matrix
          call VSLOFDM1( norb, dmatrd, dmat )
        endif
c
  100 continue
c
c       Copy dmat from k-point masters to the other processors
c       processing the same k-points.
c
      if( nproc_k .gt. 1 .and.  nkloc .gt. 0 )then
        lenmsg = ncplx*nkloc*norb*norb
        call MPBCAST4( master_k, lenmsg, dmat, icomm_k )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOFDM2
c
c
      subroutine VSLOFDM2( norb, nkloc, ik, dmatrd, dmat )
c---------------------------------------------------------------
c Purpose: pack complex dmat from r8 into full-c8 for vslofrc
c
c Written: Peter A. Schultz,  4-December-2008, for v2.63 (k-parallel)
c
c Revision history:
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c Input:
      INTEGER  norb, nkloc,ik
      DOUBLE PRECISION  dmatrd
      DIMENSION  dmatrd(norb,norb)
c Output:
      REAL       dmat
      DIMENSION  dmat(2,nkloc,norb,norb)
c
c Local declarations:
      INTEGER    i,j
      REAL       r4zero
      DATA       r4zero /0.e0/
c
c >>>> EXECUTABLE CODE:
c
      do  j=1,norb
        do  i=1,j-1
          dmat(1,ik,i,j) =  dmatrd(j,i)
          dmat(2,ik,i,j) =  dmatrd(i,j)
        enddo
          dmat(1,ik,j,j) =  dmatrd(j,j)
          dmat(2,ik,j,j) =  r4zero
        do  i=j+1,norb
          dmat(1,ik,i,j) =  dmatrd(i,j)
          dmat(2,ik,i,j) = -dmatrd(j,i)
        enddo
      enddo
c
c    That's all Folks
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOFDM1
c
c
      subroutine VSLOFDM1( norb, dmatrd, dmat )
c---------------------------------------------------------------
c Purpose: pack real dmat from r8 into full-r4 for vslofrc
c
c Written: Peter A. Schultz,  4-December-2008, for v2.63 (k-parallel)
c
c Revision history:
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c Input:
      INTEGER  norb
      DOUBLE PRECISION  dmatrd
      DIMENSION  dmatrd(norb,norb)
c Output:
      REAL       dmat
      DIMENSION  dmat(norb,norb)
c
c Local declarations:
      INTEGER    i,j
c
c >>>> EXECUTABLE CODE:
c
      do  j=1,norb
        do  i=1,j
          dmat(i,j) = dmatrd(j,i)
        enddo
        do  i=j+1,norb
          dmat(i,j) = dmatrd(i,j)
        enddo
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOM1B
c
c
      subroutine VSLOM1B( ibox,
     $ norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox,nobox,inboxs,
     $ wvfcns, vslobox, wkbi,
     $ vkij,vkbx )
c---------------------------------------------------------------
c Purpose: compute matrix elements of grid potentials
c          over real grid basis orbitals
c          Version using level-3 blas
c
c Written: Peter A. Schultz, 12-May-1999, for v2.36
c          Based on a suggestion by Dave Raczkowski
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Notes:
c  The matrix elements are computed over the grid for wave fcns
c  in this box using the level-3 blas routine for the cpu-heavy
c  arithmetic, and are loaded into the full dense matrix after.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  vkij, vkbx
      REAL  vslobox
      REAL  r4zero,r4one
c
c output arrays:
      DIMENSION  vkij(norb,norb)
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(nrbox,nobox)
      DIMENSION  vslobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(nrbox,nobox), vkbx(nobox,nobox)
c local declarations:
      DATA  r4zero,r4one / 0.e0,1.e0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
c Put potentials into left grid orbitals
      do  ib=1,nobox
        do  nr=1,nrbox
          wkbi(nr,ib) = vslobox(nr)*wvfcns(nr,ib)
        enddo
      enddo
c
c Do heavy lifting inside level-3 blas routine:
      call SGEMM( 't','n', nobox,nobox,nrbox, r4one,
     $ wvfcns,nrbox, wkbi,nrbox, r4zero, vkbx, nobox )
c
c  Put matrix elements into full dense matrix:
c
      inbox = 0
      jnbox = 0
c
c    Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        inext = 0
        ibnext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            ib0 = ibnext
            ibnext = ibnext + norbshi
c
            jrec = 0
            jatshl = 0
            jnext = 0
            jbnext = 0
            do 100 jatm=1,iatm
              jtyp = itypa(jatm)
              nshlj = numshl(jtyp)
              if( jatm.eq.iatm ) nshlj = ishl
c
              do 80 jshl=1,nshlj
                norbshj = 2*lshel(jshl,jtyp) + 1
c
                jnbox = jnbox/2
                if( inrec*(jatshl/inrec).eq.jatshl )then
                  jrec = jrec + 1
                  jnbox = inboxs(jrec,ibox)
                endif
                jatshl = jatshl + 1
                j0 = jnext
                jnext = jnext + norbshj
                if( EVEN(jnbox) ) goto 80
c
                jb0 = jbnext
                jbnext = jbnext + norbshj
c
                joff = 0
                if( jatm.eq.iatm .and. jshl.eq.ishl )then
                  norbshj = 0
                  joff = 1
                endif
c
                i = i0
                ib = ib0
                do 170 iorbsh=1,norbshi
                  i = i + 1
                  ib = ib + 1
c
                  norbshj = norbshj + joff
c
                  j = j0
                  jb = jb0
                  do 70 jorbsh=1,norbshj
                    j = j + 1
                    jb = jb + 1
c
                    vkij(i,j) = vkij(i,j) + vkbx(ib,jb)
c
   70             continue
  170           continue
c
   80         continue
  100       continue
c
  180     continue
  200   continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOM1
c
c
      subroutine VSLOM1( ibox,
     $ norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox,nobox,inboxs,
     $ wvfcns, vslobox, wkbi,
     $ vkij )
c---------------------------------------------------------------
c Purpose: compute matrix elements of grid potentials
c          over real grid basis orbitals
c
c Written: Peter A. Schultz, 12-May-1999, for v2.35
c
c Revision history:
c  13Jan12-PAS/2.62: fix bug (declare sdot as real!)
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  vkij, vintr
      REAL  vslobox
      REAL  r4zero
      REAL  SDOT
c
c output arrays:
      DIMENSION  vkij(norb,norb)
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(nrbox,nobox)
      DIMENSION  vslobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(nrbox,5)
c local declarations:
      DATA  r4zero / 0.e0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
      jnbox = 0
c
c    Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        iwvshl = 0
        inext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            iwvx = 0
            iwv = iwvshl
            do  iorbsh=1,norbshi
              iwvx = iwvx + 1
              iwv = iwv + 1
              do  nr=1,nrbox
                wkbi(nr,iwvx) = vslobox(nr)*wvfcns(nr,iwv)
              enddo
            enddo
c
            jrec = 0
            jatshl = 0
            jwvshl = 0
            jnext = 0
            do 100 jatm=1,iatm
              jtyp = itypa(jatm)
              nshlj = numshl(jtyp)
              if( jatm.eq.iatm ) nshlj = ishl
c
              do 80 jshl=1,nshlj
                norbshj = 2*lshel(jshl,jtyp) + 1
c
                jnbox = jnbox/2
                if( inrec*(jatshl/inrec).eq.jatshl )then
                  jrec = jrec + 1
                  jnbox = inboxs(jrec,ibox)
                endif
                jatshl = jatshl + 1
                j0 = jnext
                jnext = jnext + norbshj
                if( EVEN(jnbox) ) goto 80
c
                joff = 0
                if( jatm.eq.iatm .and. jshl.eq.ishl )then
                  norbshj = 0
                  joff = 1
                endif
c
                iwvxorb = 0
c                iwvorb = iwvshl
                i = i0
                do 170 iorbsh=1,norbshi
                  i = i + 1
c
                  norbshj = norbshj + joff
c
                  jwvorb = jwvshl
                  j = j0
                  do 70 jorbsh=1,norbshj
                    j = j + 1
c
                    iwvx = iwvxorb + 1
c                    iwv = iwvorb + 1
                    jwv = jwvorb + 1
c
c Use blas to substitute for explicit loop ...
                    vintr = SDOT( nrbox, wkbi(1,iwvx),1,
     $               wvfcns(1,jwv),1 )
c
c  ... and this is the reduced op code it replaces:
c                    vintr = r4zero
c                    do  nr=1,nrbox
c                      vintr = vintr + wkbi(nr,iwvx)*wvfcns(nr,jwv)
c                    enddo
c  ... and this was the original full code:
c                    do  nr=1,nrbox
c                    vint =+ wvfcns(nr,iwv)*CONJG(wvfcns(nr,jwv))*v
c                      vintr = vintr + vslobox(nr)*
c     $                 wvfcns(nr,iwv)*wvfcns(nr,jwv)
c                    enddo
c
                    vkij(i,j) = vkij(i,j) + vintr
c
                    jwvorb = jwvorb + 1
   70             continue
c
                  iwvxorb = iwvxorb + 1
c                  iwvorb = iwvorb + 1
  170           continue
c
                jwvshl = jwvshl + norbshj
   80         continue
  100       continue
c
            iwvshl = iwvshl + norbshi
  180     continue
  200   continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOM2B
c
c
      subroutine VSLOM2B( ibox,
     $ norb,nk, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox, nobox,inboxs,
     $ wvfcns, vslobox, wkbi,
     $ vkij,vkbx )
c---------------------------------------------------------------
c Purpose: compute matrix elements of grid potentials
c          over complex grid basis orbitals
c          Version using level-3 blas
c
c Written: Peter A. Schultz,  9-Jun-1999, for v2.36
c          Based on suggestion by Dave Raczkowski
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Notes:
c  The matrix elements are computed over the grid for wave fcns
c  in this box using the level-3 blas routine for the cpu-heavy
c  arithmetic, and are loaded into the full dense matrix after.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  vkij, vkbx
      REAL  vslobox
      REAL  c4zero,c4one
c
c output arrays:
      DIMENSION  vkij(nk,norb,norb)
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,nrbox,nk,nobox)
      DIMENSION  vslobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(2,nrbox,nobox), vkbx(2,nobox,nobox,nk)
c local declarations:
      DIMENSION  c4zero(2),c4one(2)
      DATA  c4zero / 0.e0,0.e0 /, c4one / 1.e0,0.e0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      do  k=1,nk
c
c Put potentials into left grid orbitals
        do  ib=1,nobox
          do  nr=1,nrbox
            wkbi(1,nr,ib) =  vslobox(nr)*wvfcns(1,nr,k,ib)
            wkbi(2,nr,ib) = -vslobox(nr)*wvfcns(2,nr,k,ib)
          enddo
        enddo
c
c Do heavy lifting inside level-3 blas routine, k-by-k:
        call CGEMM( 't','n', nobox,nobox,nrbox, c4one,
     $   wvfcns(1,1,k,1),nk*nrbox,  wkbi, nrbox,
     $   c4zero, vkbx(1,1,1,k), nobox )
c
      enddo
c
c  Put matrix elements into full dense matrix:
c
      inbox = 0
      jnbox = 0
c
c    Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        inext = 0
        ibnext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            ib0 = ibnext
            ibnext = ibnext + norbshi
c
            jrec = 0
            jatshl = 0
            jnext = 0
            jbnext = 0
            do 100 jatm=1,iatm
              jtyp = itypa(jatm)
              nshlj = numshl(jtyp)
              if( jatm.eq.iatm ) nshlj = ishl
c
              do 80 jshl=1,nshlj
                norbshj = 2*lshel(jshl,jtyp) + 1
c
                jnbox = jnbox/2
                if( inrec*(jatshl/inrec).eq.jatshl )then
                  jrec = jrec + 1
                  jnbox = inboxs(jrec,ibox)
                endif
                jatshl = jatshl + 1
                j0 = jnext
                jnext = jnext + norbshj
                if( EVEN(jnbox) ) goto 80
c
                jb0 = jbnext
                jbnext = jbnext + norbshj
c
                joff = 0
                if( jatm.eq.iatm .and. jshl.eq.ishl )then
                  norbshj = 0
                  joff = 1
                endif
c
                i = i0
                ib = ib0
                do 170 iorbsh=1,norbshi
                  i = i + 1
                  ib = ib + 1
c
                  norbshj = norbshj + joff
c
                  j = j0
                  jb = jb0
                  do 70 jorbsh=1,norbshj
                    j = j + 1
                    jb = jb + 1
c
                    do 60 k=1,nk
c
                      vkij(k,i,j) = vkij(k,i,j) + vkbx(1,jb,ib,k)
                      if( i.ne.j )
     $                 vkij(k,j,i) = vkij(k,j,i) - vkbx(2,jb,ib,k)
c
   60               continue
c
   70             continue
c
  170           continue
c
   80         continue
  100       continue
c
  180     continue
  200   continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOM2
c
c
      subroutine VSLOM2( ibox,
     $ norb,nk, natm,ntyp, nshld,  itypa,numshl,lshel,
     $ nbox,nrec,inrec, nrbox, nobox,inboxs,
     $ wvfcns, vslobox, wkbi,
     $ vkij )
c---------------------------------------------------------------
c Purpose: compute matrix elements of grid potentials
c          over complex grid basis orbitals
c
c Written: Peter A. Schultz, 12-May-1999, for v2.35
c
c Revision history:
c  13Jan12-PAS/2.62: cosmetic changes, to matchvslom1 bugfix
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      REAL  wvfcns, wkbi
      REAL  vkij, vintr,  vinti,vintv
      COMPLEX  vintc
      REAL  vslobox
      REAL  r4zero
      COMPLEX  CDOTC
c
c output arrays:
      DIMENSION  vkij(nk,norb,norb)
c input arrays:
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp)
      DIMENSION  inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,nrbox,nk*nobox)
      DIMENSION  vslobox(nrbox)
c scratch arrays:
      DIMENSION  wkbi(2,nrbox,nk*5)
c local declarations:
      DIMENSION  vintv(2)
      EQUIVALENCE  (vintv(1),vintr),(vintv(2),vinti)
      EQUIVALENCE  (vintv,vintc)
      DATA  r4zero / 0.e0 /
      LOGICAL    EVEN
c statement function:
      EVEN(int) = (AND(int,1).eq.0)
c
c >>>> EXECUTABLE CODE:
c
      inbox = 0
      jnbox = 0
c
c    Loop over atoms/shells
c
        irec = 0
        iatshl = 0
        iwvshl = 0
        inext = 0
        do 200 iatm=1,natm
          ityp = itypa(iatm)
c
          do 180 ishl=1,numshl(ityp)
            norbshi = 2*lshel(ishl,ityp) + 1
            inbox = inbox/2
            if( inrec*(iatshl/inrec).eq.iatshl )then
              irec = irec + 1
              inbox = inboxs(irec,ibox)
            endif
            iatshl = iatshl + 1
            i0 = inext
            inext = inext + norbshi
            if( EVEN(inbox) ) goto 180
c
            iwvx = 0
            iwv = iwvshl
            do  iorbsh=1,norbshi
              do  k=1,nk
                iwvx = iwvx + 1
                iwv = iwv + 1
                do  nr=1,nrbox
                  wkbi(1,nr,iwvx) = vslobox(nr)*wvfcns(1,nr,iwv)
                  wkbi(2,nr,iwvx) = vslobox(nr)*wvfcns(2,nr,iwv)
                enddo
              enddo
            enddo
c
            jrec = 0
            jatshl = 0
            jwvshl = 0
            jnext = 0
            do 100 jatm=1,iatm
              jtyp = itypa(jatm)
              nshlj = numshl(jtyp)
              if( jatm.eq.iatm ) nshlj = ishl
c
              do 80 jshl=1,nshlj
                norbshj = 2*lshel(jshl,jtyp) + 1
c
                jnbox = jnbox/2
                if( inrec*(jatshl/inrec).eq.jatshl )then
                  jrec = jrec + 1
                  jnbox = inboxs(jrec,ibox)
                endif
                jatshl = jatshl + 1
                j0 = jnext
                jnext = jnext + norbshj
                if( EVEN(jnbox) ) goto 80
c
                joff = 0
                if( jatm.eq.iatm .and. jshl.eq.ishl )then
                  norbshj = 0
                  joff = 1
                endif
c
                iwvxorb = 0
c                iwvorb = iwvshl
                i = i0
                do 170 iorbsh=1,norbshi
                  i = i + 1
c
                  norbshj = norbshj + joff
c
                  jwvorb = jwvshl
                  j = j0
                  do 70 jorbsh=1,norbshj
                    j = j + 1
c
                    iwvx = iwvxorb
c                    iwv = iwvorb
                    jwv = jwvorb
c
                    do 60 k=1,nk
                      iwvx = iwvx + 1
c                      iwv = iwv + 1
                      jwv = jwv + 1
c
c Use blas to substitute for explicit loop ...
                      vintc = CDOTC( nrbox, wvfcns(1,1,jwv),1,
     $                                       wkbi(1,1,iwvx),1 )
c
c  ... and this is the reduced op code it replaces:
c                      vintr = r4zero
c                      vinti = r4zero
c                      do  nr=1,nrbox
c                        vintr = vintr + wkbi(1,nr,iwvx)*wvfcns(1,nr,jwv)
c     $                                + wkbi(2,nr,iwvx)*wvfcns(2,nr,jwv)
c                        vinti = vinti + wkbi(2,nr,iwvx)*wvfcns(1,nr,jwv)
c     $                                - wkbi(1,nr,iwvx)*wvfcns(2,nr,jwv)
c                      enddo
c  ... and this was the original full code:
c                      do  nr=1,nrbox
c                      vint =+ wvfcns(nr,iwv)*CONJG(wvfcns(nr,jwv))*v
c                        vintr = vintr + vslobox(nr)*
c     $                   ( wvfcns(1,nr,iwv)*wvfcns(1,nr,jwv)
c     $                   + wvfcns(2,nr,iwv)*wvfcns(2,nr,jwv) )
c                        vinti = vinti + vslobox(nr)*
c     $                   ( wvfcns(2,nr,iwv)*wvfcns(1,nr,jwv)
c     $                   - wvfcns(1,nr,iwv)*wvfcns(2,nr,jwv) )
c                      enddo
c
                      vkij(k,i,j) = vkij(k,i,j) + vintr
                      if( j.ne.i ) vkij(k,j,i) = vkij(k,j,i) + vinti
c
   60               continue
c
                    jwvorb = jwvorb + nk
   70             continue
c
                  iwvxorb = iwvxorb + nk
c                  iwvorb = iwvorb + nk
  170           continue
c
                jwvshl = jwvshl + nk*norbshj
   80         continue
  100       continue
c
            iwvshl = iwvshl + nk*norbshi
  180     continue
  200   continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOMAT
c
c
      subroutine VSLOMAT( ncplx,idwf,doblas3,
     $ norb,nk, natm,ntyp, nshld,nald, nlat,
     $ itypa,numshl,lshel,nala,ala,cala, alamin, ratm,rlat,
     $ coskr,sinkr,
     $ weight, hh, ndbox,nbox,nrec,inrec,noboxs,inboxs, boxrad,
     $ wvfcns, wf, vslobox, wkbox, wkbi,
     $ vijk,         vkij,          vslo )
c      R8(mat_nkloc) R4(2mat*nkloc) R8(nptr)
c      =nmatloc   =nmatloc                = nptr
c---------------------------------------------------------------
c Purpose: compute matrix elements of grid potentials
c
c Written: Peter A. Schultz,  3-June-1997, for v2.20 (boxes)
c
c Revision history:
c  17Nov08-PAS/2.63: k-parallel scf matrices
c   4Jan08-PAS/2.61: reduced (dist) memory for grid wvfcns
c  13Feb06-PAS/2.60: mpi-clean
c   6Jul06-APT/    : merged task parallel and image parallel
c  25Sep04-PAS/tp0.1: clean-up task-parallel routines
c  28Mar03-DMC: Many changes to make this a parallel version.
c     I need to distribute files which were only written on
c     processor 0 to all processors.  Also, this routine does
c     every n'th element on a processor, and then uses MPI_Reduce
c     and MPI_Bcast to accumulate the results on all processors.
c   2May01-PAS/2.47: remove disk storage of grid orbitals
c  10Jun99-PAS/2.36: blas3 implemention and flag
c  19May99-PAS/2.35: subcalls to separate real/complex
c  13Feb99-PAS/2.31: reduce op ct plus blas of bottom grid code
c   9Nov98-PAS/2.28: single precision grid orbitals/wf4
c  10Sep98-PAS/2.26: on-the-fly grid orbitals
c---------------------------------------------------------------
c
c Notes:
c  Assumes potential vslo has been shuffled into boxes on input
c
c  Note imaginary part of the integral is stored in v(j,i,k).
c  Thus im(v(i,j,k)) is minus what I store for (j,i), and is thus
c  the imaginary part of the integral of the potential with
c  conjg(phi-i)*phi-j, as is true for the rest of the Hamiltonian
c
c  Using subcalls to separate real/complex paths incurs a cost of
c  ~5% as opposed to pulling code up here in combined arithmetic.
c  Will pay this cost for purpose of clarity and compactness, and
c  another time worry about refining the code to get last bit
c  of speed.  17May99-PAS/2.35
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      REAL  wvfcns,wf, wkbi
      REAL  vkij
      REAL  weightr4
      REAL  vslobox
c
c Input/Output arrays:
      DIMENSION  vijk(norb,norb,*)
c                vijk(norb,norb,nkloc)
c Input arrays:
      LOGICAL    doblas3
      DIMENSION  itypa(natm),numshl(ntyp),lshel(nshld,ntyp),
     $ nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  alamin(ntyp), ratm(3,natm), rlat(3,nlat)
      DIMENSION  coskr(nk,nlat),sinkr(nk,nlat)
      DIMENSION  hh(3,3), ndbox(2,2,3),noboxs(nbox),inboxs(nrec,nbox)
      DIMENSION  wvfcns(2,*),wf(*)
      DIMENSION  vslo(*)
c Scratch array
      DIMENSION  wkbi(*), wkbox(*), vslobox(*)
      DIMENSION  vkij(*)
c                vkij(nkloc,norb,2*norb)
c
c Local declarations:
      DIMENSION  r0box(3),boxctr(3)
c
c >>>> EXECUTABLE CODE:
c
c  Get Local MP info - note we are working at the k-level
      call MPNODES_K( nprocs_k )
      call MPNODE0_K( master_k )
      call MPNODE_K( iproc_k )
      call MPCOMM_K( icomm_k )
c
c  Set up kparallel
      call KPMINE( nk, nkloc, nk0 )
c
      call MKSZERO( nkloc*norb*norb, vkij )
      if( nkloc .eq. 0 ) goto 1001

      ipvkij2 = nkloc*norb*norb + 1
c
c  Initialize location of grid orbitals
      ir00 = 0
c
      irpot = 0
c
c Cycle over boxes of grid points
c
      do 1000 ibox=1,nbox
c
c       Get basic box data
        call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $   ira0,irb0,irc0, idra,idrb,idrc )
        nrbox = idra*idrb*idrc
c
c       Update location in global mesh potential array
        iv0 = irpot
        irpot = irpot + nrbox
c
c       Get number of orbitals in this box; skip if none
        nobox = noboxs(ibox)
        if( nobox.le.0 ) goto 1000
c
c       Each processor will do every nprocs_k'th box in this loop.
        if( MOD( ibox, nprocs_k ) .ne. iproc_k ) goto 1000
c
c       Get grid orbitals:
c
        if( idwf.eq.0 )then
c         Compute orbitals on mesh in this box
c
c         Generate mesh point coordinates
          call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
          call MKRBOX( hh,r0box, idra,idrb,idrc, wkbox )
          ir00 = 0
          iwk1 = 1
          iwk2 = iwk1 + 3*nrbox
          iwk3 = iwk2 + nrbox
          iwk4 = iwk3 + nrbox
          iwk5 = iwk4 + nrbox
          iwk6 = iwk5 + nrbox
          iwk7 = iwk6 + nrbox
          iwk8 = iwk7 + nrbox
c
          call BOXWFN( ibox, ncplx,
     $     nk,nk0,nkloc,  natm,ntyp, nshld,nald, nlat,
     $     itypa,numshl,lshel,nala,ala,cala,alamin,
     $     ratm,rlat,coskr,sinkr,
     $     nobox,nrbox,nrec,inrec,inboxs, boxrad,boxctr,
     $     wvfcns(1,ir00+1), wf(ir00+1),
     $     wkbox      ,wkbox(iwk2),wkbox(iwk3),wkbox(iwk4),
     $     wkbox(iwk5),wkbox(iwk6),wkbox(iwk7),wkbox(iwk8) )
c
        endif
c
c       Put r*8 potential into r*4 space for use below:
        do  nr=1,nrbox
          vslobox(nr) = weight*vslo(iv0+nr)
cwt          vslobox(nr) = vslo(iv0+nr)
        enddo
c
c       ***************************************************
c       Compute contribution to matrix elements in this box
c       ***************************************************
c
        if( ncplx.eq.2 )then
c
c         Complex orbitals
c
          if( doblas3 )then
            call VSLOM2B( ibox,
     $       norb,nkloc, natm,ntyp, nshld,  itypa,numshl,lshel,
     $       nbox,nrec,inrec, nrbox, nobox,inboxs,
     $       wvfcns(1,ir00+1), vslobox, wkbi,
     $       vkij, vkij(ipvkij2) )
c            R4(nkloc*mat)   R4(2*noboxmax*noboxmax*nk)
c            (nmatloc+1)/2    nk*noboxmax**2
          else
            call VSLOM2( ibox,
     $       norb,nkloc, natm,ntyp, nshld,  itypa,numshl,lshel,
     $       nbox,nrec,inrec, nrbox, nobox,inboxs,
     $       wvfcns(1,ir00+1), vslobox, wkbi,
     $       vkij )
          endif
c
        elseif( ncplx.eq.1 )then
c
c         Real orbitals
c
          if( doblas3 )then
            call VSLOM1B( ibox,
     $       norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $       nbox,nrec,inrec, nrbox, nobox,inboxs,
     $       wf(ir00+1), vslobox, wkbi,
     $       vkij, vkij(ipvkij2) )
c            R4(mat)  R4(noboxmax**2)
          else
            call VSLOM1( ibox,
     $       norb, natm,ntyp, nshld,  itypa,numshl,lshel,
     $       nbox,nrec,inrec, nrbox, nobox,inboxs,
     $       wf(ir00+1), vslobox, wkbi,
     $       vkij )
c            R4(mat)
          endif
c
        endif
c
c       Close box loop:
  900   continue
        ir00 = ir00 + nkloc*nobox*nrbox
 1000 continue
c     Bypass for nkloc = 0:
 1001 continue
c 
      if( nprocs_k .gt. 1 )then
c       Each local processor now has a partial dHam matrix built from its boxes
c       Need to sum these into a single array, on master_k (node 0).
c
        nmatloc = nkloc*norb*norb
        call MPREDUC4( master_k, nmatloc,
     $       vkij,    vkij(ipvkij2),    icomm_k )
c -----> nmatloc(r*4) nmatloc(r*4)
c
        call SCOPY( nmatloc, vkij(ipvkij2),1, vkij,1 )
c
      endif
c
c  Load grid matrix elements into Hamiltonian only on kmasters
c
       if( iproc_k.eq.master_k )then
c       kmaster adds vslomat r4(kij) matrix into total r8(ijk) matrix:
        call VSLOMLOAD( norb, nkloc, vijk, vkij )
cwt        call VSLOMLOAD( norb, nkloc, weight, vijk, vkij )
       endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VSLOMLOAD
c
c
      subroutine VSLOMLOAD( norb, nkloc, vijk, vkij )
cwt      subroutine VSLOMLOAD( norb, nkloc, weight, vijk, vkij )
c---------------------------------------------------------------
c Purpose: load computed r4 vslomat into total r8 Ham
c
c Written: Peter A. Schultz,  4-December-20-8, for 2.62 (k-parallel)
c
c Revision history:
c   4Dec08-PAS/2.62: pushed down from vslomat
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c Input:
      INTEGER    nkloc,norb
      REAL       vkij
      DIMENSION  vkij(nkloc,norb,norb)
c Input/Output:
      DOUBLE PRECISION  vijk
cwt      DOUBLE PRECISION  weight
      DIMENSION  vijk(norb,norb,nkloc)
c
c Local declarations:
      INTEGER    ikloc,i,j
c
c >>>> EXECUTABLE CODE:
c
      do  ikloc=1,nkloc
        do  j=1,norb
          do  i=1,norb
            vijk(i,j,ikloc) = vijk(i,j,ikloc) + vkij(ikloc,i,j)
cwt            vijk(i,j,ikloc) = vijk(i,j,ikloc) + weight*vkij(ikloc,i,j)
          enddo
        enddo
      enddo
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:        
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WF1COFK
c
c
      subroutine WF1COFK( orbofk,  norb,nk, natm,ntyp,nshld,nald, nlat,
     $ itypa, numshl,lshel,nala,ala,cala, norba, ratm,rlat,coskr,sinkr )
c---------------------------------------------------------------
c Purpose: calculate quantities orbofk = k-space value of the
c     i-th orbital at the n-th nucleus.
c
c Revision history:
c   7Mar02-PAS/2.52: ang constants extracted
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Apr97-PAS/2.17: naming conventions
c  13Apr94-PAS/2.10
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c output array:
      DIMENSION  orbofk(2,natm,norb,nk)
c input arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  norba(ntyp)
      DIMENSION  ratm(3,natm),rlat(3,nlat),coskr(nk,*),sinkr(nk,*)
c
c local declarations:
      DIMENSION  ri(3),rji(3), oint(5),ph(2)
c
      DIMENSION  vnorm(5)
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
      DATA  ph / 1.d0,0.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Get angular normalizations:
      call VNORMS( vnorm )
c
      argmx = half*cutexp
c
      call MKZERO( 2*natm*norb*nk, orbofk )
c
c    Loop on remote atom site:
c
      inext = 0
      do 200 iatm=1,natm
        ityp = itypa(iatm)
        istart = inext
        inext = istart + norba(ityp)
c
c    Lattice vector loop:
c
        do 190 ilat=1,nlat
          do  ir=1,3
            ri(ir) = ratm(ir,iatm) + rlat(ir,ilat)
          enddo
c
          i0 = istart
          do 180 ishl=1,numshl(ityp)
            nali = nala(ishl,ityp)
            lshl = lshel(ishl,ityp)
            norbsh = 2*lshl + 1
            almini = ala(1,ishl,ityp)
            do  ial=1,nali
              almini = MIN(almini,ala(ial,ishl,ityp))
            enddo
c
c    Loop on site about which we compute 1-ctr density
c
            do 100 jatm=1,natm
              if( jatm.eq.iatm .and. ilat.eq.1 ) goto 100
c
              do  jr=1,3
                rji(jr) = ratm(jr,jatm) - ri(jr)
              enddo
              rjisq = rji(1)*rji(1) + rji(2)*rji(2) + rji(3)*rji(3)
              if( almini*rjisq.gt.argmx ) goto 100
c
c      evaluate contribution of orbital i at site jatm
c
              sumg = zero
              do  ial=1,nali
                alrsq = ala(ial,ishl,ityp)*rjisq
                if( alrsq.le.argmx )
     $           sumg = sumg + cala(ial,ishl,ityp)*EXP( -alrsq )
              enddo
c
c install angular factor
c
              goto (40,41,42), lshl+1
c     s-fcn
   40         oint(1) = sumg/vnorm(1)
              goto 50
c     p-fcn:  x;  y;  z
   41         fac = sumg/vnorm(2)
              oint(1) = rji(1) * fac
              oint(2) = rji(2) * fac
              oint(3) = rji(3) * fac
              goto 50
c     d-fcn:  xy;  yz;  zx;  x2-y2;  2z2-x2-y2
   42         fac = sumg/vnorm(3)
              oint(1) = rji(1)*rji(2) * fac
              oint(2) = rji(2)*rji(3) * fac
              oint(3) = rji(3)*rji(1) * fac
              fac = sumg/vnorm(4)
              oint(4) = (rji(1)**2-rji(2)**2) * fac
              fac = sumg/vnorm(5)
              oint(5) = (two*rji(3)**2-rji(1)**2-rji(2)**2) * fac
c
   50         continue
c
c    Alpha loop:
c
              i = i0
              do  is=1,norbsh
                i = i + 1
                do  k=1,nk
                  ph(1) = coskr(k,ilat)
                  ph(2) = sinkr(k,ilat)
                  orbofk(1,jatm,i,k)=orbofk(1,jatm,i,k) + oint(is)*ph(1)
                  orbofk(2,jatm,i,k)=orbofk(2,jatm,i,k) + oint(is)*ph(2)
                enddo
              enddo
c
  100       continue
c
            i0 = i0 + norbsh
  180     continue
  190   continue
  200 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WF1COFR
c
c
      subroutine WF1COFR( orb,grorb,grgrorb,
     $ nuc,jatm, lj,jtyp,jshl,nalj,
     $ natm,ntyp,nshld,nald, nlat, ala,cala, ratm,rlat,
     $ g,gg,rji,f,gauss )
c---------------------------------------------------------------
c Purpose: for each basis function, compute value, gradient, and
c          second gradient at nucleus of all atoms but its own.
c
c Revision history:
c   7Mar02-PAS/2.52: ang constants extracted
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Apr97-PAS/2.17: naming conventions
c  26Aug94-PAS/2.11: cleaned up, underflow protection
c---------------------------------------------------------------
c
c Output used to construct charge density as sum of 1-ctr stuff
c containing all short-range near-nucleus rapid variation
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c
      DIMENSION  orb(nlat),grorb(3,nlat),grgrorb(3,3,nlat)
      DIMENSION  ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  ratm(3,natm),rlat(3,nlat)
c scratch declarations:
      DIMENSION  g(3,nlat),gg(3,3,nlat),rji(3,nlat),
     $           f(nlat),gauss(nlat)
c
c local declarations:
      DIMENSION  vnorm(9)
      DATA  zero,half,one,two, four / 0.d0,0.5d0,1.d0,2.d0, 4.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Get angular normalizations:
      call VNORMS9( vnorm )
c
      argmx = half*cutexp
      do  jlat=1,nlat
        do  jr=1,3
          do  ir=1,3
            grgrorb(ir,jr,jlat) = zero
            gg(ir,jr,jlat) = zero
          enddo
          grorb(jr,jlat) = zero
          g(jr,jlat) = zero
        enddo
        orb(jlat) = zero
      enddo
c
c      lattice vector loop
c
      do  jr=1,3
        do  jlat=1,nlat
          rji(jr,jlat) = ratm(jr,nuc) - ratm(jr,jatm) - rlat(jr,jlat)
        enddo
      enddo
c
      goto (10,20,30,40,50,60,70,80,90) lj
c
   10 do  jlat=1,nlat
        f(jlat) = one
      enddo
      goto 200
c
   20 do  jlat=1,nlat
        f(jlat) = rji(1,jlat)
        g(1,jlat) = one
      enddo
      goto 200
c
   30 do  jlat=1,nlat
        f(jlat) = rji(2,jlat)
        g(2,jlat) = one
      enddo
      goto 200
c
   40 do  jlat=1,nlat
        f(jlat) = rji(3,jlat)
        g(3,jlat) = one
      enddo
      goto 200
c
   50 do  jlat=1,nlat
        f(jlat) = rji(1,jlat)*rji(2,jlat)
        g(1,jlat) = rji(2,jlat)
        g(2,jlat) = rji(1,jlat)
        gg(1,2,jlat) = one
        gg(2,1,jlat) = one
      enddo
      goto 200
c
   60 do  jlat=1,nlat
        f(jlat) = rji(2,jlat)*rji(3,jlat)
        g(2,jlat) = rji(3,jlat)
        g(3,jlat) = rji(2,jlat)
        gg(2,3,jlat) = one
        gg(3,2,jlat) = one
      enddo
      goto 200
c
   70 do  jlat=1,nlat
        f(jlat) = rji(3,jlat)*rji(1,jlat)
        g(1,jlat) = rji(3,jlat)
        g(3,jlat) = rji(1,jlat)
        gg(3,1,jlat) = one
        gg(1,3,jlat) = one
      enddo
      goto 200
c
   80 do  jlat=1,nlat
        f(jlat) = rji(1,jlat)**2 - rji(2,jlat)**2
        g(1,jlat) =  two*rji(1,jlat)
        g(2,jlat) = -two*rji(2,jlat)
        gg(1,1,jlat) =  two
        gg(2,2,jlat) = -two
      enddo
      goto 200
c
   90 do  jlat=1,nlat
        f(jlat) = two*rji(3,jlat)**2 - rji(1,jlat)**2 - rji(2,jlat)**2
        g(1,jlat) = -two*rji(1,jlat)
        g(2,jlat) = -two*rji(2,jlat)
        g(3,jlat) = four*rji(3,jlat)
        gg(1,1,jlat) = -two
        gg(2,2,jlat) = -two
        gg(3,3,jlat) = four
      enddo
      goto 200
c
  200 continue
c
c    Alpha loop:
c
      vn = vnorm(lj)
      do 400 jal=1,nalj
        alj = ala(jal,jshl,jtyp)
        calj = cala(jal,jshl,jtyp)/vn
c
c  evaluate value of orbital j at site nuc
        rjimx = argmx/alj
        do  jlat=1,nlat
          rjisq = rji(1,jlat)**2 + rji(2,jlat)**2 + rji(3,jlat)**2
          if( rjisq .gt. rjimx )then
            gauss(jlat) = zero
          else
            gauss(jlat) = calj*EXP( -alj*rjisq )
            orb(jlat) = orb(jlat) + gauss(jlat)*f(jlat)
          endif
        enddo
c
c  evaluate gradients of orbital j at site nuc
        do 321 n=1,3
          do  jlat=1,nlat
            grorb(n,jlat) = grorb(n,jlat) + gauss(jlat)*
     $       ( g(n,jlat) - two*alj*rji(n,jlat)*f(jlat) )
            grgrorb(n,n,jlat) = grgrorb(n,n,jlat) - gauss(jlat)*
     $       two*alj*f(jlat)
          enddo
  321   continue
c
        do 332 n=1,3
          do 331 nn=1,3
            do  jlat=1,nlat
              grgrorb(nn,n,jlat) = grgrorb(nn,n,jlat) + gauss(jlat)*
     $         ( gg(nn,n,jlat)
     $         - two*alj*(rji(n,jlat)*g(nn,jlat)+rji(nn,jlat)*g(n,jlat))
     $         + four*alj**2*rji(n,jlat)*rji(nn,jlat)*f(jlat) )
            enddo
  331     continue
  332   continue
c
  400 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WKMEM
c
c
      subroutine WKMEM( IWR, lvlout, maxwkd,
     $ do_gga,do_spin,do_blas3, Lijkmat,
     $ idosolv, do_kppsolve,do_psolv, do_eigvecs,Lnonscf,
     $ mat,nmat,nmatkp,  nptr, nhiste,
     $ ncplx,nk,nlat, norb,nstate, noad,natm,ntyp,itypa,norba,
     $ mxang, ndbox,nbox,noboxs,mxrb,
     $ near2c,irhoopt, idwf,  memwf,memwfw, iwf,iwfw,
     $ icoskr,isinkr, is1at,
     $ ioint,ioofk, ieigval,ieigpop,
     $ idbr, imblnde, memblnde,
     $ i00, i01s, i01,i02,i03,i04,
     $ i05,i06,i07,i08,i09,i10,i11,i12 )
c---------------------------------------------------------------
c Purpose: to allot/assign memory for the whole code, with the
c          big workspace wk().  Check for memory sufficiency.
c          Make decision about on-the-fly v. stored grid orbs
c
c Written: Peter A. Schultz, 7-June-2001, for 2.47
c
c Revision history:
c  14Dec14-PAS/PAS/2.66: adapt (minor!) for ASD e-blend
c  17Jan13-PAS+ACP/2.64: k-parallelparallel memory reductions, and flags
c  26Feb13-PAS/2.63b: bugfix - parallel stripe v. square(ijk) consistency
c   9Dec08-PAS/2.62: reduced mem p-schroed
c  15Oct08-PAS/2.62: stripe-parallel mat0set/frc
c  22Sep09-PAS/2.62: split dmat spin file; reduce doengy mem; err retrace
c  23Sep08-PAS/2.61h: error in m4 memory arithmetic
c  24May08-PAS/2.61d: reduce blend-assigned mem to get large spin-calcs
c  17May08-PAS/2.61c: fix the vslomat memory allocation
c  12Feb08-PAS/2.61: pack i03/i04 tighter through vslomat/gridrho
c   4Jan08-PAS/2.61: reduced (dist) memory for grid wvfcns
c   9Feb07-PAS/2.60: memory for in-core broyden; harmonize tp-serial;
c                    patch 24apr07, 4jun07
c  30Jun06-PAS/2.60: tighten memory usage in i03/i04/i05
c  11Sep05-PAS/2.59: static mem for linear dependence code (rpm)
c  18Aug05-PAS/2.59-tp21: reworking solver mem
c   5Nov04-PAS/2.59-tp: temporary hack to get needed mem to pschroed
c   3Oct02-PAS/2.54: reduce mem needed in setup
c  22Jan02-PAS/2.52: int-overflow max reset to (2**31-1)
c  25Oct01-PAS/2.50: int-overflow fix
c  20Jul01-PAS/2.49: spin-polarized dft (2*eigs, iwfw, purge fpop)
c  21JUn01-PAS/2.48: replace STOPs
c---------------------------------------------------------------
c
c **************************************************************
c *** THIS IS THE MOST DANGEROUS AND CRITICAL ROUTINE IN THE ***
c *** ENTIRE CODE. IT MANAGES AND ASSIGNS MEMORY EVERYWHERE. ***
c **************************************************************
c
c This routine partitions all big memory, everywhere in the code.
c Hence any changes in memory usage and requirements in Quest
c should be checked and validated against this routine, and
c appropriate updates made.
c
c We will be assigning "pointers" for all "irregular" N**2+ arrays
c that need to carry data through an scf cycle ...
c    ... needed in all major routines [mat0/grid0/scf/frc]:
c   icoskr  -> coskr(nk,nlat)
c   isinkr  -> sinkr(nk,nlat)
c    ... could be left until scf, but now needed in [mat0->scf]:
c   is1at   -> s1atom(noad,noad,nk,natm)
c    ... used only in scf, generated at end of set [set->scf]:
c   ioint   -> orbint(2,norb,nk)      [iff near2c=2, else skipped]
c   ioofk   -> orbofk(2,natm,norb,nk) [iff near2c=2, else skipped]
c    ... used only during scf [scf]:
c   ieigval -> eigval(nstate,nk)
c   ieigpop -> eigpop(nstate,nk)
c These should be staged carefully to be "allocated" only when
c necessary.
c
c And, the biggies, we assign "pointers" for the big workspaces
c that carry orbital matrices and grid fields:
c   i01s, i01,i02, ... ,i12
c The i00 denotes the first available (unused) space within the
c array, and should be simply "1", but just to be safe ...
c
c We will compute how much memory is required to keep grid bf, both
c fully in memory and on-the-fly, and flag whether there is enough
c memory to keep grid bf:
c in memory, or to compute them on-the-fly:
c   idwf = 0 ... compute grid orbitals on the fly
c        = 1 ... grid orbitals stored in memory
c
c We assign a pointer for the grid bf. The location of grid bf's
c depends on whether the bf's are saved (in which case this routine
c must make sure that other workspace does not step on them), or
c computed on-the-fly, in which case we can use any idle space:
c   iwf
c
c We assign space for grid workspace.  The amount of memory needed
c is dependent on the scheme chosen to evaluate the density
c (DM=density-matrix v. EF=eigenfcn), and whether we use blas3 or not.
c I only examine DM v. EF, and ignore blas3 flag (picking biggest):
c   iwfw
c
c Note that the grid bf and grid workspace is all single precision,
c while (for right now in 2.47) everything else is double precision.
c
c I need to know what the largest possible integer is in order to fend
c off integer overflow problems in some key parts of the following.
c I will not to do a full check of everything because it is too painful
c to code.  I will only do an overflow check for those operations that
c involve *optional* memory.  If required space goes over this value,
c the system is too big to do anyway, and I may as well let code bomb.
c 2**31 = 2 147 483 648
c For a 4-byte integer, (2**31-1) is the (safe) maximum:
      PARAMETER  ( maxint = 2 147 483 647 )
c
c Input arrays:
c      ... flags that affect memory needs:
      LOGICAL    do_gga, do_spin, do_blas3
      LOGICAL    Lijkmat
      LOGICAL    do_kppsolve, do_psolv
c
      LOGICAL    do_eigvecs, Lnonscf
c       do_eigvecs = flag determines if eigenvectors (and memory) are needed
c       Lnonscf    = flag to turn off contributions to memory not-used by non-SCF
c                    parts of the code. (e.g. Broyden)
c
c      ... information about atom types, and norb/atom:
      DIMENSION  itypa(natm),norba(ntyp)
c      ... information about box breakup, and occupancies:
      DIMENSION  ndbox(2,2,3),noboxs(nbox)
c
c Local declarations:
      DATA  lvldbg / 0 /
      LOGICAL  flagdum
      LOGICAL  USE_KPSTORE
      LOGICAL  DEBUG_MEM
      DATA     DEBUG_MEM  / .false. /
c
c >>>> EXECUTABLE CODE:
c
      USE_KPSTORE = .true.
c     For nk=1, old scheme is smaller by nmatpr:
      if( nk .eq. 1 ) USE_KPSTORE = .false.
cxxx: declare dev-version of wkmem:
      write(IWR,*) 'DEV264h/wkmem: perlsolv dist-mem'
      write(IWR,*) 'DEV/wkmem: KPSTORE=',USE_KPSTORE
      write(IWR,*) 'DEV/wkmem: psolv version, input do_psolv=',do_psolv
      lstout = MAX( lvlout, lvldbg )
c
  100 continue
c
      mem0 = i00 - 1
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c       Compute workspace needed for the "irregular" named spaces:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c      ... needed in all major routines [mat0/grid0/scf/frc]:
      mcoskr  = nk*nlat
      msinkr  = nk*nlat
c      ... could be left until scf, but now needed in [mat0->scf]
      ms1at   = noad*noad*nk*natm
c      ... used only in scf, generated at end of set [set->scf]:
      moint   = 2*norb*nk
      moofk   = 2*natm*norb*nk
c      ... used only during scf [scf]:
      meigval = nstate*nk
      meigpop = nstate*nk
      nspin = 1
      if( do_spin )then
        nspin = 2
        meigval = 2*meigval
        meigpop = 2*meigpop
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c       Allocate space needed for "irregular" and regular spaces:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      icoskr  = i00
      isinkr  = icoskr + mcoskr
      is1at   = isinkr + msinkr
c     coskr/sinkr/s1at is core allocation in setup
      i1set   = is1at + ms1at
      mem0set = i1set - 1
      inext   = is1at + ms1at
      if( near2c.eq.2 )then
c       Allocate space for two-center (orbint and orbofk) defect terms:
        ioint = inext
        ioofk = ioint + moint
        inext = ioofk + moofk
      else
c       Skip two-center contributions to atom density defects:
        ioint = is1at
        ioofk = is1at
      endif
      ieigval = inext
      ieigpop = ieigval + meigval
c Up to here is core memory in scf phase:
      i1scf   = ieigpop + meigpop
      mem0scf = i1scf - 1
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c  Determine allocation sizes needed for stripe-parallel setup routines:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c  Get Local MP info
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
c     
c Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
      nmatstr = ncplx*nk*matstr
      if( lstout .gt. 2 )then
        write(IWR,*) 'WKMEM: full striped matrix size, all-k storage=',
     $                       matstr,nmatstr
      endif
c Need maximum value of norba for memory allocation.
      maxnorba = norba(1)
      do  ityp=2,ntyp
        maxnorba = MAX( maxnorba, norba(ityp) )
      enddo
c           
c Figure out how much belongs on local processor:
      call MATLOCSTR( iproc,nprocs,nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
      nmatpr = mymatpr*ncplx*nk
      mxnmatpr = maxmatpr*ncplx*nk
      if( nprocs.gt.1 .and. lstout.gt.2 )then
        write(IWR,*)'WKMEM: striped-mat; nprocs,active=',nprocs,nprocstr
        write(IWR,*)'WKMEM: striped/proc: my, max=',nmatpr,mxnmatpr
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c  Determine allocation sizes for other parts of the code:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c Bigger of Hamiltonian matrix, grid field (for first couple slots):
      nwk = MAX( nmatkp, nptr )
c
c Find the largest number of orbitals in a box
      noboxmax = 1
      do  ibox=1,nbox
        nobox = noboxs(ibox)
        if( nobox .gt. noboxmax ) noboxmax = nobox
      enddo
c Get local MP info (here, the k-parallel partitions)
      call MPNODES_K( nprocs_k )
      call MPNODE_K( iproc_k )
c
      call KPMINE( nk, nkloc, nk0 )
c
c Biggest headache is budgeting around vslomat (gridrho less so)
c How much scratch space do we need (beginning at i03, i05 reserved)?
c noboxmax is max number of orbitals overlapping a given box
c
c vslomat requirements
c  vijk:     nspin*nk*norb^2 for Hams, in i01
c  scratch: in i01+nspin*nmat (all these r4)
c   without blas3:   nk*norb^2
c   with blas3   :   nk*norb^2 + nc*nk*noboxmax^2 (i.e. add last term)
c   with parallel:   nk*norb^2 + nk*norb^2 (i.e. add last term)
c                    (last term is target in matrix reduce)
c gridrho requirements
c  dmatrd: norb^2[r8], buffer to read in dmat from disk, k-by-k,
c    and transfer in into [r4] dmat(nc*nk*norb^2)=nmat space.
c  DM-blas3: nc*nk*norb^2 + nc*nk*noboxmax^2
c  DM-w/o  : nc*nk*norb^2
c  EF-blas3: nc*nk*norb*nstate + nc*nk*noboxmax*nstate
c  EF-w/o  : nc*nk*norb*nstate
c
c For vslomat, compute scratch spave needed, counting from i03,
c     Beginning with space devoted to running ham vij [r8] storage
      mvslomat = -nwk
      if( do_spin ) mvslomat = mvslomat + nwk
c     Now work out amount of r4 workspace needed
c
c     This to compute r4 dense ham and r4 full ham (and r4 reduce also)
      m4vsl1 = nmatkp
cxxxcpas: acp had converted "ncplx" to "2" also ... is this needed? Apparantly, no.
      if( do_blas3 ) m4vsl1 = m4vsl1 + ncplx*nkloc*noboxmax**2
c
      m4vsl2 = nmatkp
c     If nprocs .gt. 1, need another nmatkp as buffer for MPI_Reduce
C      call MPNODES( nprocs ) ! switch to k-parallel
      call MPNODES_K( nprocs )
      if( nprocs .gt. 1 ) m4vsl2 = nmatkp + nmatkp
c
      m4vsl = MAX( m4vsl1, m4vsl2 )
      mvslomat = mvslomat + (m4vsl+1)/2
c
c For gridrho, use larger blas3-active requirement, too.
c  However, know that vslomat memory requirements trump this.
c  Lots of space to play with here, dmat into i01, dmatrd(mat) into i02.
c  And then enough room for everything in i02 after dmat reads done.
      mgridrho = 0
c  Compute memory needs offset from i03, assuming i02(nwk)
      mgridrho = -nwk
c  dmatrd space for rhdmat/rheigvec
c  Assume i01 (dmat), need r8(mat)=r4(2mat) in i02 buffer to read dmatrd:
      m4grh1 = 2*mat
c  dmatrd space for grhodm*/grhoef*
c  And then r4 memory needed as scratch after dmat obtained
      m4grh2 = 0
C      if( do_blas3 ) m4gr2 = ncplx*nkloc*noboxmax**2
      if( do_blas3 )then
        if( irhoopt.eq.1 )then
c         irhoopt.eq.1 (DM-density matrix)
          m4grh2 = ncplx*nkloc*noboxmax**2
        else
c         irhoopt.eq.2 (EF-eigenfunction)
          m4grh2 = ncplx*nkloc*noboxmax*nstate
        endif
c         Alternately since noboxmax<=norb and nstate<=norb, universal:
c         m4grh2 = ncplx*nkloc*noboxmax*norb
      endif
c dmatrd space
      m4grh = MAX( m4grh1, m4grh2 )
c Convert to r8 units
      mgridrho = mgridrho + (m4grh+1)/2
c
c For grdovlp, it can poke above ceiling, too, in k-parallel (Code patch by ACP)
c   NB: currently, arrays are declared and used as nk rather than kparallel nkloc
c   NB: this is cause to push k-parallel into various overlap arrays used by grdovlp <sigh>
      meikr = 2*nk*mxrb
c grdovlp requirement relative to i03 (hence -2nwk)
      mgrdovlp = meikr + MAX( 2*norb*nk, noad*noad*nk*natm ) - 2*nwk
c
      m0304 = MAX( 2*nptr, mvslomat, mgridrho, mgrdovlp )
      if( lstout .gt. 2 )
     $ write(IWR,9130) 'WKMEM: max orbs in box noboxmax=',noboxmax
      if( lstout .gt. 3 )
     $ write(IWR,9130) 'DEV/WKMEM: m0304,2nwk,mgrdo,mvsl,2nptr=',
     $                     m0304,2*nwk,mgrdovlp,mvslomat,2*nptr
c
      i01s = i1set
c
      i01 = i1scf
      i02 = i01 + nwk
      i03 = i02 + nwk
C      i04 = i03 + nwk
C      i05 = i04 + nwk
      i04 = i03 + nwk
      i05 = i03 + m0304
      if( (i04+nptr) .gt. i05 ) i04 = i05 - nptr
      i06 = i05 + nptr
      i07 = i06 + nptr
      i08 = i07 + nptr
      i09 = i08 + nptr
      i10 = i09 + nptr
      i11 = i10 + nptr
      i12 = i11 + nptr
cmem      memixx = 4*nwk + 8*nptr
      memixx = 2*nwk + m0304 + 8*nptr
c Idiot check that total-mem matches incrementally added mem amount
      if( (mem0scf+memixx+1) .ne. (i12+nptr) ) call STOPXERR('wkmemi12')
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c       Compute memory needed for grid basis functions
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c NB: Grid orbitals are stored r*4, but space in wk() is declared r*8.
c     Hence, we have 2X declared space to store wvfcns
c
c Survey boxes to get grid bf size: total, and biggest in single box
      nrwfbmx = 0
      nrwfall = 0
      nrmax = 0
      do 400  ibox=1,nbox
c
c       Each processor will do every nprocs'th box in this loop
        if( MOD( ibox, nprocs_k ) .ne. iproc_k ) goto 400
c
        nobox = noboxs(ibox)
        call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $   ira0,irb0,irc0, idra,idrb,idrc )
        nrbox = idra*idrb*idrc
        if( nrbox .gt. nrmax ) nrmax = nrbox
cdev        nrwf = ncplx*nk*nobox*nrbox
        nrwf = ncplx*nkloc*nobox*nrbox
        if( nrwf .gt. nrwfbmx ) nrwfbmx = nrwf
c
c       Add to full mem requirement, with int overflow check:
        if( nrwfall .le. (maxint-nrwf) .and. nrwfall .ge. 0 )then
          nrwfall = nrwfall + nrwf
        else
          nrwfall = -1
        endif
c
  400 continue
c
      if( nrwfall .gt. 0 )then
        if( lstout .gt. 1 ) write(IWR,9040)  nrwfbmx,nrwfall
      else
        if( lstout .gt. 1 ) write(IWR,9041)  nrwfbmx
      endif
 9040 format(/1x,'Need',i12,'-length r*4 array to pack grid wfcns/box',
     $       /1x,'Need',i12,'-length r*4 array to pack all grid wfcns')
 9041 format(/1x,'Need',i12,'-length r*4 array to pack grid wfcns/box',
     $ /1x,'Would need too much length array to pack all grid wfcns')
c
cwf4: fit r*4 orbs into r*8 space (all and biggest box):
      memwfa = ( nrwfall + 1 ) / 2
      memwfb = ( nrwfbmx + 1 ) / 2
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c            Compute workspace needed for grid routines
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c nc=ncplx,nk=nkloc,no=nobox,nsh=biggest(2l+1),nr=nrbox,np=npop=nstate
c            with blas3      without
c gridrho/dm  nc*no*nr     nc*nk*nsh*nr
c gridrho/ef  nc*np*nr     nc*nk*np *nr
c vslomat     nc*no*nr     nc*nk*nsh*nr
c vslofrc     nc*no*nr*nk  nc*nk*   *nr
c
      memdm = memwfb
      memef1 = memwfb
cdev      memef2 = (ncplx*nk*nstate*nrmax+1)/2
      memef2 = (ncplx*nkloc*nstate*nrmax+1)/2
      memef = MAX( memef1,memef2 )
      if( irhoopt .eq. 1 )then
        memwfw = memdm
      elseif( irhoopt .eq. 2 )then
        memwfw = memef
      else
        memwfw = MAX( memdm, memef )
      endif
      if( lstout .gt. 1 ) write(IWR,9042)  2*memwfw
 9042 format( 1x,'Need',i12,'-length r*4 array for grid wfcns scratch')
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c         Compute memory requirements in major code bottlenecks
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c >>>>> setup phase
c
c Default to the (usually much) smaller distributed stripe mat0set
      Lijkmat = .false.
c
c setup/"mat0set"/ijk-tp
      memijkv = 3*nmat + mat
      memijka = 2*nmat + mxang
      if( nprocs .gt. 1 )then
c       Count up tp-reduce space as well:
        memijkv = 4*nmat
        memijka = 2*nmat + mxang
      endif
      memijk  = MAX( memijkv, memijka )
c
c setup/"mat0set"/stripes ...
c   ... Merge all-k striped matrices
c NB: use mxnmatpr, NOT local nmatpr, to ensure consistency across procs
      memstr1v = 2*mxnmatpr + nmatstr + mat
C      memseta = 2*nmatpr + nmatstr + MAX( mxang, mat )
      memstr1a = 2*mxnmatpr + mxang
      memstr1 = MAX( memstr1v, memstr1a )
c   ... Merge k-by-k striped matrices reduced memory footprint store
      memstr2v = 3*mxnmatpr + MAX( matstr*ncplx, 3*norb*maxnorba ) + mat
      memstr2a = 2*mxnmatpr + mxang
      memstr2 = MAX( memstr2v, memstr2a )
c
      if( DEBUG_MEM .or. lvlout .gt. 3 )then
      write(IWR,*) 'DEV/WKMEM: memstr2v,memstr2a=',memstr2v,memstr2a
      write(IWR,*) 'DEV/WKMEM: nmatpr,matstr,mat=',nmatpr,matstr,mat
      write(IWR,*) 'DEV/WKMEM: norb,maxnorba,mxang=',norb,maxnorba,mxang
      endif
c
c     Record stripe memory requirements appropriate to the branch chosen
      if( .not. USE_KPSTORE )then
        memstr = memstr1
      else
        memstr = memstr2
      endif
c
      if( DEBUG_MEM .or. lstout .gt. 3 )then
        write(IWR,*) 'MEM/WKMEM: memstr(old,new)=',memstr1,memstr2
        write(IWR,*) 'MEM/WKMEM: USE_KPSTORE=',USE_KPSTORE,memstr
      endif
c
c Decide whether to revert back to ijkmat for setup:
      msetstr = mem0set + memstr
      msetijk = mem0set + memijk
c
      if( DEBUG_MEM .or. lstout .gt. 3 )
     $ write(IWR,*) 'DEV/MEM: msetstr,msetijk=',msetstr,msetijk
      if( msetstr.gt.maxwkd .and. msetijk.le.maxwkd )then
c       The stripe-parallel does not fit, but the ijk-mat does
        Lijkmat = .true.
      endif
      if( ncplx.eq.2 .and. natm.le.4 .and. msetijk.lt.msetstr )then
c       With very small systems, the ijk-mat will be better
        Lijkmat = .true.
      endif
cxxx264c MAT0SET1 is broken (PAS: really?, I've not seen this)
cxxx264      Lijkmat = .false.
cxxx263b: Should have reduce bcast here to ensure procs have same info
c
c
      if( DEBUG_MEM .or. lstout .gt. 3 )then
        write(IWR,*) 'DEV/MEM: nmatpr,nmatstr=',nmatpr,nmatstr
        write(IWR,*) 'DEV/MEM: nmat,mat,mxang=',nmat,mat,mxang
        memold = MAX( 4*nmat,  (3*nmat+mxang) )
        write(iWR,*) 'DEV/MEM: memstr,ijk,old=',memstr,memijk,memold
      endif
c
      memmat0 = memstr
      if( Lijkmat )then
c       We will use the ijkmat branch in the setup
        memmat0 = memijk
        if( lstout .gt. 0 )
     $   write(IWR,*) 'WKMEM: using ijk+Reduce setup integrals'
      else
        if( lstout .gt. 0 )
     $   write(IWR,*) 'WKMEM: using stripe-parallel+Merge  setup'
      endif
c
c setup/"grid0set"
      if( do_gga )then
        memgr0 = 14*nptr
      else
        memgr0 = 5*nptr
      endif
c setup/
      memset = mem0set + MAX( memmat0, memgr0 )
c
c >>>>> scf phase
c
c scf/eigensolvers
      if( ncplx .eq. 1 )then
c       Real eigensolver/erlsolv
c
c       How many processors on this image?
        call MPNODES( nprocs )
        if( nprocs .eq. 1 )then
c         Serial lapack solver, just needs ...
          memeig = 4*mat
        else
cxxx264   Memory needs for distributed parallel real solver needs doing
c          memeig = 5*mat
          call EIGPROCS( nprocs, nprow,npcol, npsolver )
          call EIGMDIST( matdist, norb, npsolver )
          memeig = 4*matdist + mat
        endif
c
      elseif( ncplx .eq. 2 )then
c       Complex eigensolver/eigsolv
c
c       Serial lapack complex eigensolver memory needs (as baseline):
        memeig = mat + norb*(4*norb+2*nstate) + 7*norb
        if( idosolv.eq.3 )then
c         Linear dependence treatment in SCHROED needs more
          memeig = mat + norb*(6*norb) + 7*norb
        endif
c
c       Allot distributed memory for complex parallel solver pschroed:
c       ***** MUST be compatible with branching in PEIGSOLV *****
c
        call MPNODES( nprocs )
c
c       Determine if we MUST avoid serial-solves due to memory limits
        memscfmx = maxwkd - i01 + 1
        memeigmx = 2*(memscfmx/3)
        if( nprocs.ge.4 .and. memeig.gt.memeigmx )then
c         We want some slack above memeig for the blend, etc.
c         In future design, we might use an "npsolv" rather than do_psolv
          do_psolv = .true.
          if( DEBUG_MEM .or. lstout .gt. 0 )then
          write(IWR,*) 'DEV/wkmem: turned psolv to do_psolv=',do_psolv
          write(IWR,*) '>>>>> mem needed for seq solves=',memeig
          write(IWR,*) '>>>>> limited to ',memeigmx,' of free ',memscfmx
          endif
        endif
c
cxxx264: the solver (memory) branches and their criteria need to be cleaned up
        if( do_kppsolve
C  The following is now determined in main (outside wkmem)
C     $     .and. ( norb.ge.200*(nprocs/nk+1) )
     $                  )then
c         New k-parallel-parallel solver, invokes ScaLAPACK solvers within k-point groups
c         Sizing routine in pschroedkp.f
          if( lstout .gt. 0 )
     $    write(IWR,*) 'WKMEM: Use k-parallel-parallel solver'
          flagdum = .false.
ctp
CTPc kppmemx call is mpi-/blacs-dependent, needs be removed for serial
CTPc kppmem0 is mpi-/blacs-independent, and is good enough for parallel, too
CTP         if( DEBUG_MEM )then
CTP            call KPPMEMX( flagdum, do_eigvecs,
CTP     $                    norb,nstate, memeig )
CTP            write(IWR,*) 'DEV/WKMEM: kppmemx memeig=',memeig
CTP          endif
          call KPPMEM0( flagdum, do_eigvecs,
     $                  norb,nstate, memeig )
          if( DEBUG_MEM .or. lstout .gt. 2 )
     $    write(IWR,*) 'DEV/WKMEM: kppmem0 memeig=',memeig
c
        elseif( nprocs.eq.1 .or.
     $         (  .not. do_psolv .and.
     $           ( norb.lt.800 .or. nk.gt.4 .or. nprocs.lt.(4*nk) )  )
     $                           )then
c         Use serial lapack solver
c          IF 1 proc (already serial)
c          OR if not compelled to be parallel-solves AND:
c              a small problem (little benefit from parallel)
c           OR more than 4 k-points (do k-distrbuted serial solves)
c           OR too few procs for a parallel-parallel ...
c               (this last is likely moot with the new k-parallel-parallel)
          if( DEBUG_MEM .or. lstout .gt. 0 )
     $    write(IWR,*) 'WKMEM: Use serial complex solver in PSCHROED2'
          if( DEBUG_MEM .or. lstout .gt. 2 )
     $    write(IWR,*) 'DEV/WKMEM: serial memeig=', memeig
c
        else
c         Parallel-solver pschroed
c         Get number of active procs
          call EIGPROCS( nprocs, nprow,npcol, npsolver )
c         Get size of distributed matrix
C          call EIGMDIST( matdist, norb, npsolver )
          call PSCHWKSZ0(            npsolver, do_eigvecs,
     $     norb, matdist, lwzwork, lzwork, lrwork, liwork )
          lwork = lzwork
c         Memory bottlenecks in pschroed have following requirements:
          nwpreph = 2*matdist + 3*mat
          nwpreps = 4*matdist + 2*mat
          nwprep = MAX( nwpreph, nwpreps )
          nwsolv = 6*matdist + lwzwork + lrwork + liwork + norb
C          nwclose = 6*matdist + 2*norb*nstate ! this is more precise?
          nwclose = 6*matdist + 2*norb*norb
          nwpsch = MAX( nwprep, nwsolv, nwclose )
          memeig = nwpsch
c
          if( DEBUG_MEM .or. lstout .gt. 0 )
     $    write(IWR,*) 'WKMEM: Use parallel complex solver in PSCHROED'
          if( DEBUG_MEM .or. lstout .gt. 2 )
     $    write(IWR,*) 'DEV/WKMEM: parallel memeig=',memeig
        endif
c
      else
        call STOPXERR( 'wkmem-nc/ncplx is disallowed value' )
      endif
c
c scf/doengy
c  Need to track all nspin hams, and also dmat and h0mat for single k
      memengy = nspin*nmatkp + 2*mat
c
c scf/blend&blendhistory
c  Length of full k-parallel blend vector
      nvecbl = nspin*nmatkp
c
c     Determine size of data-distributed blend Hams
      call MPNODES_K( nprocbl )
      nveclocl = ( nvecbl + nprocbl - 1 ) / nprocbl
c
c     Now minimum memory we need to run blend ...
c      ... upon input (and in gesser) use two full sets of Hams:
      memblndi = 2*nvecbl
c      ... and, if k-parallel, further need read buffer(mat) in h0readkp:
      if( nkloc .lt. nk ) memblndi = memblndi + mat
c      ... in blend, pass a full set plus three local scratch spaces:
      memblnds = nvecbl + 3*nveclocl
c      ... and the workspace we need is the larger of these two:
      memblnd = MAX( memblndi, memblnds )
      if( Lnonscf ) memblnd = 0
c
c     Determine how much memory would need to keep blend history in-core:
c     (Note: ASD has nhiste=0 need)
      memhiste = 2*nveclocl + 2*nhiste*nveclocl
      if( Lnonscf ) memhiste = 0
c
c scf/*before wf*
c     memscf is largest extent of scratch memory used in scf.
c     Beyond memscf can be used for storage, wil survive from on iter into next
      memscf = mem0scf + MAX( memixx, memeig, memengy, memblnd )
c
      if( DEBUG_MEM .or. lstout .gt. 3 )then
        write(IWR,9130) 'WKMEM: mem0scf=',mem0scf
        write(IWR,9130) 'WKMEM: memixx/eig/engy/blnd=',
     $   memixx, memeig, memengy, memblnd
      endif
c
c >> grid orbitals
c
c Allocate space for grid wf temp work space(location is critical!!!):
c Must see memory usage around gridrho/vslomat/vslofrc for this to work.
      iwfw = i07
c Compute space available for grid wf ...
c  ... idiot-check that temp wf space does not spill over end of ixx,
c      to ensure that stored grid orbitals are safe
      memscfw = iwfw + memwfw
      if( memscf .gt. memscfw ) memscfw = memscf
c  ... memory available (and used) for in-core grid wf:
      iwfall = memscfw + 1
      maxwfa = maxwkd - memscfw
      memall = memscfw + memwfa
c  ... and for on-the-fly grid wf:
      iwffly = iwfw + memwfw
      memfly = iwffly + memwfb - 1
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c           Now we put it all together and make decisions
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      minmem = MAX( memset, memscf, memfly )
c
      if( lstout .gt. 0 ) write(IWR,9020)  minmem
 9020 format(1x,'Minimum maxwkd for scf to complete=',i12)
c     Note: vslofrc uses extra memory that may exceed this minimum
c
      if( lstout .gt. 2 )then
        write(IWR,9130)  'WKMEM: from memset,memscf,memfly=',
     $   memset,memscf,memfly
      endif
 9130 format(1x, a, 6(1x,i12) )
c
      if( minmem .gt. maxwkd )then
        write(IWR,*) '>>>>> need maxwkd=',minmem
        write(IWR,*) '>>>>> have maxwkd=',maxwkd
        if( lstout .lt. 5 )then
c         Go back and give more detail ...
          write(IWR,*) ' retracing to get more detail on memory needs'
          lstout = 5
          goto 100
        endif
        call STOPXERR( 'maxwkd  - insufficient memory for scf calc' )
      endif
c
      if( nrwfall .gt. 0 .and. memall .le. maxwkd )then
c       All wave fcns is not too many, and all wvfcns fit
        write(IWR,9021) 'All grid wfcns stored in', memwfa,
     $                  ' of', maxwfa,' available'
 9021   format(1x, a,i10,a,i10,a )
        idwf = 1
        iwf = iwfall
        memwf = memwfa
        memtopscf = memall
      elseif( memfly .le. maxwkd )then
c       Have to do on-the-fly grid orbitals
        write(IWR,9021)  'Box-wise grid wfcns use ',memwfb,';  ',
     $                    maxwfa,' available'
        if( maxwfa .lt. memwfb ) write(IWR,*) ' for in-core grid wfcns'
        idwf = 0
        iwf = iwffly
        memwf = memwfb
c       Top mem usage is either on-the-fly scratch, or scf sandbox:
        memtopscf = MAX( memfly, memscf )
      else
        call STOPXERR( 'wkmem   - logic failure in WKMEM routine' )
      endif
c
c See if we can squeeze in-core broyden into remaining space:
c
      memfree = maxwkd - memtopscf
      if( memhiste .le. memfree )then
c       Have room for full in-core broyden - set memblnde location, size
        write(IWR,9021) 'WKMEM: in-core Broyden! uses',memhiste,
     $                  ' out of', memfree,' available'
        imblnde = memtopscf + 1
        memblnde = memhiste
        idbr = 1
      else
c       Not room for full in-core broyden - set memblnde to 0
        imblnde = 1
        write(IWR,9021) 'WKMEM: on-disk Broyden! for in-core',memhiste,
     $                  ' needed, but only', memfree,' available'
        memblnde = 0
        idbr = 0
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MEMCHK
c
c
c###############################################################
c  Purpose: check for integrity of in-core stored arrays,
c           e.g., grid orbitals or blending history,
c           to check if memory is stepped on by memory overrun in job
c           This is solely debugging, a user should never see this
c
c Written: Peter A. Schultz, 11-Jabuary-2012, for 2.63
c          based on a suggestion from Andy Pineda
c
c Revisions:
c  none
c###############################################################
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MEMCHKIWF
c
c
      subroutine MEMCHKIWF( idwf, itypchk, labelwf, wvfcns, wfiwf )
c---------------------------------------------------------------
c Purpose: check the grid orbitals
c  idwf = flag if grid orbitals are indeed stored
c---------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
      REAL    wvfcns, wfiwf, wfiwf1
      DIMENSION  wvfcns(*)
      CHARACTER*(*) labelwf
c
c Local declarations:
      DATA  lvldbg / 0 /
c
c >>>> EXECUTABLE CODE:
c
      if( idwf .le. 0 ) goto 999
c
      call FLGETIWR( IWR )
c
 1800 format(a,a,1p4d10.3)
      if( itypchk .eq. 0 )then
c       Initialize
        wfiwf = wvfcns(1)
        if( lvldbg .gt. 0 )
     $  write(IWR,1800) 'IWFINIT/wf(1): ',labelwf, wfiwf
      elseif( itypchk .eq. 1 )then
c       Check against recorded value
        wfiwf1 = wvfcns(1)
        if( lvldbg .gt. 0 )
     $  write(IWR,1800) 'IWFCHK/wf(1): ',labelwf, wfiwf1
        if( wfiwf1 .ne. wfiwf )then
          write(IWR,1800) '***** IWFBUG *****',labelwf,wfiwf,wfiwf1
          call STOPXERR( 'Memory error - grid wave fcns overwritten' )
        endif
      elseif( itypchk .eq. 2 )then
c       Just output the value without check
        wfiwf1 = wvfcns(1)
        write(IWR,1800) 'IWFCHK/wf(1): ',labelwf, wfiwf1
      endif
c
  999 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MEMCHKIBR
c
c
      subroutine MEMCHKIBR( idbr, itypchk, labelbr, wkbroy, savbr )
c---------------------------------------------------------------
c Purpose: check the blending data
c  Complicated by the need to track IF blend data exists yet
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input:
      DIMENSION  wkbroy(*)
      CHARACTER*(*) labelbr
c
c Local declarations:
      DATA  initbr  / 0 /
c
      DATA  lvldbg / 0 /
c
c >>>> EXECUTABLE CODE:
c
c  If do not have in-memory broyden, bounce out ...
      if( idbr .eq. 0 ) goto 999
      if( idbr .eq. -1 )then
c       Initialize
        initbr = 0
        goto 999
      endif
c
      thisbr = wkbroy(idbr)
c
      call FLGETIWR( IWR )
c
 1800 format(a,a,1p4d10.3)
      if( itypchk .eq. 0 )then
c       Initialize
        savbr = thisbr
        initbr = 1
        if( lvldbg .gt. 0 )
     $  write(IWR,1800) 'IBR-INIT/br(1): ',labelbr, savbr
      elseif( initbr.ne.0 )then
c       There has been an initialization with history data
        if( itypchk .eq. 1 )then
c         Check against recorded value
          if( lvldbg .gt. 0 )
     $    write(IWR,1800) 'IBRCHK/br(1): ',labelbr, thisbr
          if( thisbr .ne. savbr )then
            write(IWR,1800) '***** IBRBUG *****',labelbr,savbr,thisbr
            call STOPXERR( 'Memory error - blend history overwritten' )
          endif
        elseif( itypchk .eq. 2 )then
c         Just output the value without a check
          write(IWR,1800) 'IBRCHK/br(1): ',labelbr, thisbr
        endif
      endif
c
  999 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPPMEM0
c
c
      subroutine KPPMEM0( per_process, do_eigvecs,
     $ norb,nstate,  memeig )
c---------------------------------------------------------------
c Purpose: compute memory requirements (size of wmat argument) of 
c          PSCHROEDKP for wkmem using Scalapack calls.
c
c Written:  Andrew C. Pineda,  9-February-2010 for v2.62
c Revision history:
c  4Jan13-PAS/2.64: clean-up
c---------------------------------------------------------------
c
c Return argument:
c    memeig = process value (per_process = .true.)
c           = max value over all processes (per_process = .false.)
c
      INTEGER     NB
      PARAMETER  (NB=32)
C      INCLUDE  'mpif.h'
c
      INTRINSIC  MAX
c
c Input arguments
      INTEGER  norb
      LOGICAL  per_process
      LOGICAL  do_eigvecs
c
c Output arguments
      INTEGER  memeig
c
c Local variables
      integer  memeiglocal
      logical  per_process_local
c
      integer  mat, matdist
      integer  nwpreph, nwpreps, nwprep, nwsolv
      integer  nwclose, nwpsch, nwleft
      integer  iwHmat, iwOvlp, iwVecs
      integer  iwZwork, iwRwork, iwIwork, iwiwk1, iwlast, iwEnd
      integer  lwzwork,lzwork, lrwork, liwork
      integer  iwMat1, iwMat2, iwVeco
c
      integer  CONTEXT_K
      integer  nprocs_k, icomm
      integer  nprow_k, npcol_k, npsolver_k
c
      integer  ierr
c
      LOGICAL  USE_SCALAPACK_FORMULAS
      DATA    USE_SCALAPACK_FORMULAS / .true. /
C      LOGICAL  OPTIMAL_EIGENVECTORS
C      DATA    OPTIMAL_EIGENVECTORS   / .true. /
      LOGICAL  DEBUG_MEM
      DATA     DEBUG_MEM / .false. /
c
c >>>> EXECUTABLE CODE:
c
      if( DEBUG_MEM )then
        call FLGETIWR( IWR )
        write(IWR,*) 'DEV/KPPMEM0: do_eigvecs=',do_eigvecs
      endif
      mat = norb*norb
c  Get Local MP info
c     Image level info
      call MPCOMM( icomm )
c     K-point level info
      call MPNODES_K( nprocs_k )
c
      memeiglocal = 0
c
      if( nprocs_k .eq. 1 )then
c       Using Lapack serial eigensolver
c 
c       Only one processor assigned to the MPI context this processor
c       belongs to, set up memory to use LAPACK. 
c
        matdist = mat
        lwzwork = MAX( 4*norb, mat )
        lrwork  = 7*norb
        liwork  = 5*norb
c
c       Close serial solver memory needs
      else
c       USING SCALAPACK
c
c       Get the process grid dimensions, given the context size
c
        call EIGPROCS( nprocs_k, nprow_k, npcol_k, npsolver_k )
c
c       Determine pzhegvx workspace requirements
c
C        if( USE_SCALAPACK_FORMULAS )then
Cc         Get EXACT mpi/blacs-aware work space using this context:
CC          CONTEXT_K = -1
C          call MPCOMM_K( icomm_k )
C          CONTEXT_K = icomm_k
C          call BLACS_GRIDINIT( CONTEXT_K, 'R', nprow_k, npcol_k )
C          call PSCHWKSZX( CONTEXT_K, npsolver_k, do_eigvecs,
C     $     norb, matdist, lwzwork, lzwork, lrwork, liwork )
C          lwork = lzwork
C          call BLACS_GRIDEXIT( CONTEXT_K )
C        else
c         Use default mpi/blacs-avoiding naive work space:
          call PSCHWKSZ0(            npsolver_k, do_eigvecs,
     $     norb, matdist, lwzwork, lzwork, lrwork, liwork )
          lwork = lzwork
C        endif
      endif
c
c     Initialize memory allocations within icomm_k.
c     MEM-Solver: d-C16-H, d-C16-S, d-C16-Vec, d-C16-Zwork, d-R8-Rwork)
c
cxxx264: list solver memory allocs as implemented, but not used here
      iwHmat  = 1
      iwOvlp  = iwHmat + 2*matdist
      iwVecs  = iwOvlp + 2*matdist
      iwZwork = iwVecs + 2*matdist
      iwRwork = iwZwork + lwzwork
      iwIwork = iwRwork + lrwork
      iwiwk1  = iwIwork + liwork
      iwlast  = iwiwk1  + norb
      iwEnd   = iwlast  - 1
c
      iwMat1  = iwOvlp
      iwMat2  = MAX( iwMat1 + mat, iwVecs )
      iwVeco  = iwZwork
c
c     The solver memory allocations have the following requirements:
      nwpreph = 2*matdist + 3*mat
      nwpreps = 4*matdist + 2*mat
      nwprep = MAX( nwpreph, nwpreps )
      nwsolv = 6*matdist + lwzwork + lrwork + liwork + norb
c     nwclose = 6*matdist + 2*norb*nstate
c     because all vectors are brought back into full norb*norb ...
cxx264: nwclose (eigeenec store) needs to be dealt with (norb*nstate(
      nwclose = 6*matdist + 2*norb*norb
      nwpsch = MAX( nwprep, nwsolv, nwclose )
c
      nwleft = nwpsch - nwsolv
      if( DEBUG_MEM )then
        write(IWR,*) 'DEV/KPPMEM0: spare solver mem=',nwleft
      endif
c
cxxx264: is this mem-req for LAPACK solve cognizant of do_eigvecs?
      memeiglocal = MAX( iwEnd, iwMat2+2*mat, iwVeco+2*mat )
c
c >>>>> Put it all together and report to final result
c
      per_process_local = per_process
c
C      if( per_process_local ) then
c        Report the local memeig value
         memeig = memeiglocal
C      else
Cc       Report the maximum value of memeig for any process in icomm
Cc       Need barrier to prevent a crash
C        call MPBARRIER( icomm )
C        icount = 1
C        call MPI_ALLREDUCE( memeiglocal, memeig, icount,
C     $       MPI_INTEGER, MPI_MAX, icomm,
C     $       ierr )
C      endif
      if( DEBUG_MEM )then
        write(IWR,'(a,4i12)') 'DEV/KPPMEM0: works,Z,R,I=',
     $                         lwzwork, lrwork, liwork
        write(IWR,'(a,3i12)') 'DEV/KPPMEM0: nwsch,memeig=',
     $                         nwpsch, memeiglocal, memeig
        write(IWR,*) 'DEV/KPPMEM0: icomm,nprocs_k=',icomm,nprocs_k
        call FLUSH( IWR )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> PSCHWKSZ0
c
c
      subroutine PSCHWKSZ0(          nprocs, do_eigvecs,
     $ norb, matdist, lwzwork, lzwork, lrwork, liwork )
c---------------------------------------------------------------
c Purpose: compute exact memory requirements for PSCHROEDKP solvers,
c          using Scalapack (p)zhegvx calls.
c      
c Written:  Peter A. Schultz, 10-January-2013, for 2.64
c           Derived from PSCHROEDKPSZ by Andrew C. Pineda (9Feb10)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c  Work array space for
c    (1)  serial solver zhegvx
c    (2)  parallel solver pzhegvx
c
      INTEGER     NB
      PARAMETER  (NB=32)
C      INCLUDE  'mpif.h'
c
      INTRINSIC  MAX
c
c Input arguments
C      INTEGER  icontxt
      INTEGER  nprocs
      LOGICAL  do_eigvecs
c
      INTEGER  norb
c
c Output arguments
      INTEGER  matdist
      INTEGER  lwzwork, lzwork, lrwork, liwork
c
c Local variables
      INTEGER  mat
      INTEGER  nprow, npcol, npsolver
c
      LOGICAL  DEBUG_MEM
      DATA     DEBUG_MEM / .false. /
c
c >>>> EXECUTABLE CODE:
c
      if( DEBUG_MEM )then
        call FLGETIWR( IWR )
        write(IWR,*) 'DEV/WKSZ-0: norb,nprocs=',norb,nprocs
      endif
cxx:end

      mat = norb*norb
c
      if( nprocs .eq. 1 )then
c       Using Lapack serial eigensolver
c 
c       Only one processor assigned to the MPI context this processor
c       belongs to, set up memory to use LAPACK. 
c
        matdist = mat
cxxx264        lwzwork = 2*MAX( 2*norb, mat ) ! I am sure we don't need 2mat -pas
        lwzwork =   MAX( 4*norb, mat )
        lzwork  = lwzwork / 2
        lrwork  = 7*norb
        liwork  = 5*norb
cxxx264 - need to scope a do_eigvecs-aware memory for single-proc
C        memeig = 2*mat + 2*mat + 2*norb*nstate + mat + 7*norb
c
c       Close serial solver zhegvx memory needs
      else
c       Parallel, USING SCALAPACK
c
c       Get the process grid dimensions, given the context size
        call EIGPROCS( nprocs, nprow, npcol, npsolver )
c       NOTE: following is a crude approximation to matdist, NOT exact
        call EIGMDIST( matdist, norb, npsolver )
c
c   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c    Simplified appxximate work memory requirements
c   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c      Simplified naive values
        lwzwork = 2*matdist
        lzwork = lwzwork / 2
        lrwork = 2*matdist
        liwork = 6*norb
        if( .not. do_eigvecs )then
c         No eigenvectors, this becomes much less:
          lzwork = (NB+1) * (norb+1)
          lrwork =9*norb
        endif
c
c       Close pzhegvx parallel solver work array memory needs
      endif
c
      if( DEBUG_MEM )then
        write(IWR,'(a,3i12)') 'DEV/WKSZ-0: works, Z,R,I=',
     $                         lwzwork,lrwork,liwork
        call FLUSH( IWR )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> WRSETD
c
c
      subroutine WRSETD( iset0fl, iprgm,jprgm, nxcd,
     $ norb,nk, natm,ntyp,nrd, noad, nlat,nlat1c,nlat2c,nlat3c,
     $ atm0engy, xc0val,  vatrad,vesrad,vxcrad,excrad, gntcomb,
     $ rhoatom,nearest, near2c, s1atom, orbint,orbofk,
     $ nang,nfitd, angylm,nfityp,radwf )
c---------------------------------------------------------------
c Purpose: write out (almost) generally dimensioned iset0fl file
c
c Written: Peter A. Schultz, 17-February-1994
c
c Revision history:
c  14Jun05-PAS/2.59: File units
c  21Jun01-PAS/2.48: replace STOPs, writes
c   3May99-PAS/2.35: use near2c to determine 2c defect use
c  17Dec98-PAS/2.30: take all force stuff out of setup phase
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  22May98-PAS/2.22: bugfix
c  28Apr97-PAS/2.17: naming conventions
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  xc0val(nxcd)
      DIMENSION  vatrad(nrd,ntyp),vesrad(nrd,ntyp),
     $           vxcrad(nrd,ntyp),excrad(nrd,ntyp)
      DIMENSION  gntcomb(8100)
      DIMENSION  rhoatom(natm,3),nearest(3,natm)
      DIMENSION  s1atom(noad,noad,nk,natm)
      DIMENSION  orbint(2,norb,nk),orbofk(2,natm,norb,nk)
c for stress routines:
      DIMENSION  angylm(nang,9),nfityp(ntyp),radwf(nang,nrd,noad,nfitd)
c
c  Dump to iset0fl:
c
      REWIND( unit=iset0fl )
      write(iset0fl)  iprgm,jprgm
      write(iset0fl)  nxcd, norb,nk, natm,ntyp,nrd, noad, near2c
      write(iset0fl)  nlat, nlat1c,nlat2c,nlat3c
      write(iset0fl)  atm0engy,xc0val
      write(iset0fl)  vatrad,vesrad,vxcrad,excrad,gntcomb
      if( near2c.eq.2 )then
        write(iset0fl)  rhoatom,nearest,s1atom,orbint,orbofk
      else
        write(iset0fl)  rhoatom,nearest,s1atom
      endif
      write(iset0fl)  nang,nfitd
      write(iset0fl)  angylm,nfityp,radwf
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RDSETD
c
c
      ENTRY RDSETD(iset0fl, iprgm,jprgm, nxcd,
     $ norb,nk, natm,ntyp,nrd, noad, nlat,nlat1c,nlat2c,nlat3c,
     $ atm0engy, xc0val,  vatrad,vesrad,vxcrad,excrad, gntcomb,
     $ rhoatom,nearest, near2c, s1atom, orbint,orbofk,
     $ nang,nfitd, angylm,nfityp,radwf )
c
c  Retrieve from file:
c
      REWIND( unit=iset0fl )
      read(iset0fl)  iprgm,jprgm
      if( iprgm.lt.230 ) call STOPXERR( 'isetdvrs/restart version' )
      read(iset0fl)  mxcd, morb,mk, matm,mtyp,mrd, moad, mear2c
c check the dimensioning:
      if( morb.ne.norb .or. mk.ne.nk .or. matm.ne.natm .or.
     $    mtyp.ne.ntyp .or. mrd.ne.nrd .or. moad.ne.noad )then
        call FLGETIWR( IERRFL )
        write(IERRFL,*) 'DATA:  norb, nk, natm, ntyp, nrd, noad'
        write(IERRFL,*) 'input:',norb,nk, natm,ntyp,nrd, noad
        write(IERRFL,*) 'saved:',morb,mk, matm,mtyp,mrd, moad
        call STOPXERR( 'isetdims/restart file dim mismatch' )
      endif
      read(iset0fl)  nlat, nlat1c,nlat2c,nlat3c
      read(iset0fl)  atm0engy,(xc0val(i),i=1,mxcd)
      read(iset0fl)  vatrad,vesrad,vxcrad,excrad, gntcomb
      if( mear2c.ne.near2c )then
        call STOPXERR( 'near2c  /input near2c .ne. disk near2c' )
      elseif( near2c.eq.2 )then
        read(iset0fl)  rhoatom,nearest,s1atom,orbint,orbofk
      else
        read(iset0fl)  rhoatom,nearest,s1atom
      endif
      read(iset0fl)  mang,mfitd
      if( mang.ne.nang .or. mfitd.ne.nfitd ) call STOPXERR( 'isetd1c' )
      read(iset0fl)  angylm,nfityp,radwf
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> XCONMSH
c
c
      subroutine XCONMSH( natm,ntyp,nshld, nlat, n1r,n2r,n3r,nptr,
     $ itypa, numshl,lshel, ratm,hh,rlat, mngr3,ngr,
     $ nfityp,almnv1c,alxcmin,lmx1ctr,
     $ alfxc,nalfxc,cv,ce,nalfxcd,
     $ vxcmsh,excmsh,expfac,r )
c---------------------------------------------------------------
c Purpose: Initializes xc potential and energy density
c          on mesh using fit coefficients from v1ctrij
c
c Written: P.J. Feibelman
c
c Revision history:
c   1Mar00-PAS/2.43: bugfix for non-xcfit
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c   1May97-PAS/2.17: naming conventions, new grid coord rtn
c  11Nov94-PAS/2.10: cleanup/first round optimization
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c input arrays:
      DIMENSION  itypa(natm), numshl(nshld),lshel(nshld,ntyp)
      DIMENSION  ratm(3,natm),hh(3,3),rlat(3,nlat)
      DIMENSION  mngr3(*),ngr(*)
      DIMENSION  nfityp(ntyp),almnv1c(ntyp),alxcmin(ntyp),lmx1ctr(ntyp)
      DIMENSION  nalfxc(ntyp),alfxc(nalfxcd,ntyp)
      DIMENSION  cv(10,nalfxcd,natm),ce(10,nalfxcd,natm)
c output arrays:
      DIMENSION  vxcmsh(nptr),excmsh(nptr)
c scratch arrays:
      DIMENSION  expfac(nptr),r(3,nptr)
c local declarations:
      DIMENSION  r0(3),rnuc(3),rlast(3),rshift(3),number(3)
      DATA  number / 1,4,10 /
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
      r0(1) = zero
      r0(2) = zero
      r0(3) = zero
      call MKRBOX( hh,r0, n1r,n2r,n3r, r )
c
c    Loop on atoms:
c
      iorb = 1
      do 1000 iatm=1,natm
        ityp = itypa(iatm)
        nrat = ngr(iorb)
        imin3 = mngr3(iorb)
        do  ishl=1,numshl(ityp)
          if( ngr(iorb).gt.nrat )then
            nrat = ngr(iorb)
            imin3 = mngr3(iorb)
          endif
          iorb = iorb + 2*lshel(ishl,ityp) + 1
        enddo
        if( nfityp(ityp).eq.0 ) goto 1000
c
        nr0 = n1r*n2r*(imin3-1)
c  Check against 1-c cutoff AND xc-fit cutoff:
        alxmin = alxcmin(ityp)
        alxmin = MAX(alxcmin(ityp),almnv1c(ityp))
        numlmx = number(lmx1ctr(ityp)+1)
c
c    Loop on fit alphas for this atom type:
c
        do  ial=1,nalfxc(ityp)
          ial1 = ial
          alxc = alfxc(ial,ityp)
          if( alxc.ge.alxmin ) goto 22
        enddo
c  No gaussians reach cutoff, skip center
        goto 1000
c
   22   continue
        rlast(1) = zero
        rlast(2) = zero
        rlast(3) = zero
c
        do 900 ilat=1,nlat
c
          do  ir=1,3
            rnuc(ir) = ratm(ir,iatm) + rlat(ir,ilat)
          enddo
          do  ir=1,3
            rshift(ir) = rnuc(ir) - rlast(ir)
          enddo
          do  ir=1,3
            rlast(ir) = rnuc(ir)
          enddo
c  Shift coordinates:
          do  nr=nr0+1,nr0+nrat
            r(1,nr) = r(1,nr) - rshift(1)
            r(2,nr) = r(2,nr) - rshift(2)
            r(3,nr) = r(3,nr) - rshift(3)
          enddo
c
c    Loop over fit alphas:
c
          do 200 ial=ial1,nalfxc(ityp)
c
c    Compute exponentials when argument is small enough.
c
            do  nr=nr0+1,nr0+nrat
              rsq = r(1,nr)**2 + r(2,nr)**2 + r(3,nr)**2
              arg = alxc*rsq
              if( arg.gt.cutgrid )then
                expfac(nr) = zero
              else
                expfac(nr) = EXP(-arg)
              endif
            enddo
c
c    Compute counter-potential using this information ...
c
            if( numlmx.ge.1 )then
c         ... s-like xc potential
              do  nr=nr0+1,nr0+nrat
                vxcmsh(nr) = vxcmsh(nr) - expfac(nr)*cv(1,ial,iatm)
                excmsh(nr) = excmsh(nr) - expfac(nr)*ce(1,ial,iatm)
              enddo
            endif
c
            if( numlmx.ge.4 )then
c         ... p-like xc potential
              do  nr=nr0+1,nr0+nrat
                x = r(1,nr)
                y = r(2,nr)
                z = r(3,nr)
                vxcmsh(nr) = vxcmsh(nr) - expfac(nr)*( cv(1,ial,iatm)
     $           + x*cv(2,ial,iatm)+y*cv(3,ial,iatm)+z*cv(4,ial,iatm) )
                excmsh(nr) = excmsh(nr) - expfac(nr)*( ce(1,ial,iatm)
     $           + x*ce(2,ial,iatm)+y*ce(3,ial,iatm)+z*ce(4,ial,iatm) )
              enddo
            endif
c
            if( numlmx.ge.10 )then
c         ... d-like xc potential
              do  nr=nr0+1,nr0+nrat
                x = r(1,nr)
                y = r(2,nr)
                z = r(3,nr)
                vxcmsh(nr) = vxcmsh(nr) - expfac(nr)*( cv(1,ial,iatm)
     $           +x*(cv(2,ial,iatm)+y*cv(5,ial,iatm)+x*cv(8,ial,iatm) )
     $           +y*(cv(3,ial,iatm)+z*cv(6,ial,iatm)+y*cv(9,ial,iatm) )
     $           +z*(cv(4,ial,iatm)+x*cv(7,ial,iatm)+z*cv(10,ial,iatm)))
                excmsh(nr) = excmsh(nr) - expfac(nr)*( ce(1,ial,iatm)
     $           +x*(ce(2,ial,iatm)+y*ce(5,ial,iatm)+x*ce(8,ial,iatm) )
     $           +y*(ce(3,ial,iatm)+z*ce(6,ial,iatm)+y*ce(9,ial,iatm) )
     $           +z*(ce(4,ial,iatm)+x*ce(7,ial,iatm)+z*ce(10,ial,iatm)))
              enddo
            endif
c
  200     continue
c
  900   continue
c  Restore coordinates:
          do  nr=nr0+1,nr0+nrat
            r(1,nr) = r(1,nr) - rlast(1)
            r(2,nr) = r(2,nr) - rlast(2)
            r(3,nr) = r(3,nr) - rlast(3)
          enddo
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> XCORB
c
c
      subroutine XCORB( nang,nrd,noad,nfitd,
     $ natm,ntyp,nshld,nald, itypa, numshl,lshel,nala,ala,cala,
     $ nrad,radmsh, angpts, nfityp, radwf,
     $ gauss,rsq )
c---------------------------------------------------------------
c Purpose: calculates orbitals on radial mesh for those atom
c          types with 1-ctr potentials, for the purpose of
c          fitting of the rapid part of xc-potentials
c
c Written: Version 1.0, 12/19/89, by PJF
c
c Revision history:
c   7Mar02-PAS/2.52: ang constants extracted, arg list fixed
c   1Mar00-PAS/2.43: bugfix for non-xcfit
c  21Dec99-PAS/2.42: cosmetic clean-up
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  28Apr97-PAS/2.17: naming conventions
c  20Apr93-PAS: fix underflow, ang dims, clean/opt code
c---------------------------------------------------------------
c
c      theta-phi points are chosen according to
c      A. D. McLaren's 72 point formula, which guarantees
c      accuracy through l=14. See, Math. Comp. 17, 361 (1963).
c      Radial points are given via array radmsh
c
c 20Apr93-PAS: should invert nr/nang dims in array radwf and
c              invert corresponding loops.
c              this would pay off in the d-loops below
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CONST/ pi,rtpi,cutexp
c data arrays:
      DIMENSION  itypa(natm), numshl(ntyp),lshel(nshld,ntyp),
     $  nala(nshld,ntyp),ala(nald,nshld,ntyp),cala(nald,nshld,ntyp)
      DIMENSION  nrad(ntyp),radmsh(nrd,ntyp)
      DIMENSION  angpts(*)
      DIMENSION  nfityp(ntyp)
c output arrays:
      DIMENSION  radwf(nang,nrd,noad,nfitd)
c scratch arrays:
      DIMENSION  gauss(*),rsq(*)
c
c local declarations:
      DIMENSION  vnorm(5)
      DATA  zero / 0.d0 /
c
c >>>> EXECUTABLE CODE:
c
c Get angular normalizations:
      call VNORMS( vnorm )
c
c     Loop on atom types:
      do 1000 ityp=1,ntyp
c
c      skip this type if its alphas are small
c
        itypxc = nfityp(ityp)
        if( itypxc.eq.0 ) goto 1000
c
c       Loop on shells of atom type ityp
        ioa = 0
        do 800 ishl=1,numshl(ityp)
          lshl = lshel(ishl,ityp)
c
          nrmax = nrad(ityp)
          do  nr=1,nrmax
            r = radmsh(nr,ityp)
            rsq(nr) = r*r
            gauss(nr) = zero
          enddo
c
c  Compute radial factor for this radial orbital
c
          do 45 ial=1,nala(ishl,ityp)
            coeff = cala(ial,ishl,ityp)
            ali = ala(ial,ishl,ityp)
c  Underflow protection cut-off stuff:
            rsqmax = 0.4*cutexp/ali
            nrmx = nrmax
            do  nr=nrmax,1,-1
              if( rsq(nr).lt.rsqmax ) goto 39
              nrmx = nrmx - 1
            enddo
   39       continue
            do  nr=1,nrmx
              gauss(nr) = gauss(nr) + coeff* EXP( -ali*rsq(nr) )
            enddo
   45     continue
c
c  Compute angular factors for this radial orbital
c
          if( lshl.eq.0 )then
c           S-ORBITAL
            do  nr=1,nrmax
              gauss(nr) = gauss(nr)/vnorm(1)
            enddo
            do  nr=1,nrmax
              do  iang=1,nang
                radwf(iang,nr,ioa+1,itypxc) = gauss(nr)
              enddo
            enddo
c
          elseif( lshl.eq.1 )then
c           P-ORBITALS
            do  nr=1,nrmax
              gauss(nr) = gauss(nr)*radmsh(nr,ityp)/vnorm(2)
            enddo
            do  nr=1,nrmax
              iang0 = 0
              do  iang=1,nang
                radwf(iang,nr,ioa+1,itypxc) = angpts(iang0+1)*gauss(nr)
                radwf(iang,nr,ioa+2,itypxc) = angpts(iang0+2)*gauss(nr)
                radwf(iang,nr,ioa+3,itypxc) = angpts(iang0+3)*gauss(nr)
                iang0 = iang0 + 3
              enddo
            enddo
c
          elseif( lshl.eq.2 )then
c           D-ORBITALS
            do  nr=1,nrmax
              gauss(nr) = gauss(nr)*rsq(nr)/vnorm(3)
            enddo
            vn34 = vnorm(3)/vnorm(4)
            vn35 = vnorm(3)/vnorm(5)
            do  nr=1,nrmax
              iang0 = 0
              do  iang=1,nang
                x = angpts(iang0+1)
                y = angpts(iang0+2)
                z = angpts(iang0+3)
                xsq = x*x
                ysq = y*y
                zsq = z*z
                xsqysq = (xsq-ysq)*vn34
                dzsq = (zsq+zsq-xsq-ysq)*vn35
                radwf(iang,nr,ioa+1,itypxc) = x*y*gauss(nr)
                radwf(iang,nr,ioa+2,itypxc) = y*z*gauss(nr)
                radwf(iang,nr,ioa+3,itypxc) = z*x*gauss(nr)
                radwf(iang,nr,ioa+4,itypxc) = xsqysq*gauss(nr)
                radwf(iang,nr,ioa+5,itypxc) = dzsq*gauss(nr)
                iang0 = iang0 + 3
              enddo
            enddo
c
          endif
c
          ioa = ioa + 2*lshl + 1
c
c    Close shell loop:
c
  800   continue
c
c    Close atom loop:
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> YLMREAL
c
c
      subroutine YLMREAL( ylm,lmax,r )
c---------------------------------------------------------------
c Purpose: compute real spherical harmonics for m=0,l=0,1,...lmax
c          m=1,2,...,lmax;m=lmax,l=lmax
c
c Revision history:
c  21Jun01-PAS/2.48: replace STOPs
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c  The real ylm's are defined by:
c      ylm-plus  = ylm, if m=0
c      ylm-minus = 0, if m=0
c      ylm-plus  = sqrt(2.)*real(ylm), if m.ne.0
c      ylm-minus = sqrt(2.)*imag(ylm), if m.ne.0
c
c      the ylm-pluses are returned in the real part of array "ylm"
c      the ylm-minuses are returned in the imaginary part
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DOUBLE COMPLEX  ylm(*),  ylp2m
c
      DIMENSION  r(3)
      DATA  zero,one,two / 0.d0,1.d0,2.d0 /
c
      rt2 = SQRT(two)
      rpsq = r(1)**2 + r(2)**2
      rpar = SQRT(rpsq)
      rmag = SQRT(r(3)**2+rpsq)
      if( rmag.eq.zero ) call STOPXERR( 'ylmrlr=0' )
      costh = r(3)/rmag
      sinth = rpar/rmag
      if( rpar.eq.zero )then
        sinph = zero
        cosph = one
      else
        cosph = r(1)/rpar
        sinph = r(2)/rpar
      endif
c
c      compute  ylm's:
c
      lmaxp1 = lmax + 1
      do 20 mm=1,lmaxp1
        m = mm - 1
        mstore = 1 + (lmax+2)*m - (m*(m+1))/2
        call YMM( ylm(mstore),sinth,cosph,sinph,m )
        if( m.ne.0 ) ylm(mstore) = ylm(mstore)*rt2
        if( m.eq.lmax ) goto 20
        mstore = mstore + 1
        ylm(mstore) = SQRT( DBLE(2*m+3))*costh*ylm(mstore-1)
        if( m.eq.lmax-1 ) goto 20
c generate remaining ylm's by recursion
        mp2 = m + 2
        do 10 l=mp2,lmax
          mstore = mstore + 1
          ylm(mstore) = YLP2M(ylm(mstore-2),ylm(mstore-1),costh,l-2,m)
   10   continue
   20 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> YLP2M
c
c
      FUNCTION YLP2M( ylm,ylp1m,cth,l,m )
c---------------------------------------------------------------
c Revision history:
c  11Mar02-PAS/2.52: last literal reals to d0
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DOUBLE COMPLEX  ylp2m
      DOUBLE COMPLEX  ylp1m,ylm
      DIMENSION  c1(12,12),c2(12,12)
c
      DATA  ((c1(mm,ll),mm=1,12),ll=1,4) /
     $  .19364916731037d+01,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .19720265943665d+01, .20916500663352d+01,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .19843134832984d+01, .20493901531919d+01, .22912878474779d+01,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .19899748742132d+01, .20310096011590d+01, .21712405933672d+01,
     $  .24874685927665d+01,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                /
      DATA  ((c1(mm,ll),mm=1,12),ll=5,8) /
     $  .19930434571836d+01, .20213149892370d+01, .21139418156610d+01,
     $  .23013683530231d+01, .26739483914242d+01,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .19948914348241d+01, .20155644370746d+01, .20816659994661d+01,
     $  .22079402165820d+01, .24308621740220d+01, .28504385627478d+01,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .19960899278339d+01, .20118695404074d+01, .20615528128088d+01,
     $  .21532216876958d+01, .23048861143232d+01, .25570415597838d+01,
     $  .30178043106111d+01,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .19969111950679d+01, .20093531297410d+01, .20481223583578d+01,
     $  .21180441711898d+01, .22291771507062d+01, .24016363469221d+01,
     $  .26791375063213d+01, .31770662567847d+01,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                /
      DATA  ((c1(mm,ll),mm=1,12),ll=9,12) /
     $  .19974984355438d+01, .20075614636426d+01, .20386883037875d+01,
     $  .20939473213563d+01, .21794494717703d+01, .23065125189342d+01,
     $  .24968730444298d+01, .27970572771691d+01, .33291640592397d+01,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .19979328159851d+01, .20062402647739d+01, .20317984959649d+01,
     $  .20766559657295d+01, .21447610589527d+01, .22430448056158d+01,
     $  .23837686425441d+01, .25900450446533d+01, .29109593282157d+01,
     $  .34749100707788d+01,0.d0                ,0.d0                ,
     $  .19982631347136d+01, .20052378963552d+01, .20266087084444d+01,
     $  .20637972912230d+01, .21194781197267d+01, .21981657747106d+01,
     $  .23073955174772d+01, .24602096615832d+01, .26809513236909d+01,
     $  .30210898905832d+01, .36149940274061d+01,0.d0                ,
     $  .19985201625795d+01, .20044593143432d+01, .20225995873897d+01,
     $  .20539595906444d+01, .21004201260420d+01, .21650635094611d+01,
     $  .22528177844479d+01, .23717082451263d+01, .25354627641855d+01,
     $  .27695585470350d+01, .31277162108561d+01, .37500000000000d+01/
      DATA  ((c2(mm,ll),mm=1,12),ll=1,4) /
     $  .57735026918963d+00,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .51639777949432d+00, .44721359549996d+00,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .50709255283711d+00, .47809144373376d+00, .37796447300923d+00,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .50395263067897d+00, .48795003647427d+00, .43643578047198d+00,
     $  .33333333333333d+00,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                /
      DATA  ((c2(mm,ll),mm=1,12),ll=5,8) /
     $  .50251890762960d+00, .49236596391733d+00, .46056618647184d+00,
     $  .40201512610368d+00, .30151134457776d+00,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .50174520600426d+00, .49472744491815d+00, .47304991679126d+00,
     $  .43452409462674d+00, .37397879600338d+00, .27735009811261d+00,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .50128041182760d+00, .49613893835683d+00, .48038446141526d+00,
     $  .45291081365784d+00, .41137667560372d+00, .35082320772281d+00,
     $  .25819888974716d+00,0.d0                ,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .50097943286812d+00, .49705012174771d+00, .48507125007266d+00,
     $  .46442036401282d+00, .43386091563731d+00, .39107694443752d+00,
     $  .33136674783180d+00, .24253562503633d+00,0.d0                ,
     $ 0.d0                ,0.d0                ,0.d0                /
      DATA  ((c2(mm,ll),mm=1,12),ll=9,12) /
     $  .50077339566719d+00, .49767260179344d+00, .48825207923700d+00,
     $  .47213368521878d+00, .44859602103995d+00, .41638277222178d+00,
     $  .37325445134508d+00, .31475579014585d+00, .22941573387056d+00,
     $ 0.d0                ,0.d0                ,0.d0                ,
     $  .50062617432176d+00, .49811675413690d+00, .49051147158797d+00,
     $  .47756693294092d+00, .45883146774112d+00, .43355498476206d+00,
     $  .40050093945741d+00, .35751859933741d+00, .30037570459305d+00,
     $  .21821789023599d+00,0.d0                ,0.d0                ,
     $  .50051733071262d+00, .49844478627923d+00, .49217479094801d+00,
     $  .48154341234308d+00, .46625240412016d+00, .44582257006028d+00,
     $  .41950379837732d+00, .38609367125267d+00, .34352936171490d+00,
     $  .28777723153448d+00, .20851441405707d+00,0.d0                ,
     $  .50043459373698d+00, .49869394639790d+00, .49343516379517d+00,
     $  .48454371185235d+00, .47181425969567d+00, .45492474294011d+00,
     $  .43338907110877d+00, .40646942234853d+00, .37300192329612d+00,
     $  .33100637062042d+00, .27662562992325d+00, .20000000000000d+00/
c
c >>>> EXECUTABLE CODE:
c
      ylp2m = c1(m+1,l+1) * ( cth*ylp1m - ylm*c2(m+1,l+1) )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> YMM
c
c
      subroutine YMM( y,sth,cph,sph,m )
c---------------------------------------------------------------
c Revision history:
c  11Mar02-PAS/2.52: last literal reals to d0
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c  calculates y-sub-m,m spherical harmonic
c     sth=sin(theta)
c     cph=cos(phi)
c     sph=sin(phi)
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( half = 0.5d0 )
c
      DOUBLE COMPLEX    y
c
      DIMENSION  ynorm(12)
      DATA  ynorm /
     $   .28209479177388d+00,
     $   .69098829894267d+00,
     $   .15450968080928d+01,
     $   .33377905890623d+01,
     $   .70805230791198d+01,
     $   .14852230510108d+02,
     $   .30917383269124d+02,
     $   .64005064137030d+02,
     $   .13194982000571d+03,
     $   .27113110604413d+03,
     $   .55565341895088d+03,
     $   .11362831437960d+04/
c
c >>>> EXECUTABLE CODE:
c
      y = ynorm(m+1)
      if( m.ne.0 ) y = y*( -half*DCMPLX(cph,sph)*sth )**m
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> YRECUR
c
c
      subroutine YRECUR( clp1m,clm,l,m )
c---------------------------------------------------------------
c Revision history:
c  10Dec98-PAS/2.29: promote source to explicit double precision
c---------------------------------------------------------------
c
c      produces coefficients for ylp2m=clp1m*ylp1m+clm*ylm
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      clp1m = SQRT( DBLE((2*l+5)*(2*l+3))/ DBLE((l+2)**2-m**2))
      clm = clp1m* SQRT( DBLE((l+1)**2-m**2)/ DBLE((2*l+1)*(2*l+3)))
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROYDATA
c
c
c---------------------------------------------------------------
c Purpose: mini-module to manage storage and retrieval of
c          history data for broyden blend
c
c Written: Peter A. Schultz, 26-January-2007, for 2.60
c
c Revision history:
c  29Dec19-PAS/2.68a: blsav() array declarations in passthrough routines
c---------------------------------------------------------------
c
      subroutine BROYINIT( incorebr, iters,ithist,nhist,
     $ nvecbr,membroy )
c---------------------------------------------------------------
c Purpose: simple initialization of broyden data storage: do we
c          store on disk or in memory, and basic startup.
c
c Written: Peter A. Schultz, 26-January-2007, for 2.60
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION (a-h, o-z)
c
c Module data for file part of broyden data storage:
      PARAMETER  ( maxfl_broy=20 )
      COMMON /BROYFSTUFF/ nfl_broy,nit_file,ifl_broy,it_file,
     $                    ibrfls(maxfl_broy)
c      maxfl_broy = max num of files available for broyden data storage
c      nfl_broy   = number of files which are used to keep broyden data
c      nit_file   = number of iterations (entries) of data on each file
c      ifl_broy   = index (not file unit) of current file in sequence of files
c      it_broy    = local (to file) index of current data entry in current file
c      ibrfls()   = list of file units on which broyden data is stored
c
c Module data for memory part of broyden data storage:
      COMMON /BROYMSTUFF/ i0bl0, ibl0, i0bl2, ibl2, nbl2, itertotl
c      ibl0     = index to track save of vin/dv "broyfl0" data
c      ibl2     = index of first entry of u/dft data in memory
c      nbl2     = number of entries (iterations) of u/dft data in memory
c      itertotl = total (not truncated) index (iteration) of current entry
c
c Input:
c   incorebr < 0 - compel on-disk broyden, else attempt in-core
c   nvecbr  = length of r8 vector on local processor
c   nhist   = length of history (iterations) to be stored
c   membroy = length of storage space available for in-core histories
c
c >>>> EXECCUTABLE CODE:
c
      call FLGETIWR( IWR )
c Default to a disk-based (nfl_broy>0, i0bl0<0) scheme:
      nfl_broy = 1
      i0bl0 = -1
c
      if( incorebr .lt. 1 )then
c       We restrict to a file-based scheme
        if( IWR .ge. 0 ) write(IWR,*) 'EBROYDDJ: on-disk history'
        RETURN
      endif
c
c Determine if we have room to store full broyden history in memory:
      nbr0mem = nvecbr*2
      nbr2mem = nvecbr*2*nhist
      nbrmem = nbr0mem + nbr2mem
c
      if( nbrmem .le. membroy )then
c       We have enough free memory, use in-core broyden history
        nfl_broy = -1
c
c       Set up some defaults:
        i0bl0 = 0
        i0bl2 = i0bl0 + 2
        nbl2 = i0bl2 + 2*nhist
        itertotl = 0
c
c       Reset iters if have in-core history, and restart first iter
c       (i.e., history is empty!)
        if( ithist .eq. 0 )then
          iters = 0
          if( IWR .ge. 0 ) write(IWR,*) 'EBROYDDJ: in-core history'
        endif
      else
c       We keep broyden history on disk
c
        nfl_broy = 1
        i0bl0 = -1
        if( ithist .eq. 0 )then
          if( IWR .ge. 0 ) write(IWR,*) 'EBROYDDJ: on-disk history'
        endif
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY0OPEN
c
c
      subroutine BROY0OPEN( ibrfl0, broyfl )
c---------------------------------------------------------------
c Purpose: open storage location of vin/dv broyden data
c Written: Peter A. Schultz, 26-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION (a-h, o-z)
c
c Module data for file part of broyden data storage:
      PARAMETER  ( maxfl_broy=20 )
      COMMON /BROYFSTUFF/ nfl_broy,nit_file,ifl_broy,it_file,
     $                    ibrfls(maxfl_broy)
c Input: file name
      CHARACTER  broyfl*80
c
c >>>> EXECCUTABLE CODE:
c
      if( nfl_broy .gt. 0 )then
c       Open disk file
        call FLOPENB( ibrfl0, broyfl )
      else
c       Set file unit to -1 to signal no file
        ibrfl0 = -1
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY0CLOSE
c
c
      entry BROY0CLOSE( ibrfl0 )
c---------------------------------------------------------------
c Purpose: close file for v/dv storage
c Written: Peter A. Schultz, 30-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      if( ibrfl0 .gt. 0 )then
c       Close disk file
        call FLCLOSE( ibrfl0 )
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY0RWND
c
c
      subroutine BROY0RWND( ibrfl0 )
c---------------------------------------------------------------
c Purpose: set storage of vin/dv broyden data to beginning
c Written: Peter A. Schultz, 26-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION (a-h, o-z)
c
c Module data for file part of broyden data storage:
      PARAMETER  ( maxfl_broy=20 )
      COMMON /BROYFSTUFF/ nfl_broy,nit_file,ifl_broy,it_file,
     $                    ibrfls(maxfl_broy)
c
c Module data for memory part of broyden data storage:
      COMMON /BROYMSTUFF/ i0bl0, ibl0, i0bl2, ibl2, nbl2, itertotl
c
      DIMENSION  veclocl(*), wbroy(*)
c
c >>>> EXECCUTABLE CODE:
c
      if( ibrfl0 .ge. 0 )then
c       Rewind the disk ...
        REWIND( unit=ibrfl0 )
      else
c       Reset memory pointer to first entry - v()
        ibl0 = 1
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY0PUT
c
c
      entry BROY0PUT( ibrfl0, nveclocl, veclocl, wbroy )
c---------------------------------------------------------------
c Purpose: save v/dv to disk/memory
c Written: Peter A. Schultz, 30-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      if( ibrfl0 .gt. 0 )then
c       Write to disk ...
        call WRITBIG( ibrfl0, nveclocl, veclocl )
      else
c       Save to memory ...
        ibl = i0bl0 + ibl0
        call STASHVEC( ibl, nveclocl, veclocl, wbroy )
        ibl0 = ibl0 + 1
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY0GET
c
c
      entry BROY0GET( ibrfl0, nveclocl, veclocl, wbroy )
c---------------------------------------------------------------
c Purpose: retrieve v/dv from disk/memory
c Written: Peter A. Schultz, 30-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      if( ibrfl0 .gt. 0 )then
c       Read from disk ...
        call READBIG( ibrfl0, nveclocl, veclocl )
      else
c       Retrieve from  memory ...
        ibl = i0bl0 + ibl0
        call RETRVVEC( ibl, nveclocl, veclocl, wbroy )
        ibl0 = ibl0 + 1
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> STASHVEC
c
c
      subroutine STASHVEC( ibl, nveclocl, veclocl, wbroy )
c---------------------------------------------------------------
c Purpose: save data to memory, retrieve data from memory
c Written: Peter A. Schultz, 30-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  veclocl(*), wbroy(*)
c
c >>>> EXECUTABLE CODE:
c
      ipvec = 1 + nveclocl*(ibl-1)
      call DCOPY( nveclocl, veclocl,1, wbroy(ipvec),1 )
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RETRVVEC
c
c
      entry      RETRVVEC( ibl, nveclocl, veclocl, wbroy )
c
      ipvec = 1 + nveclocl*(ibl-1)
      call DCOPY( nveclocl, wbroy(ipvec),1, veclocl,1 )
c
      RETURN
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C Routines that handle the broyden history data
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
c
c       
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY2OPEN
c       
c     
      subroutine BROY2OPEN( itersm1,iterb,itmaxbr, sufx,
     $ ibroyfl, nveclocl )
c---------------------------------------------------------------
c Purpose: set up storage of broyden history: u() and dft()
c Written: Peter A. Schultz, 30-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION (a-h, o-z)
c
c Module data for file part of broyden data storage:
      PARAMETER  ( maxfl_broy=20 )
      COMMON /BROYFSTUFF/ nfl_broy,nit_file,ifl_broy,it_file,
     $                    ibrfls(maxfl_broy)
c 
c Module data for memory part of broyden data storage:
      COMMON /BROYMSTUFF/ i0bl0, ibl0, i0bl2, ibl2, nbl2, itertotl
c
      CHARACTER  sufx*(*)
c
c >>>> EXECCUTABLE CODE:
c     
      if( nfl_broy .gt. 0 )then
c       Set up disk file storage:
c
c       Compute nfl_broy=number of files necessary to hold broyden data:
c       msize_it = how big array needed to save per iteration
c       itersav=itersm1 - saves *all* past iters in more and more files
c       itersav=iterb   - uses (and reuses) minimum possible files
c
        msize_it = 2*nveclocl
        itertot = itersm1
        itersav = iterb
c
        call FLGETIWR( IWR )
        call BROYF( IWR, itertot,itersav, itmaxbr, msize_it,
     $   nit_file,maxfl_broy, nfl_broy )
        call BROYFOPEN( sufx, nfl_broy, ibrfls )
        ibroyfl = ibrfls(1)
c
      else
c       Set number of files to zero
        nfl_broy = 0
        ibrfls(1) = -1
        ibroyfl = -1
c       Memory-based storage, starts in third entry, nbl2= history length
        ibl2 = 1
c
      endif
c
      RETURN
c
c       
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY2CLOSE
c       
c     
      entry BROY2CLOSE( ibroyfl )
c---------------------------------------------------------------
c Purpose: close storage of broyden history: u() and dft()
c Written: Peter A. Schultz,  9-February-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      if( ibroyfl .gt. 0 )then
c       Close the disk files:
        call BROYFCLOSE( nfl_broy,ibrfls )
      else
c       Nothing to do for in-core Broyden, just "rewind"
        ibl2 = 1
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY2RWND
c
c
      subroutine BROY2RWND( ibroyfl )
c---------------------------------------------------------------
c Purpose: set storage of vin/dv broyden data to beginning
c Written: Peter A. Schultz, 26-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION (a-h, o-z)
c
c Module data for file part of broyden data storage:
      PARAMETER  ( maxfl_broy=20 )
      COMMON /BROYFSTUFF/ nfl_broy,nit_file,ifl_broy,it_file,
     $                    ibrfls(maxfl_broy)
c
c Module data for memory part of broyden data storage:
      COMMON /BROYMSTUFF/ i0bl0, ibl0, i0bl2, ibl2, nbl2, itertotl
c
      DIMENSION  ulocl(*), dlocl(*), blsav(*)
c
c >>>> EXECCUTABLE CODE:
c
      if( ibroyfl .gt. 0 )then
c       Rewind the disks ...
        call BROYF0( ibroyfl, ifl_broy,it_file, ibrfls )
        REWIND( unit=ibroyfl )
      else
c       Reset memory pointer to first entry - u[it=1]
        ibl2 = 1
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY2SKIP
c
c
      entry BROY2SKIP( itprune, ibroyfl, nveclocl )
c---------------------------------------------------------------
c Purpose: save u[it] and dft[it] to disk/memory
c Written: Peter A. Schultz, 30-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      if( ibroyfl .gt. 0 )then
c       Skip through files ...
        if( itprune .gt. 0 )then
c         Skip to beginning of active Broyden history:
          it_skip = itprune
          call BROYFSKIP( itprune,it_skip, ibroyfl,
     $     ifl_broy,it_file, nit_file,nfl_broy,ibrfls )
c 
          REWIND( ibroyfl )
          do  it=1,it_skip
            call READSKP( ibroyfl, nveclocl )
            call READSKP( ibroyfl, nveclocl )
          enddo
        endif
c
      else
c       Skip through memory entries ...
        do  it=1,itprune
          ibl = i0bl2 + ibl2
          if( ibl .gt. nbl2 )then
            ibl2 = 1
            ibl = i0bl2 + ibl2
          endif
          ibl2 = ibl2 + 2
        enddo
c 
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY2PUT
c
c
      entry BROY2PUT( ibroyfl, nveclocl, ulocl,dlocl, blsav )
c---------------------------------------------------------------
c Purpose: save u[it] and dft[it] to disk/memory
c Written: Peter A. Schultz, 30-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      if( ibroyfl .gt. 0 )then
c       write to disk ...
        call BROYFIT( ibroyfl,
     $   ifl_broy,it_file, nit_file,nfl_broy,ibrfls )
        call WRITBIG( ibroyfl, nveclocl, ulocl )
        call WRITBIG( ibroyfl, nveclocl, dlocl )
      else
c       save to memory ...
        ibl = i0bl2 + ibl2
        if( ibl .gt. nbl2 )then
c         Off end of storage, reset index
          ibl2 = 1
          ibl = i0bl2 + ibl2
        endif
        iblu = ibl
        ibld = ibl + 1
        call STASHVEC( iblu, nveclocl, ulocl, blsav )
        call STASHVEC( ibld, nveclocl, dlocl, blsav )
        ibl2 = ibl2 + 2
       endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY2GETU
c
c
      entry BROY2GETU( ibroyfl, nveclocl, ulocl, blsav )
c---------------------------------------------------------------
c Purpose: retrieve u[it] from disk/memory
c Written: Peter A. Schultz, 30-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      if( ibroyfl .gt. 0 )then
c       Get u[it] from disk, and skip dft[it] ...
        call BROYFIT( ibroyfl,
     $   ifl_broy,it_file, nit_file,nfl_broy,ibrfls )
c     
        call READBIG( ibroyfl, nveclocl, ulocl )
        call READSKP( ibroyfl, nveclocl )
      else
c       retrieve from  memory ...
        ibl = i0bl2 + ibl2
        if( ibl .gt. nbl2 )then
c         Off end of storage, reset index
          ibl2 = 1
          ibl = i0bl2 + ibl2
        endif
        iblu = ibl
        call RETRVVEC( iblu, nveclocl, ulocl, blsav )
        ibl2 = ibl2 + 2
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROY2GETD
c
c
      entry BROY2GETD( ibroyfl, nveclocl, dlocl, blsav )
c---------------------------------------------------------------
c Purpose: retrieve dft[it] from disk/memory
c Written: Peter A. Schultz, 30-January-2007
c Revision history:
c  none
c---------------------------------------------------------------
c
      if( ibroyfl .gt. 0 )then
c       Get dft[it] from disk, skipping u[it]
        call BROYFIT( ibroyfl,
     $   ifl_broy,it_file, nit_file,nfl_broy,ibrfls )
c
        call READSKP( ibroyfl, nveclocl )
        call READBIG( ibroyfl, nveclocl, dlocl )
      else
c       retrieve from  memory ...
        ibl = i0bl2 + ibl2
        if( ibl .gt. nbl2 )then
          ibl2 = 1
          ibl = i0bl2 + ibl2
        endif
        ibld = ibl + 1
        call RETRVVEC( ibld, nveclocl, dlocl, blsav )
        ibl2 = ibl2 + 2
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROYF
c
c
c---------------------------------------------------------------
c Purpose: routines to handle the split-file Broyden file stuff
c          to enable truncating histories and 2GB file limits
c Written: Peter A. Schultz, 10-January-2003
c Revision history:
c  none
c---------------------------------------------------------------
c
      subroutine BROYF( IWR, itertot,itersav, itmaxbr, msize_it,
     $ nit_file,maxfl_broy, nfl_broy )
c---------------------------------------------------------------
c Purpose: determine number of files to divide Broyden into,
c          based on length of retained history, and 2GB limits
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c    2GB file limit = 2**31 = 2 147 483 648 bytes
c                   = 2**23 =   268 435 456 r*8 array spaces
      PARAMETER  ( maxflsiz =   268 435 456 )
c
      DIMENSION  ibrfls(*)
      CHARACTER  broyfl*80, broynum*3
      CHARACTER  sufx*(*)
c
c >>>> EXECUTABLE CODE:
c
c Determine limit on number of iterations per Broyden history file ...
c  ... number of iterations that fit into size limit of file
      nit_file = maxflsiz / msize_it
c  ... limit single file length to length of single complete history:
      if( nit_file.gt.itmaxbr ) nit_file = itmaxbr
c
c Determine number of files needed for broyden:
c  nfl_tot = number of files for all iterations:
      nfl_tot = (itertot - 1) / nit_file + 1
c  nfl_sav = # of files needed for select reduced number of iters:
      nfl_sav = (itersav - 2) / nit_file + 2
c  nfl_broy = # of files required
      nfl_broy = MIN( nfl_tot, nfl_sav )
      if( nfl_broy .ne. 1 ) write(IWR,*) ' BROY: nfiles=',nfl_broy
      if( nfl_broy.lt.1 .or. nfl_broy.gt.maxfl_broy )
     $ call STOPXERR( 'nfl_broy' )
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROYF0
c
c
      entry BROYF0( ibroyfl,
     $ ifl_broy,it_file,                   ibrfls )
c---------------------------------------------------------------
c Purpose: set broyden file pointer to very beginning
c---------------------------------------------------------------
c
      ifl_broy = 1
      ibroyfl = ibrfls(ifl_broy)
      it_file = 0
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROYFSKIP
c
c
      entry BROYFSKIP( itprune,it_skip, ibroyfl,
     $ ifl_broy,it_file, nit_file,nfl_broy,ibrfls )
c---------------------------------------------------------------
c Purpose: locate and set files to initial step in active blend
c          Skip through "itprune" steps to get to first active iter
c---------------------------------------------------------------
c
c Number of total files to skip through:
      nfl_skip = itprune / nit_file
c Number of file sets that are repeated
      nh_skip = nfl_skip / nfl_broy
c The file number in the current set of files:
      ifl_broy = nfl_skip - nh_skip*nfl_broy + 1
c Identify file unit number, and index in file of last skipped iter
      ibroyfl = ibrfls(ifl_broy)
      it_file = itprune - nfl_skip*nit_file
c
      it_skip = it_file
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROYFIT
c
c
      entry BROYFIT( ibroyfl,
     $ ifl_broy,it_file, nit_file,nfl_broy,ibrfls )
c---------------------------------------------------------------
c Purpose: step to next iteration in broyden history 
c---------------------------------------------------------------
c
      it_file = it_file + 1
      if( it_file.gt.nit_file )then
c       This file done, go to next file in sequence:
        ifl_broy = ifl_broy + 1
        if( ifl_broy.gt.nfl_broy ) ifl_broy = 1
        ibroyfl = ibrfls(ifl_broy)
        REWIND( ibroyfl )
        it_file = 1
      endif
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROYFOPEN
c
c
      entry BROYFOPEN( sufx, nfl_broy, ibrfls )
c---------------------------------------------------------------
c Purpose: open files used to store Broyden history
c---------------------------------------------------------------
c
      do  ifl_br=1,nfl_broy
        call STRNUM( nstr, broynum, ifl_br, nfl_broy )
        broyfl  = 'broy' // broynum(1:nstr) // '_' // sufx
c
        call FLOPENB( ibrfl , broyfl  )
c
        ibrfls(ifl_br) = ibrfl
      enddo
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BROYFCLOSE
c
c
      entry BROYFCLOSE( nfl_broy, ibrfls )
c---------------------------------------------------------------
c Purpose: close all files used to store Broyden history
c---------------------------------------------------------------
c
      do  ifl_br=1,nfl_broy
        ibrfl = ibrfls(ifl_br)
        call FLCLOSE( ibrfl )
      enddo
c
      RETURN
c
c    That's all Folks!
c
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> EBROYDDJ
c
c
      subroutine EBROYDDJ( IWR, sufx, iter,ithist, nhist, blendfac,
     $ chg, nvec, nvecloc, membroy,
     $ vv1,vv2,vv3,vv4, wbroy )
c---------------------------------------------------------------
c Purpose: blend guess vectors using Johnson modified Broyden
c          [D.D. Johnson, PRB 38,12807 (1988)]
c
c Written: Peter A. Schultz
c          Based on original code by D.D. Johnson
c          Via code modified by P.J. Feibelman
c
c Revision history:
c  26Apr12-ACP&PAS/2.63: for kparallel, lift distribution out of here
c  20Jun07-PAS/2.60: merge serial and tp
c  13Feb07-PAS/2.60: make tp/serial more consistent;
c                    extract file-handling to separate file;
c                    in-core broyden history; purge Bcast ges
c   6Jul06-APT/    : merged task parallel and image parallel
c   3Nov04-PAS/2.59-tp: parallelized (split form)
c   5Feb03-PAS/2.57a: fix bug in diagnostic output (prune),
c     and fix bug that sets number of Broyden files.
c  11Sep03-PAS/2.57: push itmaxd into broyden
c   8Jan03-PAS/2.55: file size limits, limited history added
c   8Mar02-PAS/2.52: literal constants to d0
c   6Dec01-PAS/2.51: file mgmt
c  11Oct01-PAS/2.50: purge 'inquire' usage
c  21Dec99-PAS/2.42: cosmetic clean-up
c  15Feb99-PAS/2.31: routine to intercept perhaps too-big i/o
c  10Dec98-PAS/2.29: promote source to explicit double precision
c  22Sep97-PAS/2.21: pass dv in vv1, take out convrg tests,
c                    use for geo opt, and rename.
c   9May95-PAS/2.12: shrink memory usage 2X
c---------------------------------------------------------------
c
c Notes:
c  This routine protects itself like a module.
c  It is initialized with input of iter.le.1, but afterwards
c  maintains its state internally.  It should be able to
c  protect itself from all eventualities short of malicious
c  tampering with its files.
c
c Variables:
c  sufx  = character string/tag identifying optimized quantity
c  iter  = .le.1 - restart broyden; else - *ignored*
c          (broyden step numbers are maintained internally)
c  ithist = number of iterations in current history
c  nhist = if>0, max number of steps used in Broyden history
c  blendfac = mixing parameter for first step
c          (recommend: electronic: ~.1->.3; geometric: ~0.5->6.0)
c  chg   = for weighting set, measure of goodnees of this set
c          (e.g. max force/change, or rms, etc)
c
c  nvec  = length of total vector to be optimized
c  nvecloc  = length of vector on local process
c  vv2() = v(in) [input] -> new guess v() [output]
c  vv1() = dv()  [input]
c  vv3,vv4 = scratch space of dimensioned length
c  wbroy() = in-core saved broyden history
c  membroy = amount of space available for in-core
c  
c
c  itmaxd = maximum number of active Broyden steps
c
c Notes:
c  u() and dft() = johnson's u() and df(transpose)
c    These are continually updated and all iterations stored on
c    unit ibroyfl to avoid memory cost of holding entire jacobian
c  dv()  = v(out) - v(in) OR d(F)/d(v())
c  ddv() = dv(m+1) - dv(m)
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.0d0, one=1.0d0 )
c
c Input/Output:
      CHARACTER  sufx*(*)
      DIMENSION  vv1(*),vv2(*)
      DIMENSION  wbroy(*)
c Scratch:
      DIMENSION  vv3(*),vv4(*)
c
c Local declarations:
c    itmaxd = max steps in history for blend (30 is likely overkill)
      PARAMETER  ( itmaxd = 30 )
      DIMENSION  a(itmaxd,itmaxd),b(itmaxd,itmaxd),cm(itmaxd)
      DIMENSION  d(itmaxd,itmaxd),w(itmaxd)
      DIMENSION  td(itmaxd),ad(itmaxd),bd(itmaxd)
c    maxfl_broy = maximum files to divide Broyden data into
      PARAMETER  ( maxfl_broy = 20 )
      DIMENSION  ibrfls(maxfl_broy)
      CHARACTER  broyfl*80
c
      DATA  lstout / 0 /
c
c >>>> EXECUTABLE CODE:
c
c Routine now uses input size for distribution
      nveclocl = nvecloc
c
c Obtain parallel environment:
      call MPNODES( nprocl )
      call MPNODE0( masterl )
      call MPNODE( iprocl )
      call MPCOMM( icomml )
c
c Open binary file for broyden:
      broyfl = 'broy0_' // sufx
      call FLOPENB( ibrfl0, broyfl )
c
      iterb = iter
c     Decide on storage (disk=0, or in-core>0) of broyden history.
      incorebr = 1
      call BROYINIT( incorebr, iterb,ithist,nhist,nveclocl,membroy )
      broyfl = 'broy0v_' // sufx
C      call FLOPENB( ibrfl0v, broyfl )
      call BROY0OPEN( ibrfl0v, broyfl )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c        Broyden blend: first iteration is simple blend
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      if( iter .le. 1 .or. iterb .eq. 0 )then
c       If either signaled to (iter.le.1), or lacking history (iterb=0),
c       then restart blend
c
        blendbr = blendfac
        write(IWR,'(a,a,a,f9.6)') '>>>>> Broyden: first step (', sufx,
     $      ') simple blend ratio=', blendbr
        iters = 1
        iterbm1 = 0
        REWIND( unit=ibrfl0 )
        write(ibrfl0)  blendbr, iters,iterbm1, nprocl
c
c       Store first vin/vv2 and dv/vv1:
        call BROY0RWND( ibrfl0v )
        ithist = 1
        call BROY0PUT( ibrfl0v, nveclocl, vv2, wbroy )
        call BROY0PUT( ibrfl0v, nveclocl, vv1, wbroy )
c
c       On first iteration, simple blend to get new vector.
        do  n=1,nveclocl
          vv2(n) = vv2(n) + blendbr*vv1(n)
        enddo
c
        goto 900
c
      endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c        Broyden blending method for later iterations
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
      write(IWR,'(a,a)') '>>>>> Broyden blend to get next step - ',sufx
c
c  w0 = weighting factor for the zeroth iteration
      w0 = 0.01d0
      REWIND( unit=ibrfl0 )
      read(ibrfl0,end=1301,err=1301)  blendbr, itersm1,iterbm2, nprocbr
      if( nprocbr .ne. nprocl ) call STOPXERR( 'BROY = #procs changed' )
c
c  Retrieve vv3<=previous vin ; vv4<=previous dv
      call BROY0RWND( ibrfl0v )
      call BROY0GET( ibrfl0v, nveclocl, vv3    , wbroy )
      call BROY0GET( ibrfl0v, nveclocl, vv4    , wbroy )
c
      if( iterbm2.gt.0 .and. iterbm2.lt.itmaxd )then
        read(ibrfl0)  ( ( a(jt,it),jt=1,iterbm2 ), it=1,iterbm2 )
        read(ibrfl0)  ( w(it), it=1,iterbm2 )
      endif
c
c Check limits on blend counts:
      itmaxbr = itmaxd
      if( nhist.gt.0 .and. nhist.lt.itmaxd ) itmaxbr = nhist
      if( iterbm2.eq.itmaxbr )then
c       Drop old iterations in limited-history blend
        write(IWR,'(a)') ' Broyden: limit-history, dropping oldest'
        do  jt=2,iterbm2
          w(jt-1) = w(jt)
          do it=2,iterbm2
            a(it-1,jt-1) = a(it,jt)
          enddo
        enddo
        iterbm2 = iterbm2 - 1
      elseif( iterbm2.gt.itmaxbr )then
        write(IWR,*) 'BROYDEN: more iterations than dimensioned for'
        write(IWR,*) 'This event indicates a coding error, sys failure'
        call STOPXERR( 'BROY dimensions' )
      endif
c Set up blend counts:
c  iter (as input) = total number of steps in overall scf attempt
c  iters = total number of steps in this broyden scf
c  iterb = number of steps in active broyden history
      iters   = itersm1 + 1
      iterbm1 = iterbm2 + 1
      iterb   = iterbm1 + 1
      itprune = iters - iterb
c
c Have vin and dv of current iteration, write to ibrfl0 for use later
      REWIND( unit=ibrfl0 )
      write(ibrfl0)  blendbr, iters,iterbm1, nprocl
c
c  Store current vv2=vin ; vv1=dv
      call BROY0RWND( ibrfl0v )
      call BROY0PUT( ibrfl0v, nveclocl, vv2    , wbroy )
      call BROY0PUT( ibrfl0v, nveclocl, vv1    , wbroy )
c
c  vv1=current dv ; vv2=current vin ; vv3=previous vin ; vv4=previous dv
c  vv3=>delta-vin ; vv4=>ddv
      do  n=1,nveclocl
        vv3(n) = vv2(n) - vv3(n)
        vv4(n) = vv1(n) - vv4(n)
      enddo
c
c For i-th iter, dfnorm = | dv[i] - dv[i-1] |, for normalization
      dfnorm = zero
      do  n=1,nveclocl
        dfnorm = dfnorm + vv4(n)*vv4(n)
      enddo
c
      if( nprocl .gt. 1 )then
c       Reduce and brodcast dfnorm
        lenred = 1
        call MPREDUC8( masterl, lenred, dfnorm,dfnormtp, icomml )
C        call MPI_Reduce( dfnorm,dfnormtp,1,MPI_DOUBLE_PRECISION,
C     $   MPI_SUM, masterl, icomml, ierr )
        dfnorm = dfnormtp
        call MPBCAST8( masterl, lenred, dfnorm, icomml )
C        call MPI_Bcast ( dfnorm, 1, MPI_DOUBLE_PRECISION,
C     $   masterl, icomml, ierr )
      endif
      dfnorm = SQRT( dfnorm )
      if( lstout.gt.0 ) write(IWR,'(a,f16.8)')  ' dfnorm=',dfnorm
c
      fac2 = one / dfnorm
      fac1 = blendbr*fac2
c  vv3=>u ; vv4=>dft
      do  n=1,nveclocl
        vv3(n) = fac1*vv4(n) + fac2*vv3(n)
        vv4(n) = fac2*vv4(n)
      enddo
c
c*********** calculation of coefficient matrices *************
c***********    and the sum for corrections      *************
c
c recall: a(i,j) is a symmetric matrix
c       : b(i,j) is the inverse of [ w0**2 I + a ]
c
c Initialize history storage:
      call BROY2OPEN( itersm1,iterb,itmaxbr, sufx,
     $ ibroyfl, nveclocl )
c
c Rewind history storage:
      call BROY2RWND( ibroyfl )
c
      if( iterb .gt. 2 )then
c
        if( itprune .gt. 0 )then
c         Skip itprune steps, to begin of active Broyden history:
          call BROY2SKIP( itprune, ibroyfl, nveclocl )
        endif
c
        do  it=1,iterbm2
c         Get dft[it] in vv2(), skipping u[it]
          call BROY2GETD( ibroyfl, nveclocl, vv2, wbroy )
c
          aij = zero
          cmj = zero
          do  n=1,nveclocl
            aij = aij + vv2(n)*vv4(n)
            cmj = cmj + vv2(n)*vv1(n)
          enddo
          a(iterbm1,it) = aij
          a(it,iterbm1) = aij
          cm(it)       = cmj
        enddo
      endif
c
      cmj = zero
      aij = zero
      do  n=1,nveclocl
        cmj = cmj + vv4(n)*vv1(n)
        aij = aij + vv4(n)*vv4(n)
      enddo
      cm(iterbm1)        = cmj
      a(iterbm1,iterbm1) = aij
c
      if( nprocl .gt. 1 )then
c       Reduce/broadcast a/cm matrices (bd() is free for scratch)
        call MPREDUC8( masterl, iterbm1, a(1,iterbm1),bd, icomml )
C        call MPI_Reduce( a(1,iterbm1),bd, iterbm1, MPI_DOUBLE_PRECISION,
C     $   MPI_SUM, masterl, icomml, ierr )
        call DCOPY( iterbm1, bd,1, a(1,iterbm1),1 )
        call MPBCAST8( masterl, iterbm1, a(1,iterbm1), icomml )
C        call MPI_Bcast ( a(1,iterbm1), iterbm1, MPI_DOUBLE_PRECISION,
C     $   masterl, icomml, ierr )
        do  it=1,iterbm1
          a(iterbm1,it) = a(it,iterbm1)
        enddo
c
        call MPREDUC8( masterl, iterbm1, cm,bd, icomml )
C        call MPI_Reduce( cm,bd, iterbm1, MPI_DOUBLE_PRECISION,
C     $   MPI_SUM, masterl, icomml, ierr)
        call DCOPY( iterbm1, bd,1, cm,1 )
        call MPBCAST8( masterl, iterbm1, cm, icomml )
C        call MPI_Bcast ( cm, iterbm1, MPI_DOUBLE_PRECISION,
C     $   masterl, icomml, ierr)
      endif
c
c  Store latest vv3=u ; vv4=dft
      call BROY2PUT( ibroyfl, nveclocl, vv3  ,vv4  , wbroy )
c
c Weighting factors for each iteration set to one over sqrt of max error
c This need not be the case, e.g., could be one over rms instead.
      wtmp = zero
      if( chg.gt. 1.0d-09 ) wtmp = 2.0d0*SQRT( 0.010d0/chg )
      if( wtmp.lt.one ) wtmp = one
      w(iterbm1) = wtmp
      if( lstout.gt.0 ) write(IWR,'(a,f20.6)') 'weighting set=',wtmp
c
      write(ibrfl0)  ( ( a(jt,it), jt=1,iterbm1 ), it=1,iterbm1 )
      write(ibrfl0)  ( w(it), it=1,iterbm1 )
c
c Set up and calculate beta matrix
      do  it=1,iterbm1
        do  jt=1,iterbm1
          d(jt,it) = a(jt,it)*w(jt)*w(it)
          b(jt,it) = zero
        enddo
        b(it,it) = one
        d(it,it) = w0**2 + d(it,it)
      enddo
c
      call INVERT( d,b,iterbm1, td,ad,bd, itmaxd )
c
c Compute input vector for new iteration
c
      REWIND( unit=ibrfl0 )
      read(ibrfl0)  blendbr, itm1_t,itm2_t, nprocbr
      if( nprocbr .ne. nprocl ) call STOPXERR( 'BROY - #procs changed' )
c
      call BROY0RWND( ibrfl0v )
      call BROY0GET( ibrfl0v, nveclocl, vv2    , wbroy )
      do  n=1,nveclocl
        vv2(n) = vv2(n) + blendbr*vv1(n)
      enddo
c
      call BROY2RWND( ibroyfl )
c
      if( itprune .gt. 0 )then
c       Skip itprune steps, to beginning of active Broyden history:
        call BROY2SKIP( itprune, ibroyfl, nveclocl )
      endif
c
      do  it=1,iterbm1
c       Get u[it] in vv3(), skipping dft[it]
        call BROY2GETU( ibroyfl, nveclocl, vv3, wbroy )
c
        gmi = zero
        do  jt=1,iterbm1
          gmi = gmi + cm(jt)*b(jt,it)*w(jt)
        enddo
        do  n=1,nveclocl
          vv2(n) = vv2(n) - gmi*vv3(n)*w(it)
        enddo
      enddo
c
c Close the Broyden history file(s):
C      call FLCLOSE( ibroyfl )
      call BROY2CLOSE( ibroyfl )
c
      goto 900
c
 1301 continue
      call STOPXERR( 'BROYDDJ - broyden files missing/mangled' )
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c        Clean up and get out:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
  900 continue
c
      call FLCLOSE( ibrfl0 )
      call BROY0CLOSE( ibrfl0v )
c
      write(IWR,'(a,i6)') '<<<<< Broyden step complete, scf step=',iter
      if( iter.ne.iters )then
        write(IWR,'(a,i6)') '<<<<< Broyden blend step=',iters
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
      subroutine RSCHROED(idosolv,scut,ispin,nspin,
     $     idhamfl,iham0fl,iovlpfl,ivecfl,
     $     norb,nstate,eigval,sefp,iwork,
     $     ifail,lwork4,vmat)

c Purpose: solve Schroedinger equation given input ham and ovlp
c
c Written: Rick Muller,  June 4, 2007

      implicit NONE
      integer info,i,j,neff,nstout
      integer idosolv,idhamfl,iham0fl,iovlpfl,ivecfl
      integer ispin,nspin
      integer lwork4,lwork
      integer norb,nstate,mat
      double precision eigval(nstate),scut
      double precision vmat(norb,norb,*)
c     sefp first used to store eigenvalues of S in algorithm
c     to remove linear dependence from basis, and then as
c     occupation factor to set up density matrix construction
      double precision  sefp(nstate)
      integer  iwork(5*norb),ifail(norb)
      CHARACTER  jobz*1
      double precision DLAMCH
      double precision zero,half,one,two
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
c
c >>>> EXECUTABLE CODE:
c
c
c  Do eigenvectors with jobz='V' (jobz='N' turns off eigvecs)
      jobz = 'V'
      mat = norb*norb

c     Retrieve delta-Ham from disk if spin (if not, already in mem)
      if( nspin .eq. 2 ) call READBIG( idhamfl, mat, vmat(1,1,1) )
c
c     Retrieve iteration-independent Hamiltonian, overlap matrices:
      REWIND( unit=iham0fl )
      call READBIG( iham0fl, mat, vmat(1,1,2) )
      REWIND( unit=iovlpfl )
      call READBIG( iovlpfl , mat, vmat(1,1,3) )
c
c  Combine iteration-independent Ham and del-Ham to get total Ham:
      call DAXPY( mat, one, vmat(1,1,1),1, vmat(1,1,2),1 )
c
c  Total hamiltonian is now in vmat(,,2), overlap in vmat(,,3)
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c                    Solve Schroedinger Equation
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c lwork is workspace available within vmat(,,4), and normally you
c would set lwork=mat and that would be more than ample.
c But for small problems (e.g. H-atom), we crash as the routine wants
c more than the small mat it gets.  AAAArrrrrgggghhhh!
c Hence I pass in the full space available ...
      lwork = lwork4
c
      if( idosolv.eq.1 )then
c
c     ***** Full real symmetric eigenproblem *****
c
         call DSYGV( 1,jobz, 'L',
     $        norb, vmat(1,1,2),norb,vmat(1,1,3),norb, eigval,
c     -->          H(n,n)-i/vec(n,n)-o S(n,n)-i
     $        vmat(1,1,4),lwork, INFO )
c     -->      work(lwork)
c
c     Put eigenvectors into vmat(,,1)
         call DCOPY( norb*nstate, vmat(1,1,2),1,vmat(1,1,1),1 )
c
      elseif( idosolv.eq.2 )then
c
c     ***** Selected eigvals/vecs real symmetric eigenproblem *****
c
         call DSYGVX( 1,jobz, 'I','L',
     $        norb, vmat(1,1,2),norb, vmat(1,1,3),norb,
c     -->            H(n,n)-i          S(n,n)-i
     $        -100d0,-20d0,1,nstate,2*DLAMCH('S'),
     $        nstout,eigval,
     $        vmat(1,1,1),norb, vmat(1,1,4), lwork,
c     -->      vec(n,nstate)     work(lwork)
     $        iwork,    ifail, INFO )
c     -->      int(5nt)-s in(n)-s
c
      elseif( idosolv .eq. 3 )then
c
c     ***** Deal with linear dependence issues *****
c
c     Rick's new code for the solver that removes 
c     linearly dependent basis sets
c     
c     
c     Compute the eigenvalues/vectors of the overlap matrix
c2         call DSYEV( 'V','L',norb,vmat(1,1,3),norb,
c2     $        sefp ,vmat(1,1,4),lwork,info )
c
c     Use the eigenvectors to do form the orthogonalizing matrix X
c2         neff = 0
c2         do  j=1,norb
c2            if( sefp(j) .gt. scut )then
c2               neff = neff + 1
c2               do  i=1,norb
c2                  vmat(i,neff,3) = vmat(i,j,3) / DSQRT( sefp(j) )
c2               enddo
c2            endif
c2         enddo
         call symorth(norb,vmat(1,1,3),norb,sefp,vmat(1,1,4),
     $        lwork,scut,neff)
c     
c     First square H out, since only the lower triangle is stored
         do  j=1,norb
            do  i=1,j
               vmat(i,j,2) = vmat(j,i,2)
            enddo
         enddo
c
c     Use X for similarity transformation of H, stored in vmat(1,1,2)
c     Overwrite vmat(1,1,2)
c1         call DGEMM( 'N','N',norb,neff,norb,one,vmat(1,1,2),norb,
c1     $        vmat(1,1,3),norb,zero,vmat(1,1,1),norb )
c1         call DGEMM( 'T','N',neff,neff,norb,one,vmat(1,1,3),norb,
c1     $        vmat(1,1,1),norb,zero,vmat(1,1,2),norb )
         call simx(norb,neff,vmat(1,1,2),norb,vmat(1,1,3),norb,
     $        vmat(1,1,1),norb)

c     Now solve the transformed matrix
         call DSYEV( 'V','L',neff,vmat(1,1,2),norb,
     $        eigval,vmat(1,1,4),lwork,INFO )
c     
c     The eigvals are now correct. Transform the eigvecs using X
c     and put them in vmat(1,1,1)
         call DGEMM( 'N','N',norb,neff,neff,one,vmat(1,1,3),norb,
     $        vmat(1,1,2),norb,zero,vmat(1,1,1),norb )
c
      elseif( idosolv .eq. 4 )then
         
         

       else
c
          call STOPXERR( 'solv-opt/ ERLSOLV has invalid solver option' )
c     
       endif
c
       if( INFO .ne. 0 )then
          call STOPXERR( 'diag-err/ ERLSOLV diagonalization error' )
       endif
c
c     Save the the eigenvectors in vmat(,,1) to ivecfl
       call WRITBIG( ivecfl, norb*nstate, vmat(1,1,1) )
c
        
       return
       end

      subroutine simx(n,m,A,lda,B,ldb,AB,ldab)
c     Compute the similarity tranformation A=BtAB
      implicit none
      integer n,m,lda,ldb,ldab
      double precision A(lda,n),B(ldb,n),AB(ldab,n)

      call DGEMM('N','N',n,m,n,1d0,A,lda,B,ldb,0d0,AB,ldab)
      call DGEMM('T','N',m,m,n,1d0,B,ldb,AB,ldab,0d0,A,lda)

      return
      end

      subroutine simxt(n,m,A,lda,B,ldb,AB,ldab)
c     Compute the similarity tranformation A=BABt
      implicit none
      integer n,m,lda,ldb,ldab
      double precision A(lda,n),B(ldb,n),AB(ldab,n)

      call DGEMM('N','T',n,m,n,1d0,A,lda,B,ldb,0d0,AB,ldab)
      call DGEMM('N','N',m,m,n,1d0,B,ldb,AB,ldab,0d0,A,lda)

      return
      end

      subroutine symorth(n,S,lds,seval,work,lwork,scut,neff)
c     Compute the orthogonalizing transform based on S
      implicit none
      integer n,lds,info,i,j,neff,lwork
      double precision S(lds,n),work(lwork),seval(n),scut

      call DSYEV('V','L',n,S,lds,seval,work,lwork,info)
      neff = 0
      do j=1,n
         if (seval(j) .gt. scut) then
            neff = neff + 1
            do i=1,n
               S(i,neff) = S(i,j)/SQRT(seval(j))
            enddo
         endif
      enddo
      return
      end
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RRHOIJ
c
c
      subroutine RRHOIJ(doblas3,
     $     idmatfl,iematfl,norb,nstate,
     $     eigval,eigpop,fpop,numpop, wt,
     $     dmat,emat,eigvec,work)
c---------------------------------------------------------------
c Purpose: construct density matrix in orbital basis, real
c
c Written: Rick Muller, June 4, 2007
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
      integer n,i,j,mat,numpop
      integer idmatfl,iematfl,norb,nstate
      double precision eigval(nstate),eigpop(nstate),
     $     fpop(nstate)
      double precision wt,dm,em
      LOGICAL    doblas3
      double precision dmat(norb,norb), emat(norb,norb)
      double precision eigvec(norb,norb), work(norb,norb)
c
      double precision zero,half,one,two
      DATA  zero,half,one,two / 0.d0,0.5d0,1.d0,2.d0 /
c
c >>>> EXECUTABLE CODE:
c
      mat = norb*norb
      if( numpop .lt. 1 )then
c     No occupied levels: dmat=emat=0, and skip construction
         call MKZERO( mat, dmat )
         call MKZERO( mat, emat )
         goto 390
      endif
c
c     Scale level occupations with appropriate sample weights
      do  n=1,numpop
         fpop(n) = wt*eigpop(n)
      enddo
c
      if( doblas3 ) then
c
c >>>>> Closed shell, use Raczkowski blas code:
c
         call DCOPY( norb*numpop, eigvec,1,
     $        work,1 )
         do  i=1,numpop
            call DSCAL( norb, fpop(i), work(1,i),1 )
         enddo
c
c     Make density matrix:
         call DGEMM( 'n','t', norb,norb,numpop,one,
     $        work,norb, eigvec,norb,
     $        zero, dmat,norb )
c
c     Make e-matrix:
         do  i=1,numpop
            call DSCAL( norb, eigval(i), work(1,i),1 )
         enddo
c
         call DGEMM( 'n','t', norb,norb,numpop,one,
     $        work,norb,  eigvec,norb,
     $        zero, emat,norb)
c     
c     Clear out imaginary part of matrices:
         do  j=1,norb
            do  i=1,j-1
               dmat(i,j) = zero
               emat(i,j) = zero
            enddo
         enddo
c
c     Scale dmat and emat by weight function:
         call DSCAL( 2*mat, wt, dmat,1 )
c
        else
c
c >>>>> General occupations code to generate density matrix:
c
c     Transpose the eigenvector matrix:
           do  n=1,numpop
              do  i=1,norb
                 work(n,i) = eigvec(i,n)
              enddo
           enddo
c     
           do  i=1,norb
              do  n=1,numpop
                 eigvec(n,i) = fpop(n)*work(n,i)
              enddo
           enddo
c
           do  j=1,norb
c     Set imaginary triangle to zero
              do  i=1,j-1
                 dmat(i,j) = zero
                 emat(i,j) = zero
              enddo
c     Construct real triangle
              do  i=j,norb
                 dm = zero
                 em = zero
c     Tripling up on this loop (3 i's at a time) gets you another
c     25%, not enough to merit complicating the code.
                 do  n=1,numpop
                    dm = dm + eigvec(n,i)*work(n,j)
                    em = em + eigvec(n,i)*work(n,j)*eigval(n)
                 enddo
                 dmat(i,j) = dm
                 emat(i,j) = em
              enddo
           enddo
c
        endif
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c               Write out density-matrix, e-matrix:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
 390    continue
c
c       Save density matrix to idmatfl:
        call WRITBIG( idmatfl, mat, dmat )
c
c       Save e-matrix to iematfl:
        call WRITBIG( iematfl, mat, emat )
c
c    That's all, Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SPINOPT
c
c
      subroutine SPINOPT( nspin, fermilvl, spinold,spinnew,
     $ etemp, elecno, nstate,nk, wtk,eigval,
     $ wklvl )
c---------------------------------------------------------------
c Purpose: compute fermi level across spin, associated spinpol
c
c Written: Peter A. Schultz, 11-January-2008, for 2.61
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER ( zero=0.d0, one=1.d0, two=2.d0 )
c
c Input:
      DIMENSION  wtk(nk), eigval(nstate,nk,*)
      DIMENSION  elecno(2)
c Scratch:
      DIMENSION  wklvl(*)
c
c Local:
      DIMENSION  elspin(2)
      LOGICAL    xch,pos,neg
      DATA  elcerr,elconv / 1.d-6,1.d-11 /
      DATA  occnil / 1.d-9 /
c Local:
      DIMENSION  occlvl(2)
      DATA       occlvl / 2.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      if( nspin .ne. 2 ) call STOPXERR( 'spinopt/no-spin' )
c
      nstk = nstate*nk
      nstall = nstk*2
c
      occfull = occlvl(nspin)
      elnumbr = elecno(1) + elecno(2)
c
      call POP( nspin, spindif,
     $ fermilvl, egap,
     $ etemp, elnumbr, esumsp, occfull,
     $ nstate,nk, wtk, eigval,wklvl(1),npop,
     $ wklvl(1+1*nstall),wklvl(1+2*nstall),wklvl(1+3*nstall),
     $ wklvl(1*4*nstall),wklvl(1+5*nstall) )
c -->  elvl wlvl klvl nlvl flvl
c
      spinold = elecno(1) - elecno(2)
      spinnew = spindif
c
c    That's all, Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SPUPDATE
c
c
      subroutine SPUPDATE( istat_sp, istep_sp, spindata,
     $ elecno, spinold,spinnew,spinges,
     $ nstep_sp,meth_sp,conv_sp,blend_sp )
c---------------------------------------------------------------
c Purpose: compute update for spin polarization
c
c Written: Peter A. Schultz, 11-January-2008, for 2.61
c
c Revision history:
c   2Dec10-PAS/2.62: prevent jump to negative spin on first step
c---------------------------------------------------------------
c
c I have two schemes here.
c One "simple" is just to use the up/dn electron count ("spinnew")
c  from a fermi level equilibration with the eigenspectrum with
c  the current up/dn electron count ("spinold").
c The other, called "linear", is to take the intersection of the
c  lines given by the input up/dn electron count ("old") and the
c  output up/dn electron count ("new"), with constraints to make
c  sure that things behave reasonably.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER ( zero=0.d0, one=1.0d0, two=2.d0 )
c
c Input/Output:
      DIMENSION  elecno(2)
      DIMENSION  spindata(4,2)
c Local:
      DIMENSION  occlvl(2)
      DATA       occlvl / 2.d0,1.d0 /
c
c >>>> EXECUTABLE CODE:
c
      elnumbr = elecno(1) + elecno(2)
      spindel = spinnew - spinold
      spinchg = ABS( spindel )
c
c For the moment, only implement the SIMPLE scheme.
c
      istat_sp = 0
      if( spinchg .lt. conv_sp )then
c       Spin is converged
        istat_sp = 2
        spinges = spinold
      else
c       Spin is not converged
        if( istep_sp .eq. nstep_sp ) istat_sp = 1
c
        if( istep_sp .eq. 1 .or. meth_sp .eq. 0 )then
c         Use simple blend
          spinsmpl = spinold + spindel*blend_sp
          spinges = spinsmpl
          spinslope = blend_sp
        elseif( istep_sp .gt. 1 )then
c         Use linear fit for guess, unless numerical issues
          spinold1 = spindata(1,1)
          spinnew1 = spindata(2,1)
          spindel1 = spinnew1 - spinold1
          spinold2 = spinold
          spinnew2 = spinnew
          spindel2 = spindel
          spinfac = (spinold1-spinold2) / (spindel2-spindel1)
          if( spinfac .lt. zero )then
c           Then this is not convergent, revert to simple blend
            spinslope = blend_sp
          elseif( spinfac .gt. two )then
c           This looks dangerously large, limit slope
            spinslope = two
          else
c           We have a reasonable slope, intersect the two lines
            spinslope = spinfac
          endif
          spinges = spinold2 + spindel2*spinslope
c
c         Shift up data from previous last step
          spindata(1,2) = spindata(1,1)
          spindata(2,2) = spindata(2,1)
          spindata(3,2) = spindata(3,1)
          spindata(4,2) = spindata(4,1)
        else
c         Cannot be, and check is free
          call STOPXERR( 'istep_sp=0 in SPUPDATE' )
        endif
c
        if( spinges .lt. zero )then
c         We overshot from above into a (spurious) negative spin, stifle
          spinges = spinnew
          spinslope = one
c         If by some numerical noise, spin<0, set to zero:
          if( spinges .lt. zero ) spinges = zero
        endif
c
c       Pack up this step:
        spindata(1,1) = spinold
        spindata(2,1) = spinnew
        spindata(3,1) = spinges
        spindata(4,1) = spinslope
c
c       Set up electron counts for next spin step:
        elecno(2) = ( elnumbr - spinges ) / two
        elecno(1) = elecno(2) + spinges
      endif
c
c    That's all, Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MATSTR
c
c
      subroutine MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c---------------------------------------------------------------
c Purpose: compute how many elements in striped-matrix
c
c Written: Peter A. Schultz,  2-October-2008, for 2.62
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c Output:
      INTEGER  matstr
c Input arrays:
      INTEGER  norb,nk,ncplx, natm,ntyp
      INTEGER  itypa, norba
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c Local declatations:
      INTEGER  jatm, jtyp
      INTEGER  j0, norbatj, njstripe, matjstr, nmatstr
c
c >>>> EXECUTABLE CODE:
c
c Count up how much to clear:
      matstr = 0
      j0 = 0
      do  jatm=1,natm
        jtyp = itypa(jatm)
        norbatj = norba(jtyp)
        njstripe = norb - j0
        matjstr = norbatj*njstripe
        matstr = matstr + matjstr
        j0 = j0 + norbatj
      enddo
      nmatstr = ncplx*nk*matstr
c
c    That's all, Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MATLOCSTR
c
c
      subroutine MATLOCSTR( iproc,nproc, nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c---------------------------------------------------------------
c Purpose: apportion stripes of matrix over processors
c
c Written: Peter A. Schultz,  2-October-2008, for 2.62
c
c Revision history:
c  none
c---------------------------------------------------------------
c  This scheme approtions stripes of a block diagoanl matrix
c  over processors; each processor will do a single sequence
c  of atom-blocked stripes, delineated by first (mayatm1) and
c  last (mayatm2) atom of that sequence, inclusive.
c
      IMPLICIT NONE
c
c Output:
      INTEGER  nprocstr
      INTEGER  myatm1,myatm2,myj0
      INTEGER  maxmatpr, mymatpr
c Input arrays:
      INTEGER  iproc,nproc
      INTEGER  matstr
      INTEGER  norb,nk,ncplx, natm,ntyp
      INTEGER  itypa, norba
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c Local declatations:
      INTEGER  jatm, jtyp
      INTEGER  j0,j0next,j0start, norbatj, njstripe, matjstr
      INTEGER  matavepr
      INTEGER  jproc, matpr, jatm1,jatm2
c
      INTEGER  IWR
      INTEGER  npdbg, npr
      PARAMETER  ( npdbg = 64 )
      INTEGER  matsum
      INTEGER  myats(2,npdbg), mymats(npdbg), myj0s(npdbg)
c
      INTEGER  lvldbg
      DATA     lvldbg / 0 /
c
c >>>> EXECUTABLE CODE:
c
      if( nproc.eq. 1 )then
c       Single-processr does it all ...
        myatm1 = 1
        myatm2 = natm
        myj0 = 0
        maxmatpr = matstr
        mymatpr = matstr
        nprocstr = 1
        goto 900
      endif
c
c Set defaults to do no atoms with no storage
c   (in case I end up with an idle processor)
      myatm1 = natm + 1
      myatm2 = 0
      mymatpr = 0
c
      do  jproc=1,npdbg
        myats(1,jproc) = 0
        myats(2,jproc) = 0
        mymats(jproc) = 0
      enddo
c
c
c Compute the target storage: average the total storage over procs:
      matavepr = ( matstr + nproc - 1 ) / nproc
      matsum = 0
      maxmatpr = 0
      matpr = 0
c
c Count up how much to clear:
      jproc = 0
      j0next = 0
      jatm1 = 1
      j0start = j0next
      do  jatm=1,natm
        jtyp = itypa(jatm)
        norbatj = norba(jtyp)
        j0 = j0next
        j0next = j0 + norbatj
        njstripe = norb - j0
c
        matjstr = norbatj*njstripe
        matpr = matpr + matjstr
        if( matpr.gt.matavepr .or. jatm.eq.natm )then
c         Another processor is full, load up its data
          jatm2 = jatm
          if( jproc.eq.iproc )then
            myatm1 = jatm1
            myatm2 = jatm2
            myj0 = j0start
            mymatpr = matpr
          endif
          if( matpr.gt.maxmatpr ) maxmatpr = matpr
          matsum = matsum + matpr
c
          if( lvldbg.gt.0 .and. (jproc+1).le.npdbg )then
            myats(1,jproc+1) = jatm1
            myats(2,jproc+1) = jatm2
            myj0s(jproc+1) = j0start
            mymats(jproc+1) = matpr
          endif
c
          nprocstr = jproc + 1
c
          jproc = jproc + 1
          jatm1 = jatm + 1
          j0start = j0next
          matpr = 0
c         Finished with this processor allotment
        endif
c
      enddo
c
  900 continue
c
      if( lvldbg.gt.0 )then
        call FLGETIWR( IWR )
        write(IWR,*) 'MATLOC: stripes by procs:'
        npr = MIN( npdbg,nproc )
        do  jproc=1,npr
          write(IWR,'(1x,a,1x,i4,1x,2i5,2x,i6,2x,i12)')
     $     'proc,a1,a2,i0,matpr=',
     $     jproc-1, myats(1,jproc),myats(2,jproc),
     $     myj0s(jproc), mymats(jproc)
        enddo
        write(IWR,*) 'MATLOC: average over processors=',matavepr
        write(IWR,*) 'MATLOC: largest over processors=',maxmatpr
        write(IWR,*) 'MATLOC: size of square matrix   =',norb*norb
        write(IWR,*) 'MATLOC:  ... striped matrix, chk=',matstr,matsum
      endif
c
c    That's all, Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> H0STOREKP
c
c
      subroutine H0STOREKP( imatfile, nprocstr, master, iproc, icomm,
     $ nmatstr, nmatpr, mymatpr, mat,
     $ norb, nk, ncplx, natm, ntyp, itypa, norba,
     $ hmatstr,  hmatijk, matstr, hmatkbuf )
c -->  nmatpr    mat              ncplx*matstr
c---------------------------------------------------------------
c Purpose: Put hamiltonians to disk, converting distributed striped matrices
c          into square matrics.  Like H0STORE, but without the need to hold
c          all-k striped matrices at once on the master.
c          Requires an auxiliary buffer, hmatkbuf, of size ncplx*matstr.
c
c Written: Andrew C. Pineda,  23-November-2009, for 2.63
c
c Revision history:
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input/Output arrays:
      DIMENSION  hmatstr(nk,*), hmatijk(norb,norb)
c NB: hmatstr only needs ~(1/nprocstr) the size of hmatstr in H0STORE.
c     It does not need to hold all the full merged (striped) matrices.
c
c Input arrays:
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c Scratch array:
      DIMENSION  hmatkbuf(*)
c      hmatkbuf = Buffer space to hold unsorted striped matrix for a single k-point.
c      Its size needs to be matstr*ncplx.
c
c >>>> EXECUTABLE CODE:
c
      if( iproc .eq. master )then
        REWIND( unit=imatfile )
      endif
c
      do  ik=1, nk, 1
c
c       Collect pieces for current k-point, ik, onto master in hmatkbuf
        call STRMERGEKP( ik, nk, nprocstr, master, iproc,
     $                    icomm, ncplx, mymatpr, matstr,
     $                    hmatstr, hmatkbuf )
c
c       Sort current k-point on the master, packing the imaginary part
c       into the lower left half of the matrix if present.
c
        if( iproc .eq. master )then
          call MSORT2IJ( norb, ncplx, natm, ntyp, itypa, norba,
     $                   hmatkbuf, hmatijk )
c         Save matrix to imatfile from master only:
          call H0WRIT( imatfile, mat, 1, hmatijk )
        endif
c
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> STRMERGEKP
c
c
      subroutine STRMERGEKP( ik, nk, nprocstr, master, iproc,
     $                       icomm, ncplx, mymatpr, matstr,
     $                       hmat, hbuffer )
c---------------------------------------------------------------
c Purpose: Merge one k-point from the stripe-distributed matrix
c          onto master
c
c Written: Andrew C. Pineda, 23-November-2009 for 2.62.
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      INTEGER    mymatprb
      DIMENSION  hmat(*)
      DIMENSION  hbuffer(*)
c       NB: hbuffer needs to hold one full k-point, size matstr*ncplx.
c
cxkp    ***** NB: code assumes master=0 ***** where does this assumption act?
c
c  Merge the stripes for this k-point onto the master.
c  Loop over processes holding the stripes, imaginary parts, if present, get
c  packed after the real parts.
c
c >>>> EXECUTABLE CODE:
c
      jmaster = 1
      jloc = ik
c
c  Each process sends its stripe for this k-point to master process.
c  Note on each stripe the array indices/dimensions are (nk,mymatpr,ncplx).
c  So it is strided by nk.
c
      do 400 jproc = 0, nprocstr-1
         do 300 icplx=1, ncplx, 1
c
            if( jproc .eq. master )then
               if( iproc .eq. master )then
c                 This stripe computed on the master, just load it
                  do  i=jmaster, jmaster+mymatpr-1, 1
                     hbuffer(i) = hmat(jloc)
                     jloc = jloc + nk
                  enddo
                  jmaster = jmaster + mymatpr
               endif
            else
c              Non-master process did this, send stripe to the Master
               if( jproc .eq. iproc )then
                  do i=1, mymatpr,1
                     hbuffer(i) = hmat(jloc)
                     jloc = jloc + nk
                  end do
c
                  call MPSENDI( master,  1,       mymatpr, icomm ) 
                  call MPSENDR8( master, mymatpr, hbuffer, icomm )
               endif
c
c              Master process receives every stripe.
               if( iproc .eq. master )then
                  lenmsg = 1
                  call MPRECVI( jproc, lenmsg,
     $                 mymatprb,         icomm ) 
                  call MPRECVR8( jproc, mymatprb,
     $                 hbuffer(jmaster), icomm )
                  jmaster = jmaster + mymatprb
               endif
c
            endif
c
  300    continue
  400 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MSORT2IJ
c
c
      subroutine MSORT2IJ( norb, ncplx, natm, ntyp, itypa, norba,
     $                     hmatstr, hmatij )
c---------------------------------------------------------------
c Purpose: Sort single k-point from the Hamiltonian matrix in striped/atom-blocked
c          into i-j form.
c
c Written: Andrew C. Pineda, 23-November-2009
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input/Output arrays:
      DIMENSION  hmatstr(*), hmatij(norb,norb)
c Input arrays:
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c Local declarations:
      LOGICAL    diagatm
c
c >>>> EXECUTABLE CODE:
c
c Clear out square matrix target of sort:
      nmatijk = norb*norb
      call MKZERO( nmatijk, hmatij )
c
c     Atom j loop:
c
      jjnext = 0
      jnext = 0
      do 2000 jatm=1,natm
        jtyp = itypa(jatm)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        njstripe = norb - jstart
        matjstr = norbatj*njstripe
        jjstart = jjnext
        jjnext = jjstart + matjstr*ncplx
c
        j0 = jstart
c
c       Atom i loop:
c
        ijnext = jjstart
        inext = jstart
        do 1000 iatm=jatm,natm
          ityp = itypa(iatm)
          norbati = norba(ityp)
          istart = inext
          inext = istart + norbati
c
          matij = norbati*norbatj
          ijstart = ijnext
          ijnext = ijstart + matij*ncplx
c
          i0 = istart
c
          diagatm = .false.
          if( iatm.eq.jatm ) diagatm = .true.
c
          ij0 = ijstart
          ij0 = ij0 - norbati
c
c         Atom orbital loops:
c
          iorbat1 = 1
          do 720 jorbat=1,norbatj
            j = j0 + jorbat
c
            ij0 = ij0 + norbati
            if( diagatm ) iorbat1 = jorbat
            do 710  iorbat=iorbat1,norbati
              i = i0 + iorbat
              ij = ij0 + iorbat
              ijc = ij + matij
c
                hmatij(i,j) = hmatstr(ij)
c
              if( ncplx.eq.2 .and. i.ne.j )then
                  hmatij(j,i) = hmatstr(ijc)
              endif
c
c             Close Atom orbital loops
  710       continue
  720     continue
c
c         Close Atom i loop:
 1000   continue
c
c       Close Atom j loop:
 2000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> H0STORE
c
c
      subroutine H0STORE( imatfile, nprocstr, master, iproc, icomm,
     $ nmatstr, nmatpr, mat,
     $ norb, nk, ncplx, natm, ntyp, itypa, norba,
     $ hmatstr, hmatijk )
c -->  nmatstr  mat
c---------------------------------------------------------------
c Purpose: Put striped/atom-blocked matrix into storage
c          Here, into k-resolved full H(n,n) onto disk
c
c Written: Peter A. Schultz,  9-October-2008, for 2.62
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c Note: I pass ik into this routine simply to avoid a problem
c that had occurred (in a different place) where an optimizing
c compiler purged a loop-index from a call to H0SORT1
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input/Output arrays:
      DIMENSION  hmatstr(nk,*), hmatijk(norb,norb)
c Input arrays:
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c >>>> EXECUTABLE CODE:
c
      call STRMERGE( nprocstr, master,iproc,icomm, nmatstr,nmatpr,
     $ hmatstr )
c -->  nmatpr-i/nmatstr-o
c
      if( iproc .eq. master )then
        REWIND( unit=imatfile )
        ik = 0
  100   continue
        ik = ik + 1
        call MSORT1IJK( norb,ik,nk,ncplx, natm,ntyp,itypa, norba,
     $   hmatstr,   hmatijk )
c -->    hmatstr-i  hmatijk-o
c -->    nmatstr    mat
c       Save matrix to imatfile:
        call H0WRIT( imatfile, mat, 1, hmatijk )
        if( ik .lt. nk ) goto 100
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> STRMERGE
c
c
      subroutine STRMERGE( nprocstr, master,iproc,icomm, nmatstr,nmatpr,
     $ hmat )
c---------------------------------------------------------------
c Purpose: merge distributed matrix onto master
c Written: Peter A. Schultz, 4-October-2008, for 2.62
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  hmat(*)
c
      if( nprocstr .gt. 1 .and. iproc .lt. nprocstr )then
c       Merge the stripes to full set of stripes on master:
        nmatpr1 = 1
        call MPMERGER8( nprocstr, master, iproc,
     $   nmatstr,nmatpr1,nmatpr, hmat, icomm )
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MSORTIJK
c
c
      subroutine MSORTIJK( norb,nk,ncplx, natm,ntyp,itypa, norba,
     $ hmatstr,hmatijk )
c---------------------------------------------------------------
c Purpose: sort Hamiltonian matrix from striped/atom-blocked
c          into k-resolved i-j form.
c
c Written: Peter A. Schultz, 25-Septemeber-2008
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input/Output arrays:
      DIMENSION  hmatstr(nk,*), hmatijk(norb,norb,nk)
c Input arrays:
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c Local declarations:
      LOGICAL    diagatm
c
c >>>> EXECUTABLE CODE:
c
c Clear out square matrix target of sort:
      nmatijk = norb*norb*nk
      call MKZERO( nmatijk, hmatijk )
c
c     Atom j loop:
c
      jjnext = 0
      jnext = 0
      do 2000 jatm=1,natm
        jtyp = itypa(jatm)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        njstripe = norb - jstart
        matjstr = norbatj*njstripe
        jjstart = jjnext
        jjnext = jjstart + matjstr*ncplx
c
        j0 = jstart
c
c       Atom i loop:
c
        ijnext = jjstart
        inext = jstart
        do 1000 iatm=jatm,natm
          ityp = itypa(iatm)
          norbati = norba(ityp)
          istart = inext
          inext = istart + norbati
c
          matij = norbati*norbatj
          ijstart = ijnext
          ijnext = ijstart + matij*ncplx
c
          i0 = istart
c
          diagatm = .false.
          if( iatm.eq.jatm ) diagatm = .true.
c
          ij0 = ijstart
          ij0 = ij0 - norbati
c
c         Atom orbital loops:
c
          iorbat1 = 1
          do 720 jorbat=1,norbatj
            j = j0 + jorbat
c
            ij0 = ij0 + norbati
            if( diagatm ) iorbat1 = jorbat
            do 710  iorbat=iorbat1,norbati
              i = i0 + iorbat
              ij = ij0 + iorbat
              ijc = ij + matij
c
              do  k=1,nk
                hmatijk(i,j,k) = hmatstr(k,ij)
              enddo
c
              if( ncplx.eq.2 .and. i.ne.j )then
                do  k=1,nk
                  hmatijk(j,i,k) = hmatstr(k,ijc)
                enddo
              endif
c
c             Close Atom orbital loops
  710       continue
  720     continue
c
c         Close Atom i loop:
 1000   continue
c
c       Close Atom j loop:
 2000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MSORT1IJK
c
c
      subroutine MSORT1IJK( norb,ik,nk,ncplx, natm,ntyp,itypa, norba,
     $ hmatstr,hmatijk )
c---------------------------------------------------------------
c Purpose: sort Hamiltonian matrix from striped/atom-blocked
c          into k-resolved i-j form.
c
c Written: Peter A. Schultz, 25-Septemeber-2008
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input/Output arrays:
      DIMENSION  hmatstr(nk,*), hmatijk(norb,norb)
c Input arrays:
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c Local declarations:
      LOGICAL    diagatm
c
c >>>> EXECUTABLE CODE:
c
      k = ik
      if( k.lt.1 .or. k.gt.nk )then
c       The compiler killed the passed k
        call FLGETIERR( IERR )
        write(IERR,*) 'MSORT1 receives corrupted k-index'
        write(IERR,*) 'Likely opting compiler purged argument in call'
        call STOPXERR( 'MSORT1IJK - trouble with compiler?' )
      endif
c
c Clear out square matrix target of sort:
      nmatijk = norb*norb
      call MKZERO( nmatijk, hmatijk )
c
c     Atom j loop:
c
      jjnext = 0
      jnext = 0
      do 2000 jatm=1,natm
        jtyp = itypa(jatm)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        njstripe = norb - jstart
        matjstr = norbatj*njstripe
        jjstart = jjnext
        jjnext = jjstart + matjstr*ncplx
c
        j0 = jstart
c
c       Atom i loop:
c
        ijnext = jjstart
        inext = jstart
        do 1000 iatm=jatm,natm
          ityp = itypa(iatm)
          norbati = norba(ityp)
          istart = inext
          inext = istart + norbati
c
          matij = norbati*norbatj
          ijstart = ijnext
          ijnext = ijstart + matij*ncplx
c
          i0 = istart
c
          diagatm = .false.
          if( iatm.eq.jatm ) diagatm = .true.
c
          ij0 = ijstart
          ij0 = ij0 - norbati
c
c         Atom orbital loops:
c
          iorbat1 = 1
          do 720 jorbat=1,norbatj
            j = j0 + jorbat
c
            ij0 = ij0 + norbati
            if( diagatm ) iorbat1 = jorbat
            do 710  iorbat=iorbat1,norbati
              i = i0 + iorbat
              ij = ij0 + iorbat
              ijc = ij + matij
c
                hmatijk(i,j) = hmatstr(k,ij)
c
              if( ncplx.eq.2 .and. i.ne.j )then
                  hmatijk(j,i) = hmatstr(k,ijc)
              endif
c
c             Close Atom orbital loops
  710       continue
  720     continue
c
c         Close Atom i loop:
 1000   continue
c
c       Close Atom j loop:
 2000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MSORT1STR
c
c
      subroutine MSORT1STR( norb,ik,nk,ncplx, natm,ntyp,itypa, norba,
     $ hmatstr,hmatijk )
c---------------------------------------------------------------
c Purpose: sort Hamiltonian matrix into striped/atom-blocked
c          from k-resolved i-j form.
c
c Written: Peter A. Schultz, 14-October-2008
c
c Revision history:
c  14Oct08-PAS/2.62: adapted from msort1ijk
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input/Output arrays:
      DIMENSION  hmatstr(nk,*), hmatijk(norb,norb)
c Input arrays:
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c Local declarations:
      LOGICAL    diagatm
c
c >>>> EXECUTABLE CODE:
c
      k = ik
      if( k.lt.1 .or. k.gt.nk )then
c       The compiler killed the passed k
        call FLGETIERR( IERR )
        write(IERR,*) 'MSORT1 receives corrupted k-index'
        write(IERR,*) 'Likely opting compiler purged argument in call'
        call STOPXERR( 'MSORT1STR - trouble with compiler?' )
      endif
c
c     Atom j loop:
c
      jjnext = 0
      jnext = 0
      do 2000 jatm=1,natm
        jtyp = itypa(jatm)
        norbatj = norba(jtyp)
        jstart = jnext
        jnext = jstart + norbatj
c
        njstripe = norb - jstart
        matjstr = norbatj*njstripe
        jjstart = jjnext
        jjnext = jjstart + matjstr*ncplx
c
        j0 = jstart
c
c       Atom i loop:
c
        ijnext = jjstart
        inext = jstart
        do 1000 iatm=jatm,natm
          ityp = itypa(iatm)
          norbati = norba(ityp)
          istart = inext
          inext = istart + norbati
c
          matij = norbati*norbatj
          ijstart = ijnext
          ijnext = ijstart + matij*ncplx
c
          i0 = istart
c
          diagatm = .false.
          if( iatm.eq.jatm ) diagatm = .true.
c
          ij0 = ijstart
          ij0 = ij0 - norbati
c
c         Atom orbital loops:
c
          iorbat1 = 1
          do 720 jorbat=1,norbatj
            j = j0 + jorbat
c
            ij0 = ij0 + norbati
            if( diagatm ) iorbat1 = jorbat
            do 710  iorbat=iorbat1,norbati
              i = i0 + iorbat
              ij = ij0 + iorbat
              ijc = ij + matij
c
                hmatstr(k,ij) = hmatijk(i,j)
c
              if( ncplx.eq.2 .and. i.ne.j )then
                  hmatstr(k,ijc) = hmatijk(j,i)
              endif
c
c             Close Atom orbital loops
  710       continue
  720     continue
c
c         Close Atom i loop:
 1000   continue
c
c       Close Atom j loop:
 2000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c 
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DM0FETCH
c
c     
      subroutine DM0FETCH( idmatfl,idmatsfl, nspin,
     $ norb,nk,ncplx, natm,ntyp,itypa,norba,
     $ dmatstr,dmatij )
c---------------------------------------------------------------
c Purpose: retrieve full density (or energy-weighted) matrices,
c          and send to processors in striped form.
c     
c Written: Peter A. Schultz, 13-October-2008, for v2.62 (stripe-par)
c     
c Revision history:
c  22Jan12-PAS/2.63: harmonized with ACP/dm0fetchkp, installed below
c---------------------------------------------------------------
c     
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c     
      PARAMETER  ( zero = 0.d0, one = 1.d0 )
c
c Input arrays:
      DIMENSION  itypa(natm),norba(ntyp)
c Output array:  dmastr[nmatstr]  spin&k=1: max(nmatstr,mat)
      DIMENSION  dmatstr(*)
c
c Scratch array: dmatij[mat(k=1)|nspin*mat(k>1)]
      DIMENSION  dmatij(*)
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
      mat = norb*norb
      if( iproc .eq. master )then
        REWIND( unit=idmatfl )
        if( nspin.eq.2 ) REWIND( unit=idmatsfl )
      endif
c
      ik = 0
  100 continue
      ik = ik + 1
c
c  The master retrieves amd sorts the matrices (up&dn spin summed)
      mat = norb*norb
      if( iproc .eq. master )then
        call READBIG( idmatfl, mat, dmatij )
        if( nspin .eq. 2 )then
c         Read other spin and sum into this:
          if( nk .gt. 1 )then
c           We need to use an extra buffer to avoid wiping dmatstr
            call READBIG( idmatsfl, mat, dmatij(1+mat) )
            call DAXPY( mat, one, dmatij(1+mat),1, dmatij,1 )
          else
c           With nk=1, dmatstr is idle, overlap use as buffer here
            call READBIG( idmatsfl, mat, dmatstr )
            call DAXPY( mat, one, dmatstr,1, dmatij,1 )
          endif
        endif
c        ... and inserts this dmat(ik) into full nk-striped matrix:
        call MSORT1STR( norb,ik,nk,ncplx, natm,ntyp,itypa,norba,
     $   dmatstr,dmatij )
      endif
c
      if( ik .lt. nk ) goto 100
c
c  Master sends the correct stripe to the all processors:
      call MSENDSTR( norb,nk,ncplx, natm,ntyp,itypa,norba,
     $ nprocs,iproc,master,icomm,
     $ dmatstr )
c
c    That's all Folks!
c
      RETURN
      END
c
c    
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MSENDSTR
c
c
      subroutine MSENDSTR( norb,nk,ncplx, natm,ntyp,itypa,norba,
     $ nprocs,iproc,master,icomm,
     $ dmatstr )
c---------------------------------------------------------------
c Purpose: Send matrix stripes out to their respective owners
c     
c Written: Peter A. Schultz, 14-October-2008
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input/Output arrays:
      DIMENSION  dmatstr(*)
c Input arrays:
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
c
c >>>> EXECUTABLE CODE:
c     
c Determine size of full striped matrix
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
      nmatstr = ncplx*nk*matstr
c
c Figure out how much belongs on local processor:
      call MATLOCSTR( iproc,nprocs,nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
      nmatpr = mymatpr*ncplx*nk
c
      if( nprocstr.le.1 ) goto 900
c
c Master will start sending AFTER its own allotment:
      jjnext = nmatpr
c
      do 1000 jproc=1,nprocstr-1
c
        if( iproc.eq.master )then
c         Find length to be sent, and from what starting point:
          call MATLOCSTR( jproc,nprocs,nprocstr,
     $      jatm1,  jatm2, jpj0, maxmatpr, jmatpr ,
     $     matstr,
     $     norb,nk,ncplx, natm,ntyp,itypa, norba )
          nmatjpr = jmatpr*ncplx*nk
          ij1 = jjnext + 1
          jjnext = jjnext + nmatjpr
          lenmsg = nmatjpr
          call MPSENDR8( jproc, lenmsg, dmatstr(ij1), icomm )
c
        elseif( iproc.eq.jproc )then
c         Receive this stripe from the master:
          ij1 = 1
          lenmsg = nmatpr
          call MPRECVR8( master, lenmsg, dmatstr(ij1), icomm )
c
        endif
c
 1000 continue
c
  900 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c 
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DM0FETCHKP
c
c
      subroutine DM0FETCHKP( idmatfl, idmatsfl, nspin,
     $ norb, nk, ncplx, natm, ntyp, itypa, norba,
     $ dmatstr,              dmatij,       dmatstrbuf )
c      nk*mymatpr*ncplx-o    mat-s         nc*matstr-s
c      = nmatpr                            spin: & mat-s
c---------------------------------------------------------------
c Purpose: retrieve full density (or energy-weighted) matrices,
c          and send to processors in striped form.
c          (Inverse of H0STOREKP.)
c     
c Written: Andrew C. Pineda, 7-January-2010, for 2.62 (k-blocked,
c          stripe-par)
c
c Total space required:
c    no-spin:  nmatpr + mat + ncplx*matstr
c    spin:     nmatpr + mat + max( ncplx*matstr, mat )
c  note: could be packed tighter still (nmatpr less) for nk=1,
c        by overlapping needed scratch space with output space
c     
c Revision history:
c  7-Jan-2010/ACP: Derived from DM0FETCH.
c---------------------------------------------------------------
c     
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c     
      PARAMETER  ( zero = 0.d0, one = 1.d0 )
c
c Input arrays:
      DIMENSION  itypa(natm), norba(ntyp)
c
c Output array:  dmatstr[nmatpr], nmatpr = ncplx*nk*mymatpr 
      DIMENSION  dmatstr(*)
c
c Scratch array: dmatij[mat]
      DIMENSION  dmatij(*)
c Scratch array: dmatstrbuf: ncplx*matstr, spin: max( buf, mat )
      DIMENSION  dmatstrbuf(*)
c    NB:  matstr <= mat so can use a buffer of ncplx*mat here to use 
c                dmatstrbuf for other purposes
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nprocs )
      call MPNODE( iproc )
      call MPNODE0( master )
      call MPCOMM( icomm )
c
      mat = norb*norb
      if( iproc .eq. master )then
        REWIND( unit=idmatfl )
        if( nspin.eq.2 ) REWIND( unit=idmatsfl )
      endif
c
      ik = 0
  100 continue
      ik = ik + 1
c
c The master retrieves the matrix (up&dn spin summed) one k-point at a time.
c
      mat = norb*norb
      if( iproc .eq. master )then
        call READBIG( idmatfl, mat, dmatij )
        if( nspin .eq. 2 )then
c         Read other spin and sum into this
          call READBIG( idmatsfl, mat, dmatstrbuf )
          call DAXPY( mat, one, dmatstrbuf,1, dmatij,1 )
        endif
c
c Inserts this dmat(ik) into striped matrix for 1 k-point on the master.
c
        ikphony = 1
        nkphony = 1
        call MSORT1STR( norb, ikphony, nkphony, ncplx, natm,
     $   ntyp, itypa, norba,
     $   dmatstrbuf,       dmatij )
c -->    ncplx*matstr-o    mat-i
c
      endif
c
c Scatter the stripe across processors to the full distributed nk-striped matrix.
c
      call MSCATTERSTRKP( norb, ik, nk, ncplx, natm,
     $ ntyp, itypa, norba,
     $ nprocs, iproc, master, icomm,
     $ dmatstr,           dmatstrbuf )
c -->  ncplx*mymatpr*nk   ncplx*matstr-i
c -->  = nmatpr
c
      if( ik .lt. nk ) goto 100
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> MSCATTERSTRKP
c
c
      subroutine MSCATTERSTRKP( norb, ik, nk, ncplx, natm,
     $     ntyp, itypa, norba,
     $     nprocs, iproc, master, icomm,
     $     dmatstr, dmatstrbuf )
c---------------------------------------------------------------
c Purpose: Send pieces of a matrix stripe out to their respective owners
c     
c Written: Andrew C. Pineda, 7-Jan-2010, for 2.62
c
c Total space required: (nk*mymatpr*ncplx + matstr*ncplx)
c
c Revision history:
c   7-Jan-2010/ACP:  Derived from MSENDSTR
c  21-Jan-2010/ACP:  Both implementations now work.
c  29-Jan-2010/ACP:  Cleaned out development code and commented out original code.
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c Input/Output arrays:
c     dmatstr[nk*mymatpr*ncplx], mymatpr is local to processor
      DIMENSION  dmatstr(*)
c     Array buffer for a single stripe or partial stripe (1 k-point)
c     dmatstrbuf[matstr*ncplx] on master, dmatstrbuf[mymatpr*ncplx] elsewhere
      DIMENSION  dmatstrbuf(*)
c Input arrays:
      DIMENSION  itypa(natm)
      DIMENSION  norba(ntyp)
      LOGICAL REFERENCE_IMPLEMENTATION
      DATA REFERENCE_IMPLEMENTATION /.false./
c
c >>>> EXECUTABLE CODE:
c     
c Determine size of a striped matrix for 1 k-point
c
      call MATTOTSTR( matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c      nmatstr = ncplx*nk*matstr
c
c Figure out how much belongs on local processor:
      call MATLOCSTR( iproc, nprocs, nprocstr,
     $ myatm1, myatm2, myj0, maxmatpr, mymatpr,
     $ matstr,
     $ norb,nk,ncplx, natm,ntyp,itypa, norba )
c      nmatpr = mymatpr*ncplx*nk
      matpr = mymatpr*ncplx
c
c      if( nprocstr.le.1 ) goto 900
c
c Master will start sending AFTER its own allotment:
c      jjnext = matpr
c
c      ij_send_offset=1
      ij_send_offset=1
      do 1000 jproc=0, nprocstr-1
         if(REFERENCE_IMPLEMENTATION) then

            if(iproc.eq.jproc) then
c Receiving process sends how much data it needs unless it is also the master process.
               lenmsg=1
               if(iproc.ne.master) then
                  call MPSENDI(master, lenmsg, matpr, icomm)
               else
                  ij_recv_offset=ij_send_offset
               endif
            endif

            if(iproc.eq.master) then
c Master process receives the length of the data it needs to send and sends it.
               lenmsg=1
               if(iproc.ne.jproc) then
                  call MPRECVI(jproc, lenmsg, matjpr, icomm)
                  lenmsg=matjpr
                  call MPSENDR8(jproc, lenmsg,
     $                 dmatstrbuf(ij_send_offset), icomm)
               endif
               ij_send_offset=ij_send_offset+matjpr
            endif

            if(iproc.eq.jproc) then
               lenmsg=matpr
               if(iproc.ne.master) then
c If receiving process is not the master get the data from the master
                  ij_recv_offset=1
                  call MPRECVR8( master, lenmsg,
     $                 dmatstrbuf(ij_recv_offset),
     $                 icomm )
               endif

c Receiving process puts the data in the correct place in local memory.
               ioffset=ik
               do ij3=0, matpr-1
                  dmatstr(ioffset)=dmatstrbuf(ij_recv_offset+ij3)
                  ioffset=ioffset+nk
               end do

            endif
         else
c     
            if( iproc.eq.master )then
c    Find length of stripe to be sent from master to jproc
               call MATLOCSTR( jproc, nprocs, nprocstr,
     $              jatm1,  jatm2, jpj0, maxmatpr, jmatpr ,
     $              matstr,
     $              norb, nk, ncplx, natm, ntyp, itypa, norba )
               matjpr = jmatpr*ncplx
               if(jproc.ne.master) then
c     Destination (jproc) is not master, do a send operation.
                  lenmsg = matjpr
                  call MPSENDR8( jproc, lenmsg,
     $                 dmatstrbuf(ij_send_offset),
     $                 icomm )
               else
c   Destination is on master, so the master only needs to know where the 
c   data starts to unpack it below. (jproc.eq.master)
                  ij_recv_offset=ij_send_offset
                  lenmsg = matjpr
               endif
c   Increment send offset to next block of data for next pass.
               ij_send_offset = ij_send_offset + matjpr
            endif
c
c   Receive this stripe if this is the destination
c
            if( iproc.eq.jproc )then
c   Do receive operation if I'm not the master. Can use all of dmatstrbuf.
               if(iproc.ne.master) then
                  ij_recv_offset=1
                  lenmsg = matpr
                  call MPRECVR8( master, lenmsg,
     $                 dmatstrbuf(ij_recv_offset),
     $                 icomm )
               endif
c     Put the stripe in its proper location on this processor
c     in dmatstr. This is just starting at offset = ik and strided by nk.

               ioffset=ik
               do ij3=0, matpr-1
                  dmatstr(ioffset)=dmatstrbuf(ij_recv_offset+ij3)
                  ioffset=ioffset+nk
               end do
c     
            endif
c     
         endif
 1000 continue
c
  900 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLABCHRG
c
c
      subroutine SLABCHRG( ion_opt,ndim,
     $ elchrg, origws, zchrglm,zchrgcc,
     $ dipole,rdipole,  esion,vacplus,
     $ rprim, n1r,n2r,n3r,  hh, weight, ndbox,nbox,
     $ rhlmcc, vlmcc, r )
c---------------------------------------------------------------
c Purpose: Apply above-surface slab counter-charge plane to
c          balance charge, compute dipole potential from dipole
c          planes and remove the surface charge from the density.
c
c Written: Peter A. Schultz, 22-February-2011 (for 2.62)
c          (Initial version adapted from DIPSLAB---nuetral slab)
c
c Revision history:
c  14Sep11-PAS/2.62: finally debugged and consistent with DIPSLA
c---------------------------------------------------------------
c
c  Notes:
c   Construct a pair of one-dimensional Gaussian planes:
c   one at the centroid (zchrglm) of the net charge on the slab
c   and a counter-charge plane at specified point (zchrgcc) in vacuum.
c   Compute the full LMCC dipole potential here.
c   Compute the net charge plane to neutralize the slab net charge.
c
c   Extends method set out in: P.A.Schultz, PRB 60, 1551 (1999),
c   which describes the construction of a dipole potential
c
c   Key assumption: z-axis is surface normal
c
c   Makes no checks if choices of counterslab positions are sensible
c
c   Should be merged with DIPSLAB after code is vetted.
c
c  NB: ASSUMPTION INTO CODE THAT Z_VECTOER IS SLAB NORMAL
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  (zero=0.d0,half=0.5d0,one=1.d0,two=2.d0)
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
      COMMON  /CONST/ pi,rtpi,cutexp
c
c Input arrays:
      DIMENSION  dipole(3), rdipole(3)
      DIMENSION  origws(3)
c
      DIMENSION  zchrglm(3), zchrgcc(3)
c  unit cell vectors, and grid generating basis vectors
      DIMENSION  rprim(3,3), hh(3,3)
      DIMENSION  ndbox(2,2,3)
c Output arrays:
c  lmcc slab dipole density, and associated electrostatic potential:
      DIMENSION  rhlmcc(*),vlmcc(*)
c
c Scratch arrays:
      DIMENSION  r(3,*)
c
c Local declarations:
      LOGICAL    ingaus
      DIMENSION  r0box(3),boxctr(3)
      DIMENSION  origlm(3), rvec3(3), gg(3,3)
      DIMENSION  nro(3),nrx(3)
cdef  Not ready for prime time yet, but getting ready ...
      PARAMETER  (nlmd=2)
      DIMENSION  ilmq(nlmd), qlmcc(nlmd), zlmcc(nlmd)
c
      DATA  four / 4.d0 /
c
c   Parameters for slab lmcc:
      DATA  alflmcc / 0.30d0 /, dzlmcc / 1.5d0 /
      DATA  zlmaxdif / 10.0d0 /
c      alflmcc = Gaussian exponent for dipole charges
c      dzlmcc  = z-offset from dipole center for lmcc gaussian planes
c      zlmaxdif = largest jump in slab charge plane
c   These are adjustable parameters, constrained by the need to be ...
c    ... small enough to be well integrable on any reasonable grid
c    ... but large enough to be contained within any viable unit cell
c
c >>>> EXECUTABLE CODE:
c
      esion = zero
      vacplus = zero
c
c Routine is for charged slab, with planar countercharge
c
cxxx:start
      call FLGETIWR( IWR )
      write(IWR,*) 'DBG/SLABCHRG: ====== elchrg,ion_opt=',elchrg,ion_opt
  913 format(1x,'  SLABQ: ',a,6f12.6)
cxxx:end
      if( elchrg .eq. zero ) RETURN
      if( ndim.ne.2 .or. IABS( ion_opt ) .ne. 3 ) RETURN
c
      qgaus = -elchrg
c
c Set up some constants 
      fourpi = four*pi
      rtalf = SQRT( alflmcc )
      alfdpi = alflmcc / pi
c
c Compute slab normal vector
      call CROSS( rprim(1,1),rprim(1,2), rvec3 )
      area = SQRT( rvec3(1)**2 + rvec3(2)**2 + rvec3(3)**2 )
      vol = rvec3(1)*rprim(1,3) + rvec3(2)*rprim(2,3)
     $    + rvec3(3)*rprim(3,3)
      if( vol .lt. zero )then
        rvec3(1) = -rvec3(1)
        rvec3(2) = -rvec3(2)
        rvec3(3) = -rvec3(3)
      endif
      rvec3(1) = rvec3(1)/area
      rvec3(2) = rvec3(2)/area
      rvec3(3) = rvec3(3)/area
c
c Project dipoles and grid spacing onto slab normal (z-vector)
      z0dipole = rvec3(1)*rdipole(1) + rvec3(2)*rdipole(2)
     $         + rvec3(3)*rdipole(3)
      zhh = rvec3(1)*hh(1,3) + rvec3(2)*hh(2,3) + rvec3(3)*hh(3,3)
c
      dipolez = rvec3(1)*dipole(1) + rvec3(2)*dipole(2)
     $        + rvec3(3)*dipole(3)
cxxx:start
      write(IWR,913) 'dipole=',dipole
      write(IWR,913) 'dipolez(revc3.dipole)=',dipolez
cxxx:end
      dipzmag = ABS( dipolez )
c
c Determine z-location of charge in slab, for local moment charge
      ilmq(1) = 1
      zgauslm = origws(3) + dipolez / qgaus
cxxx:start
      write(IWR,913) 'old zlm zchrglm=',(zchrglm(i),i=1,3)
      write(IWR,913) 'new zlm zgauslm=',zgauslm
cxxx:end
      zlmdif = zgauslm - zchrglm(3)
      if( ABS( zlmdif ) .gt. zlmaxdif )then
c       Regulate this to make it more stable
        zgauslm = zchrglm(3) + zlmaxdif*( zlmdif/ABS(zlmdif) )
        write(IWR,913) 'regulated zlm zgauslm=',zgauslm
      endif
      zchrglm(1) = zero
      zchrglm(2) = zero
      zchrglm(3) = zgauslm
c Load z-location of countercharge plane (xxx worry about offset)
      ilmq(2) = 0
      zgauscc = zchrgcc(3)
c
c----------------------------------------------------------------------
c  Slab system has a charge.
c  Construct one lmcc density plane for slab charge, with potential
c  Construct potential (no density) from second counterdensity plane in vacuum
c----------------------------------------------------------------------
c
c Hijack vetted DIPSLAB machinery to better ensure code works
      z0dipole = ( zgauslm + zgauscc ) / two
      dzlmcc = zgauslm - z0dipole
cxxx:start dev debug diagnostics
      call FLGETIWR( IWR )
      write(IWR,913) 'z_lm,z_cc=',zgauslm,zgauscc
      write(IWR,913) 'z0_lm,dz_lm=',z0dipole,dzlmcc
      write(IWR,913) '  qgaus=',qgaus
      write(IWR,913) '  dipolez,dipzmag=',dipolez,dipzmag
      rhlmsum = 0.d0
      nptslm = 0
cxxx:end
c
c Get range of lmcc Gaussians on the grid:
      rngalf = SQRT( cutgrid/alflmcc )
c
      call CROSS( hh(1,2),hh(1,3), gg(1,1) )
      call CROSS( hh(1,3),hh(1,1), gg(1,2) )
      call CROSS( hh(1,1),hh(1,2), gg(1,3) )
      do  j=1,3
        gmag = SQRT( gg(1,j)**2 + gg(2,j)**2 + gg(3,j)**2 )
        gg(1,j) = gg(1,j)/gmag
        gg(2,j) = gg(2,j)/gmag
        gg(3,j) = gg(3,j)/gmag
      enddo
c
      do  id=1,3
        rhh = ABS( gg(1,id)*hh(1,id) + gg(2,id)*hh(2,id)
     $           + gg(3,id)*hh(3,id) )
        rnx = rngalf/rhh + half
        nrx(id) = rnx
      enddo
c
c  Branch to correct location:
c
      if( IABS( ion_opt ) .eq. 3 )then
c
c      ***** Slab system *****
c
       ilmgaus = 0
       pole = one
c      Do ign weidity to align internals of loop with dipslab
       qgaus = -qgaus
       zgauspole = zgauslm
 2100   continue
c       Start with negative-z pole of dipole, then switch to z(+)
        ilmgaus = ilmgaus + 1
        pole = -pole
        qgaus = -qgaus
c
c       First, offset gaussian pole from center of neutralizing dipole:
C        zgaus = - z0dipole - pole*(dipolez/dipzmag)*dzlmcc
        zgaus = -zgauspole
        zgauspole = zgauscc
c
        nro(3) = (-zgaus/zhh) + half + one
c
        ic1 = nro(3) - nrx(3)
        icn = nro(3) + nrx(3)
        if( ic1.lt.1 ) ic1 = 1
        if( icn.gt.n3r ) icn = n3r
c
        gcoef = qgaus* SQRT( alfdpi ) / area
c       Coefficients for gaussian and error function terms
        vgcoef = -gcoef*fourpi / alflmcc
        vecoef = -gcoef*fourpi / SQRT( alfdpi )
c
        origlm(1) = zero
        origlm(2) = zero
        origlm(3) = zgaus
c
cxxx:start
      rhlmtot = 0.d0
      velmtot = 0.d0
      nboxin = 0
cxxx:end
        esiongr = zero
        esioncc0 = zero
        esioncc = zero
        irpot = 0
        do 2250 ibox=1,nbox
c
c         Get basic box info
          call INDBOX( ibox, ndbox, iboxa,iboxb,iboxc,
     $     ira0,irb0,irc0, idra,idrb,idrc )
          nrbox = idra*idrb*idrc
c
          iv0 = irpot
          irpot = irpot + nrbox
c
          ingaus = .true.
          if( (irc0+idrc).lt.ic1 .or. icn.le.irc0 ) ingaus = .false.
c
c         Generate coordinates of points within box
          call BOXR( hh,ira0,irb0,irc0, idra,idrb,idrc, r0box,boxctr )
          r0box(1) = r0box(1) + origlm(1)
          r0box(2) = r0box(2) + origlm(2)
          r0box(3) = r0box(3) + origlm(3)
          call MKRBOX( hh,r0box, idra,idrb,idrc, r )
c
          if( ingaus )then
c           This box is within the gaussian range
c
c           Turn off lm density for off-slab countercharge
cxxx:
       nboxin = nboxin + 1
            rhcoef = gcoef
            if( ilmq(ilmgaus) .eq. 0 ) rhcoef = zero
            do  nr=1,nrbox
              zval = r(3,nr)
              zmag =  ABS( zval )
              zsq = zmag*zmag
              expaz2 =  EXP( -alflmcc*zsq )
cxxx:
C              rhadd = rhcoef* EXP( -alflmcc*zsq )
              rhadd = rhcoef* expaz2 
C              vadd = vgcoef* EXP( -alflmcc*zsq )
              vadd = vgcoef* expaz2
     $         + vecoef*zmag*DERF( rtalf*zmag )
cxxx:
       rhlmtot = rhlmtot + rhadd
       velmtot = velmtot + vadd
       esioncc0 = esioncc0 + rhlmcc(iv0+nr)*vadd
       esioncc = esioncc + (gcoef*expaz2)*vlmcc(iv0+nr)
              rhlmcc(iv0+nr) = rhlmcc(iv0+nr) + rhadd
              vlmcc(iv0+nr) = vlmcc(iv0+nr) + vadd
              esiongr = esiongr + vlmcc(iv0+nr)*rhlmcc(iv0+nr)
            enddo
          else
c           Outside gaussian range, asymptotic potential
c
            do  nr=1,nrbox
              zval = r(3,nr)
              zmag =  ABS( zval )
              rhadd = zero
              vadd = vecoef*zmag
       esioncc0 = esioncc0 + rhlmcc(iv0+nr)*vadd
              vlmcc(iv0+nr) = vlmcc(iv0+nr) + vadd
              esiongr = esiongr + vlmcc(iv0+nr)*rhlmcc(iv0+nr)
            enddo
          endif
c
c         Close loop over boxes
 2250   continue
c
c       Compute self-energy of dipole on grid:
        esiongr = weight*esiongr/two
cxxx
        esioncc0 = weight*esioncc0 / two
        esioncc = weight*esioncc / two
c
        esion = esiongr
cxxx:
      write(IWR,913) '  q_gaus,z_gaus= ',qgaus,zgaus
      write(IWR,*) '   DBG/SLABQ: rhlmtot,vlmtot,nboxin',
     $ rhlmtot*weight,velmtot*weight, nboxin
CC      write(IWR,913) 'DBG: aft, vgeof,vecoef=',vgcoef,vecoef
c
       if( pole.lt.zero ) goto 2100
c
c      Compute asymptotic vacuum potential (due to dipole)
       vacplus = -vecoef*two*dzlmcc*(dipolez/dipzmag)
c      Add dble layer energy into (minus sign due to attractive dipole).
cxxx: this sign is problematic ....
       esion = esion + esioncc0
cxxx:
       write(IWR,913) 'dipole vacuum offset vacplus=',vacplus
       write(IWR,913) 'esiongr,esioncc,esion(Ry)=',
     $  esiongr,esioncc0,esion
C       write(IWR,*) 'Vacuum(-z),vacuum(+z)[Ry]=', -vacplus, vacplus
c
      endif
cxxx:start
C      call GRIDAVE( IWR, n1r,n2r,n3r, 1, rhlmcc, ave, r, 'RHLMCC' )
C      call GRIDAVE( IWR, n1r,n2r,n3r, 1, vlmcc, ave, r, 'VLMCC' )
      write(IWR,*) 'DBG/SLABCHRG =========== end slabchrg ==========='
cxxx:end
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ZPOTOUT
c
c
      subroutine ZPOTOUT( igridfl,IWRT,
     $ iatmfmt, ntyp,natm, natmnm, itypa, atmnm,typnm, ratm,
     $ nspin, hh, n1r,n2r,n3r,nptr,
     $ wkz, delrho, delves )
c---------------------------------------------------------------
c Purpose: output plane(z)-averaged potential and density
c
c Written: P.A. Schultz, 2011, for qDFT-flDFT coupling prep in 2.62
c          12-january-2011
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c On input:
c   igridfl > 0 - read density and potential from disk file
c           else, use density and potential as passed
c   IWRT    > 0 - write analysis to file unit = IWRT
c           else, do not write analysis
c   hh(3,3)     = basis vectors for real-space grid
c   n1r,n2r,n3r = linear dimensions of grid
c   nptr        = total number of grid points (=n1r*n2r*n3r)
c   wkz()    = scratch workspace, of at least wkz(n3r) size
c   delrho() = delta density on grid, implicit dims(n1r,n2r,n3r)
c   delves() = electrostatic potential, implicit dims(n1r,n2r,n3r)
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  (zero=0.d0, one=1.d0)
c
c Input arrays:
c   ... atomic positions
      DIMENSION  itypa(*)
      CHARACTER*(*)  typnm, atmnm
      DIMENSION  typnm(*), atmnm(*)
      DIMENSION  ratm(3,natm)
c   ... potentials
      DIMENSION  hh(3,3)
      DIMENSION  delrho(nptr), delves(nptr)
c
c Scratch arrays:
      DIMENSION  wkz(*)
c
c Local declarations:
      DIMENSION  ave(2)
c
c >>>> EXECUTABLE CODE:
c
      if( IWRT .le. 0 ) RETURN
c
c  If input not loaded, get the density and potential from disk file
c
      if( igridfl .ge. 0 )then
c       Retrieve the density and potential from the grid file
        REWIND( unit=igridfl )
c
c       Retrieve converged grid delta density from igridfl
c
c       Read delta-rho (total, or up-spin if spin-polarized)
        call READBIG( igridfl, nptr, delrho )
        if( nspin .eq. 2 )then
c         Read dn-spin delta-rho and sum into up-delrho to get total delta-rho
          call READBIG( igridfl, nptr, delves )
          call DAXPY( nptr, one, delves,1, delrho,1 )
        endif
c
c       Read the delta-electrostatic potential
        call READBIG( igridfl, nptr, delves )
      endif
c
c  Do the analysis and send it to output
c
      if( IWRT .ge. 0 )then
c       Output the density to the specified file:
c
        write(IWRT,*) '### ATOM POSITIONS: name, type, x,y,z (Bohr) ###'
        call CONFIGWR( IWRT   , iatmfmt, natmnm, ntyp,typnm,
     $   natm, atmnm, itypa, ratm )
c
        write(IWRT,*) '##### Z-AVERAGE DENSITY and POTENTIAL #####'
        write(IWRT,'(a/f10.7,a)') 'spacing of points',hh(3,3),' Bohr'
        write(IWRT,'(a/i6)') 'number of points in z-direction',n3r
        call GRIDAVE( IWRT,
     $   n1r,n2r,n3r, 1,delrho,ave, wkz, 'del-density (e/bohr^3)')
        call GRIDAVE( IWRT,
     $   n1r,n2r,n3r, 1,delves,ave, wkz, 'electrostatic del-Ves (Ry)')
      endif
c
      write(IWRT,*) '##### END Z-AVERAGE DENSITY and POTENTIAL #####'
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPARALLEL
c
c
c###############################################################
c Purpose: manage the k-parallel stuff
c
c Written: Peter A. Schultz, 22-November-2008, for 2.63
c
c Revision history:
c  Apr12-ACP&PAS/2.63: add stuff to enable k-parallel in scf
c###############################################################
c Notes on KPARALLEL
c  Processor allocations in each k-point are contiguous ranks,
c  as are the sets of ranks through the k-points
c
c  The strategy implemented here is to do as even a distribution
c  as possible. If perfect balance is not possible, allocate
c  the lighter load to the early processors, so that the image
c  master that sits in the early block is assured of doing
c  no more work (and perhaps less) than any other processor,
c  and thereby hide some of its extra tasks behind others' compute.
c
c
c  We have two possibilities nproc<nk, and nproc>nk.
c  With nproc<nk, if nk is not exactly divisible by nproc,
c    then each later proc gets one assigned one more k-point than
c    each early proc.
c  With nk<nproc, if nproc is not exactly divisible by nk,
c    then each later k-point gets one FEWER proc assigned to it
c    then each earlier k-point (i.e., with more procs/k in the
c    early k-points and procs, they finish more quickly).
c
c Module data: KPSTUFF - manages nature of k-parallelism
c  kparopt - flag that specifies nature of k-parallelims
c  Note: (1) KPSTUFF should probably also record the paramemters that
c            define the k-parallelism (e.g., nkloc, nk0, kpmaster ...)
c        (2) KPSTUFF might be better located folded into MPSTUFF, which
c            already manages the (more coarse) aspects of parallelism
c
c Public routines:
c  KPFLAG_SET - set flags controlling k-parallel operation
c  KPFLAG_GET - get flags controlling k-parallel operation
c  KPBETTER   - evaluate whether k-parallel is good enough
c  KPEFFIC    - computes computational efficiency of k-parallel (ideal)
c  KPDEFINE   - assignments defining k-parallel distribution
c  KPMASTER   - returns rank (local/image) of master of given k-point
c  KPWHERE    - returns range of processor ranks owning given k-point
c  KPSYNC()   - a sync to allow k-masters to catch up to their clients
c
c Public routines for development purposes
c  KPARMERGE - merge all k-hams onto master from k-masters
c  KPARDISTR - distribute k-hams onto k-masters from master
c
c###############################################################
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPFLAG_SET
c
c
      subroutine KPFLAG_SET( kparoptp )
      IMPLICIT NONE
      integer kparoptp
      integer kparopt
c
      COMMON  /KPSTUFF/ kparopt
c
      kparopt = kparoptp
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPFLAG_GET
c
c
      
      subroutine KPFLAG_GET( kparoptp )
      IMPLICIT NONE
      integer kparoptp
      integer kparopt
c
      COMMON  /KPSTUFF/ kparopt
c
      kparoptp = kparopt
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPBETTER
c
c
      subroutine KPBETTER( nk, kparopt )
c---------------------------------------------------------------
c Purpose: unless dictated, decide k-parallel cf. efficiency
c---------------------------------------------------------------
c
      IMPLICIT NONE
c Input:
      INTEGER  nk
c Input/Output:
      INTEGER  kparopt
c Local:
      DOUBLE PRECISION  effic
      INTEGER  nprocs
      INTEGER  idokpar
      DATA     idokpar / -2 /
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nprocs )
C      call KPFLAG_GET( kparopt )
      if( nprocs.eq.1 .or. nk.eq.1 )then
c       There is no option, must be standard task-parallel
        kparopt = -1
C        call KPFLAG_SET( kparopt )
        goto 900
      endif
      if( kparopt .ne. 0 )then
c       This has been decided/dictated earlier
        goto 900
      endif
c
c Return efficiency of a k-parallel scheme vs. all task-parallel
      call KPEFFIC( effic, nk,nprocs )
c
c Now decide whether k-parallel is likely to outperform
c  a standard all-parallel, based on expected efficiencies.
c
      if( nprocs.le.4 )then
c       On 4 procs, typically get >75% from all-par, ask more from kpar
        if( effic .gt. 0.89d0 ) kparopt = idokpar
c
      elseif( nprocs.le.8 )then
c       On 8 procs, can get as much as 75% from all-par, ask more from kpar
        if( effic .gt. 0.79d0 ) kparopt = idokpar
c
      elseif( nprocs .le. 12 )then
c       On 12 procs, can get as much as 66% from all-par, ask more from kpar
        if( effic .gt. 0.74d0 ) kparopt = idokpar
c
      elseif( nprocs .le. 16 )then
c       On 2^4=16 proc, can get as much as 50% from all-par, ask more from kpar
        if( effic .gt. 0.66d0 ) kparopt = idokpar
c
      else
c       More than 16 processors, compel k-parallel
        kparopt = idokpar
c
      endif
C      call KPFLAG_SET( kparopt )
c
  900 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPEFFIC
c
c
      subroutine KPEFFIC( effickp, nk,nprocs )
c---------------------------------------------------------------
c Purpose: compute ideal efficiency of k-parallel scheme
c---------------------------------------------------------------
c
      IMPLICIT NONE
c Input:
      INTEGER  nk,nprocs
c Output:
      DOUBLE PRECISION  effickp
c Local:
      INTEGER  kpernbig, nperksml
      DOUBLE PRECISION  effic, wkldallp,wkldkpar, speedap,speedkp
c
c >>>> EXECUTABLE CODE:
c
      if( nk .ge. nprocs )then
c       Nprocs < nk, everyone gets their own k-points
c
c       Compare workload (#k/proc) of all-parallel proc vs. k-parallel busiest proc
        kpernbig = ( nk + nprocs - 1 ) / nprocs
        wkldallp = DBLE( nk ) / DBLE( nprocs )
        wkldkpar = DBLE( kpernbig )
c
        effic = wkldallp / wkldkpar
      else
c       Nprocs > nk, multiple nprocs per k-point
        kpernbig = 1
c
c       Compare speed (# procs/k) of all-p kpts vs. k-parallel fewest-node k-point
        nperksml = nprocs / nk
        speedap = DBLE( nprocs ) / DBLE( nk )
        speedkp = DBLE( nperksml )
c
        effic = speedkp / speedap
      endif
c
      effickp = effic
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPSETUP
c
c
      subroutine KPSETUP( nk, kparopt )
c---------------------------------------------------------------
c Purpose: set up k-parallel communicators
c---------------------------------------------------------------
c
c From input parameter ...
c  nk      = number of nk-points for this problem
c  kparopt = flag that determines type of k-parallism
c          = -2 => turn k-parallel ON
c          = -1 => keep k-parallel OFF
c          =  0 => defer choice to code
c
c   ... set the following output parameters:
c  nk0      = 0-index of k-pts assigned to this proc, in global nk
c  nkloc    = number of k-points assigned to this node
c  nklocmax = maximum number of k-points assigned to any processor
c
c   ... and set up the communicators
c
      IMPLICIT NONE
c Input:
      INTEGER  nk, kparopt
c Output:
      INTEGER  nk0,nkloc,nklocmax
c Local:
      INTEGER  nprocs, iproc, icomm
      INTEGER  icolorkp
c
c >>>> EXECUTABLE CODE:
c
c Check that KP has not already been initialized
      if( kparopt .gt. 0 ) RETURN
c
      call KPBETTER( nk, kparopt )
c
      if( kparopt .eq. -2 )then
        call MPNODES( nprocs )
        call MPNODE( iproc )
c       Define processor groups for k-parallel distribution
        call KPDEFINE( nk,nprocs,iproc,
     $   nklocmax,nkloc,nk0, icolorkp )
c
c       Create split communicators along "colors" defined by k-points
        call MPSPLITICOMM( icolorkp )
c
c       Now that kparallel is set up, set kparopt = 2 (k-parallel)
        kparopt = 2
      elseif( kparopt .eq. 0 .or. kparopt .eq. -1 )then
c       No k-parallel, set kparopt = 1 (not k-parallel)
        kparopt = 1
      else
        call STOPXERR( 'KPSETUP: kparopt is wrong' )
      endif
c
      call KPFLAG_SET( kparopt )
c        
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPDEFINE
c
c
      subroutine KPMINE( nk,nkloc,nk0 )
c---------------------------------------------------------------
c Purpose: for this processor, get assignment
c---------------------------------------------------------------
c
c From input parameters ...
c  nk     = number of nk-points for this problem
c  nprocs = total number of processors for this image
c  iproc  = rank of this particular processor in the image
c
c ... determine following output parameters:
c  nkloc    = number of k-points assigned to this node
c  nk0      = 0-index of k-pts assigned to this proc, in global nk
c  
      IMPLICIT NONE
c Input:
      INTEGER  kparopt, nk
c Output:
      INTEGER  nklocmax,nkloc,nk0, icolorkp
c Local:
      INTEGER  nprocs, iproc
      INTEGER  kpernbig,kpernsml, nsmlprocs
      INTEGER  nperkbig,nperksml, lastbigk,lastbign
c
c >>>> EXECUTABLE CODE:
c
c Default is standard all-parallel:
      nk0 = 0
      nkloc = nk
      call KPFLAG_GET( kparopt )
c
      if( kparopt.eq.2 )then
c       Get id of this proc in image
        call MPNODES( nprocs )
        call MPNODE( iproc )
c       Get the k-parallel distribution
        call KPDEFINE( nk,nprocs,iproc,
     $   nklocmax,nkloc,nk0, icolorkp )
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPDEFINE
c
c
      subroutine KPDEFINE( nk,nprocs,iproc,
     $ nklocmax,nkloc,nk0, icolorkp )
c---------------------------------------------------------------
c Purpose: define k-parallel distribution
c---------------------------------------------------------------
c
c From input parameters ...
c  nk     = number of nk-points for this problem
c  nprocs = total number ofprocessors for this problem
c  iproc  = rank of this particular processor
c
c ... determine following output parameters:
c  nklocmax = maximum number of k-points assigned to any processor
c  nkloc    = number of k-points assigned to this node
c  nk0      = 0-index of k-pts assigned to this proc, in global nk
c  icolorkp = communicator grouping for this processor
c  
      IMPLICIT NONE
c Input:
      INTEGER  nk, nprocs, iproc
c Output:
      INTEGER  nklocmax,nkloc,nk0, icolorkp
c Local:
      INTEGER  kpernbig,kpernsml, nsmlprocs
      INTEGER  nperkbig,nperksml, lastbigk,lastbign
c
c >>>> EXECUTABLE CODE:
c
      if( nk .ge. nprocs )then
c       Nodes < nk, everyone gets their own k-points
c
c       Every proc in their own group (k-local comm):
        icolorkp = iproc + 1
c
        kpernbig = ( nk + nprocs - 1 ) / nprocs
        kpernsml = kpernbig - 1
        nsmlprocs = nprocs*kpernbig - nk
c
        if( iproc .lt. nsmlprocs )then
c         Proc is small-nk, use 0-index iproc:
          nk0 = kpernsml*iproc
          nkloc = kpernsml
        else
          nk0 = kpernbig*iproc - nsmlprocs*(kpernbig-kpernsml)
          nkloc = kpernbig
        endif
        nklocmax = kpernbig
c
      else
c       Nprocs > nk, every proc only 1 k-point, each kpt maybe multiple procs
c
        nkloc = 1
        nklocmax = 1
        nperkbig = ( nprocs + nk - 1 ) / nk
        nperksml = nperkbig  - 1
        lastbigk = nprocs - nperksml*nk
        lastbign = lastbigk * nperkbig
c
        if( iproc .lt. lastbign )then
c         Proc is in first block of k-points with more procs/k
          nk0 = iproc / nperkbig
        else
c         Proc is in second block of k-points with less procs/k
          nk0 = lastbigk + ( iproc - lastbign ) / nperksml
        endif
c
c       The proc groups (k-local comms) segregated by k-point:
        icolorkp = nk0 + 1
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPMASTER
c
c
      subroutine KPMASTER( nk,nprocs, k,kmasterpr )
c---------------------------------------------------------------
c Purpose: identify parallel distribution
c---------------------------------------------------------------
c
c     nk = number of global k-points
c nprocs = number of (local comm) procs serving this image with nk
c      k = k-point for which the k-local master is desired
c kmasterpr = rank in local comm for k-local master of k-point
c
      IMPLICIT NONE
c Input:
      INTEGER  nk, nprocs
      INTEGER  k
c Output: 
      INTEGER  kmasterpr
c
c Local:
      INTEGER  kparopt
      INTEGER  kproc
      INTEGER  nkloc
      INTEGER  kpernbig,kpernsml, nsmlprocs
      INTEGER  nperkbig,nperksml, lastbigk
c
c >>>> EXECUTABLE CODE:
c
c Note: the following assumes proc ranks (iproc) are 0-indexed
c
      call KPFLAG_GET( kparopt )
c
      if( kparopt.eq.2 )then
c       If k-parallel is ON ...
c
      if( nk .ge. nprocs )then
c       Nodes < nk, everyone got their own k-points
c
        kpernbig = ( nk + nprocs - 1 ) / nprocs
        kpernsml = kpernbig - 1
        nsmlprocs = nprocs*kpernbig - nk
c
        if( k .le. nsmlprocs*kpernsml )then
c         Proc owning this k-point is in small-nkloc early block of procs
          nkloc = kpernsml
          kproc = ( k - 1 ) / kpernsml
        else
c         Proc owning this k-point is in big-nkloc later block of procs
          nkloc = kpernbig
          kproc = ( k + nsmlprocs - 1 ) / kpernbig
        endif
c
      else
c       Nprocs > nk, every proc only 1 k-point, each kpt maybe multiple procs
c
        nkloc = 1
c
        nperkbig = ( nprocs + nk - 1 ) / nk
        nperksml = nperkbig - 1
        lastbigk = nprocs - nperksml*nk
c
        if( k .le. lastbigk )then
c         This k-point is in big-proc early block of k-points
          kproc = ( k - 1 ) * nperkbig
        else
c         This k-point is in small-proc later block of k-points
          kproc = lastbigk*nperkbig  + ( k - lastbigk - 1 ) * nperksml
        endif
c
      endif
c
      kmasterpr = kproc
c
      else
c       If k-parallel is OFF, the image master is k-master
        CALL MPNODE0( kmasterpr )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPWHERE
c
c
      subroutine KPWHERE( nk, ik, iproc_min, iproc_max )
c---------------------------------------------------------------
c Purpose: Find ranks of processors in the current image that
c          hold the k-point ik.
c---------------------------------------------------------------
c
c From input parameters ...
c  nk     = number of nk-points for this problem
c  ik     = ith k-point (1,...,nk)
c Output parameters
c  Determine rank(s) of processes
c    iproc_min  = lowest rank process
c    iproc_max  = highest rank process
c  where iproc_min.le.iproc_max.
c
      IMPLICIT NONE
c
c Input:
      INTEGER  nk, ik
c Output:
      INTEGER  iproc_min, iproc_max
c Local:
c     nprocs = total number of processors in this image
      INTEGER  kparopt
      INTEGER  nprocs, iproc
      INTEGER  kpernbig, kpernsml, nsmlprocs
      INTEGER  nperkbig, nperksml, lastbigk
c
c >>>> EXECUTABLE CODE:
c
      call MPNODES( nprocs )
      call KPFLAG_GET( kparopt )

      if( kparopt.eq.2 )then
c       If k-parallel is ON, then determine where ik is located
c
      if( nk .ge. nprocs )then
c
c       Nodes < nk
c       Oonly one process for each k.
c
        kpernbig = ( nk + nprocs - 1 ) / nprocs
        kpernsml = kpernbig - 1
        nsmlprocs = nprocs*kpernbig - nk
c
        if( ik .lt. nsmlprocs*kpernsml )then
          iproc = (ik-1) / kpernsml
        else
          iproc = nsmlprocs + (ik-nsmlprocs*kpernsml) / kpernbig
        endif
        iproc_min = iproc
        iproc_max = iproc
c
      else
c
c       Nprocs > nk
c       Every proc only 1 k-point, each k-pt might be on multiple procs.
c
c       let a= int(nprocs/nk). b=remainder(nprocs/nk)
c       nperkbig = a if b=0, a+1 if b>0.
        nperkbig = ( nprocs + nk - 1 ) / nk
c       nperksml = a-1 if b=0, a if b>0
        nperksml = nperkbig  - 1
c       lastbigk = nk if b=0, b if b>0
        lastbigk = nprocs - nperksml*nk
c
        if( ik .le. lastbigk )then
c         The lower k have an extra process assigned to them.
          iproc_max = ik*nperkbig - 1
          iproc_min = iproc_max - nperkbig + 1
        else
          iproc_max = lastbigk*nperkbig + (ik-lastbigk)*nperksml - 1
          iproc_min = iproc_max - nperksml + 1
        endif
c
      endif
c
      else
c       If k-parallel if OFF, then ik resides on all processors of image
        call MPNODE0( iproc_min )
        call MPNODES( iproc_max )
        iproc_max = ( iproc_max - 1 ) + iproc_min
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPSYNC
c
c
      subroutine KPSYNC()
c---------------------------------------------------------------
c Purpose: synch clients to their KPMASTER
c
c Written: Peter A. Schultz, 18-April-2012 f0r 2.63 (k-parallel)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c Input:
      INTEGER  kparopt
c Local:
      INTEGER  nprocl
      INTEGER  nproc_k, master_k, iproc_k, icomm_k
      INTEGER  r4msg
c
      call MPNODES( nprocl )
      if( nprocl .eq. 1 ) RETURN
c
      call KPFLAG_GET( kparopt )
      if( kparopt .eq. 2 )then
c       Get k-local MP info
        call MPNODES_K( nproc_k )
        if( nproc_k .gt. 1 )then
          call MPNODE0_K( master_k )
          call MPNODE_K( iproc_k ) 
          call MPCOMM_K( icomm_k ) 
c
c         Use a bcast from the master to synch clients to k-master
          r4msg = 0.0
          call MPBCAST4( master_k, 1, r4msg, icomm_k )
        endif
      endif
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPARMERGE
c
c
      subroutine KPARMERGE( norb,nk, vijk )
c---------------------------------------------------------------
c Purpose: merge k-parallel Hams from kmasters onto image master
c
c Written: Peter A. Schultz,  4-December-2008, for 2.63 (k-parallel)
c
c Revision history:
c   4Dec08-PAS/2.63: pushed down from vslomat
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c Input: nk=global k-pts, nkloc=local number of k-pts
      INTEGER    norb, nk,nkloc
c Input/Output
      DOUBLE PRECISION  vijk
      DIMENSION  vijk(norb*norb,*)
c
c Local declarations:
      INTEGER    kparopt
      INTEGER    nprocl,masterl,iprocl,icomml, master,nprocs,iproc
      INTEGER    nk0, k,ikloc,  kmasterpr
      INTEGER    mat, lenmsg
c
c  For k-parallel, send all the k-resolved matrices to image master
c
      call KPFLAG_GET( kparopt )
      if( kparopt .eq. 2 )then
c       Get image/local MP info
        call MPNODES( nprocl )
        call MPNODE0( masterl )
        call MPNODE( iprocl )
        call MPCOMM( icomml )
c       Get k-local MP info
        call MPNODES_K( nprocs )
        call MPNODE0_K( master )
        call MPNODE_K( iproc ) 
c  Set up k-parallel
c        call KPMINE( kparopt, nk,nkloc,nk0 )
        call KPMINE( nk,nkloc,nk0 )
c
        mat = norb*norb
c  
        if( iprocl.eq.masterl )then
c         Image master, collect matrices from k-local masters
          do  k=1,nk
            call KPMASTER( nk,nprocl, k,kmasterpr )
            if( kmasterpr .ne. masterl )then
              call MPSENDTICKET( kmasterpr, icomml )
              lenmsg = mat
              call MPRECVR8( kmasterpr, lenmsg, vijk(1,k), icomml )
            endif
          enddo
        elseif( iproc .eq. master .and. nkloc .gt. 0 )then
c         Master of this k-point, send image/local master the matrix
          do  ikloc=1,nkloc
            call MPRECVTICKET( masterl, icomml )
            lenmsg = mat
            call MPSENDR8( masterl, lenmsg, vijk(1,ikloc), icomml )
          enddo
        endif
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> KPARDISTR
c
c
      subroutine KPARDISTR( norb,nk,vijk )
c---------------------------------------------------------------
c Purpose: merge k-parallel Hams from kmasters onto image master
c
c Written: Peter A. Schultz,  4-December-2008, for 2.63 (k-parallel)
c
c Revision history:
c   4Dec08-PAS/2.63: pushed down from vslomat
c---------------------------------------------------------------
c
      IMPLICIT NONE
c
c Input: nk=global k-pts, nkloc=local number of k-pts
      INTEGER    norb, nk,nkloc
c Input/Output
      DOUBLE PRECISION  vijk
      DIMENSION  vijk(norb*norb,*)
c
c Local declarations:
      INTEGER    kparopt
      INTEGER    nprocl,masterl,iprocl,icomml, master,nprocs,iproc
      INTEGER    nk0, k,ikloc,  kmasterpr
      INTEGER    mat, lenmsg
c
c  For k-parallel, send all the k-resolved matrices to image master
c
      call KPFLAG_GET( kparopt )
      if( kparopt .eq. 2 )then
c       Get image/local MP info
        call MPNODES( nprocl )
        call MPNODE0( masterl )
        call MPNODE( iprocl )
        call MPCOMM( icomml )
c       Get k-local MP info
        call MPNODES_K( nprocs )
        call MPNODE0_K( master )
        call MPNODE_K( iproc ) 
c  Set up k-parallel
        call KPMINE( nk,nkloc,nk0 )
c
        mat = norb*norb
c  
        if( iprocl .eq. masterl )then
c         Image master, collect matrices from k-local masters
          do  k=1,nk
            call KPMASTER( nk,nprocl, k, kmasterpr )
            if( kmasterpr .ne. masterl )then
              call MPRECVTICKET( kmasterpr, icomml )
              lenmsg = mat
              call MPSENDR8( kmasterpr, lenmsg, vijk(1,k), icomml )
            endif
          enddo
        elseif( iproc .eq. master .and. nkloc .gt. 0 )then
c         Master of this k-point, send image/local master the matrix
          do  ikloc=1,nkloc
            call MPSENDTICKET( masterl, icomml )
            lenmsg = mat
            call MPRECVR8( masterl, lenmsg, vijk(1,ikloc), icomml )
          enddo
        endif
      endif
c
c    That's all Folks!
c
      RETURN
      END
c         
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDDATA
c
c
      subroutine BANDDATA( IDAT,IWR, nbranchd,nbranch,bvl,bsymb )
c---------------------------------------------------------------
c Purpose: read band structure data from input deck.
c
c Written: A.H. Edwards, 6-Oct-2008
c
c Revisions:
c  21Jan15/2.66-PAS: add add-gamma option; lnwrite lines
c  03May12-ACP&29Dec12-PAS: Merged into 2.64
c---------------------------------------------------------------
c
c  Arrays/variables for band structure calculations
c
c     bvl = symbol for Bravais Lattice
c            fcc    face centered cubic
c            hex    hexagonal
c            stc    simple triclinic
c            sc     simple cubic
c            ...    there are others, see bandkpts
c           gam     Gamma point, in whatever lattice
c     nbranch = number of branches for band structure
c     bsymb(nbranchd) = symbols for the endpoints of the branches
c         G always represents Gamma
c         Rest from BSW (???) paper
c         per: W. Setyawan and S. Curtarolo, Comp. Mat. Sci. 49, 299 (2010).
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c 
      CHARACTER*3  bvl
      CHARACTER*2  bsymb
      DIMENSION    bsymb(nbranchd)
c
      PARAMETER  ( nline = 128 )
      CHARACTER  readlbl*6,wantlbl*6,label*(nline)
      EQUIVALENCE( label, readlbl )
c
c >>>> EXECUTABLE CODE:
c
 8000 format(a128)
 9100 format(1x,'# For definitions of symbols, use and cite (G=gamma):'
     $ /1x,'# W. Setyawan and S. Curtarolo, ',
     $       'Comp. Mat. Sci. 49, 299 (2010).' )
c
      read(IDAT,8000)  label
c
      wantlbl = 'bravai'
      if( readlbl.eq.wantlbl )then
        call LNWRIT( IWR, label, nline )
c       Read bravais lattice type
        read(IDAT,*)  bvl
        write(IWR,*)  bvl
c
        read(IDAT,8000)  label
        if( readlbl.eq. 'nbranc' )then
          call LNWRIT( IWR, label, nline )
          read(IDAT,*)  nbranch
          write(IWR,*)  nbranch,' = number of branches'
        else
          write(IWR,*) readlbl,' not >nbranch<  ... bye!'
          call STOPXERR( 'b.s. keyword >nbranch< not found' )
        endif
c
        read(IDAT,8000)  label
        if( readlbl.eq. 'symbol' )then
          call LNWRIT( IWR, label, nline )
          write(IWR,9100)
          do  i=1,nbranch
            read(IDAT,*)  bsymb(i)
c           Put in error step
            write(IWR,*)  bsymb(i)
          enddo
        else
          write(IWR,*)  readlbl,'  not >symbol<  bye!'
          call STOPXERR( 'b.s. keyword >symbol< not found' )
        endif
c
      elseif( readlbl.eq. 'gamma ' .or. readlbl.eq. 'Gamma ' )then
c       Just add gamma point to end of list
        call LNWRIT( IWR, label, nline )
        bvl = 'gam'
        nbranch = 1
        bsymb(1) = 'GG'
      else
        write(IWR,*)  readlbl,' not >bravais<  ... bye!'
        call STOPXERR( 'b.s. keyword >bravais< not found' )
      endif
c
      read(IDAT,8000)  label
      if(  readlbl.ne. 'end ba' )then
        write(IWR,*)  readlbl, ' not >end bands< ...  bye!'
        call STOPXERR( 'final b.s. keyword >end bands< not found' )
      else
        call LNWRIT( IWR, label, nline )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDKPTS
c
c
      subroutine BANDKPTS( veckn,veck,wtkn,nnscf,nknscfd,nkd,bvl,
     $    nbranch, nbranchd,bsymb,rprim,gprim,dk,nbr,IWR )
c---------------------------------------------------------------
c Purpose: defined bands of k-points for band structure
c
c Written: A.H. Edwards, 100608,
c
c Revision history:
c  21Jan15-PAS/2.66: add-gamma option, add-klist option
c  03May12-ACP: Merged into 2.64
c---------------------------------------------------------------
c
cAHE 100608
c     We start to put substance into this program
c     We start by fixing the number of points on each branch (=15)
c     we will use bvl to determine the appropriate subroutine.
c     This is now almost a dummy program. We will put the first scf veck 
c     into veckn.
c     nnscf will be the number of non-scf k-points
c     We must check at the end of the routine that nnscf <nknscfd
c
c Band structure symbol definitions are taken from:
c   W. Setyawan and S. Curtarolo, Comp. Mat. Sci. 49, 299 (2010).
c
      IMPLICIT REAL*8(a-h,o-z)
c
      PARAMETER  ( zero=0.d0, one=1.d0  )
      DIMENSION  veckn(3,nknscfd),veck(3,nkd),wtkn(nknscfd)
      DIMENSION  rprim(3,3)
      DIMENSION  gprim(3,3),dk(nknscfd),nbr(nbranchd)
      CHARACTER*3  bvl
      CHARACTER*2  bsymb(2,nbranchd)
c
      CHARACTER  symb1, symb2
c
c >>>> EXECUTABLE CODE:
c
c  We need to calculate the total number of non-SCF points.
c
      write(IWR,*)  'Bravais lattice, bvl = ', bvl
c
      if( bvl .eq. 'gam' )then
c        Add just the gamma point to the wanted k-points
         write(IWR,*) '  Adding gamma point, and just the gamma point'
         nnscf = 1
         veckn(1,1) = zero
         veckn(1,2) = zero
         veckn(1,3) = zero
         wtkn(1) = one
c
      elseif( bvl .eq. 'bcc' )then
c       Body-centered cubic lattice (per Setyawan and Curtarolo)
        call BANDSBCC( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $       nknscfd,gprim,dk,nbr,IWR )
c
      elseif( bvl .eq. 'sc ' )then
c       Simple cubic lattice (standard)
        call BANDSSC( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $       nknscfd,gprim,dk,nbr,IWR )
      elseif( bvl .eq. 'cub' )then
c       Cubic lattice  (per Setyawan and Curtarolo)(different implementation of sc)
        call BANDSCUB( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $       nknscfd,gprim,dk,nbr,IWR )
c
      elseif( bvl .eq. 'fcc' )then
c       Face-centered cubic lattice (standard)
        call BANDSFCC( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $       nknscfd,gprim,dk,nbr,IWR )
      elseif( bvl .eq. 'fc2' )then
c       Face-centered cubic  (per Setyawan and Curtarolo) (equivalent to fcc)
        call BANDSFCC2( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $       nknscfd,gprim,dk,nbr,IWR )
c
      elseif( bvl .eq. 'hex' )then
c       Hexagonal lattice
        call BANDSHEX( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $       nknscfd,gprim,dk,nbr,IWR )
c
      elseif( bvl .eq. 'orc' )then
c       Orthorhombic  (per Setyawan and Curtarolo)
        call BANDSORC( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $       nknscfd,gprim,dk,nbr,IWR )
c
      elseif( bvl .eq. 'rhl' )then
c       Rhombohedral  (per Setyawan and Curtarolo)
        call BANDSRHL( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $       nknscfd,rprim,gprim,dk,nbr,IWR )
c
      elseif( bvl .eq. 'tet' )then
c       Tetragonal  (per Setyawan and Curtarolo)
        call BANDSTET( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $       nknscfd,gprim,dk,nbr,IWR )
c
      elseif( bvl .eq. 'tri' )then
c       Triclinic  (per Setyawan and Curtarolo)
        call BANDSTRI( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $       nknscfd,gprim,dk,nbr,IWR )
c
      elseif( bvl .eq. 'stc' )then
cxxx264 ??? Simple-triclinic (standard) ???
        call BANDSSTC( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $        nknscfd,gprim,dk,nbr,IWR )
c
      elseif( bvl .eq. 'mcl' )then
c       Simple monoclinic (per Setyawan and Curtarolo)
        call BANDSMCL( nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $       nknscfd,rprim,gprim,dk,nbr,IWR )
      elseif( bvl .eq. 'smc' )then
cxxx264 ???  Simple monoclinic = redundant with bvl='mcl' above?
c       We need to use the real-space vectors to determine:
c       phi, the acute monoclinic angle
c       lambda = c/(b*cos(phi)
c
        write(IWR,*) 'Monoclinic >smc< is a work in progress!'
        call STOPXERR( 'Bravais lattice >smc< not supported' )
c
      else
        write(IWR,*) '***** ERROR: bravais option not supported:', bvl
        call STOPXERR( 'Bravais lattice option not supported' )
      endif
c
      write(IWR,*) 'BANDKPTS: total nnscf,max = ', nnscf, nknscfd
      if( nnscf.gt.nknscfd ) call STOPXERR('nnscf is too large!')
c
c    That's all Folks
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c***********************************************************************
c    BANDS - Quest band structure module
c    Written: Art Edwards, 2008-2012, for version 2.64 (kpp+b.s.)
c    Aided by: Andy Pineda
c
c***********************************************************************
c Revision history:
c  30Jan14-ACP/2.65b: patch to make b.s. symbols to work out right
c  31Jan13-PAS/2.64: installation into production code
c  2008-2012: ACP: merging into main code
c***********************************************************************
c
c    Special points from:
c     Setyawan and Curtarolo, Comp. Mat. Sci. 49,(2010), 299, 312.
c
c    Routines setting up bands for different crystals
c     BANDSBCC
c     BANDSCUB
c     BANDSFCC2
c     BANDSFCC
c     BANDSHEX
c     BANDSMCL
c     BANDSMCL2
c     BANDSORC
c     BANDSRHL
c     BANDSSC
c     BANDSSTC
c     BANDSTC
c     BANDSTET
c     BANDSTRI
c
c    Utility function:
c     INTEGER FUNCTION LOOKUP_SYMPT( sympt,symlabels,nsyms )
c
c***********************************************************************
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSBCC
c
c
c REVISION HISTORY:
c   4Sep12-ACP: Forked from BANDSHEX
c   3May12-ACP: Merged into 2.64
c  20Dec10-ACP: Fully merged into 2.62dev.
c  07Oct08-AHE: Written for 2.61b
c
      SUBROUTINE BANDSBCC(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER (numpts=4)
c
c     BCC Bravais Lattice
c     One of a suite of routines that calculate a set of branches for
c     band structure calculations.
c
c     Conventional Lattice Setting
c      a1=(a,0,0)
c      a2=(0,a,0)
c      a3=(0,0,a)
c     Primitive Lattice Setting
c      a1=(-a/2,a/2,a/2)
c      a2=(a/2,-a/2,a/2)
c      a3=(a/2,a/2,-a/2)
c     
c     First attempt to parse the bsymb routine into constituent
c     characters, and check against the set of special points in BCC.
c
      CHARACTER*10 thisroutine
      CHARACTER*4  latname
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER symlabels(numpts),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),gprim(3,3)
      DIMENSION gspec(3,numpts),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION symcoeffs(3,numpts)
      DATA thisroutine /'BANDSBCC'/
      DATA latname     /'BCC'/
      DATA symlabels/'G','H','P','N'/
      DATA symcoeffs / 0.0d0,  0.0d0,  0.0d0,
     $                 0.5d0, -0.5d0,  0.5d0,
     $                 0.25d0, 0.25d0, 0.25d0,
     $                 0.0d0,  0.0d0,  0.5d0 /
      np1=30
c
c     Use the primitive lattice vectors to make special points
c
      WRITE(IWR,*)thisroutine//': primitive reciprical lattice vectors'
      DO ivec=1,3
         WRITE(IWR,*)(gprim(icart,ivec),icart=1,3)
      ENDDO
      write(IWR,*)
      WRITE(IWR,*)thisroutine//': symcoeffs'
      DO ispec=1,numpts
        WRITE(IWR,*)symlabels(ispec),':',
     $    (symcoeffs(ivec,ispec),ivec=1,3)
      END DO
      WRITE(IWR,*)
c     Special points from Setyawan and Curtarolo, Comp. Mat. Sci. 49,
c     (2010), 299, 312.
      DO ispec=1,numpts
        DO icart = 1,3
          gspec(icart,ispec)=0.0d0
          DO ivec = 1,3
            gspec(icart,ispec) = gspec(icart,ispec)
     $        + gprim(icart,ivec)*symcoeffs(ivec,ispec)
          END DO
        END DO
      END DO
c
c     Now write out the values of the special points
c
      DO ispec=1,numpts
         WRITE(IWR,*) '  ',symlabels(ispec),' ',
     $    (gspec(icart,ispec),icart=1,3)
         WRITE(IWR,*)' '
      ENDDO      
c Use default path if nbranch<=0
      IF (nbranch.LE.0) THEN
        WRITE(IWR,*)'Default '//latname//
     $    ' bandstructure option selected'
        bsymb(1)='GH'
        bsymb(2)='HN'
        bsymb(3)='NG'
        bsymb(4)='GP'
        bsymb(5)='PH'
        bsymb(6)='PN'
        nbranch=6
      ENDIF
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         ibegin=LOOKUP_SYMPT(symb, symlabels, numpts)
         IF (ibegin.LT.1) THEN
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
         iend=LOOKUP_SYMPT(syme, symlabels, numpts)
         IF (iend.LT.1) THEN
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ. LOOKUP_SYMPT('G', symlabels, numpts)) THEN 
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('P', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('N', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('H', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('P', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('N', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('P', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('N', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('N', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('P', symlabels, numpts )) GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)thisroutine//': d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/dfloat(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)thisroutine//': nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSCUB
c
c
c REVISION HISTORY:
c   4Sep12-ACP: Forked from BANDSHEX
c   3May12-ACP: Merged into 2.64
c  20Dec10-ACP: Fully merged into 2.62dev.
c  07Oct08-AHE: Written for 2.61b
c
      SUBROUTINE BANDSCUB(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER (numpts=4)
c
c     CUB Bravais Lattice
c     One of a suite of routines that calculate a set of branches for
c     band structure calculations.
c     
c     Conventional Lattice Setting
c      a1=(a,0,0)
c      a2=(0,a,0)
c      a3=(0,0,a)
c
c     First attempt to parse the bsymb routine into constituent
c     characters, and check against the set of special points in CUB.
c
      CHARACTER*10 thisroutine
      CHARACTER*4  latname
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER symlabels(numpts),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),gprim(3,3)
      DIMENSION gspec(3,numpts),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION symcoeffs(3,numpts)
      DATA thisroutine /'BANDSCUB'/
      DATA latname     /'CUB'/
      DATA symlabels/'G','M','R','X'/
      DATA symcoeffs / 0.0d0, 0.0d0, 0.0d0,
     $                 0.5d0, 0.5d0, 0.0d0,
     $                 0.5d0, 0.5d0, 0.5d0,
     $                 0.0d0, 0.5d0, 0.0d0 /
      np1=30
c
c     Use the primitive lattice vectors to make special points
c
      WRITE(IWR,*)thisroutine//': primitive reciprical lattice vectors'
      DO ivec=1,3
         WRITE(IWR,*)(gprim(icart,ivec),icart=1,3)
      ENDDO
      WRITE(IWR,*)
      WRITE(IWR,*)thisroutine//': symcoeffs'
      DO ispec=1,numpts
        WRITE(IWR,*)symlabels(ispec),':',
     $    (symcoeffs(ivec,ispec),ivec=1,3)
      END DO
      WRITE(IWR,*)
c     Special points from Setyawan and Curtarolo, Comp. Mat. Sci. 49,
c     (2010), 299, 312.
      DO ispec=1,numpts
        DO icart = 1,3
          gspec(icart,ispec)=0.0d0
          DO ivec = 1,3
            gspec(icart,ispec) = gspec(icart,ispec)
     $        + gprim(icart,ivec)*symcoeffs(ivec,ispec)
          END DO
        END DO
      END DO
c
c     Now write out the values of the special points
c
      DO ispec=1,numpts
         WRITE(IWR,*) '  ',symlabels(ispec),' ',
     $    (gspec(icart,ispec),icart=1,3)
         WRITE(IWR,*)' '
      ENDDO      
c Use default path if nbranch<=0
      IF (nbranch.LE.0) THEN
        WRITE(IWR,*)'Default '//latname//
     $    ' bandstructure option selected'
        bsymb(1)='GX'
        bsymb(2)='XM'
        bsymb(3)='MG'
        bsymb(4)='GR'
        bsymb(5)='RX'
        bsymb(6)='MR'
        nbranch=6
      ENDIF
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         ibegin=LOOKUP_SYMPT(symb, symlabels, numpts)
         IF (ibegin.LT.1) THEN
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
         iend=LOOKUP_SYMPT(syme, symlabels, numpts)
         IF (iend.LT.1) THEN
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ. LOOKUP_SYMPT('G', symlabels, numpts)) THEN 
            IF(iend.EQ. LOOKUP_SYMPT('R', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('M', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('R', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('R', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('X', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('R', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)thisroutine//': d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/dfloat(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)thisroutine//': nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSFCC2
c
c
c REVISION HISTORY:
c   4Sep12-ACP: Forked from BANDSHEX
c   3May12-ACP: Merged into 2.64
c  20Dec10-ACP: Fully merged into 2.62dev.
c  07Oct08-AHE: Written for 2.61b
c
      SUBROUTINE BANDSFCC2(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER (numpts=6)
c
c     FCC Bravais Lattice
c     One of a suite of routines that calculate a set of branches for
c     band structure calculations.
c     Conventional Lattice Setting
c      a1=(a,0,0)
c      a2=(0,a,0)
c      a3=(0,0,a)
c     Primitive Lattice Setting
c      a1=(0,a/2,a/2)
c      a2=(a/2,0,a/2)
c      a3=(a/2,a/2,0)
c     First attempt to parse the bsymb routine into constituent
c     characters, and check against the set of special points in FCC.
c
      CHARACTER*10 thisroutine
      CHARACTER*4  latname
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER symlabels(numpts),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),gprim(3,3)
      DIMENSION gspec(3,numpts),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION symcoeffs(3,numpts)
      DATA thisroutine /'BANDSFCC2'/
      DATA latname     /'FCC'/
      DATA symlabels/'G','K','L','U','W','X'/
      DATA symcoeffs / 0.000d0, 0.000d0, 0.000d0,
     $                 0.375d0, 0.375d0, 0.750d0,
     $                 0.500d0, 0.500d0, 0.500d0,
     $                 0.625d0, 0.250d0, 0.625d0,
     $                 0.500d0, 0.250d0, 0.750d0,
     $                 0.500d0, 0.000d0, 0.500d0 /
      np1=30
c
c     Use the primitive lattice vectors to make special points
c
      WRITE(IWR,*)thisroutine//': primitive reciprical lattice vectors'
      DO ivec=1,3
         WRITE(IWR,*)(gprim(icart,ivec),icart=1,3)
      ENDDO
      WRITE(IWR,*)
      WRITE(IWR,*)thisroutine//': symcoeffs'
      DO ispec=1,numpts
        WRITE(IWR,*)symlabels(ispec),':',
     $    (symcoeffs(ivec,ispec),ivec=1,3)
      END DO
      WRITE(IWR,*)
c     Special points from Setyawan and Curtarolo, Comp. Mat. Sci. 49,
c     (2010), 299, 312.
      DO ispec=1,numpts
        DO icart = 1,3
          gspec(icart,ispec)=0.0d0
          DO ivec = 1,3
            gspec(icart,ispec) = gspec(icart,ispec)
     $        + gprim(icart,ivec)*symcoeffs(ivec,ispec)
          END DO
        END DO
      END DO
c
c     Now write out the values of the special points
c
      DO ispec=1,numpts
         WRITE(IWR,*) '  ',symlabels(ispec),' ',
     $    (gspec(icart,ispec),icart=1,3)
         WRITE(IWR,*)' '
      ENDDO      
c Use default path if nbranch<=0
      IF (nbranch.LE.0) THEN
        WRITE(IWR,*)'Default '//latname//
     $    ' bandstructure option selected'
        bsymb(1)='GX'
        bsymb(2)='XW'
        bsymb(3)='WK'
        bsymb(4)='KG'
        bsymb(5)='GL'
        bsymb(6)='LU'
        bsymb(7)='UW'
        bsymb(8)='WL'
        bsymb(9)='LK'
        bsymb(10)='UX'
        nbranch=10
      ENDIF
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         ibegin=LOOKUP_SYMPT(symb, symlabels, numpts)
         IF (ibegin.LT.1) THEN
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
         iend=LOOKUP_SYMPT(syme, symlabels, numpts)
         IF (iend.LT.1) THEN
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ. LOOKUP_SYMPT('G', symlabels, numpts)) THEN 
            IF(iend.EQ. LOOKUP_SYMPT('L', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('K', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('K', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('L', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('W', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('L', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('K', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('W', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('U', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('U', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('L', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('W', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('W', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('L', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('U', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('K', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('X', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('U', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('W', symlabels, numpts )) GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)thisroutine//': d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/dfloat(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)thisroutine//': nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSFCC
c
c
c REVISION HISTORY:
c   3May12-ACP: Merged into 2.64
c  20Dec10-ACP: Fully merged into 2.62dev.
c  07Oct08-AHE: Written for 2.61b.
c
      SUBROUTINE BANDSFCC(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
cAHE 100708
c
c     One of a suite of routines that calculate a set of branches for band structure 
c     calculations.
c     
c     First attempt to parse the bsymb routine into constituent characters, and check
c     against the set of special points in FCC
c
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER FCC(7),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),gprim(3,3)
      DIMENSION gspec(3,7),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION xnorm(3),wp(3)
      DATA FCC/'G','X','L','K','W','U','A'/
      np1=30
c
c     Use the primitive lattice vectors to make special points
c
      DO i = 1,3
c     G (gamma)
         gspec(i,1)=0.0d0
cc     K
c         gspec(i,4)=(gprim(i,1)+gprim(i,2)+2.0*gprim(i,3))*0.5
c     X
         gspec(i,2)=(gprim(i,2)+gprim(i,3))*0.5
c     L
         gspec(i,3)=(gprim(i,1)+gprim(i,2)+gprim(i,3))*0.5
c     A another gamma point
         gspec(i,7)=gprim(i,1)+gprim(i,2)+gprim(i,3)
      ENDDO
c
c     These are the edge and corner points that are derived from other special points
c     We have to test whether the new points are related correctly to the old points
c
c     K
      IF(gspec(3,2).GT.1.0d-5) THEN
         gspec(1,4)=1.5*gspec(1,3)
         gspec(3,4)=gspec(1,4)
         gspec(2,4)=0.0d0
      ELSE
         gspec(1,4)=1.5*gspec(1,3)
         gspec(2,4)=gspec(1,4)
         gspec(3,4)=0.0d0
      ENDIF
c
c     W and U
c
      ddX=0.0d0
      DO icart=1,3
         ddX=ddX+gspec(icart,2)*gspec(icart,2)
      ENDDO
      ddX=SQRT(ddX)
      WRITE(IWR,*)'ddX = ', ddx
      DO icart = 1,3
         IF(gspec(icart,2).GT.1.0d-5) THEN 
            gspec(icart,5)=gspec(icart,2)
            gspec(icart,6)=gspec(icart,2)
         ELSEIF(gspec(icart,4).LT.1.0d-5) THEN
            gspec(icart,5)=0.0
            gspec(icart,6)=0.5*(3*gspec(icart,3)-ddX)
         ELSE
            gspec(icart,5)=3*gspec(icart,3)-ddX
            gspec(icart,6)=0.5*(3*gspec(icart,3)-ddX)
         ENDIF
      ENDDO
c
c     Now write out all of the special points
c
c
c     Now write out the values of the special points
c
      DO ispec=1,7
         WRITE(IWR,*) '  ',FCC(ispec),' ',(gspec(icart,ispec),icart=1,3)
         WRITE(IWR,*)' '
      ENDDO
c Use default path if nbranch<=0
      IF (nbranch.LE.0) THEN
        WRITE(IWR,*)'Default FCC'//
     $    ' bandstructure option selected'
        bsymb(1)='GX'
        bsymb(2)='XW'
        bsymb(3)='WK'
        bsymb(4)='KG'
        bsymb(5)='GL'
        bsymb(6)='LU'
        bsymb(7)='UW'
        bsymb(8)='WL'
        bsymb(9)='LK'
        bsymb(10)='UX'
        nbranch=10
      ENDIF
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         write(IWR,*)symb,'  ',syme
         IF(symb.EQ.'G') THEN
            ibegin=1
         ELSEIF(symb.EQ.'X') THEN
            ibegin=2
         ELSEIF(symb.EQ.'L')THEN
            ibegin=3
         ELSEIF(symb.EQ.'K')THEN
            ibegin=4
         ELSEIF(symb.EQ.'W') THEN
            ibegin=5
         ELSEIF(symb.EQ.'U')THEN
            ibegin=6
         ELSEIF(symb.EQ.'A')THEN
            ibegin=7
         ELSE
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'not in the FCC set of special points.  Bye!'
            STOP
         ENDIF
         IF(syme.EQ.'G') THEN
            iend=1
         ELSEIF(syme.EQ.'X') THEN
            iend=2
         ELSEIF(syme.EQ.'L')THEN
            iend=3
         ELSEIF(syme.EQ.'K')THEN
            iend=4
         ELSEIF(syme.EQ.'W')THEN
            iend=5
         ELSEIF(syme.EQ.'U')THEN
            iend=6
         ELSEIF(syme.EQ.'A')THEN
            iend=7
         ELSE
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'not in the FCC set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ.1.AND. iend.NE.1) THEN 
            GO TO 10
         ELSEIF(ibegin.EQ.2) THEN
            IF(iend.NE.4.AND. iend.NE.3) GO TO 10
         ELSEIF(ibegin.EQ.3) THEN
            IF(iend.EQ.4.OR.iend.EQ.1.OR.iend.EQ.5.OR.iend.EQ.6)  
     $           GO TO 10
         ELSEIF(ibegin.EQ.4) THEN
            if(iend.EQ.1.OR.iend.EQ.3) GO TO 10
         ELSEIF(ibegin.EQ.5.AND.iend.NE.5) THEN
            GO TO 10
         ELSEIF(ibegin.EQ.6)THEN
            if(iend.NE.6.AND.iend.NE.4)GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)'In BANDSFCC, d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/DFLOAT(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)'in BANDSFCC, nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSHEX
c
c
c REVISION HISTORY:
c  21Feb13-ACP:  Forked from BANDSFCC2 (to fix bug)
c   3May12-ACP: Merged into 2.64
c  20Dec10-ACP: Fully merged into 2.62dev.
c  07Oct08-AHE: Written for 2.61b
c
      SUBROUTINE BANDSHEX(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER (numpts=6)
c
c     HEX Bravais Lattice
c     One of a suite of routines that calculate a set of branches for
c     band structure calculations.
c     Lattice Setting
c      a1=(a/2, -a*sqrt(3)/2, 0)
c      a2=(a/2, a*sqrt(3)/2,  0)
c      a3=(0,   0,            c)
c     First attempt to parse the bsymb routine into constituent
c     characters, and check against the set of special points in FCC.
c
      CHARACTER*10 thisroutine
      CHARACTER*4  latname
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER symlabels(numpts),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),gprim(3,3)
      DIMENSION gspec(3,numpts),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION symcoeffs(3,numpts)
      DATA thisroutine /'BANDSHEX'/
      DATA latname     /'HEX'/
      DATA symlabels/'G','A','H','K','L','M'/
      DATA symcoeffs / 0.000d0, 0.000d0, 0.000d0,
     $                 0.000d0, 0.000d0, 0.500d0,
     $          0.333333333333333333d0, 0.333333333333333333d0, 0.500d0,
     $          0.333333333333333333d0, 0.333333333333333333d0, 0.000d0,
     $                 0.500d0, 0.000d0, 0.500d0,
     $                 0.500d0, 0.000d0, 0.000d0 /
      np1=30
c
c     Use the primitive lattice vectors to make special points
c
      WRITE(IWR,*)thisroutine//': primitive reciprical lattice vectors'
      DO ivec=1,3
         WRITE(IWR,*)(gprim(icart,ivec),icart=1,3)
      ENDDO
      WRITE(IWR,*)
      WRITE(IWR,*)thisroutine//': symcoeffs'
      DO ispec=1,numpts
        WRITE(IWR,*)symlabels(ispec),':',
     $    (symcoeffs(ivec,ispec),ivec=1,3)
      END DO
      WRITE(IWR,*)
c     Special points from Setyawan and Curtarolo, Comp. Mat. Sci. 49,
c     (2010), 299, 312.
      DO ispec=1,numpts
        DO icart = 1,3
          gspec(icart,ispec)=0.0d0
          DO ivec = 1,3
            gspec(icart,ispec) = gspec(icart,ispec)
     $        + gprim(icart,ivec)*symcoeffs(ivec,ispec)
          END DO
        END DO
      END DO
c
c     Now write out the values of the special points
c
      DO ispec=1,numpts
         WRITE(IWR,*) '  ',symlabels(ispec),' ',
     $    (gspec(icart,ispec),icart=1,3)
         WRITE(IWR,*)' '
      ENDDO      
c Use default path if nbranch<=0
      IF (nbranch.LE.0) THEN
        WRITE(IWR,*)'Default '//latname//
     $    ' bandstructure option selected'
        bsymb(1)='GM'
        bsymb(2)='MK'
        bsymb(3)='KG'
        bsymb(4)='GA'
        bsymb(5)='AL'
        bsymb(6)='LH'
        bsymb(7)='HA'
        bsymb(8)='LM'
        bsymb(9)='KH'
        nbranch=9
      ENDIF
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         ibegin=LOOKUP_SYMPT(symb, symlabels, numpts)
         IF (ibegin.LT.1) THEN
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
         iend=LOOKUP_SYMPT(syme, symlabels, numpts)
         IF (iend.LT.1) THEN
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ. LOOKUP_SYMPT('G', symlabels, numpts)) THEN 
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('K', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('A', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('L', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('L', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('M', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('K', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('L', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('H', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('L', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('K', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('K', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)thisroutine//': d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/dfloat(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)thisroutine//': nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSMCL
c
c
c REVISION HISTORY:
c   4Sep12-ACP: Forked from BANDSHEX
c   3May12-ACP: Merged into 2.64
c  20Dec10-ACP: Fully merged into 2.62dev.
c  07Oct08-AHE: Written for 2.61b
c
      SUBROUTINE BANDSMCL(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, rprim, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER (numpts=16)
c
c     Simple Monoclinic Bravais Lattice
c      Ordering of the lattice a,b<=c; alpha< 90 deg; beta=gamma=90 deg
c     Lattice Setting
c      a1=(a, 0, 0)
c      a2=(0, b, 0)
c      a3=(0, c*cos(alpha), c*sin(alpha))
c     
      CHARACTER*10 thisroutine
      CHARACTER*4  latname
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER symlabels(numpts),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),rprim(3,3),gprim(3,3)
      DIMENSION gspec(3,numpts),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION symcoeffs(3,numpts)
      DATA thisroutine /'BANDSMCL'/
      DATA latname     /'MCL'/
c
c     symlabels:  GAMMA-A-C-D-D1-E-H-H1-H2-M-M1-M2-X-Y-Y1-Z
c
      DATA symlabels/'G','A','C',
     $               'D','d','E',
     $               'H','h','i',
     $               'M','m','n',
     $               'X','Y','y','Z'/
c
      DATA symcoeffs / 0.0d0,  0.0d0,  0.0d0,
     $                 0.5d0,  0.5d0,  0.0d0,
     $                 0.0d0,  0.5d0,  0.5d0,
     $                 0.5d0,  0.0d0,  0.5d0,
     $                 0.5d0,  0.0d0, -0.5d0,
     $                 0.5d0,  0.5d0,  0.5d0,
     $                 0.0d0,  100.0d0,  100.0d0,
     $                 0.0d0,  100.0d0,  100.0d0,
     $                 0.0d0,  100.0d0,  100.0d0,
     $                 0.5d0,  100.0d0,  100.0d0,
     $                 0.5d0,  100.0d0,  100.0d0,
     $                 0.5d0,  100.0d0,  100.0d0,
     $                 0.0d0,  0.5d0,  0.0d0,
     $                 0.0d0,  0.0d0,  0.5d0,
     $                 0.0d0,  0.0d0, -0.5d0,
     $                 0.5d0,  0.0d0,  0.0d0 /
c
      np1=30
c
c Compute special points that depend on rprim.
c
      a=DDOT(3,rprim(1,1),1,rprim(1,1),1)
      a=SQRT(a)
      b=DDOT(3,rprim(1,2),1,rprim(1,2),1)
      b=SQRT(b)
      c=DDOT(3,rprim(1,3),1,rprim(1,3),1)
      c=SQRT(c)
c
      cosalpha=rprim(2,3)/c
      IF (cosalpha.LE.0.0d0) THEN
        CALL BANDSMCL2(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $    nknscfd, rprim, gprim,dk,nbr,IWR)
        RETURN
      ENDIF
c
      sinalpha=rprim(3,3)/c
      IF (sinalpha.LT.0.0d0) THEN
        STOP 'BANDSMCL: sin(alpha) < 0.0d0'
      ENDIF

      should_be_zero=MAX(ABS(rprim(2,1)),ABS(rprim(3,1)),
     $                   ABS(rprim(1,2)),ABS(rprim(3,3)),
     $                   ABS(rprim(1,3)),
     $                   ABS(1.0d0-cosalpha**2-sinalpha**2))
c
      IF(should_be_zero.GT.1.d-8) THEN
        STOP 'BANDSMCL: error in rprim'
      ENDIF
c
      eta=0.5d0*(1.0d0-b*cosalpha/c)/sinalpha/sinalpha
      gnu=0.5d0-eta*c*cosalpha/b
c  H
      symcoeffs(1,7)=0.0d0
      symcoeffs(2,7)=eta
      symcoeffs(3,7)=1.0d0-gnu
c  H1=h
      symcoeffs(1,8)=0.0d0
      symcoeffs(2,8)=1.0d0-eta
      symcoeffs(3,8)=gnu
c  H2=i
      symcoeffs(1,9)=0.0d0
      symcoeffs(2,9)=eta
      symcoeffs(3,9)=-gnu
c  M
      symcoeffs(1,10)=0.5d0
      symcoeffs(2,10)=eta
      symcoeffs(3,10)=1.0d0-gnu
c  M1=m
      symcoeffs(1,11)=0.5d0
      symcoeffs(2,11)=1.0-eta
      symcoeffs(3,11)=gnu
c  M2=n
      symcoeffs(1,12)=0.5d0
      symcoeffs(2,12)=eta
      symcoeffs(3,12)=-gnu
c
c     Use the primitive lattice vectors to make special points
c
      WRITE(IWR,*)thisroutine//': primitive reciprical lattice vectors'
      DO ivec=1,3
         WRITE(IWR,*)(gprim(icart,ivec),icart=1,3)
      ENDDO
c
      WRITE(IWR,*)
      WRITE(IWR,*)thisroutine//': symcoeffs'
      DO ispec=1,numpts
        WRITE(IWR,*)symlabels(ispec),':',
     $    (symcoeffs(ivec,ispec),ivec=1,3)
      END DO
      WRITE(IWR,*)
c     Special points from Setyawan and Curtarolo, Comp. Mat. Sci. 49,
c     (2010), 299, 312.
      DO ispec=1,numpts
        DO icart = 1,3
          gspec(icart,ispec)=0.0d0
          DO ivec = 1,3
            gspec(icart,ispec) = gspec(icart,ispec)
     $        + gprim(icart,ivec)*symcoeffs(ivec,ispec)
          END DO
        END DO
      END DO
c
c     Now write out the values of the special points
c
      DO ispec=1,numpts
         WRITE(IWR,*) '  ',symlabels(ispec),' ',
     $    (gspec(icart,ispec),icart=1,3)
         WRITE(IWR,*)' '
      ENDDO      
c Use default path if nbranch<=0
      IF (nbranch.LE.0) THEN
        WRITE(IWR,*)'Default '//latname//
     $    ' bandstructure option selected'
        bsymb(1)='GY'
        bsymb(2)='YH'
        bsymb(3)='HC'
        bsymb(4)='CE'
        bsymb(5)='Em'
        bsymb(6)='mA'
        bsymb(7)='AX'
        bsymb(8)='Xh'
        bsymb(9)='MD'
        bsymb(10)='DZ'
        bsymb(11)='YD'
        nbranch=11
      ENDIF
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         ibegin=LOOKUP_SYMPT(symb, symlabels, numpts)
         IF (ibegin.LT.1) THEN
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
         iend=LOOKUP_SYMPT(syme, symlabels, numpts)
         IF (iend.LT.1) THEN
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ. LOOKUP_SYMPT('G', symlabels, numpts)) THEN 
            IF(iend.EQ. LOOKUP_SYMPT('Y', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('y', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('A', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('m', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('n', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('C', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('h', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('E', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('D', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Y', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('d', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('n', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('y', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('E', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('m', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('C', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('H', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('C', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Y', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('h', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('C', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('m', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('i', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('y', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('n', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('M', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('D', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('E', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('m', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('E', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('h', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('n', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('d', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('i', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('X', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('h', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('i', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('Y', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('D', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('y', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('i', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('d', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('Z', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('D', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('d', symlabels, numpts )) GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)thisroutine//': d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/dfloat(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)thisroutine//': nnscf = ',nnscf
      RETURN
      END

      SUBROUTINE BANDSMCL2(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, rprim, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER (numpts=16)
c
c     Simple Monoclinic Bravais Lattice
c      Ordering of the lattice a,b<=c; alpha > 90 deg; beta=gamma=90 deg
c     Lattice Setting
c      a1=(a, 0, 0)
c      a2=(0, b, 0)
c      a3=(0, c*cos(alpha), c*sin(alpha))
c     
      CHARACTER*10 thisroutine
      CHARACTER*4  latname
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER symlabels(numpts),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),rprim(3,3),gprim(3,3)
      DIMENSION gspec(3,numpts),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION symcoeffs(3,numpts)
      DATA thisroutine /'BANDSMCL2'/
      DATA latname     /'MCL'/
c
c     symlabels:  GAMMA-A-C-D-D1-E-H-H1-H2-M-M1-M2-X-Y-Y1-Z
c
      DATA symlabels/'G','A','C',
     $               'D','d','E',
     $               'H','h','i',
     $               'M','m','n',
     $               'X','Y','y','Z'/
c
      DATA symcoeffs / 0.0d0,  0.0d0,  0.0d0,
     $                 0.5d0,  0.5d0,  0.0d0,
     $                 0.0d0,  0.5d0, -0.5d0,
     $                 0.5d0,  0.0d0,  0.5d0,
     $                 0.5d0,  0.0d0, -0.5d0,
     $                 0.5d0,  0.5d0, -0.5d0,
     $                 0.0d0,  100.0d0,  100.0d0,
     $                 0.0d0,  100.0d0,  100.0d0,
     $                 0.0d0,  100.0d0,  100.0d0,
     $                 0.5d0,  100.0d0,  100.0d0,
     $                 0.5d0,  100.0d0,  100.0d0,
     $                 0.5d0,  100.0d0,  100.0d0,
     $                 0.0d0,  0.5d0,  0.0d0,
     $                 0.0d0,  0.0d0,  0.5d0,
     $                 0.0d0,  0.0d0, -0.5d0,
     $                 0.5d0,  0.0d0,  0.0d0 /
c
      np1=30
c
c Compute special points that depend on rprim.
c
      a=DDOT(3,rprim(1,1),1,rprim(1,1),1)
      a=SQRT(a)
      b=DDOT(3,rprim(1,2),1,rprim(1,2),1)
      b=SQRT(b)
      c=DDOT(3,rprim(1,3),1,rprim(1,3),1)
      c=SQRT(c)
c
      cosalpha=rprim(2,3)/c
      IF (cosalpha.GT.0.0d0) THEN
        STOP 'BANDSMCL2: cos(alpha) > 0.0d0'
      ENDIF
c
      sinalpha=rprim(3,3)/c
      should_be_zero=MAX(ABS(rprim(2,1)),ABS(rprim(3,1)),
     $                   ABS(rprim(1,2)),ABS(rprim(3,3)),
     $                   ABS(rprim(1,3)),
     $                   ABS(1.0d0-cosalpha**2-sinalpha**2))
c
      IF(should_be_zero.GT.1.d-8) THEN
        STOP 'BANDSMCL2: error in rprim'
      ENDIF
c
      eta=0.5d0*(1.0d0+b*cosalpha/c)/sinalpha/sinalpha
      gnu=0.5d0-eta*c*cosalpha/b
c  H
      symcoeffs(1,7)=0.0d0
      symcoeffs(2,7)=eta
      symcoeffs(3,7)=1.0d0-gnu
c  H1=h
      symcoeffs(1,8)=0.0d0
      symcoeffs(2,8)=1.0d0-eta
      symcoeffs(3,8)=-(1.0d0-gnu)
c  H2=i
      symcoeffs(1,9)=0.0d0
      symcoeffs(2,9)=eta
      symcoeffs(3,9)=-gnu
c  M
      symcoeffs(1,10)=0.5d0
      symcoeffs(2,10)=eta
      symcoeffs(3,10)=1.0d0-gnu
c  M1=m
      symcoeffs(1,11)=0.5d0
      symcoeffs(2,11)=1.0-eta
      symcoeffs(3,11)=-(1.0d0-gnu)
c  M2=n
      symcoeffs(1,12)=0.5d0
      symcoeffs(2,12)=eta
      symcoeffs(3,12)=-gnu
c
c     Use the primitive lattice vectors to make special points
c
      WRITE(IWR,*)thisroutine//': primitive reciprical lattice vectors'
      DO ivec=1,3
         WRITE(IWR,*)(gprim(icart,ivec),icart=1,3)
      ENDDO
c
      WRITE(IWR,*)
      WRITE(IWR,*)thisroutine//': symcoeffs'
      DO ispec=1,numpts
        WRITE(IWR,*)symlabels(ispec),':',
     $    (symcoeffs(ivec,ispec),ivec=1,3)
      END DO
      WRITE(IWR,*)
c     Special points from Setyawan and Curtarolo, Comp. Mat. Sci. 49,
c     (2010), 299, 312.
      DO ispec=1,numpts
        DO icart = 1,3
          gspec(icart,ispec)=0.0d0
          DO ivec = 1,3
            gspec(icart,ispec) = gspec(icart,ispec)
     $        + gprim(icart,ivec)*symcoeffs(ivec,ispec)
          END DO
        END DO
      END DO
c
c     Now write out the values of the special points
c
      DO ispec=1,numpts
         WRITE(IWR,*) '  ',symlabels(ispec),' ',
     $    (gspec(icart,ispec),icart=1,3)
         WRITE(IWR,*)' '
      ENDDO      
c Use default path if nbranch<=0
      IF (nbranch.LE.0) THEN
        WRITE(IWR,*)'Default '//latname//
     $    ' bandstructure option selected'
        bsymb(1)='GY'
        bsymb(2)='YH'
        bsymb(3)='HX'
        bsymb(4)='XA'
        bsymb(5)='Am'
        bsymb(6)='mE'
        bsymb(7)='EC'
        bsymb(8)='Ch'
        bsymb(9)='MD'
        bsymb(10)='DZ'
        bsymb(11)='YD'
        nbranch=11
      ENDIF
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         ibegin=LOOKUP_SYMPT(symb, symlabels, numpts)
         IF (ibegin.LT.1) THEN
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
         iend=LOOKUP_SYMPT(syme, symlabels, numpts)
         IF (iend.LT.1) THEN
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ. LOOKUP_SYMPT('G', symlabels, numpts)) THEN 
c               GAMMA - Z, Y, Y1
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Y', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('y', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('A', symlabels, numpts)) THEN
c               A  - X, M, M1
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('m', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('C', symlabels, numpts)) THEN
c               C  - E, H1, H2
            IF(iend.EQ. LOOKUP_SYMPT('E', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('h', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('i', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('D', symlabels, numpts)) THEN
c               D  - Y, Z, M
            IF(iend.EQ. LOOKUP_SYMPT('Y', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('d', symlabels, numpts)) THEN
c                D1 - Y1, Z, M2
            IF(iend.EQ. LOOKUP_SYMPT('y', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('n', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('E', symlabels, numpts)) THEN
c                E  - C, M1, M2
            IF(iend.EQ. LOOKUP_SYMPT('C', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('m', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('n', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('H', symlabels, numpts)) THEN
c                H  - M, X, Y
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Y', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('h', symlabels, numpts)) THEN
c                H1 - M1, X, C
            IF(iend.EQ. LOOKUP_SYMPT('m', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('C', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('i', symlabels, numpts)) THEN
c                H2 - M2, C, Y1
            IF(iend.EQ. LOOKUP_SYMPT('n', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('C', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('y', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('M', symlabels, numpts)) THEN
c                M  - H, D, A
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('D', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('m', symlabels, numpts)) THEN
c                M1 - H1, A, E
            IF(iend.EQ. LOOKUP_SYMPT('h', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('E', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('n', symlabels, numpts)) THEN
c                M2 -  H2, E, D1
            IF(iend.EQ. LOOKUP_SYMPT('i', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('E', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('d', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('X', symlabels, numpts)) THEN
c                X  -  A, H, H1
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('h', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('Y', symlabels, numpts)) THEN
c                Y  -  D, GAMMA, H
            IF(iend.EQ. LOOKUP_SYMPT('D', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('H', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('y', symlabels, numpts)) THEN
c                Y1 - D1, GAMMA, H2
            IF(iend.EQ. LOOKUP_SYMPT('d', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('i', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('Z', symlabels, numpts)) THEN
c                Z - GAMMA, D, D1
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('D', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('d', symlabels, numpts )) GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)thisroutine//': d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/dfloat(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)thisroutine//': nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSORC
c
c
c REVISION HISTORY:
c   4Sep12-ACP: Forked from BANDSHEX
c   3May12-ACP: Merged into 2.64
c  20Dec10-ACP: Fully merged into 2.62dev.
c  07Oct08-AHE: Written for 2.61b
c
      SUBROUTINE BANDSORC(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER (numpts=8)
c
c     Orthrhombic Bravais Lattice
c     Assumed Lattice ordering:   a<b<c
c        a1=(a,0,0)
c        a2=(0,b,0)
c        a3=(0,0,c)
c     One of a suite of routines that calculate a set of branches for
c     band structure calculations.
c     
c     First attempt to parse the bsymb routine into constituent
c     characters, and check against the set of special points in ORC.
c
      CHARACTER*10 thisroutine
      CHARACTER*4  latname
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER symlabels(numpts),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),gprim(3,3)
      DIMENSION gspec(3,numpts),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION symcoeffs(3,numpts)
      DATA thisroutine /'BANDSORC'/
      DATA latname     /'ORC'/
      DATA symlabels/'G','R','S','T','U','X','Y','Z'/
      DATA symcoeffs / 0.0d0, 0.0d0, 0.0d0,
     $                 0.5d0, 0.5d0, 0.5d0,
     $                 0.5d0, 0.5d0, 0.0d0,
     $                 0.0d0, 0.5d0, 0.5d0,
     $                 0.5d0, 0.0d0, 0.5d0,
     $                 0.5d0, 0.0d0, 0.0d0,
     $                 0.0d0, 0.5d0, 0.0d0,
     $                 0.0d0, 0.0d0, 0.5d0 /
      np1=30
c
c     Use the primitive lattice vectors to make special points
c
      WRITE(IWR,*)thisroutine//': primitive reciprical lattice vectors'
      DO ivec=1,3
         WRITE(IWR,*)(gprim(icart,ivec),icart=1,3)
      ENDDO
      WRITE(IWR,*)
      WRITE(IWR,*)thisroutine//': symcoeffs'
      DO ispec=1,numpts
        WRITE(IWR,*)symlabels(ispec),':',
     $    (symcoeffs(ivec,ispec),ivec=1,3)
      END DO
      WRITE(IWR,*)
c     Special points from Setyawan and Curtarolo, Comp. Mat. Sci. 49,
c     (2010), 299, 312.
      DO ispec=1,numpts
        DO icart = 1,3
          gspec(icart,ispec)=0.0d0
          DO ivec = 1,3
            gspec(icart,ispec) = gspec(icart,ispec)
     $        + gprim(icart,ivec)*symcoeffs(ivec,ispec)
          END DO
        END DO
      END DO
c
c     Now write out the values of the special points
c
      DO ispec=1,numpts
         WRITE(IWR,*) '  ',symlabels(ispec),' ',
     $    (gspec(icart,ispec),icart=1,3)
         WRITE(IWR,*)' '
      ENDDO      
c Use default path if nbranch<=0
      IF (nbranch.LE.0) THEN
        WRITE(IWR,*)'Default '//latname//
     $    ' bandstructure option selected'
        bsymb(1)='GX'
        bsymb(2)='XS'
        bsymb(3)='SY'
        bsymb(4)='YG'
        bsymb(5)='GZ'
        bsymb(6)='ZU'
        bsymb(7)='UR'
        bsymb(8)='RT'
        bsymb(9)='TZ'
        bsymb(10)='YT'
        bsymb(11)='UX'
        bsymb(12)='SR'
        nbranch=12
      ENDIF
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         ibegin=LOOKUP_SYMPT(symb, symlabels, numpts)
         IF(ibegin.LT.1) THEN
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'not in the ORC set of special points.  Bye!'
            STOP
         ENDIF
         iend=LOOKUP_SYMPT(syme, symlabels, numpts)
         IF(iend.LT.1) THEN
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'not in the ORC set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ. LOOKUP_SYMPT('G', symlabels, numpts)) THEN 
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Y', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('R', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('S', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('T', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('U', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('S', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('R', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Y', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('T', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('R', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Y', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('U', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('R', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('X', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('U', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('S', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('Y', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('S', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('T', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('Z', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('U', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('T', symlabels, numpts )) GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)thisroutine//': d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/DFLOAT(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)thisroutine//': nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSRHL
c
c
c REVISION HISTORY:
c   4Sep12-ACP: Forked from BANDSHEX
c   3May12-ACP: Merged into 2.64
c  20Dec10-ACP: Fully merged into 2.62dev.
c  07Oct08-AHE: Written for 2.61b
c
      SUBROUTINE BANDSRHL(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, rprim, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
c   Variation 1 has 12 symmetry points
      PARAMETER (numpts1=12)
      PARAMETER (numpath1=9)
c   Variation 2 has 8 symmetry points
      PARAMETER (numpts2=8)
      PARAMETER (numpath2=9)
c 
      PARAMETER (numptsmax=12)
c
c     Rhombohedral Lattice
c     Lattice Setting
c      a1=(a*cos(alpha/2), -a*sin(alpha/2), 0)
c      a2=(a*cos(alpha/2),  a*sin(alpha/2), 0)
c      a3=(a*cos(alpha)/cos(alpha/2), 0, a*sqrt(1-cos^2(alpha)/cos^2(alpha/2)))
c     
c     There are two variations alpha<90 (cos(alpha)>0) and alpha>90 (cos(alpha)<0).
      CHARACTER*10 thisroutine
      CHARACTER*4  latname
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER*2 RHL1PATH(numpath1), RHL2PATH(numpath2)
      CHARACTER symlabels(numptsmax), symb, syme, symeold
      CHARACTER RHL1LABELS(numpts1)
      CHARACTER RHL2LABELS(numpts2)
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),rprim(3,3),gprim(3,3)
      DIMENSION gspec(3,numptsmax),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION symcoeffs(3,numptsmax)
      DATA thisroutine /'BANDSRHL'/
      DATA latname     /'RHL'/
c     Special points from Setyawan and Curtarolo, Comp. Mat. Sci. 49,
c     (2010), 299, 312.
c     cos(alpha)>0
c     RHL1LABELS:  GAMMA-B-B1-F-L-L1-P-P1-P2-Q-X-Z
      DATA RHL1LABELS/'G','B','b',
     $                'F','L','l',
     $                'P','p','o',
     $                'Q','X','Z'/
      DATA RHL1PATH /'GL', 'Lb', 'BZ',
     $               'ZG', 'GX', 'QF',
     $               'Fp', 'pZ', 'LP' /
c     cos(alpha)<0
c     RHL2LABELS: GAMMA-F-L-P-P1-Q-Q1-Z
      DATA RHL2LABELS /'G','F','L','P',
     $                 'p','Q','q','Z' /
      DATA RHL2PATH /'GP', 'PZ', 'ZQ',
     $               'QG', 'GF', 'Fp',
     $               'pq', 'qL', 'LZ' /
c
      np1=30
      should_be_zero=MAX(ABS(rprim(3,1)),
     $                   ABS(rprim(3,2)),
     $                   ABS(rprim(2,3)))
      IF(should_be_zero.GT.1.d-8) THEN
        STOP 'BANDSRHL: error in rprim'
      ENDIF
c
c Figure out which variation to use.
c
      a=DDOT(3,rprim(1,1),1,rprim(1,1),1)
      a=SQRT(a)
      a1a3=DDOT(3,rprim(1,1),1,rprim(1,3),1)
      cosalpha=a1a3/a**2
      tanhalfalpha=rprim(2,2)/rprim(1,2)
      IF (cosalpha.GT.0.0d0) THEN
c  Variation RHL1
        eta=(1.0d0+4.0d0*cosalpha)/(2.0d0+4.0d0*cosalpha)
        gnu=0.75d0-eta*0.5d0
        numpts=numpts1
        DO ispec=1,numpts
          symlabels(ispec)=RHL1LABELS(ispec)
        END DO
c
        ispec=LOOKUP_SYMPT('G', symlabels, numpts)
        symcoeffs(1,ispec)=0.0d0
        symcoeffs(2,ispec)=0.0d0
        symcoeffs(3,ispec)=0.0d0
c
        ispec=LOOKUP_SYMPT('B', symlabels, numpts)
        symcoeffs(1,ispec)=eta
        symcoeffs(2,ispec)=0.5d0
        symcoeffs(3,ispec)=1-eta
c
        ispec=LOOKUP_SYMPT('b', symlabels, numpts)
        symcoeffs(1,ispec)=0.5d0
        symcoeffs(2,ispec)=1.d0-eta
        symcoeffs(3,ispec)=eta-1.0d0
c
        ispec=LOOKUP_SYMPT('F', symlabels, numpts)
        symcoeffs(1,ispec)=0.5d0
        symcoeffs(2,ispec)=0.5d0
        symcoeffs(3,ispec)=0.0d0
c
        ispec=LOOKUP_SYMPT('L', symlabels, numpts)
        symcoeffs(1,ispec)=0.5d0
        symcoeffs(2,ispec)=0.0d0
        symcoeffs(3,ispec)=0.0d0
c
        ispec=LOOKUP_SYMPT('l', symlabels, numpts)
        symcoeffs(1,ispec)=0.0d0
        symcoeffs(2,ispec)=0.0d0
        symcoeffs(3,ispec)=-0.5d0
c
        ispec=LOOKUP_SYMPT('P', symlabels, numpts)
        symcoeffs(1,ispec)=eta
        symcoeffs(2,ispec)=gnu
        symcoeffs(3,ispec)=gnu
c
        ispec=LOOKUP_SYMPT('p', symlabels, numpts)
        symcoeffs(1,ispec)=1.0d0-gnu
        symcoeffs(2,ispec)=1.0d0-gnu
        symcoeffs(3,ispec)=1.0d0-eta
c
        ispec=LOOKUP_SYMPT('o', symlabels, numpts)
        symcoeffs(1,ispec)=gnu
        symcoeffs(2,ispec)=gnu
        symcoeffs(3,ispec)=eta-1.0d0
c
        ispec=LOOKUP_SYMPT('Q', symlabels, numpts)
        symcoeffs(1,ispec)=1.0d0-gnu
        symcoeffs(2,ispec)=gnu
        symcoeffs(3,ispec)=0.0d0
c
        ispec=LOOKUP_SYMPT('X', symlabels, numpts)
        symcoeffs(1,ispec)=gnu
        symcoeffs(2,ispec)=0.0d0
        symcoeffs(3,ispec)=-gnu
c
        ispec=LOOKUP_SYMPT('Z', symlabels, numpts)
        symcoeffs(1,ispec)=0.5d0
        symcoeffs(2,ispec)=0.5d0
        symcoeffs(3,ispec)=0.5d0
c
c Use default path if nbranch<=0
        IF (nbranch.LE.0) THEN
          WRITE(IWR,*)'Default '//latname//
     $      '1 bandstructure option selected'
          nbranch=numpath1
          DO i=1,nbranch
            bsymb(i)=RHL1PATH(i)
          END DO
        ENDIF
      ELSEIF (cosalpha.LT.0.0d0) THEN
c  Variation RHL2
        eta=1.d0/(2.d0*tanhalfalpha**2)
        gnu=0.75d0-eta*0.5d0
        numpts=numpts2
        DO ispec=1,numpts
          symlabels(ispec)=RHL2LABELS(ispec)
        END DO
c
        ispec=LOOKUP_SYMPT('G', symlabels, numpts)
        symcoeffs(1,ispec)=0.0d0
        symcoeffs(2,ispec)=0.0d0
        symcoeffs(3,ispec)=0.0d0
c
        ispec=LOOKUP_SYMPT('F', symlabels, numpts)
        symcoeffs(1,ispec)= 0.5d0
        symcoeffs(2,ispec)=-0.5d0
        symcoeffs(3,ispec)= 0.0d0
c
        ispec=LOOKUP_SYMPT('L', symlabels, numpts)
        symcoeffs(1,ispec)=0.5d0
        symcoeffs(2,ispec)=0.0d0
        symcoeffs(3,ispec)=0.0d0
c
        ispec=LOOKUP_SYMPT('P', symlabels, numpts)
        symcoeffs(1,ispec)=1.0d0-gnu
        symcoeffs(2,ispec)=-gnu
        symcoeffs(3,ispec)=1.0d0-gnu
c
        ispec=LOOKUP_SYMPT('p', symlabels, numpts)
        symcoeffs(1,ispec)=gnu
        symcoeffs(2,ispec)=gnu-1.0d0
        symcoeffs(3,ispec)=gnu-1.0d0
c
        ispec=LOOKUP_SYMPT('Q', symlabels, numpts)
        symcoeffs(1,ispec)=eta
        symcoeffs(2,ispec)=eta
        symcoeffs(3,ispec)=eta
c
        ispec=LOOKUP_SYMPT('q', symlabels, numpts)
        symcoeffs(1,ispec)=1.0d0-eta
        symcoeffs(2,ispec)=-eta
        symcoeffs(3,ispec)=-eta
c
        ispec=LOOKUP_SYMPT('Z', symlabels, numpts)
        symcoeffs(1,ispec)= 0.5d0
        symcoeffs(2,ispec)=-0.5d0
        symcoeffs(3,ispec)= 0.5d0
c
c Use default path if nbranch<=0
        IF (nbranch.LE.0) THEN
          WRITE(IWR,*)'Default '//latname//
     $      '2 bandstructure option selected'
          nbranch=numpath2
          DO i=1,nbranch
            bsymb(i)=RHL2PATH(i)
          END DO
        ENDIF
      ELSE
        STOP "Wrong lattice vectors"
      ENDIF
c

c
c     Use the primitive lattice vectors to make special points
c
      WRITE(IWR,*)thisroutine//': primitive reciprical lattice vectors'
      DO ivec=1,3
         WRITE(IWR,*)(gprim(icart,ivec),icart=1,3)
      ENDDO
c
      WRITE(IWR,*)
      WRITE(IWR,*)thisroutine//': symcoeffs'
      DO ispec=1,numpts
        WRITE(IWR,*)symlabels(ispec),':',
     $    (symcoeffs(ivec,ispec),ivec=1,3)
      END DO
c
      WRITE(IWR,*)
      DO ispec=1,numpts
        DO icart = 1,3
          gspec(icart,ispec)=0.0d0
          DO ivec = 1,3
            gspec(icart,ispec) = gspec(icart,ispec)
     $        + gprim(icart,ivec)*symcoeffs(ivec,ispec)
          END DO
        END DO
      END DO
c
c     Now write out the values of the special points
c
      DO ispec=1,numpts
         WRITE(IWR,*) '  ',symlabels(ispec),' ',
     $    (gspec(icart,ispec),icart=1,3)
         WRITE(IWR,*)' '
      ENDDO      
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         ibegin=LOOKUP_SYMPT(symb, symlabels, numpts)
         IF (ibegin.LT.1) THEN
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
         iend=LOOKUP_SYMPT(syme, symlabels, numpts)
         IF (iend.LT.1) THEN
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path (SKIPPED)
c
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)thisroutine//': d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/dfloat(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)thisroutine//': nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSSC
c
c
c REVISION HISTORY:
c   3May12-ACP: Merged into 2.64
c  14Oct08-AHE: Written for 2.61b
c  20Dec10-ACP: Fully merged into 2.62dev.
c
      SUBROUTINE BANDSSC(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
cAHE 101408
c
c     One of a suite of routines that calculate a set of branches for band structure 
c     calculations.
c     
c     First attempt to parse the bsymb routine into constituent characters, and check
c     against the set of special points in SC
c
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER SC(4),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),gprim(3,3)
      DIMENSION gspec(3,6),dx(3),dk(nknscfd),nbr(nbranchd)
      DATA SC/'G','X','M','R'/
      np1=60
c
c     Use the primitive lattice vectors to make special points
c
      DO i = 1,3
c     G (gamma)
         gspec(i,1)=0.0d0
c     R
         gspec(i,4)=(gprim(i,1)+gprim(i,2)+gprim(i,3))*0.5
c     X
         gspec(i,2)=(gprim(i,1))*0.5
c     M
         gspec(i,3)=(gprim(i,1)+gprim(i,2))*0.5
c     
      ENDDO
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         IF(symb.EQ.'G') THEN
            ibegin=1
         ELSEIF(symb.EQ.'X') THEN
            ibegin=2
         ELSEIF(symb.EQ.'M')THEN
            ibegin=3
         ELSEIF(symb.EQ.'R')THEN
            ibegin=4
         ELSE
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'not in the SC set of special points.  Bye!'
            STOP
         ENDIF
         IF(syme.EQ.'G') THEN
            iend=1
         ELSEIF(syme.EQ.'X') THEN
            iend=2
         ELSEIF(syme.EQ.'M')THEN
            iend=3
         ELSEIF(syme.EQ.'R')THEN
            iend=4
         ELSE
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'not in the SC set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ.1.AND. iend.NE.1) THEN 
            GO TO 10
         ELSEIF(ibegin.EQ.2.AND.iend.NE.2) THEN
            GO TO 10
         ELSEIF(ibegin.EQ.3.AND.iend.NE.3) THEN
            GO TO 10
         ELSEIF(ibegin.EQ.4.AND.iend.NE.4) THEN
            GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)'BANDSSC: d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/DFLOAT(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)'in BANDSC, nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSSTC
c
c
c REVISION HISTORY:
c   3May12-ACP: Merged into 2.64
c  04Jan09-AHE: Written for 2.61b.
c  20Dec10-ACP: Fully merged into 2.62dev.
c
      SUBROUTINE BANDSSTC(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
cAHE 010409
c
c     One of a suite of routines that calculate a set of branches for band structure 
c     calculations.
c     
c     This is the simple triclinic system, not particularly attractive. We start with 
c     one line from the gamma point to the midpoint along the
c     shortest reciprocal lattice vector. We will label thie GX
c     First attempt to parse the 
c
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER TC(4),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),gprim(3,3)
      DIMENSION gspec(3,6),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION gdis(3)
      DATA TC/'O','G','B','F'/
      np1=60
c
c     Use the primitive lattice vectors to make special points
c
c     Order the directions by size of the reciprocal vectors.
c     
      gmin=0.0d0
      DO  j=1,3
         gdis(j)=0.0d0
         DO i = 1,3
            gdis(i)=gdis(i)+gprim(i,j)*gprim(i,j)
         ENDDO
         gdis(j)=sqrt(gdis(j))
      ENDDO
      jmin=1
      jmax=1
      DO j = 2,3
         IF(gdis(j).LT.gdis(jmin))jmin=j
         IF(gdis(j).GT.gdis(jmax))jmax=j
      ENDDO
      DO j=1,3
         IF(j.NE.jmin.AND.j.NE.jmax) jmid=j
      ENDDO
      DO i = 1,3
c     O (gamma)
         gspec(i,1)=0.0d0
c     G (minimum length)
         gspec(i,2)=gprim(i,jmin)*0.5
c     B (middle length)
         gspec(i,3)=gprim(i,jmid)*0.5
c     F (maximum length)
         gspec(i,4)=gprim(i,jmax)*0.5
      ENDDO
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.eq.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         IF(symb.EQ.'O') THEN
            ibegin=1
         ELSEIF(symb.EQ.'G') THEN
            ibegin=2
         ELSEIF(symb.EQ.'B') THEN
            ibegin=3
         ELSEIF(symb.EQ.'F') THEN
            ibegin=4
         ELSE
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'not in the STC set of special points.  Bye!'
            STOP
         ENDIF
         IF(syme.EQ.'O') THEN
            iend=1
         ELSEIF(syme.EQ.'G') THEN
            iend=2
         ELSEIF(syme.EQ.'B') THEN
            iend=3
         ELSEIF(syme.EQ.'F') THEN
            iend=4
         ELSE
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'not in the STC set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ.1.AND. iend.NE.1) THEN 
            GO TO 10
         ELSEIF(ibegin.EQ.2.AND.iend.NE.2) THEN
            GO TO 10
         ELSEIF(ibegin.EQ.3.AND.iend.NE.3) THEN
            GO TO 10
         ELSEIF(ibegin.EQ.4.AND.iend.NE.4) THEN
            GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)'BANDSSTC: d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/DFLOAT(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)'in BANDSTC, nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSTC
c
c
c REVISION HISTORY:
c   3May12-ACP: Merged into 2.64
c  04Jan09-AHE: Written for 2.61b.
c  20Dec10-ACP: Fully merged into 2.62dev.
c
      SUBROUTINE BANDSTC(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
cAHE 010409
c
c     One of a suite of routines that calculate a set of branches for band structure 
c     calculations.
c     
c     This is the triclinic system, not particularly attractive. We start with 
c     one line from the gamma point to the midpoint along the
c     shortest reciprocal lattice vector. We will label thie GX
c     First attempt to parse the 
c
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER*1 TC(2)
      CHARACTER SC(2),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),gprim(3,3)
      DIMENSION gspec(3,6),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION gdis(3)
      DATA TC/'G','X'/
      np1=60
c
c     Use the primitive lattice vectors to make special points
c
c     Find the shortest of the gprims
c     
      gmin=0.0
      DO  j=1,3
         gdis(j)=0.0d0
         DO i = 1,3
            gdis(i)=gdis(i)+gprim(i,j)*gprim(i,j)
         ENDDO
         gdis(j)=SQRT(gdis(j))
      ENDDO
      jmin=1
      DO j = 2,3
         IF(gdis(j).lt.gdis(jmin))jmin=j
      ENDDO
      DO i = 1,3
c     G (gamma)
         gspec(i,1)=0.0d0
c     X
         gspec(i,2)=(gprim(i,jmin))*0.5
      ENDDO
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         IF(symb.EQ.'G') THEN
            ibegin=1
         ELSEIF(symb.EQ.'X') THEN
            ibegin=2
         ELSE
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'not in the TC set of special points.  Bye!'
            STOP
         ENDIF
         IF(syme.EQ.'G') THEN
            iend=1
         ELSEIF(syme.EQ.'X') THEN
            iend=2
         ELSE
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'not in the SC set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ.1.AND. iend.NE.1) THEN 
            GO TO 10
         ELSEIF(ibegin.EQ.2.AND.iend.NE.2) THEN
            GO TO 10
         ELSEIF(ibegin.EQ.3.AND.iend.NE.3) THEN
            GO TO 10
         ELSEIF(ibegin.EQ.4.AND.iend.NE.4) THEN
            GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)'BANDSTC: d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/DFLOAT(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)'in BANDTC, nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSTET
c
c
c REVISION HISTORY:
c   4Sep12-ACP: Forked from BANDSHEX
c   3May12-ACP: Merged into 2.64
c  20Dec10-ACP: Fully merged into 2.62dev.
c  07Oct08-AHE: Written for 2.61b
c
      SUBROUTINE BANDSTET(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER (numpts=6)
c
c     Tetragonal Bravais Lattice
c     One of a suite of routines that calculate a set of branches for
c     band structure calculations.
c     
c     Conventional Lattice Setting
c      a1=(a,0,0)
c      a2=(0,a,0)
c      a3=(0,0,c)
c
c     First attempt to parse the bsymb routine into constituent
c     characters, and check against the set of special points in TET.
c
      CHARACTER*10 thisroutine
      CHARACTER*4  latname
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER symlabels(numpts),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),gprim(3,3)
      DIMENSION gspec(3,numpts),dx(3),dk(nknscfd),nbr(nbranchd)
      DIMENSION symcoeffs(3,numpts)
      DATA thisroutine /'BANDSTET'/
      DATA latname     /'TET'/
      DATA symlabels/'G','A','M','R','X','Z'/
      DATA symcoeffs / 0.0d0, 0.0d0, 0.0d0,
     $                 0.5d0, 0.5d0, 0.5d0,
     $                 0.5d0, 0.5d0, 0.0d0,
     $                 0.0d0, 0.5d0, 0.5d0,
     $                 0.0d0, 0.5d0, 0.0d0,
     $                 0.0d0, 0.0d0, 0.5d0 /
      np1=30
c
c     Use the primitive lattice vectors to make special points
c
      WRITE(IWR,*)thisroutine//': primitive reciprical lattice vectors'
      DO ivec=1,3
         WRITE(IWR,*)(gprim(icart,ivec),icart=1,3)
      ENDDO
      WRITE(IWR,*)
      WRITE(IWR,*)thisroutine//': symcoeffs'
      DO ispec=1,numpts
        WRITE(IWR,*)symlabels(ispec),':',
     $    (symcoeffs(ivec,ispec),ivec=1,3)
      END DO
      WRITE(IWR,*)
c     Special points from Setyawan and Curtarolo, Comp. Mat. Sci. 49,
c     (2010), 299, 312.
      DO ispec=1,numpts
        DO icart = 1,3
          gspec(icart,ispec)=0.0d0
          DO ivec = 1,3
            gspec(icart,ispec) = gspec(icart,ispec)
     $        + gprim(icart,ivec)*symcoeffs(ivec,ispec)
          END DO
        END DO
      END DO
c
c     Now write out the values of the special points
c
      DO ispec=1,numpts
         WRITE(IWR,*) '  ',symlabels(ispec),' ',
     $    (gspec(icart,ispec),icart=1,3)
         WRITE(IWR,*)' '
      ENDDO      
c Use default path if nbranch<=0
      IF (nbranch.LE.0) THEN
        WRITE(IWR,*)'Default '//latname//
     $    ' bandstructure option selected'
        bsymb(1)='GX'
        bsymb(2)='XM'
        bsymb(3)='MG'
        bsymb(4)='GZ'
        bsymb(5)='ZR'
        bsymb(6)='RA'
        bsymb(7)='AZ'
        bsymb(8)='XR'
        bsymb(9)='MA'
        nbranch=9
      ENDIF
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         ibegin=LOOKUP_SYMPT(symb, symlabels, numpts)
         IF (ibegin.LT.1) THEN
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
         iend=LOOKUP_SYMPT(syme, symlabels, numpts)
         IF (iend.LT.1) THEN
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ. LOOKUP_SYMPT('G', symlabels, numpts)) THEN 
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('Z', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('R', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('A', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('R', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('R', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('M', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('A', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.EQ.LOOKUP_SYMPT('X', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('R', symlabels, numpts )) GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)thisroutine//': d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c Write out last band label
      WRITE(IBLABEL,*)syme,dk(nnscf)
      CLOSE(IBLABEL,status='keep')
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/DFLOAT(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)thisroutine//': nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BANDSTRI
c
c
c REVISION HISTORY:
c   4Sep12-ACP: Forked from BANDSHEX
c   3May12-ACP: Merged into 2.64
c  20Dec10-ACP: Fully merged into 2.62dev.
c  07Oct08-AHE: Written for 2.61b
c
      SUBROUTINE BANDSTRI(nbranch,nbranchd,bsymb,veckn,wtkn,nnscf,
     $     nknscfd, gprim,dk,nbr,IWR)
      IMPLICIT REAL*8(a-h,o-z)
      PARAMETER (numpts=8)
c
c     Triclinic Bravais Lattice
c     One of a suite of routines that calculate a set of branches for
c     band structure calculations.
c
c     Conventional Triclinic Lattice Setting (a<b<c)
c
c      a1=(a,0,0)
c      a2=(b*cos(gamma),b*sin(gamma),0)
c      a3=(c*cos(beta),c*(cos(alpha)-cos(beta)*cos(gamma))/sin(gamma),
c        (c/sin(gamma))*sqrt(sin(gamma)**2-cos(alpha)**2-cos(beta)**2+2*cos(alpha)*cos(beta)*cos(gamma)))
c
c      a1.a2=a*b*cos(gamma)
c      a1.a3=a*c*cos(beta)
c      a2.a3=b*c*cos(alpha)
c     
c     There are 4 variations that depend on the angles between the
c     reciprocal lattice vectors. The variations break into two sets of 2
c     variations that share the same coefficients for symmetry points.
c
      CHARACTER*10 thisroutine
      CHARACTER*4  latname
      CHARACTER*2 bsymb(nbranchd),symd
      CHARACTER symlabels(numpts),symb,syme,symeold
      DIMENSION veckn(3,nknscfd),wtkn(nknscfd),gprim(3,3)
      DIMENSION gspec(3,numpts),dx(3),dk(nknscfd),nbr(nbranchd)
c               symcoeffs(icart,ispec,ivariation)
      DIMENSION symcoeffs(3,numpts,2)
      DATA thisroutine /'BANDSTRI'/
      DATA latname     /'TRI'/
      DATA symlabels/'G','L','M','N','R','X','Y','Z'/
      DATA symcoeffs /
     $  0.0d0,  0.0d0,  0.0d0,
     $  0.5d0,  0.5d0,  0.0d0,
     $  0.0d0,  0.5d0,  0.5d0,
     $  0.5d0,  0.0d0,  0.5d0,
     $  0.5d0,  0.5d0,  0.5d0,
     $  0.5d0,  0.0d0,  0.0d0,
     $  0.0d0,  0.5d0,  0.0d0,
     $  0.0d0,  0.0d0,  0.5d0,
     $  0.0d0,  0.0d0,  0.0d0,
     $  0.5d0, -0.5d0,  0.0d0,
     $  0.0d0,  0.0d0,  0.5d0,
     $ -0.5d0, -0.5d0,  0.5d0,
     $  0.0d0, -0.5d0,  0.5d0,
     $  0.0d0, -0.5d0,  0.0d0,
     $  0.5d0,  0.0d0,  0.0d0,
     $ -0.5d0,  0.0d0,  0.5d0
     $ /
      np1=30
c
c     Use the primitive lattice vectors to make special points
c
      WRITE(IWR,*)thisroutine//': primitive reciprical lattice vectors'
      DO ivec=1,3
         WRITE(IWR,*)(gprim(icart,ivec),icart=1,3)
      ENDDO
      WRITE(IWR,*)
c
c     Decide which variation of the triclinic system we are.
c
      coskalpha=DDOT(3,gprim(1,2),1,gprim(1,3),1)
      coskbeta=DDOT(3,gprim(1,1),1,gprim(1,3),1)
      coskgamma=DDOT(3,gprim(1,1),1,gprim(1,2),1)
      smallabs=MIN(ABS(coskalpha), ABS(coskbeta), ABS(coskgamma))
      smallest=MIN(coskalpha, coskbeta, coskgamma)
      biggest=MAX(coskalpha, coskbeta, coskgamma)
      cutoff=1.0d-8
      IF(ABS(smallabs).GT.cutoff) THEN
        IF(biggest.GT.cutoff) THEN
c        TRI2b
          ivar=2
        ELSEIF (smallest.LT.-cutoff) THEN
c        TRI2a
          ivar=1
        ELSE
          STOP "Unrecognized variation"
        ENDIF
      ELSEIF(coskalpha.LT.0.0d0.AND.coskbeta.LT.0.0d0
     $    .AND.coskgamma.LT.0.0d0) THEN
c        TRI1a
        ivar=1
      ELSEIF(coskalpha.GT.0.0d0.AND.coskbeta.GT.0.0d0
     $    .AND.coskgamma.GT.0.0d0) THEN
c        TRI1b
        ivar=2
      ELSE
        STOP "Unrecognized variation"
      ENDIF

      WRITE(IWR,*) thisroutine//
     $  ": dot products of reciprocal lattice vectors" 
      WRITE(IWR,*)'cos(kalpha)=',coskalpha
      WRITE(IWR,*)'cos(kbeta)=',coskbeta
      WRITE(IWR,*)'cos(kgamma)=',coskgamma
      WRITE(IWR,*)
      WRITE(IWR,*)thisroutine//': symcoeffs(variation=',ivar,')'
      DO ispec=1,numpts
        WRITE(IWR,*)symlabels(ispec),':',
     $    (symcoeffs(ivec,ispec,ivar),ivec=1,3)
      END DO
      WRITE(IWR,*)
c     Special points from Setyawan and Curtarolo, Comp. Mat. Sci. 49,
c     (2010), 299, 312.
      
      DO ispec=1,numpts
        DO icart = 1,3
          gspec(icart,ispec)=0.0d0
          DO ivec = 1,3
            gspec(icart,ispec) = gspec(icart,ispec)
     $        + gprim(icart,ivec)*symcoeffs(ivec,ispec,ivar)
          END DO
        END DO
      END DO
c
c     Now write out the values of the special points
c
      DO ispec=1,numpts
         WRITE(IWR,*) '  ',symlabels(ispec),' ',
     $    (gspec(icart,ispec),icart=1,3)
         WRITE(IWR,*)' '
      ENDDO      
c Use default path if nbranch<=0
c The default path is the same for all variations.
      IF (nbranch.LE.0) THEN
        WRITE(IWR,*)'Default '//latname//
     $    ' bandstructure option selected'
        bsymb(1)='XG'
        bsymb(2)='GY'
        bsymb(3)='LG'
        bsymb(4)='GZ'
        bsymb(5)='NG'
        bsymb(6)='GM'
        bsymb(7)='RG'
        nbranch=7
      ENDIF
      nnscf=1
      dk(1)=0.0d0
      CALL FLOPENA(IBLABEL, 'bandlbls')
      symeold=' '
      DO ibr=1, nbranch
         symd=bsymb(ibr)
         symb=symd(1:1)
         iskip=0
         IF(ibr.GT.1) THEN
            IF(symb.EQ.syme) THEN
c     reduce number of points by one
               iskip=1
            ENDIF
         ENDIF
         syme=symd(2:2)
         WRITE(IWR,*)symb,'  ',syme
         ibegin=LOOKUP_SYMPT(symb, symlabels, numpts)
         IF (ibegin.lt.1) THEN
            WRITE(IWR,*)'symb = ', symb
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
         iend=LOOKUP_SYMPT(syme, symlabels, numpts)
         IF (iend.LT.1) THEN
            WRITE(IWR,*)'syme = ', syme
            WRITE(IWR,*)'Not in the '//latname//
     $        ' set of special points.  Bye!'
            STOP
         ENDIF
c
c     Now check that the endpoints are proper. Do they trace a well described path
c
         IF(ibegin.EQ. LOOKUP_SYMPT('G', symlabels, numpts)) THEN 
            IF(iend.EQ. LOOKUP_SYMPT('L', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('M', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('N', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('R', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('X', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Y', symlabels, numpts )) GO TO 10
            IF(iend.EQ. LOOKUP_SYMPT('Z', symlabels, numpts )) GO TO 10
         ELSEIF(ibegin.NE.LOOKUP_SYMPT('G', symlabels, numpts)) THEN
            IF(iend.EQ. LOOKUP_SYMPT('G', symlabels, numpts )) GO TO 10
         ELSE
            WRITE(IWR,*)symb,' and ',syme,' are not on a proper line.'
            WRITE(IWR,*)'ibegin = ', ibegin,'  iend = ',iend
            WRITE(IWR,*)'bye!'
            STOP
         ENDIF
 10      CONTINUE
c
c     Now build the points for the branch, and add them to list of NSCF points
c
         d1=0.0d0
         DO icart=1,3
            dx(icart)=(gspec(icart,iend)-gspec(icart,ibegin))/
     $           FLOAT(np1-1)
            d1=d1+dx(icart)*dx(icart)
         ENDDO
         d1=SQRT(d1)
         WRITE(IWR,*)thisroutine//': d1 = ', d1
c         write(IWR,*)'dx = ',(dx(icart),icart=1,3)
         IF(iskip.EQ.0) THEN
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)
            ENDDO
            IF(nnscf.EQ.1)THEN
               dk(nnscf)=0.0d0
            ELSE
               dk(nnscf)=dk(nnscf-1)
            ENDIF
         ELSE
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
         ENDIF
c Write out band label for this branch.
         IF(nnscf.eq.1) THEN
c First point in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf)
           ENDIF
         ELSE
c Intermediate points in the band structure
           IF((symeold.EQ.' ').OR.(symb.EQ.symeold)) THEN
             WRITE(IBLABEL,*)symb,dk(nnscf-1)
           ELSE
             WRITE(IBLABEL,*)symeold//symb,dk(nnscf-1)
           ENDIF
         ENDIF
         symeold=syme
c Write out the branch
         DO ik=2,np1-iskip
            nnscf=nnscf+1
            DO icart=1,3
               veckn(icart,nnscf)=gspec(icart,ibegin)+
     $              (ik-1+iskip)*dx(icart)
            ENDDO
            dk(nnscf)=dk(nnscf-1)+d1
c            write(IWR,*)'knscf(',nnscf,') = ',(veckn(icart,nnscf),
c     $           icart=1,3)
         ENDDO
      ENDDO
c
c     Now set the artificial weights so that the occupation is correct
c
      wt1=1.0d0/DFLOAT(nnscf)
      DO innscf=1, nnscf
         wtkn(innscf)=wt1
      ENDDO
      WRITE(IWR,*)thisroutine//': nnscf = ',nnscf
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LOOKUP_SYMPT
c
c
      INTEGER FUNCTION LOOKUP_SYMPT( sympt,symlabels,nsyms )
c
c     LOOKUP_SYMPT looks up the index of a special point symbol in a
c     character array.
c
      INTEGER nsyms
      CHARACTER sympt
      CHARACTER symlabels(*)
      INTEGER ispec, iresult
c
      iresult = -1
      DO ispec=1,nsyms
        IF(sympt.EQ.symlabels(ispec)) THEN
          iresult=ispec
        ENDIF
      END DO
c
      LOOKUP_SYMPT=iresult
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000
characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End:
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c Elements moduls
c Purpose: contains atomic (element data)
c Written: Peter A. Schultz, Febraury-2013, for 2.65
c
c No private data or private routines.
c Public routines:
c  ELEMSYMB2Z - returns Z for an input atomic symbol
c  ELEMZ2SYMB - returns atomic symbol for an input Z
c  ELEM_ULG12 - vdW parameters for given input Z, for Kim&WAG ULG corerction
c  ELEM_DFTD2 - vdW parameters for given input Z, for Grimme D2 correction
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ELEMSYMB2Z
c
c
      subroutine ELEMSYMB2Z( iatZ, atsymb )
c---------------------------------------------------------------
c Purpose: convert atom Z into atom symbol, and vice-versa
c Written: Peter A. Schultz, for 2.65 (vdW corrections)
c---------------------------------------------------------------
c
c  Returns integer "Z" for valid atomic symbol
c  Returns a "0' for a blank '  ' symbol input
c  Returns a '-1' for an unknown synbol
c
c Use 120 elements, to provide latitutde for artificial atom types
c  (e.g. floating orbitals, terminators)
c
      IMPLICIT NONE
c
      INTEGER  iatZ
      CHARACTER*2  atsymb
c
      INTEGER      isymb
      CHARACTER*2  symtable(120), symb
      DATA         symtable
     $ / 'H ','He','Li','Be','B ',  'C ','N ','O ','F ','Ne',
     $    'Na','Mg','Al','Si','P ',  'S ','Cl','Ar','K ','Ca',
     $     'Sc','Ti','V ','Cr','Mn',  'Fe','Co','Ni','Cu','Zn',
     $      'Ga','Ge','As','Se','Br',  'Kr','Rb','Sr','Y ','Zr',
     $       'Nb','Mo','Tc','Ru','Rh',  'Pd','Ag','Cd','In','Sn',
     $   'Sb','Te','I ','Xe','Cs',  'Ba','La','Ce','Pr','Nd',
     $    'Pm','Sm','Eu','Gd','Tb',  'Dy','Ho','Er','Tm','Yb',
     $     'Lu','Hf','Ta','W ','Re',  'Os','Ir','Pt','Au','Hg',
     $      'Tl','Pb','Bi','Po','At',  'Rn','Fr','Ra','Ac','Th',
     $       'Pa','U ','Np','Pu','Am',  'Cm','Bk','Cf','Es','Fm',
     $   'Md','No','Lr','A4','A5',  'A6','A7','A8','A9','T0',
     $    'T1','T2','T3','T4','T5',  'T6','T7','T8','T9','FO' /
c
      iatZ = 0
      if( atsymb .eq. '  ' ) RETURN
c
      symb = atsymb
c     Left-justify symbol, to ensure valid comparison to table:
      if( symb(1:1) .eq. ' ' )then
        symb(1:1) = symb(2:2)
        symb(2:2) = ' '
      endif
c
      do  isymb=1,120
c       Find the atom in the table:
        if( symb.eq.symtable(isymb) )then
          iatZ = isymb
          RETURN
        endif
      enddo
      iatZ = -1
c
      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ELEMZ2SYMB
c
      ENTRY ELEMZ2SYMB( iatZ, atsymb )
c
      if( iatZ.gt.0 .and. iatZ.le.120 )then
        atsymb = symtable(iatZ)
      else
c       Not a defined Z
        atsymb = '??'
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ELEM_ULG12
c
c
      subroutine ELEM_ULG12( iatZ, c6, r0 )
c---------------------------------------------------------------
c Purpose: c6/r0 parameters for ULG vdW correction
c Written: Peter A. Schultz, for 2.65 (vdW corrections)
c---------------------------------------------------------------
c
c Following: H.Kim, J.-M.Choi, and WAG, JPhChL 3, 360 (2012).
c   vdW Data: D0 is in units of (kcal/mol)*A^6, R0 is in units of Angstrom
c   Output c6 is in units of Ry, r0 in units of bohr
c  
      IMPLICIT NONE
c
      REAL*8   zero,one,two
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0 )
c
c Input:
      INTEGER  iatZ
c Output:
      REAL*8   c6,r0
c
c Local:
      REAL*8   d0
c Data:
      INTEGER  nzulg
      PARAMETER  ( nzulg = 103 )
c        'H ',  'He',  'Li',  'Be',    'B ',  'C ',  'N ',  'O ',
c         'F ',  'Ne',  'Na',  'Mg',    'Al',  'Si',  'P ',  'S ',
c          'Cl',  'Ar',  'K ',  'Ca',    'Sc',  'Ti',  'V ',  'Cr',
c           'Mn',  'Fe',  'Co',  'Ni',    'Cu',  'Zn',  'Ga',  'Ge',
c        'As',  'Se',  'Br',  'Kr',    'Rb',  'Sr',  'Y ',  'Zr',
c         'Nb',  'Mo',  'Tc',  'Ru',    'Rh',  'Pd',  'Ag',  'Cd',
c          'In',  'Sn',  'Sb',  'Te',    'I ',  'Xe',  'Cs',  'Ba',
c           'La',  'Ce',  'Pr',  'Nd',    'Pm',  'Sm',  'Eu',  'Gd',
c        'Tb',  'Dy',  'Ho',  'Er',    'Tm',  'Yb',  'Lu',  'Hf',
c         'Ta',  'W ',  'Re',  'Os',    'Ir',  'Pt',  'Au',  'Hg',
c          'Tl',  'Pb',  'Bi',  'Po',    'At',  'Rn',  'Fr',  'Ra',
c           'Ac',  'Th',  'Pa',  'U ',    'Np',  'Pu',  'Am',  'Cm',
c        'Bk',  'Cf',  'Es',  'Fm',    'Md',  'No',  'Lr'
      REAL*8  xkcal2Ry, xA2bohr
      PARAMETER  ( xkcal2Ry=0.0031864d0, xA2bohr=1.8897265d0 )
      REAL*8  D0ulg, R0ulg
      DIMENSION  D0ulg(nzulg), R0ulg(nzulg)
      DATA    D0ulg
     $ / 0.0440,0.0560,0.0250,0.0850,  0.1800,0.1050,0.0690,0.0600,
     $    0.0500,0.0420,0.0300,0.1110,  0.5050,0.4020,0.3050,0.2740,
     $     0.2270,0.1850,0.0350,0.2380,  0.0190,0.0170,0.0160,0.0150,
     $      0.0130,0.0130,0.0140,0.0150,  0.0050,0.1240,0.4150,0.3790,
     $   0.3090,0.2910,0.2510,0.2200,  0.0400,0.2350,0.0720,0.0690,
     $    0.0590,0.0560,0.0480,0.0560,  0.0530,0.0480,0.0360,0.2280,
     $     0.5990,0.5670,0.4490,0.3980,  0.3390,0.3320,0.0450,0.3640,
     $      0.0170,0.0130,0.0100,0.0100,  0.0090,0.0080,0.0080,0.0090,
     $   0.0070,0.0070,0.0070,0.0070,  0.0060,0.2280,0.0410,0.0720,
     $    0.0810,0.0670,0.0660,0.0370,  0.0730,0.0800,0.0390,0.3850,
     $     0.6800,0.6630,0.5180,0.3250,  0.2840,0.2480,0.0500,0.4040,
     $      0.0330,0.0260,0.0220,0.0220,  0.0190,0.0160,0.0140,0.0130,
     $   0.0130,0.0130,0.0120,0.0120,  0.0110,0.0110,0.0110 / 
      DATA     R0ulg
     $ / 2.8860,2.3620,2.4510,2.7450,  4.0830,3.8510,3.6600,3.5000,
     $    3.3640,3.2430,2.9830,3.0210,  4.4990,4.2950,4.1470,4.0350,
     $     3.9470,3.8680,3.8120,3.3990,  3.2950,3.1750,3.1440,3.0230,
     $      2.9610,2.9120,2.8720,2.8340,  3.4950,2.7630,4.3830,4.2800,
     $   4.2300,4.2050,4.1890,4.1410,  4.1140,3.6410,3.3450,3.1240,
     $    3.1650,3.0520,2.9980,2.9630,  2.9290,2.8990,3.1480,2.8480,
     $     4.4630,4.3920,4.4200,4.4700,  4.5000,4.4040,4.5170,3.7030,
     $      3.5220,3.5560,3.6060,3.5750,  3.5470,3.5200,3.4930,3.3680,
     $   3.4510,3.4280,3.4090,3.3910,  3.3740,3.3550,3.6400,3.1410,
     $    3.1700,3.0690,2.9540,3.1200,  2.8400,2.7540,3.2930,2.7050,
     $     4.3470,4.2970,4.3700,4.7090,  4.7500,4.7650,4.9000,3.6770,
     $      3.4780,3.3960,3.4240,3.3950,  3.4240,3.4240,3.3810,3.3260,
     $   3.3390,3.3130,3.2990,3.2860,  3.2740,3.2480,3.2360 /
c
c >>>> EXECUTABLE CODE
c
      if( iatZ.gt.0 .and. iatZ.le.nzulg )then
        d0 = D0ulg(iatZ)
        r0 = R0ulg(iatZ)
        c6 = two*d0*(r0**6)
      else
        c6 = -1.
        r0 = one
      endif
c Convert units to Ry and bohr:
      c6 = c6 * xkcal2Ry * (xA2bohr**6)
      r0 = r0 * xA2bohr
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ELEM_DFTD2
c
c
      subroutine ELEM_DFTD2( iatZ, c6, r0 )
c---------------------------------------------------------------
c Purpose: c6/r0 parameters for Grimme06 DFT-D2 vdW correction
c Written: Peter A. Schultz, for 2.65 (vdW corrections)
c---------------------------------------------------------------
c
c Following: S.Grimme, J.Comput.Chem. 27, 1787 (2006).
c
c  vdW Data: C6 in units of J(nm^6)*mol^-1, R0 in units of Angstrom
c  Output c6 is in units of Ry*bohr^6, r0 in units of bohr
c  Conversion arithmetic:
c  1 J = 2.2937d+17 Ha = 4.5874d+17 Ry
c  1 nm = 10 A, 1 A = 1.8897265 bohr
c  Avogadro's = 6.022137d+23 mol^-1
c  1 Jnm6/mol = (4.5874d17 Ry/J) * (10A/nm)**6 * (1/6.022137d+23) = 0.76176 Ry*A^6
c
      IMPLICIT NONE
c
      REAL*8   zero,one,two
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0 )
c
c Input:
      INTEGER  iatZ
c Output:
      REAL*8   c6,r0
c
c Local:
      REAL*8   xJtoRy, xA2bohr
      PARAMETER  ( xJtoRy=0.76176d0, xA2bohr=1.8897265d0 )
      INTEGER  nzd2
      PARAMETER  ( nzd2 = 54 )
c        'H ',  'He',  'Li',  'Be',    'B ',  'C ',  'N ',  'O ',
c         'F ',  'Ne',  'Na',  'Mg',    'Al',  'Si',  'P ',  'S ',
c          'Cl',  'Ar',  'K ',  'Ca',    'Sc',  'Ti',  'V ',  'Cr',
c           'Mn',  'Fe',  'Co',  'Ni',    'Cu',  'Zn',  'Ga',  'Ge',
c        'As',  'Se',  'Br',  'Kr',    'Rb',  'Sr',  'Y ',  'Zr',
c         'Nb',  'Mo',  'Tc',  'Ru',    'Rh',  'Pd',  'Ag',  'Cd',
c          'In',  'Sn',  'Sb',  'Te',    'I ',  'Xe'
      REAL*8     C6D2, R0D2
      DIMENSION  C6D2(nzd2), R0D2(nzd2)
      DATA    C6D2
     $ /  0.14,  0.08,  1.61,  1.61,    3.13,  1.75,  1.23,  0.70, 
     $     0.75,  0.63,  5.71,  5.71,   10.79,  9.23,  7.84,  5.57, 
     $      5.07,  4.61, 10.80, 10.80,   10.80, 10.80, 10.80, 10.80,
     $      10.80, 10.80, 10.80, 10.80,   10.80, 10.80, 16.99, 17.10, 
     $   16.37, 12.64, 12.47, 12.01,   24.67, 24.67, 24.67, 24.67,
     $    24.67, 24.67, 24.67, 24.67,   24.67, 24.67, 24.67, 24.67,
     $     37.32, 38.71, 38.44, 31.74,   31.50, 29.99 /
      DATA     R0D2
     $ / 1.001, 1.012, 0.825, 1.408,   1.485, 1.452, 1.397, 1.342,
     $    1.287, 1.243, 1.144, 1.364,   1.639, 1.716, 1.705, 1.683,
     $     1.639, 1.595, 1.485, 1.474,   1.562, 1.562, 1.562, 1.562,
     $      1.562, 1.562, 1.562, 1.562,   1.562, 1.562, 1.650, 1.727,
     $   1.760, 1.771, 1.749, 1.727,   1.628, 1.606, 1.639, 1.639,
     $    1.639, 1.639, 1.639, 1.639,   1.639, 1.639, 1.639, 1.639,
     $     1.672, 1.804, 1.881, 1.892,   1.892, 1.881 /
c
c >>>> EXECUTABLE CODE
c
      if( iatZ.gt.0 .and. iatZ.le.nzd2 )then
        c6 = C6D2(iatZ)
        r0 = R0D2(iatZ)
      else
c       If not in set, set to invalid values
        c6 = -1.
        r0 = one
      endif
c
c Convert units to Ry and bohr:
      c6 = c6 * xJtoRy * (xA2bohr**6)
      r0 = r0 * xA2bohr
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWFF
c
c
      subroutine VDWFF( engyvdw, frcvdw,strvdw, c6vdw,r0vdw,
     $ c6ijvdw,r0ijvdw,
     $ natm,ntyp, nlat  ,nlat2c, itypa, znuc, alamin,
     $ ratm, rlat )
c---------------------------------------------------------------
c Purpose: compute van der Waals correction using pair potentials
c
c Written: Peter A. Schultz, xx-February-2013, for 2.65
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c  Two forms of pair-potential vdW corrections are currently implemented:
c  (1) DFT-D2, per Stefan Grimme, J. Comput. Chem. 27, 1787 (2006).
c  (2) ULG, per H. Kim, J.-M. Choi, and WAG III, JPhChL 3, 360 (2012).
c
c  Input vdW parameters to this routine are assumed to be Ry and bohr.
c  Output units are also in Ry atomic units
c
c  Note that meanings of d_vdw and r0vdw are different in these two methods.
c   d_vdw is used in different functional forms for damp short-range interations.
c   r0vdw in DFT-D@ is an atomic vdW radius, in ULG it is a dimer bond minimum.
c   rc_vdw os a global long-range cutoff for evaluation of these terms
c  Note that code will use overlap cutoffs to limit range of interacions,
c  as the lattice vectors are set up for this (and <10^-6 terms will not matter)
c
c  This version is non-parallel, all processors do whole thing
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON  /CUTS/ cutgaus,cutgrid,cutgwfn,cutslow,cutii,alfast
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, half=0.5d0 )
c
c Output arrays:
      DIMENSION  frcvdw(3,*), strvdw(3,3)
c
c Input arrays:
      DIMENSION  itypa(natm)
      DIMENSION  znuc(ntyp), alamin(ntyp)
      DIMENSION  ratm(3,natm)
      DIMENSION  rlat(3,nlat)
      DIMENSION  c6vdw(ntyp), r0vdw(ntyp)
      DIMENSION  c6ijvdw(ntyp,ntyp), r0ijvdw(ntyp,ntyp)
c
      LOGICAL     DO_VDW
c
c Local declarations:
c
      DIMENSION   rij(3), fij(3)
      LOGICAL     dbgvdw
      DATA        dbgvdw / .false. /
c lstout controls diagnostic output 0-none,1-minimal,n>1-more
      DATA  lstout  / 0 /
      CHARACTER*6  fcnal
c---------------------------------------------------------------
c
c >>>> EXECUTABLE CODE:
c
c Start with a blank slate:
      engyvdw = zero
      call MKZERO( 3*natm, frcvdw )
      call MKZERO( 3*3   , strvdw )
c
c Check if we have a vdW correction to evaluate
      if( .not. DO_VDW() ) RETURN
      call FLGETIWR( IWR )
      call VDWGETNAME( fcnal )
      write(IWR,*) 'VDWFF: van der Waals C6 corrections=',fcnal
c
      call VDWGET_S( sfac )
      s_vdw = sfac
      call VDWGET_RC( rcfac )
      rc_vdw = rcfac
c
      if( dbgvdw )then
        call VDWGETNAME( fcnal )
        call VDWGET_D( dfac )
        ivdw = IVDWTYPE()
 9020   format(1x,a,i3,1x,a6, 3f12.6)
        write(IWR,9020) 'VDW-FF: i/vdw.s.d.rc=',
     $   ivdw       , fcnal, sfac,dfac,rcfac
 9021   format(2x,a,2i6)
 9022   format(2x,a,(9f18.6))
        write(IWR,9022) 'VDWFF: c6vdw()=',(c6vdw(ityp),ityp=1,ntyp)
        write(IWR,9022) 'VDWFF: r0dww()=',(r0vdw(ityp),ityp=1,ntyp)
      endif
c
c Set up the local cutoff criterion
      argmx = half*cutgaus
      emax = cutslow
c
c Loop over atom pairs, collect terms
c
      do 2000 jatm=1,natm
        jtyp = itypa(jatm)
        if(dbgvdw) write(IWR,9021) 'jatm,jtyp=',jatm,jtyp
  
        if( znuc(jtyp).eq.zero ) goto 2000
c
        c6j = c6vdw(jtyp)
        r0j = r0vdw(jtyp)
        if(dbgvdw) write(IWR,9022) 'cvdw(atom): c6j,r0j=',c6j,r0j
        if( c6j .le. zero ) goto 2000
c
        alaminj = alamin(jtyp)
c
        do 1000 iatm=jatm,natm
          ityp = itypa(iatm)
          if(dbgvdw) write(IWR,9021) '  iatm,ityp=',iatm,ityp
          if( znuc(ityp).eq.zero ) goto 1000
c
          c6i = c6vdw(ityp)
          r0i = r0vdw(ityp)
          if( c6i .le. zero ) goto 1000
c
c         Construct cross-potentials, as needed
C          call VDWIJMIX( c6i,c6j, c6ij, r0i,r0j,r0ij )
          c6ij = c6ijvdw(ityp,jtyp)
          r0ij = r0ijvdw(ityp,jtyp)
          if(dbgvdw) write(IWR,9022)'  cvdw(pair): c6ij,r0ij=',c6ij,r0ij
c
c         Check that this pairwise interaction is allowed
          if( c6ij .le. zero ) goto 1000
c         Determine maximum range of interactions, using orbital overlap cutoffs
          alamini = alamin(ityp)
          rijmax = SQRT( emax*(alamini+alaminj) / (alamini*alaminj) )
          rcutoff = MIN( rijmax, rc_vdw )
c
          do 900 ilat=1,nlat
c
            rij2 = zero
            do  ir=1,3
              rij(ir) = ratm(ir,jatm) - (ratm(ir,iatm)+rlat(ir,ilat))
              rij2 = rij2 + rij(ir)**2
            enddo
            rijmag = SQRT( rij2 )
c           This ensures atom does not see itself, and cuts off long-range vdW
            if( rijmag .lt. 0.1d0 .or. rijmag .gt. rcutoff ) goto 900
c
c           Compute vdw term
            call VDWPAIR( e_vdw,de_vdw, rijmag,c6ij,r0ij )
C           write(IWR,914) '    pair vdw: ilat,rij,e_vdw=',ilat,rijmag,e_vdw
C  914      format(1x,a,i5,f9.4,3x,1pd15.8)
c
            if( iatm .eq. jatm )then
              e_vdw = e_vdw / two
              de_vdw = de_vdw / two
            endif
c
c           Add contribution to energy force and stress
            engyvdw = engyvdw + e_vdw
c
            do  ir=1,3
              fij(ir) = de_vdw*(rij(ir)/rijmag)
            enddo
            do  ir=1,3
              frcvdw(ir,jatm) = frcvdw(ir,jatm) - fij(ir)
              frcvdw(ir,iatm) = frcvdw(ir,iatm) + fij(ir)
            enddo
c
            do  jr=1,3
              do  ir=1,3
                strvdw(ir,jr) = strvdw(ir,jr) + fij(ir)*rij(jr)
              enddo
            enddo
c
c           Close Atom i + latvec loops:
  900     continue
c
 1000   continue
c
c       Close Atom j loop:
 2000 continue
c
c Scale the computed vdw results by the (functional-dependent) global scale factor
c
      if( dbgvdw ) write(IWR,'(a,f20.8)')
     $ 'End vdwff: Unscaled engyvdw, sfactor=', engyvdw,s_vdw
c
      engyvdw = engyvdw*s_vdw
      call DSCAL( 3*natm, s_vdw, frcvdw,1 )
      call DSCAL( 3*3   , s_vdw, strvdw,1 )
c
c    That's all Folks!
c
      RETURN
      END
c*******************************************************************************
c VDWLOAD - routines to populate VDW data
c
C Routines:
c  VDWNULL  - initialize vdw parameters to a null state
c  VDWCHECK - check if any atom types are missing vdW parameters
c  VDWLOADZ - from deduced atomic Z values, populate vdW ff parameters
c  VDWDATA  - from input file (within setdata), read user input for vdW ff parameters
c
c Revision history:
c   9Apr15-PAS/2.66: LN line/character manipulation routine xfers out to strpars
c*******************************************************************************
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWNULL
c
c
      subroutine VDWNULL( ntyp, c6vdw,r0vdw, c6ijvdw,r0ijvdw )
c---------------------------------------------------------------
c Purpose: Initialize vdw parameters to a null state
c Written: Peter A. Schultz, April-2013, for 2.65
c---------------------------------------------------------------
c
c The vdw parameters are all positive definite.
c A negative value denotes a parameter that is uninitialized
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( vdwna = -1.d0 )
c Output arrays:
      DIMENSION  c6vdw(ntyp), r0vdw(ntyp)
      DIMENSION  c6ijvdw(ntyp,ntyp), r0ijvdw(ntyp,ntyp)
c
c >>>> EXECUTABLE CODE:
c
      do  ityp=1,ntyp
        c6vdw(ityp) = vdwna
        r0vdw(ityp) = vdwna
        do jtyp=1,ntyp
          c6ijvdw(ityp,jtyp) = vdwna
          r0ijvdw(ityp,jtyp) = vdwna
        enddo
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWCHECK
c
c
      subroutine VDWCHECK( IWR, ntyp, typnm, c6vdw,r0vdw, iunkn )
c---------------------------------------------------------------
c Purpose: check for initialized atom types for vdW
c Written: Peter A. Schultz, April-2013, for 2.65
c---------------------------------------------------------------
c
c  ierr returns number of atom types without valid vdW parameters
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero = 0.d0 )
c Input arrays:
      DIMENSION  c6vdw(ntyp), r0vdw(ntyp)
      CHARACTER*(*)  typnm(ntyp)
c
c >>>> EXECTUABLE CODE:
c
      iunkn = 0
      do  ityp=1,ntyp
        if( c6vdw(ityp).lt.zero .or. r0vdw(ityp).lt.zero )then
c         We have an unaccounted-for atom type
          if( IWR.gt.0 )
     $    write(IWR,*) 'VDW param unknown, type=',ityp,'  ',typnm(ityp)
          iunkn = iunkn + 1
        endif
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWLOADZ
c
c
      subroutine VDWLOADZ( IWRF, ntyp, znuc,typnm,natmnm, c6vdw,r0vdw )
c---------------------------------------------------------------
c Purpose: load vdw parameters from internal data, using deduced atomic-Z
c
c Written: Peter A. Schultz, xx-February-2013, for 2.65
c
c Revision history:
c  none
c---------------------------------------------------------------
c
c  Two forms of pair-potential vdW corrections are currently implemented:
c  (1) DFT-D2, per Stefan Grimme, J. Comput. Chem. 27, 1787 (2006).
c  (2) ULG, per H. Kim, J.-M. Choi, and WAG III, JPhChL 3, 360 (2012).
c
c  Note that meanings of d_vdw and rt0vdw are different in these two methods.
c   d_vdw is used in different functional forms for damp short-range interations.
c   r0vdw in DFT-D@ is an atomic vdW radius, in ULG it is a dimer bond minimum.
c   rc_vdw os a global long-range cutoff for evaluation of these terms
c
c  Input vdW parameters are assumed to be Ry and bohr.
c  Output units are also in Ry atomic units
c  
c  Note that I will use overlap cutoffs to limit range of interacions,
c  as the lattice vectors are set up for this (and <10^-6 terms will not matter)
c
c  This version is non-parallel, all processors do whole thing
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON /VDWCTRL / i_vdw, i_dftd2,i_ulg
      COMMON /VDWSTUFF/ vdw_s,vdw_d,vdw_rc
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, half=0.5d0 )
c
c Output arrays:
      DIMENSION  c6vdw(ntyp), r0vdw(ntyp)
c
c Input arrays:
      DIMENSION  znuc(ntyp)
      CHARACTER*(*)  typnm(ntyp)
c
c Local declarations:
      CHARACTER*80  strtmp
      CHARACTER*2   symbty
      LOGICAL       printon
c
c >>>> EXECUTABLE CODE:
c
      printon = ( IWRF .ge. 0 )
      if( i_vdw.eq.0 ) RETURN
c
      if( printon )
     $write(IWRF,*) '#>>>> VDWLOADZ: load internal c6, ivdw=',i_vdw
c
      do 1000 ityp=1,ntyp
c
        if( znuc(ityp).le.zero )then
c         Floating orbital or other potential-less site
          c6vdw(ityp) = zero
          r0vdw(ityp) = zero
          goto 1000
        endif
c
c       Attempt to get element type from type name
        symbty = '  '
        call STRPARS( typnm(ityp), 1,natmnm, n1,n2 )
        if( n1 .eq. 0 ) call STOPXERR( 'nameless type in vdw' )
        strtmp(1:natmnm) = typnm(ityp)
        lennm = MIN( (n2+1-n1), 2 )
        n2 = n1 + lennm - 1
        symbty(1:lennm) =  strtmp(n1:n2)
c
        call ELEMSYMB2Z( iatZ, symbty )
        if( i_vdw .eq. i_dftd2 )then
          call ELEM_DFTD2( iatZ, c6i,r0i )
        elseif( i_vdw .eq. i_ulg )then
          call ELEM_ULG12( iatZ, c6i,r0i )
        else
          if( printon )
     $     write(IWRF,*)'#>>>> VDWLOADZ: c6 not found type=',ityp,symbty
          goto 1000
        endif
c
        c6vdw(ityp) = c6i
        r0vdw(ityp) = r0i
c
        if( printon )     
     $   write(IWRF,'(a,i2,3x,a2,2f16.4)')
     $    '# VDWLOADZ: ityp,c6(Ry),r0(Bohr)=', ityp,symbty,c6i,r0i
c
 1000 continue
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWDATA
c
c
      subroutine VDWDATA( IWRF,IDAT, ntyp, typnm,natmnm, c6vdw,r0vdw,
     $                    c6ijvdw,r0ijvdw )
c---------------------------------------------------------------
c Purpose: read user input that modifies the vdW C6 potentials
c
c Written: Peter A. Schultz, xx-February-2013, for 2.65
c
c Revision history:
c  17May14-PAS/2.65c: allow direct input of c6(pair) [w/o r0(pr)]
c   9May14-PAS/2.65c: fix bugs-ijvdw args, and misplaced goto
c---------------------------------------------------------------
c
c  Units are Rydberg atomic units: energy in Rydberg, distance in Bohr.
c
c  This routine designed to allow the entire vdw specification to be specified,
c  or only any part of it that the user wants to modify.
c  With this design, this specification could be located in a separate vdw file.
c   which would require only a little work (in setdata) to implement.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, half=0.5d0 )
c
c Output arrays:
      DIMENSION  c6vdw(ntyp), r0vdw(ntyp)
      DIMENSION  c6ijvdw(ntyp,ntyp), r0ijvdw(ntyp,ntyp)
c
c Input arrays:
      CHARACTER*(*)  typnm(ntyp)
c
c Local declarations:
      PARAMETER  (nline=80)
      CHARACTER*(nline)  line, tmpline
      CHARACTER*6  wantlbl,readlbl
      CHARACTER*1  ktype
      EQUIVALENCE  (line,readlbl)
      CHARACTER*2   symbty
      LOGICAL      printon
c
c >>>> EXECUTABLE CODE:
c
      printon = ( IWRF.ge.0 )
 8000 format(a80)
 9000 format(1x,a)
 9002 format(1x, 2(5x,f16.8) )
 9012 format(1x, a, 2(5x,f16.8) )
 9022 format(1x, a, 2x, a, 2(5x,f16.8) )
c
  100 continue
      read(IDAT,8000)  line
      if(printon) call LNWRIT( IWRF, line, nline )
c
      if( readlbl .eq. 'vdw_da' )then
c       File heading
        goto 100
      endif
c
      if( readlbl(1:5) .eq. 'vdwff' .or.
     $    readlbl .eq. 'fftype' )then
c       Read the vdw correcion type ...
c       ... and check that it is consistent with earlier input
        read(IDAT,8000)  line
        if(printon) call LNWRIT( IWRF, line, nline )
c       
        call STRPARS( line , 1,nline, n1,n2 )
        if( n1 .eq. 0 )then
           write(IWRF,*) 'no vdw type  label input is blank'
           goto 1300
        endif
        wantlbl = '      '
        nlbl = MIN( n2-n1+1, 6 )
c       Note that cannot use "readlbl" here, as readlbl==line:
        wantlbl(1:nlbl) = line(n1:n2)
c
        call VDWGETNAME( readlbl )
        if( wantlbl .ne. readlbl )then
c         This file and calculation vdw ff disagree - kill
          call FLGETIERR( IERRFL )
          write(IERRFL,*) '**** QM input and vdw file ff mismatch'
          write(IERRFL,*) '>>>> internal  ff=', readlbl
          write(IERRFL,*) '>>>> vdw-input ff=', wantlbl
          call STOPXERR( 'QM and VDW mismatch ff type' )
        endif
      endif
c
c >>>>> Get global factors for vdw pair potentials
c
  300 continue
      read(IDAT,8000)  line
      if(printon) call LNWRIT( IWRF, line, nline )
c
      if( readlbl .eq. 'sfacto' )then
c       Set the s-factor (fcnal-dependent scaling)
        read(IDAT,*) s_vdw
        if(printon)  write(IWRF,9002)  s_vdw
        call VDWSET_S( s_vdw )
        goto 300
      endif
c
      if( readlbl .eq. 'dfacto' .or. 
     $    readlbl(1:3) .eq. 'blg' )then
c       Set the d-factor (damping function factor)
        read(IDAT,*) d_vdw
        if(printon)  write(IWRF,9002)  d_vdw
        if( d_vdw .gt. zero )then
          call VDWSET_D( d_vdw )
        else
c         d-factor must be greater than zero
          call STOPXERR( 'invalid value for d_vdw' )
        endif
        goto 300
      endif
c
      if( readlbl(1:6) .eq. 'rcutof' )then
c       Set the range cutoff for vdW (in bohr)
        read(IDAT,*) rc_vdw
        if(printon)  write(IWRF,9002)  rc_vdw
        if( rc_vdw .gt. zero )then
          call VDWSET_RC( rc_vdw )
        else
c         vdw cutoff distance must be positive
          call STOPXERR( 'invalid value for rc_vdw' )
        endif
        goto 300
      endif
c
      if( readlbl .eq. 'vdw_co' )then
c       Go to the section to get parameters
        goto 400
      endif
c
c     If we lacked it, insert the keyword for coeff section:
      if(printon)  write(IWRF,9000) 'vdw_coefficients'
      goto 401
c
c >>>>> Get single-atom vdw parameters
c
  400 continue
      read(IDAT,8000)  line
      if(printon) call LNWRIT( IWRF, line, nline )
  401 continue
c
      if( readlbl .eq. 'atomc6' .or. readlbl .eq. 'c6atom' )then
c       Read(IDAT,*)     typ  c6
        read(IDAT,8000)  line
        n1 = 1
        call LNREADTYP( line,n1,nline, ityp, ntyp,typnm,natmnm )
        if( ityp.gt.0 .and. ityp.le.ntyp )then
c         Extract c6 coefficient
          call LNREADR8( line,n1,nline, c6i, ierr )
          if( ierr.eq.0 )then
            if(printon) write(IWRF,9012)  typnm(ityp), c6i
            c6vdw(ityp) = c6i
          else
            if(printon) write(IWRF,*) '***** ERROR reading c6 from:'
            if(printon) call LNWRIT( IWRF, line, nline )
            call STOPXERR( 'error reading c6 coeff' )
          endif
        else
          if(printon) call LNWRIT( IWRF, line, nline )
        endif
        goto 400
c
      elseif( readlbl .eq. 'atomr0' .or. readlbl .eq. 'r0atom' )then
C       Read(IDAT,*)     typ  c6
        read(IDAT,8000)  line
        n1 = 1
        call LNREADTYP( line,n1,nline, ityp, ntyp,typnm,natmnm )
        if( ityp.gt.0 .and. ityp.le.ntyp )then
c         Extract r0 coefficient
          call LNREADR8( line,n1,nline, r0i, ierr )
          if( ierr.eq.0 )then
            if(printon) write(IWRF,9012)  typnm(ityp), r0i
            r0vdw(ityp) = r0i
          else
            if(printon) write(IWRF,*) 'ERROR reading r0 from:'
            if(printon) call LNWRIT( IWRF, line, nline )
            call STOPXERR( 'error reading r0 coeff' )
          endif
        else
          if(printon) call LNWRIT( IWRF, line, nline )
        endif
        goto 400
c
      elseif( readlbl .eq. 'atomff' .or. readlbl.eq. 'ffatom' )then
C       Read(IDAT,*)     typ  c6  r0
        read(IDAT,8000)  line
        n1 = 1
        call LNREADTYP( line,n1,nline, ityp, ntyp,typnm,natmnm )
        if( ityp.gt.0 .and. ityp.le.ntyp )then
c         Extract vdw (c6 and r0) coefficients
          call LNREADR8( line,n1,nline, c6i, ierr1 )
          call LNREADR8( line,n1,nline, r0i, ierr2 )
          if( ierr1.eq.0 .and. ierr2.eq.0 )then
            if(printon) write(IWRF,9012)  typnm(ityp), c6i, r0i
            c6vdw(ityp) = c6i
            r0vdw(ityp) = r0i
          else
            if(printon) write(IWRF,*) 'ERROR reading c6 and r0 from:'
            if(printon) call LNWRIT( IWRF, line, nline )
            call STOPXERR( 'error reading vdw coeffs' )
          endif
        else
          if(printon) call LNWRIT( IWRF, line, nline )
        endif
        goto 400
      endif
c
c     End input of atomic c6/r0 parameters, check that dance card is full
      call VDWCHECK( IWR, ntyp, typnm, c6vdw,r0vdw, ierr )
      if( ierr .ne. 0 )then
        write(IWR,*) 'Total atom types lacking vdW parameters=',ierr
        call STOPXERR( 'Some atoms missing vdW parameters' )
      endif
c    
c     Build (default) cross-terms, and check if have 2-center input
      call VDWCROSS( ntyp, c6vdw,r0vdw, c6ijvdw,r0ijvdw )
c
      if( readlbl .ne. 'vdw_2c' ) goto 800
c
c >>>>> Modify atom-pair vdw potentials
c
  500 continue
      read(IDAT,8000)  line
      if(printon) call LNWRIT( IWRF, line, nline )
  501 continue
c
      if( readlbl .eq. 'pairff' .or. readlbl .eq. 'ffpair' )then
c       Read c6/r0 for atom pair
C       read(IDAT)       typ1  typ2  c6ij  r0ij
        read(IDAT,8000)  line
        n1 = 1
        call LNREADTYP( line,n1,nline, ityp, ntyp,typnm,natmnm )
        call LNREADTYP( line,n1,nline, jtyp, ntyp,typnm,natmnm )
        if( ityp.gt.0 .and. ityp.le.ntyp  .and.
     $      jtyp.gt.0 .and. jtyp.le.ntyp )then
c         Valid entries, extract vdw (c6 and r0) coefficients
          call LNREADR8( line,n1,nline, c6ij, ierr1 )
          call LNREADR8( line,n1,nline, r0ij, ierr2 )
          if( ierr1.eq.0 .and. ierr2.eq.0 )then
            if(printon)
     $      write(IWRF,9022)  typnm(ityp), typnm(jtyp), c6ij, r0ij
            c6ijvdw(ityp,jtyp) = c6ij
            r0ijvdw(ityp,jtyp) = r0ij
            c6ijvdw(jtyp,ityp) = c6ij
            r0ijvdw(jtyp,ityp) = r0ij
          else
            if(printon) write(IWRF,*) 'ERROR reading c6 and r0 from:'
            if(printon) call LNWRIT( IWRF, line, nline )
            call STOPXERR( 'error reading vdw coeffs' )
          endif
        else
          if(printon) call LNWRIT( IWRF, line, nline )
        endif
        goto 500
c
      elseif( readlbl .eq. 'pairc6' .or. readlbl .eq. 'c6pair' )then
c       Read c6/r0 for atom pair
C       read(IDAT)       typ1  typ2  c6ij
        read(IDAT,8000)  line
        n1 = 1
        call LNREADTYP( line,n1,nline, ityp, ntyp,typnm,natmnm )
        call LNREADTYP( line,n1,nline, jtyp, ntyp,typnm,natmnm )
        if( ityp.gt.0 .and. ityp.le.ntyp  .and.
     $      jtyp.gt.0 .and. jtyp.le.ntyp )then
c         Valid entries, extract c6 coefficients
          call LNREADR8( line,n1,nline, c6ij, ierr1 )
          if( ierr1.eq.0 )then
            if(printon)
     $      write(IWRF,9022)  typnm(ityp), typnm(jtyp), c6ij
            c6ijvdw(ityp,jtyp) = c6ij
            c6ijvdw(jtyp,ityp) = c6ij
          else
            if(printon) write(IWRF,*) 'ERROR reading c6(pair) from:'
            if(printon) call LNWRIT( IWRF, line, nline )
            call STOPXERR( 'error reading vdw coeffs' )
          endif
        else
          if(printon) call LNWRIT( IWRF, line, nline )
        endif
        goto 500
c
      elseif( readlbl .eq. 'zeroff' .or. readlbl .eq. 'ffzero' )then
c       Read ityp pair for which vdw interaction to be off(zero)
C       Read(IDAT)       typ1  typ2
        read(IDAT,8000)  line
        n1 = 1
        call LNREADTYP( line,n1,nline, ityp, ntyp,typnm,natmnm )
        call LNREADTYP( line,n1,nline, jtyp, ntyp,typnm,natmnm )
        if( ityp.gt.0 .and. ityp.le.ntyp  .and.
     $      jtyp.gt.0 .and. jtyp.le.ntyp )then
          if(printon)
     $    write(IWRF,9022)  typnm(ityp), typnm(jtyp)
          c6ijvdw(ityp,jtyp) = zero
          r0ijvdw(ityp,jtyp) = zero
          c6ijvdw(jtyp,ityp) = zero
          r0ijvdw(jtyp,ityp) = zero
        else
          if(printon) call LNWRIT( IWRF, line, nline )
        endif
        goto 500
c
      endif
c
c     End of 2-center cross-potential input
  800 continue
c
      if( readlbl .eq. 'end_vd' ) goto 900
c
c     We had a problem in the vdw input somewhere
      call FLGETIERR( IERRFL )
      write(IERRFL,*) '**** ERROR in vdw data'
      write(IERRFL,*) '>>>> keyword not recognized:', readlbl
      write(IERRFL,*) '>>>> NB: vdw section must end in: >end_vdwdata<'
 1300 continue
      call STOPXERR( 'error in vdw data input section' )
c
  900 continue
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWCROSS
c
c
      subroutine VDWCROSS( ntyp, c6vdw,r0vdw, c6ijvdw,r0ijvdw )
c---------------------------------------------------------------
c Purpose: interpolated pairwise vdW terms from atomic terms
c Written: P.A. Schultz, 8-February-2013, for 2.65
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c Inputs:
      DIMENSION  c6vdw(ntyp),r0vdw(ntyp)
c Outputs:
      DIMENSION  c6ijvdw(ntyp,ntyp), r0ijvdw(ntyp,ntyp)
c
      do 200 ityp=1,ntyp
        c6i = c6vdw(ityp)
        r0i = r0vdw(ityp)
        do 100 jtyp=ityp,ntyp
          c6j = c6vdw(jtyp)
          r0j = r0vdw(jtyp)
          call VDWIJMIX( c6i,c6j,c6ij, r0i,r0j,r0ij )
          c6ijvdw(ityp,jtyp) = c6ij
          r0ijvdw(ityp,jtyp) = r0ij
          c6ijvdw(jtyp,ityp) = c6ij
          r0ijvdw(jtyp,ityp) = r0ij
  100   continue
  200 continue
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWIJMIX
c
c
      subroutine VDWIJMIX( c6i,c6j,c6ij, r0i,r0j,r0ij )
c---------------------------------------------------------------
c Purpose: interpolated pairwise vdW terms from atomic terms
c Written: P.A. Schultz, 8-February-2013, for 2.65
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON /VDWCTRL / i_vdw, i_dftd2,i_ulg
      COMMON /VDWSTUFF/ vdw_s,vdw_d,vdw_rc
c
      REAL*8       zero,one,two
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0 )
c Inputs:
      REAL*8   c6i,c6j, r0i,r0j
c Outputs:
      REAL*8   c6ij, r0ij
Cc
C      INTEGER  i_dftd2,i_ulg
C      DATA     i_dftd2,i_ulg / 1,2 /
c
      c6ij = zero
      r0ij = one
      if( c6i.gt.zero .and. c6j.gt.zero )then
c       Both atoms have valid vdW forms
c
c       All vdW (so far) use root norm for c6 coeffs:
        c6ij = SQRT( c6i*c6j )
c
        if( i_vdw .eq. i_dftd2 )then
c         The pair interaction r0 is sum of atomic radii
          r0ij = r0i + r0j
        elseif( i_vdw .eq. i_ulg )then
c         The r0 is root norm of atomic r0
          r0ij = SQRT( r0i*r0j )
        else
c         Invalid vdW option
          r0ij = SQRT( r0i*r0j )
          call STOPXERR( 'vdwij: invalid i_vdw' )
        endif
c
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWPAIR
c
c
      subroutine VDWPAIR( e, de, r, c6, r0 )
c---------------------------------------------------------------
c Purpose: compute energy and gradient of vdW pair potential
c Written: P.A. Schultz, 6-February-2013, for 2.65
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON /VDWCTRL / i_vdw, i_dftd2,i_ulg
      COMMON /VDWSTUFF/ vdw_s,vdw_d,vdw_rc
c
      REAL*8       zero, one, two, six
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0, six=6.d0 )
c
c Output:
      REAL*8   e, de
c Input:
      REAL*8   r, c6, r0
c
c Local:
      REAL*8  r5,r6,r7,expfac,f,df
c
c >>>> EXECUTABLE CODE
c
      d_vdw = vdw_d
      e = zero
      de = zero
      if( r .lt. 0.1 .or. i_vdw .eq. 0 ) RETURN
c
      r5 = r**5
      r6 = r5*r
      r7 = r6*r
c
      if( i_vdw .eq. i_dftd2 )then
c       Grimme06 DFT-D2
        expfac = EXP( -d_vdw*( r/r0 - one ) )
        f = one / (one + expfac)
        e = -(c6/r6) * f
c
        df = (d_vdw/r0)*expfac * f**2
        de = -(c6/r6) * df + 6.d0*c6/r7 * f
c
      elseif( i_vdw .eq. i_ulg )then
c       Kim/Choi/WAG ULG12
        e = -c6 / (r6 + d_vdw*r0**6)
        de = c6*(6.d0*r5) / (r6 + d_vdw*r0**6)**2
c
      else
c       Not a valid vdw option
        call STOPXERR( 'vdwpair: bad vdw option' )
      endif
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWSTAMP
c
c
      subroutine VDWSTAMP( IWR, ntyp, c6vdw,r0vdw, c6ijvdw,r0ijvdw )
c---------------------------------------------------------------
c Purpose: interpolated pairwise vdW terms from atomic terms
c Written: P.A. Schultz, 8-February-2013, for 2.65
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c Inputs:
      DIMENSION  c6vdw(ntyp),r0vdw(ntyp)
c Outputs:
      DIMENSION  c6ijvdw(ntyp,ntyp), r0ijvdw(ntyp,ntyp)
c
      if( IWR.le.0 ) RETURN
c
      mtyp = ntyp
 9100 format(2x,a)
 9101 format(4x,1p8d12.4)
c
      write(IWR,9100) ' ***** Recap of vdW parameters *****'
c
      call VDWGET_S( sfac )
      call VDWGET_D( dfac )
      call VDWGET_RC( rcfac )
      write(IWR,'(3x,a,3f12.6)') 'sfactor,dfactor,rc=',sfac,dfac,rcfac
c
      write(IWR,9100) ' C6atom (Ry):'
      write(IWR,9101) (c6vdw(ityp),ityp=1,mtyp)
c
      write(IWR,9100) ' R0atom (Bohr):'
      write(IWR,9101) (r0vdw(ityp),ityp=1,mtyp)
c
      write(IWR,9100) ' C6pair matrix[type,type] (Ry):'
      do  ityp=1,mtyp
        write(IWR,9101) (c6ijvdw(ityp,jtyp),jtyp=1,mtyp)
      enddo
c
      write(IWR,9100) ' R0pair matrix[type,type] (Bohr):'
      do  ityp=1,mtyp
        write(IWR,9101) (r0ijvdw(ityp,jtyp),jtyp=1,mtyp)
      enddo
c
      write(IWR,9100) ' <<<<< End vdW parameter recap'
c
      RETURN
      END
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c vdW control module
c Purpose: Manages data about the nature of vdW corrections
c Written: Peter A. Schultz, Febraury-2013, for 2.65
c
c Module data:
c  i_vdw, i_<vdW> = index of activated vdW, and indices of available vdW corrections
c  vdw_s          = s-factor, for global (fcnal-dependent) scaling of vdW correction
c  vdw_d          = d-factor, parameter defining the long-to-short interpolation
c  vdw_rc         = R-cutoff, the range at which vdW correction is cutoff
c                   (NB: Quest short-circuits this to be the longest overlap interaction)
c Routines:
c  VDWSET - set the kind of (vdW) force field desired)
c  i-fcn IVDWTYPE() - return type (number) of ff
c                     NB: this is not clean module design, used for internal debugging
c  L-fcn DO_VDW()   - returns boolean for if vdW corrections are on or off
c  VDWGETNAME       - returns name of activated vdW correction
c  VDWINIT(iflag)   - initializes module (for iflag<0), sets up global vdW params
c  VDWSET_S/VDWSET_S   - get/set vdW s-factor (global fcnal scaling)
c  VDWSET_D/VDWSET_D   - get/set vdW d-factor (interpolation param)
c  VDWSET_RC/VDWSET_RC - get/set vdW R-cutoff (vdW, which Quest short-circuits
c
c * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWSET
c
c
      subroutine VDWSET( vdwlbl )
c---------------------------------------------------------------
c Purpose: set up flags for vdW correction
c Written: Peter A. Schultz, February-2013, for v2.65 (vdW)
c---------------------------------------------------------------
c
c  Sets i_vdw (communicated via common)
c
c  Default vdw is OFF
c
c  To add new vdw correction methods:
c    Extend COMMON /VDWCTRL / with new i_{labels}
c    Add new unique integer values for i_{labels" below
c    Add check for {label} in if-block here
c    Add code in vdw* routines to implement the new vdW types
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      COMMON /VDWCTRL / i_vdw, i_dftd2,i_ulg
      COMMON /VDWSTUFF/ vdw_s,vdw_d,vdw_rc
c
c Input declarations:
      CHARACTER*(*)  vdwlbl
c Local declarations:
      CHARACTER*6  vdwtyp
c
c >>>> EXECUTABLE CODE:
c
c The following are vdW id tags.  They must be distinct from one another.
      i_dftd2 = 1
      i_ulg   = 2
c      i_newvdw = 3 i.e. extend existing sequence
c
c Now go looking for a matching vdw type:
c
      vdwtyp = vdwlbl(1:6)
c
      if(     vdwtyp .eq. 'OFF   ' .or. vdwtyp .eq. 'off   '
     $   .or. vdwtyp .eq. 'NONE  ' .or. vdwtyp .eq. 'none  ' )then
c
        i_vdw = 0
c
      elseif( vdwtyp .eq. 'DFT-D2' .or. vdwtyp .eq. 'GRIMME'
     $   .or. vdwtyp .eq. 'DFTD2 ' .or. vdwtyp .eq. 'Grimme'
     $   .or. vdwtyp .eq. 'D2    '                           )then
c
        i_vdw = i_dftd2
c
      elseif( vdwtyp .eq. 'ULG   ' .or. vdwtyp .eq. 'ulg   '
     $   .or. vdwtyp .eq. 'ULG12 ' .or. vdwtyp .eq. 'ulg12 ' )then
c
        i_vdw = i_ulg
c
      else
        i_vdw = -1
        call STOPXERR( 'this vdw option is not implemented' )
      endif
c
      iflag = i_vdw
      call VDWINIT( iflag )
c
c    That's all Folks!
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> IVDWTYPE
c
      INTEGER FUNCTION IVDWTYPE( )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      COMMON /VDWCTRL / i_vdw, i_dftd2,i_ulg
      COMMON /VDWSTUFF/ vdw_s,vdw_d,vdw_rc
c
      IVDWTYPE = i_vdw
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> DO_VDW
c
      LOGICAL FUNCTION DO_VDW()
c
c DO NOT PUT (DEBUG) WRITE INTO THIS FUNCTION, CODE FAILS
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      COMMON /VDWCTRL / i_vdw, i_dftd2,i_ulg
      COMMON /VDWSTUFF/ vdw_s,vdw_d,vdw_rc
c
      if( i_vdw .gt. 0 )then
        DO_VDW = .true.
      else
        DO_VDW = .false.
      endif
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWGETNAME
c
      subroutine VDWGETNAME( vdwtyp )
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      COMMON /VDWCTRL / i_vdw, i_dftd2,i_ulg
      COMMON /VDWSTUFF/ vdw_s,vdw_d,vdw_rc
c
c Local declarations:
      CHARACTER*6  vdwtyp
c
      if( i_vdw .eq. 0 )then
c
        vdwtyp = 'NONE  '
c
      elseif( i_vdw .eq. i_dftd2 )then
c
        vdwtyp = 'DFT-D2'
c
      elseif( i_vdw .eq. i_ulg )then
c
        vdwtyp = 'ULG   '
c
      else
c
        vdwtyp = 'UNKNOW'
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWINIT
c
      subroutine VDWINIT( iflag )
c---------------------------------------------------------------
c Purpose: set up global parameters for vdW corrections
c---------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      COMMON /VDWCTRL / i_vdw, i_dftd2,i_ulg
      COMMON /VDWSTUFF/ vdw_s,vdw_d,vdw_rc
c
c Simple initialize:
      if( iflag.lt.0 ) i_vdw = 0
      if( i_vdw .eq. 0 ) RETURN
c
c Check that we have a valid initialization (SET->INIT)
      if( i_vdw .ne. iflag ) call STOPXERR( 'bad VDWINIT call' )
c
      vdw_rc = 60.d0
      if( i_vdw .eq. i_dftd2 )then
c       Set s-factor (0.75/pbe, 1.2/blyp) & d-factor for DFT-D2
        vdw_s = 0.75
        vdw_d = 20.
      elseif( i_vdw .eq. i_ulg )then
c       Set s-factor (0.7012 assumes PBE) & d-factor (aka b_{lg}) for ULG
        vdw_s = 0.7012
        vdw_d = 0.6966
      else
        call STOPXERR( 'VDWINIT: unknown i_vdw' )
      endif
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWGET_S
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWSET_S
c
      subroutine VDWSET_S( svdw )
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      COMMON /VDWCTRL / i_vdw, i_dftd2,i_ulg
      COMMON /VDWSTUFF/ vdw_s,vdw_d,vdw_rc
c
      vdw_s = svdw
c
      RETURN
c
      entry VDWGET_S( svdw )
c
      if( i_vdw.gt.0 ) svdw = vdw_s
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWGET_D
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWSET_D
c
      subroutine VDWSET_D( dvdw )
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      COMMON /VDWCTRL / i_vdw, i_dftd2,i_ulg
      COMMON /VDWSTUFF/ vdw_s,vdw_d,vdw_rc
c
      vdw_d = dvdw
c
      RETURN
c
      entry VDWGET_D( dvdw )
c
      if( i_vdw.gt.0 ) dvdw = vdw_d
c
      RETURN
      END
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWGET_RC
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> VDWSET_RC
c
      subroutine VDWSET_RC( rcvdw )
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      COMMON /VDWCTRL / i_vdw, i_dftd2,i_ulg
      COMMON /VDWSTUFF/ vdw_s,vdw_d,vdw_rc
c
      vdw_s = rcvdw
c
      RETURN
c
      entry VDWGET_RC( rcvdw )
c
      if( i_vdw.gt.0 ) rcvdw = vdw_rc
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> EBLENDASD
c
c
      subroutine EBLENDASD( IWR, sufx, itstep, memblnde,
     $ nrlx, dt,
     $ fi,ri, vi,wt, savblnd )
c---------------------------------------------------------------
c Purpose: Do ASD-type SCF blend
c
c Written: Peter A. Schultz, Decmeber-2014, for 2.66
c
c Revision History:
c   14Dec14-PAS/2.66: adapted from DMD routine
c---------------------------------------------------------------
c
C ***** IMPORTANT: THIS DOES NOT WORK YET *****
c Variables:
c  nrlx = total number of independent components to be relaxed
c   (this will usually be 3-vectors, but *could* be potentially
c    less if one introduces constraints on the geometry, e.g.
c    fixing the z-coordinate of an atom to be a fixed number)
c  ri(),fi() = (input) positions, gradients
c  vi()      = (scratch) velocities
c  wt() = inertia factor for velocity update
c  savblnd() = saved velocity and eight factors (should overlap vi and wt <sigh>)
c
c  NB: output ri() is copied into vi() tor compatibility with broyden blend
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c input/output variables
      DIMENSION  ri(*),vi(*),fi(*), wt(*)
c file stuff:
      CHARACTER  sufx*(*), dmd_tag*40
c scratch declaration:
      DIMENSION  savblnd(*)
c
c local declarations
      DATA  lstout / 2 /
      DATA  zero,one / 0.d0,1.d0 /
      DATA  two / 2.d0 /
c Defines blending type
      DATA    methbl_broy,methbl_asd / 1,2 /
c
c >>>> EXECUTABLE CODE:
c
c To fix to ASD blend
      methbl = methbl_asd
c
      dmd_tag = 'dmd_' // sufx
      if( itstep.eq.1 )then
c       Initialize velocities and inertia factors on first step
        call MKZERO( nrlx, vi )
        call DCOPY( nrlx , one,0, wt,1 )
      else
c       Recover velocities, and inertia factors (if applicable):
        if( memblnde .lt. 2*nrlx )then
          call FLOPENB( idmdfl, dmd_tag )
          REWIND( unit=idmdfl )
          call READBIG( idmdfl, nrlx, vi )
          call READBIG( idmdfl, nrlx , wt )
        else
          call DCOPY( nrlx, savblnd(1),1, vi,1 )
          call DCOPY( nrlx, savblnd(nrlx+1),1, wt,1 )
        endif
      endif
c
c Update velocity with specified quenching scheme:
      call EASDVELOC( nrlx, vi,fi,wt, dt )
c
c Update the atomic coordinates along the velocity vector:
      call DMDSTEP( nrlx, ri,vi, dt )
c
c And output some diagnostics:
      if( lstout.gt.0 )
     $ write(IWR,*) 'e-asd blend step #', itstep
c
      if( lstout.gt.1 )then
        iwtmn = 1
        iwtmx = 1
        wtmin = ABS( wt(1) )
        wtmax = ABS( wt(1) )
        do  irlx=1,nrlx
          wti = ABS( wt(irlx) )
            if( wti .lt. wtmin )then
            wtmin = wti
            iwtmn = irlx
          endif
          if( wti .gt. wtmax )then
            wtmax = wti
            iwtmx = irlx
          endif
        enddo
        write(IWR,'(a,f12.6,1x,i12)')'EASD: min mass fac=',wtmin,iwtmn
        write(IWR,'(a,f12.6,1x,i12)')'EASD: max mass fac=',wtmax,iwtmx
c
        ivvmn = 1
        ivvmx = 1
        vvmin = ABS( vi(1) )
        vvmax = ABS( vi(1) )
        do  irlx=1,nrlx
          vvi = ABS( vi(irlx) )
          if( vvi .lt. vvmin )then
            vvmin = vvi
            ivvmn = irlx
          endif
          if( vvi .gt. vvmax )then
            vvmax = vvi
            ivvmx = irlx
          endif
        enddo
        write(IWR,'(a,f12.6,1x,i12)')'EASD: min velocity=',vvmin,ivvmn
        write(IWR,'(a,f12.6,1x,i12)')'EASD: max velocity=',vvmax,ivvmx
      endif
c
c Put out the current velocity vector:
      if( memblnde .lt. 2*nrlx )then
        REWIND( unit=idmdfl )
        call WRITBIG( idmdfl, nrlx, vi )
        call WRITBIG( idmdfl, nrlx, wt )
      else
        call DCOPY( nrlx, vi,1, savblnd(1),1 )
        call DCOPY( nrlx, wt,1, savblnd(nrlx+1),1 )
      endif
c
      if( memblnde .lt. 2*nrlx )
     $call FLCLOSE( idmdfl )
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> EASDVELOC
c
c
      subroutine EASDVELOC( nrlx, vi,fi,wt, dt )
c---------------------------------------------------------------
c Purpose: (damped) dynamics update of particle velocities
c
c Written: Peter A. Schultz, 12-October-2001, for v2.50
c
c Revision History:
c  12Oct01-PAS/2.50: developed new damped dynamics scheme
c---------------------------------------------------------------
c
c Parameters for modified damped dynamics:
c  dvup = boosting factor for rate of acceleration
c         must be .ge.1, should be .le.dvdn
c  dvdn = reducing factor (if rate deemed too fast)
c         must be .ge.1, should be between 2 and 4(?)
c  cutdn = v-par/dv-update ratio that triggers deceleration
c         must be .ge.1 (if dv bigger than v-par, must slow down)
c         should be ~1.5-3.0 (dv and v-par comparable, should slow)
c  Setting dvdn=dvup=1.0 reduces to simple Jonsson damped dynamics.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      PARAMETER  ( zero=0.d0, one=1.d0, two=2.d0 )
c input/output arrays:
      DIMENSION  vi(*),fi(*), wt(*)
c
c >>>> EXECUTABLE CODE:
c
c Set parameters for the damped acceleration dynamics ...
c  ... the acceleration factor (cube root of 2.0):
      dvup = 1.25992105d0
c      dvup = 1.414213562d0
c  ... the deceleration factor (2.0 seems good number):
      dvdn = 2.d0
c  ... and cutoff ratio for deceleration (2.0-3.0 appears to work):
      cutdn = 2.d0
c  ... and limit weight boosting, and velocity update
      wtlimit = 2.d0/dt
      filimit = 2.0d0
cxxx:
      call FLGETIWR( IWR )
      write(IWR,*) 'DBG/EASDVELOC: dt,filimit=',dt,filimit
c
c       >>>> accel. steepest desc.
c
        do  irlx =1,nrlx
c
c         Get size of force&velocity vectors, and dot product
          vdotf = vi(irlx)*fi(irlx)
          fdotf = fi(irlx)*fi(irlx)
          vdotv = vi(irlx)*vi(irlx)
c
          if( vdotf .lt. zero )then
c           Velocity and force reversed: quench, and update
c
            dvfac = ABS( wt(irlx) )
            dvfacx = dvfac
c
            dvmag = (fi(irlx)* dvfac*dt)**2
            fac = vdotf/fdotf
            vpar = fac*fac*fdotf
            dvmag = SQRT( dvmag )
            vpar = SQRT( vpar )
c
c           If we have a big reversal ...
            if( cutdn*dvmag .gt. vpar .or.
c              ... or reversed twice in a row ...
     $                     wt(irlx) .gt. zero )then
c              ... decrease acceleration rate:
              dvfac = dvfac / dvdn
              dvfacx = dvfac
c
c             If we still overshoot after damping ...
              if( (dvmag/dvdn) .gt. vpar )then
c                ... limit update size to previous step size:
                dvfacx = dvfac*( vpar / (dvmag/dvdn) )
              endif
c
            endif
c
            vi(irlx) = fi(irlx)* dvfacx*dt
c
c           We just reversed, set as boost-ineligible:
            wt(irlx) = dvfac
c
          else
c           Velocity and force aligned, update velocity along force
c
            dvfac = ABS( wt(irlx) )
c
            if( fdotf .ne. zero )then
              fac = vdotf/fdotf
              dvmag = (fi(irlx)* dvfac*dt)**2
              vpar = fac*fac*fdotf
              dvmag = SQRT( dvmag )
              vpar = SQRT( vpar )
            else
              fac = zero
              dvmag = zero
              vpar = zero
            endif
c
            if( wt(irlx) .lt. zero )then
c             We are repeatedly heading in the right direction ...
c
cpas: probably should do unconditional boost.
              if( two*dvmag .lt. vpar )then
c                ... and not accelerating fast enough - boost
                dvfac = dvfac * dvup
              endif
c             Note boost-eligibility in sign of mass factor:
c               ... after limiting weighting:
              if( dvfac .gt. wtlimit ) dvfac = wtlimit
              wt(irlx) = -dvfac
c
            else
c             We recently (but not this time) reversed
c
              if( two*dvmag .lt. vpar )then
c               Looks like we are converging, quench velocity ...
                fac = zero
c                ... and leave this as boost-ineligible
                wt(irlx) = dvfac
              else
c               We have healthly acceleration ...
                if( vpar .gt. zero )then
c                  ... and constructive (non-zero) alignment
                  if( two*dvmag .gt. vpar )then
c                    ... and the acceleration is hefty - boost
c                    (even though we were nominally ineligible)
                    dvfac = dvfac * dvup
                  endif
c                 Now boost-eligible, note in sign of mass factor:
                   if( dvfac .gt. wtlimit ) dvfac = wtlimit
c               ... after limiting weighting:
                  wt(irlx) = -dvfac
                endif
              endif
c
            endif
c
C            vi(irlx) = fac*fi(irlx) + fi(irlx)*dvfac*dt
            facfi = fac + dvfac*dt
            if( facfi .gt. filimit )then
c             Jumpino too far, limit step, and unboost eligible
              wt(irlx) = ABS( wt(irlx) )
              facfi = filimit
            endif
            vi(irlx) = facfi*fi(irlx)
c
          endif
c
        enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c*******************************************************************************
c NEBSTAT - routines to try and handle image-related NEB failure gracefully
c C Routines: c  NEBSTAT  - the neb_master receiving status messages
c  NEBSTATOK- the image master reports to neb_master that all is ok
c  NEBSTATX - the image master reports failure to neb_master
c
c Written: Peter A. Schultz, 10-April-2015, for 2.66
c
c Revision history:
c  none
c*******************************************************************************
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBSTAT
c
c
      subroutine NEBSTAT( nodei, image, ierr, icomm )
c---------------------------------------------------------------
c Purpose: Neb_master checking status
c---------------------------------------------------------------
c
      IMPLICIT NONE
      INTEGER  nodei, image, ierr, icomm
c Local:
      INTEGER  lenmsg, msgneb(2)
c
      lenmsg = 2
      call MPRECVI( nodei, lenmsg, msgneb, icomm )
c
      image = msgneb(1)
      ierr  = msgneb(2)
c
c This might be the place to convert the error code to a useful message,
c  given that tne he nebstatx routine in here did the complement.
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBSTATOK
c
c
      subroutine NEBSTATOK( neb_master, image, icomm )
c---------------------------------------------------------------
c Purpose: Neb_master checking status
c---------------------------------------------------------------
c
      IMPLICIT NONE
      INTEGER  neb_master, image, ierr, icomm
c Local:
      INTEGER  lenmsg, msgneb(2)
c
      ierr = 0
      msgneb(1) = image
      msgneb(2) = ierr
c
      lenmsg = 2
      call MPSENDI( neb_master, lenmsg, msgneb, icomm )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NEBSTATX
c
c
      subroutine NEBSTATX( IWRNEB, statneb, image )
c---------------------------------------------------------------
c Purpose: report failure of image to neb_master
c
c Written: Peter A. Schultz, 10-April-2015, for 2.66
c
c Revision history:
c  none
c---------------------------------------------------------------
c Notes:
c  This routine is intended to have neb_master find out about errors
c   on remote images, and to have it, at least, record the failure
c   so that the job (and the user) is not in the dark about a hang.
c  The motivating issue is an scf failure on a remote image, which
c   causes the remote image to shut down, but the rest of the NEB,
c   including the neb_master, hung waiting to hear from this image,
c   wasting cpu and leaving the user in the dark.
c  The NEB in its full set of paths is ugly machinery, and it might
c   be rather challenging to shut the whole thing down cleanly.
C  Here we just want to guarantee that at least the master shuts down
c   cleanly, leaving a message for the user to know what happened.
c  Given that a failure might be reported from anywhere in the code
c   where there is a failure, it may not know enough to say
c   much other than it bombed (it might not know the image#).
c
c  This particular routine does not stop the run.
c  It assumes that maing code will stop after more diagnostics.
c  Purpose here is simply to leave user a useful error message.
c
      IMPLICIT NONE
      INTEGER  image, IWRNEB
      CHARACTER*(*)  statneb
c Local:
      INTEGER  neb_master, nodei, icomm, master, iproc, IWR, ierr
      INTEGER  lenmsg, msgneb(2)
c
c >>>> EXECUTABLE CODE
c
      call MPNODE0_G( neb_master )
      call MPNODE_G( nodei )
      call MPCOMM_G( icomm )
      call MPNODE0( master )
      call MPNODE( iproc )
c
      call FLGETIWR( IWR )
      if( nodei .eq. neb_master )then
c       THe image on the neb_master failed.
c       Record to the neb_out, and let main code handle this.
        write(IWR   ,*) 'Failure in image on master node'
        write(IWR   ,*) 'NEB therefore fails'
        write(IWR   ,*) 'image, failure code=',image,statneb
        write(IWRNEB,*) 'Failure in image on master node'
        write(IWRNEB,*) 'NEB therefore fails'
        write(IWRNEB,*) 'image, failure code=',image,statneb
      elseif( iproc .eq. master )then
c       Report failure to neb_master
        if( iproc .eq. master )then
          write(IWR,*) 'Failure on this image in NEB'
          write(IWR,*) 'Reporting failure to neb_master'
          write(IWR,*) 'image, failure code=',image,statneb
          msgneb(1) = image
          if( statneb .eq. 'scf' )then
            ierr = 1
          else
c           Default generic error
            ierr = -1
          endif
          msgneb(2) = ierr
          lenmsg = 2
          call MPSENDI( neb_master, lenmsg, msgneb, icomm )
        endif
      endif
c
c  Try to respond to last (ierror) sync in NEB
      call MPBCASTI( neb_master, 1, ierr, icomm )
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> RUNSTEER
c
c
      subroutine RUNSTEER( scfconv, gconv,  cellconv,
     &                     itstop,  igstop, maxucstep )
c---------------------------------------------------------------
c Purpose: Modify convergence parameters for Quest midstream
c Written: Andrew Pineda and Peter Schultz, for 2.66
c Rebision History
c  none
c---------------------------------------------------------------
c
c     This routine looks for alterable parameters in a file called lcao.steer
c     that is read by the master process. Input is via NAMELIST variables, so that
c     the user can just set the parameters he/she wants to change.
c     This should be called at the end of the SCF, geometry and cell loops.
c
      IMPLICIT NONE
c
      CHARACTER filenm*128, label*6
      INTEGER  IWR, iexist, ISTEER
      LOGICAL  lexist
      INTEGER  nprocs, iproc, master, icomm
      INTEGER  len
c
c Input/Output parameters
      REAL*8   scfconv, gconv, cellconv
      INTEGER  igstop, itstop, maxucstep
c
c Local variables:
c     Since we are doing namelist input we make these variable names match
c     the appropriate QUEST keyword as best we can.
      REAL*8   scf_conv, geo_conv, cell_conv
      INTEGER  scf_max_iters, geo_max_iters, cell_max_iters
c ALTERABLE Parameters - These are convergence parameters that can be changed at run-time
c by namelist input to the master process via lcao.steer. In lcao.steer, you must use the
c variable names below.
      NAMELIST /alterable_parameters/ scf_conv, geo_conv, cell_conv,
     &     scf_max_iters, geo_max_iters, cell_max_iters
c
c >>>> EXECUTABLE CODE
c
c     Set up parallel variables
      call MPNODES( nprocs )
      call MPCOMM( icomm )
      call MPNODE0( master )
      call MPNODE( iproc )
      call FLGETIWR( IWR )
c
c Translate between QUEST variables and NAMELIST names
      scf_conv = scfconv
      geo_conv = gconv
      cell_conv = cellconv
      scf_max_iters = itstop
      geo_max_iters = igstop
      cell_max_iters = maxucstep
c
c STEER convergence criteria with a namelist input file.
      if( iproc .eq. master )then
c       Master process checks for 'lcao.steer'
        call FLNAMESP( 'steer', filenm )
c       Get the standard default output unit:
        INQUIRE( FILE=filenm, EXIST=lexist )
        if( lexist )then
          call FLOPENF( ISTEER, filenm, 'OLD', 'FOR' )
          read( ISTEER, '(a)' ) label
          if( label .eq. 'steeri' )then
 9010       format(a)
            write(IWR,*) 'Found steering file=',filenm
            write(IWR,*) 'Changing job parameters ...'
  100       continue
            read(ISTEER,9010)  label
            if( label(1:3) .eq. 'end' )then
              write(IWR,*) 'End of steering file'
              iexist = 1
              goto 200
            elseif( label .eq. 'iterat' )then
              read(ISTEER,*)  scf_max_iters
              write(IWR,*) 'Changed scf iterations to',scf_max_iters
            elseif( label .eq. 'conver' )then
              read(ISTEER,*)  scf_conv
              write(IWR,'(a,f15.8)') 'changing scfconv to ',scf_conv
            elseif( label .eq. 'gsteps' )then
              read(ISTEER,*)  geo_max_iters
              write(IWR,*) 'Changed geom steops to',geo_max_iters
            elseif( label .eq. 'gconv ' )then
              read(ISTEER,*)  geo_conv
              write(IWR,'(a,f15.8)') 'changing gconv to ',geo_conv  
            elseif( label .eq. 'ucstep' )then
              read(ISTEER,*)  cell_max_iters
              write(IWR,*) 'Changed cell steps to',cell_max_iters
            elseif( label .eq. 'uc_con' )then
              read(ISTEER,*)  cell_conv
              write(IWR,'(a,f15.8)') 'changing uc_conv to ',cell_conv
            else
c             Not known --- this is unsalvageable error
              write(IWR,*) '**** ERROR: unknown runsteer label=',label
              iexist = -1
              goto 200
            endif
            goto 100
          else
            REWIND( ISTEER )
            read( ISTEER, NML=alterable_parameters )
            iexist = 1
            goto 200
          endif
          iexist = -1
  200     continue
          call FLDELETE( ISTEER )
        else
          iexist = 0
        endif
      endif
c
      len = 1
      if( nprocs .gt. 1 ) call MPBCASTI( master, len, iexist, icomm )
c
      if( iexist .eq. 1 )then
c       Synchronize alterable parameters across processes.
        if( nprocs .gt. 1 )then
          call MPBCAST8( master, len, scf_conv,       icomm )
          call MPBCAST8( master, len, geo_conv,       icomm )
          call MPBCAST8( master, len, cell_conv,      icomm )
          call MPBCASTI( master, len, scf_max_iters,  icomm )
          call MPBCASTI( master, len, geo_max_iters,  icomm )
          call MPBCASTI( master, len, cell_max_iters, icomm )
        endif
c
c       Write parameters to main output file
        write(IWR,*) 'Steering file with alterrable parameters found,'//
     &              ' here they are:'
        write( IWR, NML=alterable_parameters )
c
c       Assign alterable parameters back to internal variables
        scfconv   = scf_conv
        gconv     = geo_conv
        cellconv  = cell_conv
        itstop    = scf_max_iters
        igstop    = geo_max_iters
        maxucstep = cell_max_iters
c
      elseif( iexist .eq. -1 )then
c       Now that we told everyone that this went bad ...
c        ... choose to die, rather than ignore.
        call STOPXERR( 'ERROR reading steering file' )
c
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c***********************************************************************
c  SLICS - selection of slic-related routines
c
c List of routines:
c
c    SLSPH    - spherical projection routine for 1-fold atoms
c    SLSPHB   - spherical de-projection routine for 1-fold atoms
c    SLCYL    - cylindrical projection routine for 2-fold atoms
c    SLCYL    - cylindrical de-projection routine for 2-fold atoms
c
c    SLBONDTO - bond-length fixing projection selection routine
c    SLBONTFR - bond-length fixing de-projection update routine
c
c    SLINKSEL - slinky/layers selection routine for slab relaxation
c    SLINKUPD - slinky/layers update routine for slab relaxation
c
c    UVWCOORD - generate orthogonal u.v.w vectors, from single input vector
c               Presumably z-axis, mapped to w.
c               Then orthgonalize least overlapping x & y to get u,v,w
c
c  ***** WARNING ***** projection routines are NOT periodic-safe
c
c***********************************************************************
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLSPH
c
c
      subroutine SLSPH( IWR,natm, islics,islic,
     $ ratm,frc, ratmP,frcP )
c---------------------------------------------------------------
c Purpose: projects 1-fold coordinates and forces to spherical coordinates
c
c Written: Renee M. Van Ginhoven
c
c Revision history:
c  15Aug17-PAS/2.68: integration into full slics
c  28Sep08-PAS/2.62: cosmetic standardization
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
c
      PARAMETER  ( zero=0.d0 )
cRMV  inputs from gselect
      INTEGER    islics(4,*)
      DIMENSION  ratm(3,natm), frc(3,natm), ratmP(3,natm), frcP(3,natm)
c
c Local declarations:
      DIMENSION  Uvec(3),Vvec(3),Wvec(3), rvec(3),bondvec(3)
      DIMENSION  Unorm(3),Vnorm(3),Wnorm(3),rnorm(3)
      DIMENSION  Fuvec(3),Fvvec(3),Fwvec(3),cartnew(3),Fuwperp(3)
      DIMENSION  Fuwperpnorm(3)
c    
      DATA  Pi / 3.141592654 /
      DATA  degperrad / 57.29577951 /
c
c spherical coordinate projection
c
c First, define new cartesian coordinate system, x,y,z -> u,v,w
c based on positions of projected and anchor atoms
c origin is set to anchor position 1
c Wvec direction is vector from a2 to a1
c Wvec = R(anchor1) -R(anchor2)  -> norm
c Rvec = bondvec = R(atomproj) - R(anchor1)
c Uvec = Uvec' = bondvec - ((bondvec dot Wvec')/|Wvec'|**2)(Wvec')  -> norm
c Vvec' = Wvec' cross Uvec' -> norm
c  initial theta is zero
c  there will be a problem if the a2,a1,pa angle is near 180!! (phi = 0)
c   
c 
c then transform projected atom to spherical coords
c r, phi and theta
c
c R = |rvec|
c W = (rvec dot Wvec')   (assume Wvec' is normalized)
c phi = cos^-1[W/R] 
c theta = sin^-1[V/rsin(phi)] 
c initially, Vvec' = 0, so theta = 0
c
c Project force vector onto new cartesian coordinates
c component along Wvec'  Fw' = (Fatom dot Wvec')
c component along Uvec'  Fu' = (Fatom dot Uvec')
c Fv = F - compU -compW
c transform to spherical
c Fr = sqrt(Fu**2+Fv**2 + Fw**2)
c       or Fr = (Fatom dot rvec)/|rvec|**2
c
c Fphi = sin^-1(FuwcompPerp*sign/Rcoord)
c phi force = magnitude of force in UW plane
c perpendicular to the bond (R) times the direction
c
c Ftheta = sin^-1[Fv/(Fr sin(Fphi))]
c
c update velocity, position
c output files (esp velocity)
c backtransform new coordinates
c
c Unew' = rsin(phi)cos(theta)
c Vnew' = rsin(phi)sin(theta)
c Wnew' = rcos(theta)
c
c return cartesians to original orientation in UNSPHERE
c
c Add option to add 1-fold atom force into anchor atom - 12Aug17
c   Adding the force component projected along the bond, worked well
c   In one test (methanol), adding the full force converged poorly
c   Not clear why the 'full" force propagation would be badly worse
c
      DATA  scalephi, scaletheta / 1.5, 1.5 /
      DATA  ifrcank / 2 /
c ifrcank = 0 raw unmodified anchor force
c         = 1 add full 1-fold force into anchor force
c         = 2 add bond-vector projected 1-fold force into anchor
      DATA  iprint / 2 /
c
c >>>> EXECUTABLE CODE:
c
 9103 format(1x,a,3f14.8)
      iatmproj = islics(2,islic)
      ia1 = islics(3,islic)
      ia2 = islics(4,islic)
      if( iprint.gt.0 )then
        write(IWR,*)'>>>>> slic/slsph: 1-fold sphere projection'
        write(IWR,*)'slic projected atom (1-fold spherical)= #',iatmproj
        write(IWR,*)'  first anchor atom (sphere center) is #',ia1
        write(IWR,*)'  second anchor atom is # ',ia2
      endif
c
c  Retrieve setup parameters
      call SLICPGET( 'FANK  ', pslic, islfank )
      if( islfank.ge.0 .and. islfank.le.2 .and. ifrcank.ne.islfank )then
        if( iprint.gt.0 ) write(IWR,*) 'f-anchor option to ',islfank,
     $    '(0=raw,1=full force,2=bond-projected)'
        ifrcank = islfank
      endif
      call SLICPGET( 'PAR1  ', pslic, isl )
      if( pslic.gt.zero )then
        if( iprint.gt.0 ) write(IWR,9103) 'Change scalephi to',pslic
        scalephi = pslic
      endif
      call SLICPGET( 'PAR2  ', pslic, isl )
      if( pslic.gt.zero )then
        if( iprint.gt.0 ) write(IWR,9103) 'Change scaletheta to',pslic
        scaletheta = pslic
      endif
c set new z->W direction, based on anchor atoms
c z direction is from a2 to a1
      wsq = zero
      do id = 1,3
         Wvec(id) = ratm(id,ia1)-ratm(id,ia2)
         wsq = wsq + (Wvec(id))**2
      enddo
      Wmag = SQRT( wsq )
      if( iprint.gt.3 ) write(IWR,*)'Wmag (reference a1-a2 bond)= ',Wmag
      do id = 1,3
         Wnorm(id) = Wvec(id)/Wmag
      enddo
c
c-------
c set rvec, based on ratom(iatmproj) and anchor1
c first, get bondvec = rvec
c get Rcoord = |bondvec|=bondmag
      bondsq = zero
      do id = 1,3
         bondvec(id)=ratm(id,iatmproj)-ratm(id,ia1)
         bondsq = bondsq +(bondvec(id))**2
      enddo
      bondmag = SQRT( bondsq )
      Rcoord = bondmag
c
c also useful, the r unit vector
      do id = 1,3
         Rnorm(id) = bondvec(id)/Rcoord
      enddo
c     
c     get Wcoord = bond dot Wnorm
      Wcoord = zero
      do id = 1,3
         Wcoord = Wcoord + Wnorm(id)*bondvec(id)
      enddo
      if( iprint.gt.3 ) write(IWR,*) 'Wcoord (b4 step)= ',Wcoord
c
c     now get uvec =normalized component of bondvec perp to Wvec
      Uvecsq = zero
      do id = 1,3
         Uvec(id) = bondvec(id)-Wcoord*Wnorm(id)
         Uvecsq = Uvecsq + (Uvec(id))**2
      enddo
      Ucoord = SQRT( Uvecsq )
      if( iprint.gt.3 ) write(IWR,*) 'Ucoord = ',Ucoord
      do id = 1,3
         Unorm(id) =  Uvec(id)/Ucoord
      enddo
c---- 
c     as a check ,also get Vcoord of iatmprojroj (should be zero!)
c use cross product  Wcrossr
      Vvec(1)=Wnorm(2)*Unorm(3)-Wnorm(3)*Unorm(2)
      Vvec(2)=Wnorm(3)*Unorm(1)-Wnorm(1)*Unorm(3)
      Vvec(3)=Wnorm(1)*Unorm(2)-Wnorm(2)*Unorm(1)
      if( iprint.gt.3 ) write(IWR,9103) 'Vvec =',(Vvec(i),i=1,3)
      Vprmagsq = zero
      do id = 1,3
         Vprmagsq = Vprmagsq +(Vvec(id))**2
      enddo
      Vprmag = SQRT( Vprmagsq )
      if( iprint.gt.3 ) write(IWR,*) 'Vprmag = ',Vprmag
      do id = 1,3
         Vnorm(id)=Vvec(id)/Vprmag
      enddo
c get Vcoord = bond dot Vnorm (should be zero!)
      Vcoord = zero
      do id = 1,3
         Vcoord = Vcoord + bondvec(id)*Vnorm(id)
      enddo
      if( iprint.gt.3 ) write(IWR,*) 'Vcoord (should=0)= ',Vcoord
c and for later we want the "Q" direction, which is just the 
c propjection of R into the UV plane
c  as a check, this initial Q should be the same as U
c
      Qcoordsq = Vcoord**2 + Ucoord**2
      Qcoord = SQRT( Qcoordsq )
      if( iprint.gt.4 )
     $write(IWR,9103) 'PROJ: Qcoord, Ucoord = ',Qcoord, Ucoord
c
c  finish spherical projection of atom coordinates
c
      phi = ACOS( Wcoord/Rcoord )
      if( iprint.gt.2 ) write(IWR,*) 'phi(radians) from acos(z/r)= ',phi
c
c test that the initial theta is zero
      sinphi = SIN( phi )
      if( iprint.gt.2 ) write(IWR,*) 'sinphi = ',sinphi
      ratio = Vcoord/Rcoord
c     if( iprint.gt.4 ) write(IWR,*)'ratio = ',ratio
      theta = ASIN( ratio/sinphi )
c     if( iprint.gt.4 ) write(IWR,*)'theta (should=0) = ',theta
c
c     ***** PROJECT FORCES *****
c
      if( ifrcank.gt.0 )then
c       Propagate outer atom forces into anchor atom
        if(     ifrcank.eq.1 )then
c         Add full 1-fold atom force to anchor (central) atom force
          if( iprint.gt.0 )
     $    write(IWR,*) 'SPHERE: full 1-fold force into central atom'
          do  id=1,3
            frcP(id,ia1) = frc(id,ia1) + frc(id,iatmproj)
          enddo
        elseif( ifrcank.eq.2 )then
c         Add bond-projected 1-fold atom force to anchor atom force
          if( iprint.gt.0 )
     $    write(IWR,*) 'SPHERE: bond 1-fold force into central atom'
          frc12 = Rnorm(1)*frc(1,iatmproj) + Rnorm(2)*frc(2,iatmproj)
     $          + Rnorm(3)*frc(3,iatmproj)
          do  id=1,3
            frcP(id,ia1) = frc(id,ia1) + frc12*Rnorm(id)
          enddo
        else
          call STOPXERR( 'Unknown anchor force update' )
        endif
        if( iprint.gt.1 )then
          write(IWR,9103) 'Raw frc 1-fold =',(frc(i,iatmproj),i=1,3)
          write(IWR,9103) 'Raw frc anchor =',(frc(i,ia1     ),i=1,3)
          write(IWR,9103) 'New frc anchor =',(frcP(i,ia1    ),i=1,3)
        endif
      endif
c
c     first onto rotated cartesians
      Fu = zero
      Fv = zero
      Fw = zero
      do id = 1,3
         Fu = Fu + frc(id,iatmproj)*Unorm(id)
         Fv = Fv + frc(id,iatmproj)*Vnorm(id)
         Fw = Fw + frc(id,iatmproj)*Wnorm(id)
      enddo
c
cFr is the easiest
      Fr = zero
      do id = 1,3
         Fr = Fr + frc(id,iatmproj)*rnorm(id)
      enddo
c
c next get projection of uw plane tangental force
c Fu+Fw component perp to Fr  (No Fv component needed)
c need vector magnitude as input to get Fphi
cget vector
c
      do i=1,3
         Fuwperp(i) = Fu*Unorm(i)+Fw*Wnorm(i)-Fr*Rnorm(i)
      enddo
      Fuwperpmagsq = zero
      do id = 1,3
         Fuwperpmagsq = Fuwperpmagsq +Fuwperp(id)**2
      enddo
      Fuwperpmag = SQRT( Fuwperpmagsq )
      if( iprint.gt.4 ) write(IWR,*) 'Perp to R force = ',Fuwperpmag
c   
c normalize Fuwperp
      do id=1,3
         Fuwperpnorm(id)= Fuwperp(id)/Fuwperpmag
      enddo
c check math...
c
c find sign of phi force Fuwperp 
c Fuwperp dot Wvec
      FperpdotW = zero
      do id=1,3
         FperpdotW = FperpdotW + Fuwperp(id)*Wvec(id)
      enddo
c set direction of force
      fsign = 1.0
      if (FperpdotW.gt.zero)then
         fsign = -1.0
      endif
      if( iprint.gt.3 ) write(IWR,*) 'sign of force = ',fsign
c set Phi force
      Fphi = ASIN( Fuwperpmag*fsign/Rcoord )
      if( iprint.gt.3 )write(IWR,*)'Fphi from asin(Fuwcomp/Rcoord)',Fphi
c if phi too close to 180, revert to cartesian
c      if (abs(phi).gt.3.0)then
c         Fphi = Fuwperpmag
c      endif
      sinphi = SIN( phi )
      ratio = Fv/(Qcoord)
      if( iprint.gt.3 ) write(IWR,9103)'ratio/Fv/Qcoor=',ratio,Fv,Qcoord
c      ratiocheck = Fv/(Rcoord*sinphi)
      Ftheta = ASIN( ratio )
c      Fthetacheck = ASIN( ratiocheck )
      if( iprint.gt.1 )
     $write(IWR,9103)'PROJ: Fr, Fphi, Ftheta =',Fr,Fphi,Ftheta
c,Fthetacheck
c    
c assign spherical forces to force vector
c return projected coordinates and forces in arrays ratmP frcP
      ratmP(1,iatmproj) = Rcoord
      ratmP(2,iatmproj) = phi
      ratmP(3,iatmproj) = theta
c forces, scaled for directions
      frcP(1,iatmproj) = Fr
      frcP(2,iatmproj) = scalephi*Fphi
      frcP(3,iatmproj) = scaletheta*Ftheta
c
      if( iprint.gt.4 )
     $write(IWR,9103)'check forces for r,phi,theta =',Fr,Fphi,Ftheta
c 
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLSPHB
c
c
      subroutine SLSPHB( IWR,natm, islics,islic, 
     $ ratm0,ratmx,ratmP )
c---------------------------------------------------------------
c Purpose: de-projects 1-fold coordinates from spherical back to cartesian
c
c Written: Renee M. Van Ginhoven
c
c Revision history:
c  24Sep08-PAS/2.62: standardization, some minor cleanup
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
c
cRMV  inputs from gselect
      DIMENSION  ratm0(3,natm),ratmx(3,natm),ratmP(3,natm)
      INTEGER    islics(4,*)
c
c Local declarations:
      DIMENSION  Uvec(3),Vvec(3),Wvec(3), rvec(3),bondvec(3)
      DIMENSION  Unorm(3),Vnorm(3),Wnorm(3),rnorm(3)
      DIMENSION  Fuvec(3),Fvvec(3),Fwvec(3),cartnew(3),Fuwperp(3)
      DIMENSION  unrot(3),unshift(3)
c
      DATA  Pi / 3.141592654 /
      DATA  degperrad / 57.29577951 /
      DATA  zero / 0.d0 /
c
c spherical coordinate projection
c
c First, define new cartesian coordinate system,
c based on positions of projected and anchor atoms
c origin is set to anchor position 1
c zvec direction is vector from a2 to a1
c zvec' = R(anchor1) -R(anchor2)  -> norm
c rvec = bondvec = R(atomproj) - R(anchor1)
c xvec' = xvec' = bondvec - ((bondvec dot zvec')/|zvec'|**2)(zvec')  -> norm
c yvec' = zvec' cross xvec' -> norm
c  initial theta is zero
c  there will be a problem if the a2,a1,pa angle is near 180!! (phi = 0)
c
c
c then transform projected atom to spherical coords
c r, phi and theta
c
c r = |rvec|
c z = (rvec dot zvec')   (assume zvec' is normalized)
c phi = cos^-1[z/r] 
c theta = sin^-1[y/rsin(phi)] 
c initially, yvec' = 0, so theta = 0
c
c Project force vector onto new cartesian coordinates
c component along zvec'  Fz' = (Fatom dot zvec')
c component along xvec'  Fx' = (Fatom dot xvec')
c Fy = F - compX -compZ
c transform to spherical
c Fr = sqrt(Fx**2+Fy**2 + Fx**2)
c       or Fr = (Fatom dot rvec)/|rvec|**2
c Fphi = cos^-1(Fz/Fr)
c Ftheta = sin^-1[Fy/(Fr sin(Fphi))]
c
c update velocity, position
c output files (esp velocity)
c backtransform new coordinates
c
c xnew' = rsin(phi)cos(theta)
c ynew' = rsin(phi)sin(theta)
c znew' = rcos(theta)
cc
c
c return cartesians to original orientation
c
      DATA  iprint / 3 /
c
c >>>> EXECUTABLE CODE:
c
 9103 format(1x,a,3f14.8)
      iatmproj = islics(2,islic)
      ia1 = islics(3,islic)
      ia2 = islics(4,islic)
      if( iprint.gt.0 )then
        write(IWR,*)'>>>>> slic/slsphb: 1-fold sphere de-projection'
        write(IWR,*)'slic projected atom (1-fold spherical)= #',iatmproj
        write(IWR,*)'  first anchor atom (sphere center) is #',ia1
        write(IWR,*)'  second anchor atom is # ',ia2
      endif
c set reference W direction, based  on anchor atoms
c W direction is from a2 to a1
      wsq = zero
      do id = 1,3
         Wvec(id) = ratm0(id,ia1)-ratm0(id,ia2)
         wsq = wsq + (Wvec(id))**2
      enddo
      Wmag = SQRT( wsq )
      do id = 1,3
         Wnorm(id) = Wvec(id)/Wmag
      enddo
c write out Wprime vector as check
      if( iprint.gt.3 ) write(IWR,*)'Wmag (reference a1-a2 bond)= ',Wmag
      if( iprint.gt.3 ) write(IWR,9103)'Wvec = Wmag * ',(Wnorm(i),i=1,3)
c
c-------
c set rvec, based on ratom(iatmproj) and anchor1
c first, get bondvec = rvec
c get Rcoord = |bondvec|=bondmag
c NOTE for nested scheme, the bond vector will have to
c be kept from the original coordinate transformation
c rather than re-calculated here
      bondsq = zero
      do id = 1,3
         bondvec(id)=ratm0(id,iatmproj)-ratm0(id,ia1)
         bondsq = bondsq +(bondvec(id))**2
      enddo
      bondmag = SQRT( bondsq )
      Rcoord0 = bondmag
      if( iprint.gt.3 ) write(IWR,9103)'Rcoord0 = ',Rcoord0
      if( iprint.gt.3 ) write(IWR,9103)'bondvec =',(bondvec(i),i=1,3)
c also useful, the r unit vector
      do id = 1,3
         rnorm(id) = bondvec(id)/Rcoord0
      enddo
c
c      
c     get Wcoord = bond dot Wnorm
      Wcoord0 = zero
      do id = 1,3
         Wcoord0 = Wcoord0 + Wnorm(id)*bondvec(id)
      enddo
c
c     now get xvec =normaliWed component of bondvec perp to Wvec
      Uvecsq = zero
      do id = 1,3
         Uvec(id) = bondvec(id)-Wcoord0*Wnorm(id)
         Uvecsq = Uvecsq + (Uvec(id))**2
      enddo
      Ucoord0 = SQRT( Uvecsq )
c
      do id = 1,3
         Unorm(id) =  Uvec(id)/Ucoord0
      enddo
c
c---- 
c     as a check ,also get yprimecoord of iatmprojroj (should be zero!)
c use cross product  Wcrossr
      Vvec(1)=Wnorm(2)*Unorm(3)-Wnorm(3)*Unorm(2)
      Vvec(2)=Wnorm(3)*Unorm(1)-Wnorm(1)*Unorm(3)
      Vvec(3)=Wnorm(1)*Unorm(2)-Wnorm(2)*Unorm(1)
      if( iprint.gt.3 ) write(IWR,9103) 'Vvec =',(Vvec(i),i=1,3)
      Vmagsq = zero
      do id = 1,3
         Vmagsq = Vmagsq +(Vvec(id))**2
      enddo
      Vmag = SQRT( Vmagsq )
      if( iprint.gt.3 ) write(IWR,*) 'Vmag = ',Vmag
      do id = 1,3
         Vnorm(id)=Vvec(id)/Vmag
      enddo
c get Vcoord = bond dot Vnorm (should be zero!)
      Vcoord0 = zero
      do id = 1,3
         Vcoord0 = Vcoord0 + bondvec(id)*Vnorm(id)
      enddo
      if( iprint.gt.3 ) write(IWR,*) 'Vcoord0 = ', Vcoord0
c
c check dot products
      VdotW = zero
      VdotU = zero
      WdotU = zero
      do id = 1,3
         VdotW = VdotW + Vvec(id)*Wvec(id)
         VdotU = VdotU + Vvec(id)*Uvec(id)
         WdotU = WdotU + Wvec(id)*Uvec(id)
      enddo
      if( iprint.gt.3 ) write(IWR,*) 'VdotW = ',VdotW
      if( iprint.gt.3 ) write(IWR,*) 'VdotU = ',VdotU
      if( iprint.gt.3 ) write(IWR,*) 'WdotU = ',WdotU
c-----
c     check maximum step for theta and phi
c    need this to prevent excessive twirling
c     
c      angvelmax = 10.
c      angvelmaxn = -10.
c      if (theta .gt. angvelmax) then
c         theta = angvelmax
c      elseif (theta .lt. angvelmaxn)then
c         theta = angvelmaxn
c      endif
c      if (phi .gt. angvelmax) then
c         phi = angvelmax
c      elseif (phi .lt. angvelmaxn)then
c         phi = angvelmaxn
c      endif
c---- 
c     Backtransformation of coordinates
c     to cartesian
c
      Rcoord = ratmx(1,iatmproj)
      phi    = ratmx(2,iatmproj)
      theta  = ratmx(3,iatmproj)
      if( iprint.gt.1 )
     $  write(IWR,9103) 'Spherical coordinates: R,phi,theta =',
     $                   Rcoord,phi,theta
      cartnew(1) = Rcoord*SIN( phi )*COS( theta )
      cartnew(2) = Rcoord*SIN( phi )*SIN( theta )
      cartnew(3) = Rcoord*COS( phi )
      if( iprint.gt.2 )then
        write(IWR,9103) 'new coordinates                   ',
     $                  (cartnew(i),i=1,3)
        write(IWR,9103) 'original shifted coordinates      ',
     $                   Ucoord0,Vcoord0,Wcoord0
        write(IWR,9103) 'original unshifted coordinates',
     $                  (Ratm0(i,iatmproj),i=1,3)
      endif
c rotate to original reference frame
      unrot(1) = cartnew(1)*Unorm(1) + cartnew(2)*Vnorm(1)  
     &         + cartnew(3)*Wnorm(1)
      unrot(2) = cartnew(1)*Unorm(2) + cartnew(2)*Vnorm(2)  
     &         + cartnew(3)*Wnorm(2)
      unrot(3) = cartnew(1)*Unorm(3) + cartnew(2)*Vnorm(3)  
     &         + cartnew(3)*Wnorm(3)
c check rotation
      if( iprint.gt.2 )
     $write(IWR,9103)'unrotated coords',(unrot(i),i=1,3)
c
c reset origin
      do i = 1,3
         unshift(i)=unrot(i)+Ratm0(i,ia1)
         if( iprint.gt.4 ) write(IWR,*)ia1,Ratm0(i,ia1)
      enddo
      if( iprint.gt.4 )
     $write(IWR,9103)'new coords',(unshift(i),i=1,3)
c
c return cartesian coordinates to ratmx array
      do id = 1,3
         ratmx(id,iatmproj) = unshift(id)
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLCYL
c
c
      subroutine SLCYL( IWR,natm, islics,islic, 
     $ ratm,frc, ratmP,frcP )
c---------------------------------------------------------------
c Purpose: projects 2-fold coordinates and forces to cylindrical coordinates
c
c Written: Renee M. Van Ginhoven
c
c Revision history:
c  24Sep08-PAS/2.62: cosmetics and some minor cleanip
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
c
cRMV  inputs from gselect
      DIMENSION  ratm(3,natm), frc(3,natm), ratmP(3,natm),frcP(3,natm)
      INTEGER    islics(4,*)
c
c islics contains the projection type, and projected atom and anchor atoms
c 1 = cylindrical projection
c 2 = spherical projection
c
c Local declarations:
      DIMENSION  Uvec(3),Vvec(3),Wvec(3), rvec(3),bondvec(3)
      DIMENSION  Unorm(3),Vnorm(3),Wnorm(3),rnorm(3)
      DIMENSION  Fuvec(3),Fvvec(3),Fwvec(3),cartnew(3),Fuwperp(3)
      DIMENSION  Fuwperpnorm(3)
      DIMENSION  ypr(3)
      DIMENSION  Frvec(3)
      DIMENSION  unrot(3),unshift(3)
c
      DATA  Pi / 3.141592654 /
      DATA  degperrad / 57.29577951 /
      DATA  zero /0.d0/
c
c cylindrical coordinate projection
c
c first, define new cartesian coordinate system,
c based on positions of projected and anchor atoms
c  Wvec' = R(anchor2)-R(anchor1)  -> norm
c  bondvec = R(atomproj)-R(anchor1)
c  Uvec' = bondvec - ((bondvec dot Wvec')/|Wvec'|**2)(zvec')  -> norm
c  Vvec' = Wvec' cross Uvec'  -> norm
cdon't actually need Vvec here
c
c then transform projected atom to polar coordinates
c W = (bondvec dot zvec')/|Wvec'|**2
c r = |Uvec'|
c r = U'/cos(theta),  theta = 0; r = U'
c theta = tan^-1(v/u)   or  theta = cos^-1(u/r)
c initially, Vvec' = 0, so theta = 0
c 
c Project force vector onto new cartesian coordinates
c component along W, component along U (=r0)
c component along y; Fy = F- compU - compW
c  transform to polar
c Ftheta = sin^-1(V/r) 
c update velocity, position
c output files (esp velocity)
c backtransform new coordinates
c
      DATA  iprint / 2 /
c
c >>>> EXECUTABLE CODE:
c
 9103 format(1x,a,3f14.8)
      iatmproj = islics(2,islic)
      ia1 = islics(3,islic)
      ia2 = islics(4,islic)
      if( iprint.gt.0 )then
        write(IWR,*)'>>>>> slic/slcyl: 2-fold cylinder projection'
        write(IWR,*)'slic projected atom (2-fold cylinder)= #',iatmproj
        write(IWR,*)'  first anchor atom is #',ia1
        write(IWR,*)'  second anchor atom is # ',ia2
      endif
c set new z direction, based  on anchor atoms
      wsq = zero
      do id = 1,3
         Wvec(id) = ratm(id,ia2)-ratm(id,ia1)
         wsq = wsq + (Wvec(id))**2
      enddo
      Wmag = SQRT( wsq )
      if( iprint.gt.3 ) write(IWR,*) 'Wmag = ' ,Wmag
      do id = 1,3
         Wnorm(id) = Wvec(id)/Wmag
      enddo
c write out W vector as check
      if( iprint.gt.3 )write(IWR,9103) 'Wvec = Wmag *',(Wnorm(i),i=1,3)
c-------
c set rvec, based on ratom(iatmproj) and new w
c first, get bondvec
      bondsq = zero
      do id = 1,3
         bondvec(id)=ratm(id,iatmproj)-ratm(id,ia1)
         bondsq = bondsq +(bondvec(id))**2
      enddo
      bondmag = SQRT( bondsq )
      if( iprint.gt.3 ) write(IWR,9103) 'bondmag =',bondmag
      if( iprint.gt.3 ) write(IWR,9103) 'bondvec =',(bondvec(i),i=1,3)
c     get Wcoord = bond dot wnorm
      Wcoord = zero
      do id = 1,3
         Wcoord = Wcoord + Wnorm(id)*bondvec(id)
      enddo
      if( iprint.gt.3 ) write(IWR,*) 'Wcoord (b4 step) = ',Wcoord
      rvecsq = zero
c     now get rvec and Rcoord
      do id = 1,3
         rvec(id) = bondvec(id)-Wcoord*Wnorm(id)
         rvecsq = rvecsq + (rvec(id))**2
      enddo
c     rvecmag = Rcoord = xprime
      Rcoord = SQRT( rvecsq )
      do id = 1,3
         rnorm(id) = rvec(id)/Rcoord
      enddo
      if( iprint.gt.3 ) write(IWR,9103) 'Rcoord =',Rcoord
      if( iprint.gt.3 ) write(IWR,9103) 'rnorm =',(rnorm(i),i=1,3)
      theta = zero
c---- 
c     as a check ,also get yprimecoord of iatmprojroj (should be zero!)
c use cross product  zcrossr
      Vvec(1)=Wcoord*Wnorm(2)*rvec(3)-Wcoord*wnorm(3)*rvec(2)
      Vvec(2)=Wcoord*Wnorm(3)*rvec(1)-Wcoord*wnorm(1)*rvec(3)
      Vvec(3)=Wcoord*wnorm(1)*rvec(2)-Wcoord*wnorm(2)*rvec(1)
      if( iprint.gt.3 ) write(IWR,9103) 'Vvec =',(Vvec(i),i=1,3)
      Vmagsq = zero
      do id = 1,3
         Vmagsq = Vmagsq +(Vvec(id))**2
      enddo
      vmag = SQRT( vmagsq )
      if( iprint.gt.3 ) write(IWR,*) 'Vmag = ',Vmag
      do id = 1,3
         Vnorm(id)=Vvec(id)/Vmag
      enddo
c get ycoord = bond dot yprnorm (should be zero!)
      Vcoord = zero
      do id = 1,3
         Vcoord = Vcoord + bondvec(id)*Vnorm(id)
      enddo
      if( iprint.gt.3 ) write(IWR,*) 'Vcoord = ', Vcoord
      theta = ASIN( Vcoord/rcoord )
      if( iprint.gt.3 ) write(IWR,*) 'THETA = ',theta
c
c check dot products
      VdotW = zero
      VdotU = zero
      WdotU = zero
      do id = 1,3
         VdotW = VdotW + Vvec(id)*Wvec(id)
         VdotU = VdotU + Vvec(id)*rvec(id)
         WdotU = WdotU + Wvec(id)*rvec(id)
      enddo
      if( iprint.gt.3 ) write(IWR,*)'VdotW = ',VdotW
      if( iprint.gt.3 ) write(IWR,*)'VdotU = ',VdotU
      if( iprint.gt.3 ) write(IWR,*)'WdotU = ',WdotU
c-------
c     project forces
c     
      Fw = zero
      do id = 1,3
         Fw =Fw + Frc(id,iatmproj)*Wnorm(id)
      enddo
      do id=1,3
         Fwvec(id) =  Fw*wnorm(id) 
      enddo
c      
      Fr = zero
      do id = 1,3
         Fr =Fr + Frc(id,iatmproj)*rnorm(id)
      enddo      
      do id=1,3
         Frvec(id) =  Fr*rnorm(id) 
      enddo
c     
c     
      Fv = zero
      Ftheta = zero
      do id = 1,3
        Fv = Fv + Frc(id,iatmproj)*Vnorm(id)
      enddo
c 
c
      FthetaCH = ASIN( Fv/Rcoord )
      if( iprint.gt.3 ) write(IWR,*) 'check force magnitudes'
      cartfsq = zero
      do i=1,3
         cartfsq=cartfsq+frc(i,iatmproj)*frc(i,iatmproj)
      enddo
      cartF = SQRT( cartfsq )
      polfsq = zero
      rotcartfsq = Fr*Fr +Fv*Fv+ Fw*Fw
      rotcartf = SQRT( rotcartfsq )
      polfsq = Fr*Fr + FthetaCH*FthetaCH+Fw*Fw
      polf = SQRT( polfsq )
      if( iprint.gt.4 )
     $write(IWR,9103)'cart and pol forces',cartf,rotcartf,polf
c
c      
c assign polar forces to force vector
c----------------------------------------------
c option 1: Fr,Ftheta,Fz with no modifications
c----------------------------------------------
c option 2: use Fy instead of Ftheta -  good if steps small enough
c      Ftheta = Fy
c----------------------------------------------
c option 3: limit maximum Fy/Rcoord ratio
c     Fy/Rcoord =ratio
c     ratiomax = 0.173
c  
c      if (ratio.gt. ratiomax)then
c         ratio = ratiomax
c      endif
c      Ftheta = ASIN( ratio )   
c-----------------------------------------------
c option 4: use a constant for Rcoord (i.e. unit vector = 1)
c and use a max cutoff for Fy to restrict dtheta to <30deg
c Therefore Fy/rfixed < 0.5       Fy < 0.008
      rfixed = 0.05
      Fvmax = 0.03
      Fvmaxn =-0.03
c
c
c-----------------------------------------------------
c option5: rescalable rfixed:  initial value based on initial Fy
c  think some more about this
c some of this function will be taked care of by asde
c
c
c
      Ftheta = 2.0*ASIN( Fv/Rcoord )
c      if (Fy.gt. Fymax)then
c         Fy = Fymax
c      endif
c      if (Fy .lt. Fymaxn) then
c         Fy = Fymaxn
c      endif
c
c      tinyforce = 0.001
c      if (abs(Fy) .lt. tinyforce)then
c         rfixed = 0.005
c      endif
c       Ftheta = ASIN( Fy/rfixed )  
c-----------------------------------------------------
c set forces
c
      if( iprint.gt.2 ) write(IWR,9103)'check cyl forces=',Fr,Ftheta,Fw
      if( iprint.gt.2 )
     $write(IWR,9103) 'check Fxyz',(frc(i,iatmproj),i=1,3)
c set atom forces to projected forces
      frcP(1,iatmproj)=Fr
      frcP(2,iatmproj)=Ftheta
      frcP(3,iatmproj)=Fw
C set atom coordinates to projected coordinates
      ratmP(1,iatmproj)=Rcoord
      ratmP(2,iatmproj)=theta
      ratmP(3,iatmproj)=Wcoord
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLCYLB
c
c
      subroutine SLCYLB( IWR,natm, islics,islic,
     $ ratm0,ratmx,ratmP )
c---------------------------------------------------------------
c Purpose: deproject 2-fold curvelinear coodrdinates back to cartesian
c
c Written: Renee M. Van Ginhoven
c
c Revision history:
c  24Sep08-PAS/2.62: some cosmetic standardization
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
c
cRMV  inputs from gupdate
      DIMENSION  ratm0(3,natm), ratmx(3,natm), ratmP(3,natm)
      INTEGER    islics(4,*)
c 
c Local declarations:
      DIMENSION  Uvec(3),Vvec(3),Wvec(3), rvec(3),bondvec(3)
      DIMENSION  Unorm(3),Vnorm(3),Wnorm(3),rnorm(3)
      DIMENSION  Fuvec(3),Fvvec(3),Fwvec(3),cartnew(3),Fuwperp(3)
      DIMENSION  Fuwperpnorm(3)
      DIMENSION  Frvec(3)
      DIMENSION  unrot(3),unshift(3)
c    
      DATA  Pi / 3.141592654 /
      DATA  degperrad / 57.29577951 /
      DATA  zero / 0.d0 /
c
c cylindrical coordinate projection
c
c first, define new cartesian coordinate system,
c based on positions of projected and anchor atoms
c  zvec' = R(anchor2)-R(anchor1)  -> norm
c  bondvec = R(atomproj)-R(anchor1)
c  xvec' = bondvec - ((bondvec dot zvec')/|zvec'|**2)(zvec')  -> norm
c  yvec' = zvec' cross xvec'  -> norm
cdon't actually need yvec here
c
c then transform projected atom to polar coordinates
c z = (bondvec dot zvec')/|zvec'|**2
c r = |xvec'|
c r = x'/cos(theta),  theta = 0; r = x'
c theta = tan^-1(y/x)   or  theta = cos^-1(x/r)
c initially, yvec' = 0, so theta = 0
c
c Project force vector onto new cartesian coordinates
c component along z, component along x (=r0)
c component along y; Fy = F- compX - compZ
c  transform to polar
c Ftheta = sin^-1(y/r) 
c update velocity, position
c output files (esp velocity)
c backtransform new coordinates
c
c--------
c set new z direction, based  on anchor atoms
c nested update is taked care of iin gupdate.  The projection vectors
c in this routine are based on the ratm0 (master array) coordinates
c If this is a nested update, the master anchor atoms
c will have been updated previously.
c and yes, this messes with the symmetry options
c
      DATA  iprint / 2 /
c
c >>>> EXECUTABLE CODE:
c
 9103 format(1x,a,3f14.8)
      iatmproj = islics(2,islic)
      ia1 = islics(3,islic)
      ia2 = islics(4,islic)
      if( iprint.gt.0 )then
        write(IWR,*)'>>>>> slic/slcylb: 2-fold cylinder de-projection'
        write(IWR,*)'slic projected atom (2-fold cylinder)= #',iatmproj
        write(IWR,*)'  first anchor atom is #',ia1
        write(IWR,*)'  second anchor atom is # ',ia2
      endif
c
c set new z direction, based  on anchor atoms
      wsq = zero
      do id = 1,3
         Wvec(id) = ratm0(id,ia2)-ratm0(id,ia1)
         wsq = wsq + (Wvec(id))**2
      enddo
      Wmag = SQRT( wsq )
      if( iprint.gt.3 ) write(IWR,9103)'Wmag = ' ,Wmag
      do id = 1,3
         Wnorm(id) = Wvec(id)/Wmag
      enddo
c write out zprime vector as check
      if( iprint.gt.3 ) write(IWR,9103) 'Wvec = Wnag *',(Wnorm(i),i=1,3)
c-------
c set rvec, based on ratom(iatmproj) and new W
c first, get bondvec
      bondsq = zero
      do id = 1,3
         bondvec(id)=ratm0(id,iatmproj)-ratm0(id,ia1)
         bondsq = bondsq +(bondvec(id))**2
      enddo
      bondmag = SQRT( bondsq )
      if( iprint.gt.3 ) write(IWR,9103) 'bondmag =',bondmag
      if( iprint.gt.3 ) write(IWR,9103) 'bondvec =',(bondvec(i),i=1,3)
c     get Wcoord = bond dot znorm
      Wcoord = zero
      do id = 1,3
         Wcoord = Wcoord + Wnorm(id)*bondvec(id)
      enddo
      if( iprint.gt.3 ) write(IWR,*) 'Wcoord (b4 step)= ',Wcoord
      if( iprint.gt.3 ) write(IWR,*) 'check coordinate transfer'
      if( iprint.gt.3 )
     $write(IWR,*)'Wcoord from previous projection',ratmP(3,iatmproj)
c
      rvecsq = zero
c     now get rvec and Rcoord
      do id = 1,3
         rvec(id) = bondvec(id)-Wcoord*Wnorm(id)
         rvecsq = rvecsq + (rvec(id))**2
      enddo
c     rvecmag = Rcoord = xprime
      Rcoord = SQRT( rvecsq )
      do id = 1,3
         rnorm(id) = rvec(id)/Rcoord
      enddo
      if( iprint.gt.3 ) write(IWR,9103) 'Rcoord =',Rcoord
      if( iprint.gt.3 ) write(IWR,9103) 'rnorm =',(rnorm(i),i=1,3)
      theta = zero
c---- 
c     as a check ,also get yprimecoord of iatmprojroj (should be zero!)
c use cross product  zcrossr
      Vvec(1)=Wcoord*Wnorm(2)*rvec(3)-Wcoord*Wnorm(3)*rvec(2)
      Vvec(2)=Wcoord*Wnorm(3)*rvec(1)-Wcoord*Wnorm(1)*rvec(3)
      Vvec(3)=Wcoord*Wnorm(1)*rvec(2)-Wcoord*Wnorm(2)*rvec(1)
      if( iprint.gt.3 ) write(IWR,9103) 'Vvec =',(Vvec(i),i=1,3)
      Vmagsq = zero
      do id = 1,3
         Vmagsq = Vmagsq +(Vvec(id))**2
      enddo
      Vmag = SQRT( Vmagsq )
      if( iprint.gt.3 ) write(IWR,9103) 'Vmag = ',Vmag
      do id = 1,3
         Vnorm(id)=Vvec(id)/Vmag
      enddo
c get ycoord = bond dot yprnorm (should be zero!)
      Vcoord = zero
      do id = 1,3
         Vcoord = Vcoord + bondvec(id)*Vnorm(id)
      enddo
      if( iprint.gt.3 ) write(IWR,*) 'Vcoord = ', Vcoord
      theta = ASIN( Vcoord/rcoord )
      if( iprint.gt.3 ) write(IWR,*) 'THETA (should=0)= ',theta
c
c check dot products
      VdotW = zero
      VdotU = zero
      WdotU = zero
      do id = 1,3
         VdotW = VdotW + Vvec(id)*Wvec(id)
         VdotU = VdotU + Vvec(id)*rvec(id)
         WdotU = WdotU + Wvec(id)*rvec(id)
      enddo
      if( iprint.gt.3 ) write(IWR,9103) 'VdotW = ',VdotW
      if( iprint.gt.3 ) write(IWR,9103) 'VdotU = ',VdotU
      if( iprint.gt.3 ) write(IWR,9103) 'WdotU = ',WdotU
c-----
c     update polar coordinates of iatmprojroj
      if( iprint.gt.3 ) write(IWR,*) 'wcoord (b4 update)= ',Wcoord
c     
c       theta1 = theta
      Rcoord = ratmx(1,iatmproj)
      theta  = ratmx(2,iatmproj)
      Wcoord = ratmx(3,iatmproj)
      if( iprint.gt.1 )
     $write(IWR,9103) 'Rcoord,theta,wcoord =',rcoord,theta,wcoord
c
c     check maximum step for theta
      angvelmax = 0.25
      angvelmaxn = -0.25
      if (theta .gt. angvelmax) then
         theta = angvelmax
      elseif (theta .lt. angvelmaxn)then
         theta = angvelmaxn
      endif  
c
c---- 
c     Backtransformation of coordinates
c     to cartesian
      if( iprint.gt.1 )
     $write(IWR,9103) 'polar coordinates, R,theta,W=',Rcoord,theta,Wcoord
      cartnew(1) = Rcoord*COS( theta )
      cartnew(2) = Rcoord*SIN( theta )
c      cartnew(1) = Rcoord
c      cartnew(2) = theta
      cartnew(3) = Wcoord
      if( iprint.gt.2 )then
        write(IWR,9103) 'new coordinates',(cartnew(i),i=1,3)
        write(IWR,9103) 'original shifted coordinates',
     $                   Rcoord,Vcoord,Wcoord
        write(IWR,9103) 'original unshifted coordinates',
     $                  (Ratm0(i,iatmproj),i=1,3)
      endif
c rotate to original reference frame
      unrot(1) = cartnew(1)*rnorm(1) + cartnew(2)*Vnorm(1)  
     &         + cartnew(3)*Wnorm(1)
      unrot(2) = cartnew(1)*rnorm(2) + cartnew(2)*Vnorm(2)  
     &         + cartnew(3)*Wnorm(2)
      unrot(3) = cartnew(1)*rnorm(3) + cartnew(2)*Vnorm(3)  
     &         + cartnew(3)*Wnorm(3)
c check rotation
      if( iprint.gt.3 )
     $ write(IWR,9103) 'unrotated coordinates',(unrot(i),i=1,3)
c
c reset origin
      do i = 1,3
         unshift(i)=unrot(i)+Ratm0(i,ia1)
c         write(IWR,*)ia1,Ratom(ia1,i)
      enddo
      if( iprint.gt.2 )
     $ write(IWR,9103) 'new coordinates',(unshift(i),i=1,3)
c
c return cartesian coordinates to ratmx array
      do id = 1,3
         ratmx(id,iatmproj) = unshift(id)
      enddo
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLBONDTO
c
c
      subroutine SLBONDTO( IWR, islic, islics,
     $ ratm,frc, ratmP,frcP )
c---------------------------------------------------------------
c Purpose: transform into bond coordinates
c Written: 1-Aug-2017, for v2.68
c Revisions: none
c---------------------------------------------------------------
c
c ratm = original cartesian coordinates
c ratmP = original projected coordinates (CM/12)
c frc = original cartesian forces
c frcP = modified projected forces (bond-length conserving)
c
c WARNING: This takes no account of periodicity
c          This will fail if bonds across cell boundaries
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  (zero=0.d0,two=2.d0)
c
      DIMENSION  islics(4,*)
      DIMENSION  ratm(3,*), frc(3,*)
      DIMENSION  ratmP(3,*), frcP(3,*)
c scratch
      DIMENSION  x12(3)
c Local diagnostics
      DATA  iprint / 2 /
c
c >>>> EXECUTABLE CODE:
c
      if( islics(1,islic).ne.4 ) RETURN
c
      iatm1 = islics(2,islic)
      iatm2 = islics(3,islic)
      if( iprint.gt.1 )
     $write(IWR,*) 'BOND-select: fixed length bond atoms=',iatm1,iatm2
c
c     Put R-CM into R-iatm1, and F-CM into F-iatm1
c     Put R-rot into R-iatm2, and F-rot into F-iatm22
      do  id=1,3
        ratmP(id,iatm1) = (ratm(id,iatm2)+ratm(id,iatm1))/two
        ratmP(id,iatm2) = (ratm(id,iatm2)-ratm(id,iatm1))/two
        frcP(id,iatm1) = (frc(id,iatm2)+frc(id,iatm1))/two
        frcP(id,iatm2) = (frc(id,iatm2)-frc(id,iatm1))/two
      enddo
c
c     Project out the interatomic-force along the bond vector
      r12 = SQRT(ratmP(1,iatm2)**2+ratmP(2,iatm2)**2+ratmP(3,iatm2)**2)
      do  id=1,3
        x12(id) = ratmP(id,iatm2)/r12
      enddo
      f12 = x12(1)*frcP(1,iatm2) + x12(2)*frcP(2,iatm2)
     $    + x12(3)*frcP(3,iatm2)
      do id=1,3
        frcP(id,iatm2) = frcP(id,iatm2) - f12*x12(id)
      enddo
c
      if( iprint.gt.1 ) write(IWR,914) 'Bond length(au)=',two*r12
      if( r12 .gt. 5.0 )then
        write(IWR,*) '***** WARNING: very long BOND (bohr)=',two*r12
      endif
      if( iprint.gt.3 )then
        write(IWR,*) 'BONDTO recap: iatm, R(iatm), Rpr(iatm);'
  913   format(3x,i5,5x,3f11.4,5x,3f11.4)
  914   format(3x,a,3f12.6)
        write(IWR,914) 'BOND axis=',x12
        write(IWR,*)'  SLIC/BOND recap: iatm, R(iatm), Rpr(iatm);'
        write(IWR,913)iatm1,(ratm(i,iatm1),i=1,3),(ratmP(i,iatm1),i=1,3)
        write(IWR,913)iatm2,(ratm(i,iatm2),i=1,3),(ratmP(i,iatm2),i=1,3)
        write(IWR,*)'  SLIN/BOND recap: iatm, F(iatm), Fpr(iatm);'
        write(IWR,913)iatm1,(frc(i,iatm1),i=1,3),(frcP(i,iatm1),i=1,3)
        write(IWR,913)iatm2,(frc(i,iatm2),i=1,3),(frcP(i,iatm2),i=1,3)
      endif
c  
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLBONDFR
c
c
      subroutine SLBONDFR( IWR, islic, islics,
     $ ratm0, ratmx, ratmP )
c---------------------------------------------------------------
c Purpose: transform back from bond coordinates
c Written:  1-Aug-2017, for v2.68
c Revisions: none
c---------------------------------------------------------------
c
c ratm0 = original cartesian coordinates
c ratmP = original projected coordinates (CM/12)
c ratmx = new project coordinates
c
c We use a simpler approach here
c  Rathe than doing a radial update (formally along sphere),
c  we do a cartesian update, and then contract the bond to fixed length
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  (zero=0.d0,two=2.d0)
c
      DIMENSION  islics(4,*)
      DIMENSION  ratm0(3,*)
      DIMENSION  ratmx(3,*)
      DIMENSION  ratmP(3,*)
c Local declarations
      DIMENSION  r1(3),r2(3)
c Local diagnostic
      DATA  iprint / 2 /
c
c >>>> EXECUTABLE CODE:
c
      if( islics(1,islic).ne.4 ) RETURN
c
      iatm1 = islics(2,islic)
      iatm2 = islics(3,islic)
      if( iprint.gt.1 )
     $ write(IWR,*)'BONDS-update: bonded atoms=',iatm1,iatm2
  913 format(3x,i5,5x,3f11.4,5x,3f11.4)
      if( iprint.gt.4 )then
       write(IWR,*)'  BOND recap: iatm, Rpr(iatm), Rpr-new(iatm);'
       write(IWR,913)iatm1,(ratmP(i,iatm1),i=1,3),(ratmx(i,iatm1),i=1,3)
       write(IWR,913)iatm2,(ratmP(i,iatm2),i=1,3),(ratmx(i,iatm2),i=1,3)
      endif
c  
      d12old = SQRT( ratmP(1,iatm2)**2 + ratmP(2,iatm2)**2
     $             + ratmP(3,iatm2)**2 ) * two
      d12new = SQRT( ratmx(1,iatm2)**2 + ratmx(2,iatm2)**2
     $             + ratmx(3,iatm2)**2 ) * two
      if( iprint.gt.2 )
     $ write(IWR,'(a,2f10.6)') 'Old,new bond=',d12old,d12new
c
c     Back transorm into native carteeian units
c     conserving bond distance
      fac = d12old/d12new
      do  id=1,3
        r1(id) = (ratmx(id,iatm1)-fac*ratmx(id,iatm2))
        r2(id) = (ratmx(id,iatm1)+fac*ratmx(id,iatm2))
      enddo
      do  id=1,3
        ratmx(id,iatm1) = r1(id)
        ratmx(id,iatm2) = r2(id)
      enddo
      if( iprint.gt.4 )then
       write(IWR,*)'  BOND recap: iatm, R0(iatm), Rxyz-new(iatm);'
       write(IWR,913)iatm1,(ratm0(i,iatm1),i=1,3),(ratmx(i,iatm1),i=1,3)
       write(IWR,913)iatm2,(ratm0(i,iatm2),i=1,3),(ratmx(i,iatm2),i=1,3)
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLINKSEL
c
c
      subroutine SLINKSEL( IWR, islic, islics,islicats,vslics,
     $ ratm,frc, ratmP,frcP )
c---------------------------------------------------------------
c Purpose: transform into slinky/layers (slabs)
c Written: 2-Aug-2017, for v2.68
c Revisions: none
c---------------------------------------------------------------
c
c ratm = original cartesian coordinates
c ratmP = original projected coordinates (CM/12)
c frc = original cartesian forces
c frcP = modified projected forces (bond-length conserving)
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  (zero=0.d0,two=2.d0)
c
      DIMENSION  islics(4,*), islicats(*), vslics(3,*)
c
      DIMENSION  ratm(3,*), frc(3,*)
      DIMENSION  ratmP(3,*), frcP(3,*)
c Local declarations
      DIMENSION  ftmp(3), uvw(3,3)
c Local diagnostic
      DATA  iprint / 2 /
c
c >>>> EXECUTABLE CODE:
c
      if( iprint.gt.1 ) write(IWR,*) 'SLINK-select (d-layer) start'
c
      if( islics(1,islic).ne.9 ) RETURN
c
      nslink = islics(2,islic)
      if( iprint.gt.2 ) write(IWR,*) 'SLINK number atoms=',nslink
      if( nslink.le.0 ) RETURN
c
      isl1 = islics(3,islic)
      isln = isl1 + nslink - 1
      islicv = islics(4,islic)
      iatm1 = islicats(isl1)
c
c     Create coordinate system around slinky axis
      call UVWCOORD( uvw, vslics(1,islicv) )
c
      if( iprint.gt.4 )then
        write(IWR,*) 'SLINK vector and projected coordinates'
        write(IWR,'(a,3f10.6)') 'slinky =',(vslics(i,islicv),i=1,3)
        write(IWR,'(a,3f10.6)') '  u =',(uvw(i,1),i=1,3)
        write(IWR,'(a,3f10.6)') '  v =',(uvw(i,2),i=1,3)
        write(IWR,'(a,3f10.6)') '  w =',(uvw(i,3),i=1,3)
      endif
c
c     Do the transformation in layer separation in new coordinates
c     Note that the final (basement) atom remains cartesian coordinates
      call MKZERO( 3, ftmp )
      iatmlast = 0
      do 200 islink=isl1,isln
        iatm = islicats(islink)
        do  iuvw=1,3
          ratmP(iuvw,iatm) = DDOT( 3, uvw(1,iuvw),1, ratm(1,iatm),1 )
          frcP(iuvw,iatm)  = DDOT( 3, uvw(1,iuvw),1,  frc(1,iatm),1 )
        enddo
        if( iatmlast.gt.0 )then
c         Install layer separation into previous slinky atom ...
          ratmP(3,iatmlast) = ratmP(3,iatmlast) - ratmP(3,iatm)
c         Accumulate projected forces into current slinky atom..
          frcP(3,iatm) = frcP(3,iatm) + frcP(3,iatmlast)
        endif
        iatmlast = iatm
  200 continue
c     And then convert the final (base) atom back to cartesian
      wfrc = frcP(3,iatm)
      do  id=1,3
c       Coordinates had not been shift
        frcP(id,iatmlast) = frc(id,iatmlast) + wfrc*uvw(id,3)
      enddo
c
cdbgDEV
      if( iprint.gt.4 )then
        write(IWR,*) 'SLINK-SELECT summary:'
        write(IWR,'(a,11x,a,20x,a)')'  Atom','Raw force','New force'
        do  islink=isl1,isln
          iatm = islicats(islink)
          write(IWR,'(i5,10x,3f11.6,10x,3f11.6)')  iatm,
     $        (frc(i,iatm),i=1,3),(frcP(i,iatm),i=1,3)
        enddo
        write(IWR,'(a,11x,a,20x,a)')'  Atom','Raw coord','projected'
        do  islink=isl1,isln
          iatm = islicats(islink)
          write(IWR,'(i5,10x,3f11.6,10x,3f11.6)')  iatm,
     $        (ratm(i,iatm),i=1,3),(ratmP(i,iatm),i=1,3)
        enddo
      endif
c  
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLINKUPD
c
c
      subroutine SLINKUPD( IWR, islic, islics,islicats,vslics,
     $ ratm0, ratmx, ratmP )
c---------------------------------------------------------------
c Purpose: transform back from bond coordinates
c Written:  1-Aug-2017, for v2.68
c Revisions: none
c---------------------------------------------------------------
c
c ratm0 = original cartesian coordinates
c ratmP = original projected coordinates (CM/12)
c ratmx = new project coordinates
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  (zero=0.d0,two=2.d0)
c
      DIMENSION  islics(4,*),islicats(*),vslics(3,*)
      DIMENSION  ratm0(3,*)
      DIMENSION  ratmx(3,*)
      DIMENSION  ratmP(3,*)
c Local declarations
      DIMENSION  uvw(3,3), rx(3)
c Loca diagnostic
      DATA  iprint / 2 /
c
c >>>> EXECUTABLE CODE:
c
      if( iprint.gt.1 ) write(IWR,*)'SLINK-update starts'
c
      if( islics(1,islic).ne.9 ) RETURN
c
      nslink = islics(2,islic)
      if( iprint.gt.2 ) write(IWR,*) 'SLINK number atoms=',nslink
      if( nslink.le.0 ) RETURN
c
      isl1 = islics(3,islic)
      isln = isl1 + nslink - 1
      islicv = islics(4,islic)
      iatm1 = islicats(isl1)
      iatmn = islicats(isln)
c
c     Create coordinate system around slinky axis
      call UVWCOORD( uvw, vslics(1,islicv) )
c
      if( iprint.gt.4 )then
        write(IWR,*) 'SLINK-UPDATE projected summary:'
        write(IWR,9010) 'Atom','Orig  uvw','post-uvw'
 9010   format(1x,a,13x,a,24x,a)
 9011   format(1x,i5,4x,3f11.6,4x,3f11.6)
        do  islink=isl1,isln
          iatm = islicats(islink)
          write(IWR,9011)  iatm,
     $        (ratmP(i,iatm),i=1,3),(ratmx(i,iatm),i=1,3)
        enddo
      endif
c
      wbase = DDOT( 3, uvw(3,1),1, ratmx(1,iatmn),1 )
      do 200 islink=isln-1,isl1,-1
        iatm = islicats(islink)  
        wdelta = ratmx(3,iatm)
        wbase = wbase + wdelta
        ratmx(3,iatm) = wbase
c       Transform back to xyz
        do  ixyz=1,3
          rx(ixyz) = ratmx(1,iatm)*uvw(ixyz,1)
     $             + ratmx(2,iatm)*uvw(ixyz,2)
     $             + ratmx(3,iatm)*uvw(ixyz,3)
        enddo
        call DCOPY( 3, rx,1, ratmx(1,iatm),1 )
  200 continue
c
      if( iprint.gt.4 )then
        write(IWR,9010) 'SLINK-UPDATE summary:'
        write(IWR,9010) 'Atom','Start-xyz','post-xyz'
        do  islink=isl1,isln
          iatm = islicats(islink)
          write(IWR,9011)  iatm,
     $        (ratm0(i,iatm),i=1,3),(ratmx(i,iatm),i=1,3)
        enddo
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> UVWCOORD
c
c
      subroutine UVWCOORD( uvw, axisvec  )
c---------------------------------------------------------------
c Purpose: create new ortho coord system around given axis
c Written:  3-Aug-2017, for v2.68
c Revisions: none
c---------------------------------------------------------------
c
c  The axis will usually be the z-axis (i.e., slab)
c  We make this our w-vec.
c  We sweep to find x,y,z-axis with smallest projection on axis.
c    and then project out w from that cartesian axis to get u.
c  Which them typically would make u=x-axis, and v=y-axis,
c    so that u,v,w maps onto z,y,z in standard cases.
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero=0.d0, one=1.d0 )
c
      DIMENSION  uvw(3,3), axisvec(3)
c
c >>>> EXECUTABLE CODE
c
c Set our w-coord to be along our axis
      call MKZERO( 9, uvw )
      do  id=1,3
        uvw(id,3) = axisvec(id)
      enddo
c
c Find the x,y,z axis with smallest projection along axis
      iwmin = 1
      wmin = ABS( uvw(iwmin,3) )
      do  id=2,3
        if( ABS( uvw(id,3) ) .lt. wmin )then
          iwmin = id
          wmin = ABS( uvw(iwmin,3) )
        endif
      enddo
c     And project w from that to get u-axis
      uvw(iwmin,1) = one
      udotw = uvw(iwmin,3)
      umag = zero
      do  id=1,3
        uvw(id,1) = uvw(id,1) - udotw*uvw(id,3)
        umag = umag + uvw(id,1)**2
      enddo
      umag = SQRT( umag ) 
      do  i=1,3
        uvw(id,1) = uvw(id,1)/umag
      enddo
c
c And do cross product of w,u to get v-axis
      call CROSS( uvw(1,3),uvw(1,1), uvw(1,2) )
c
c    That's all, Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLICINIT
c
c
      subroutine SLICINIT( sliclbl )
c---------------------------------------------------------------
c Purpose: initialize SLIC stuff
c
c Written: Peter A. Schultz, 14-August-2017
c---------------------------------------------------------------
c
      IMPLICIT NONE
      CHARACTER  sliclbl*(*)
      INTEGER  islictyp, ipslic
      REAL*8   pslic
c
      call SLICTSET( sliclbl, islictyp )
      call SLICPSET( sliclbl, pslic,ipslic )
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLICTSET
c
c
      subroutine SLICTSET( sliclbl, islictyp )
c---------------------------------------------------------------
c Purpose: set up flags for geometry update method
c
c Written: Peter A. Schultz, 30-October-2001, for v2.50 (dmd)
c---------------------------------------------------------------
c
c  Setting igc_type (communicated via common) for a given slic
c Relaxation schemes:
c  igc_fixed = frozen in place
c  igc_free  = free cartesian
c  igc_slic  = slic, 1-fold (spherical) or 2-fold (cylindrical)
c   igt_slic1 = 1-fold atom slic
c   igt_slic2 = 2-fold bridge atom slic
c  igc_frame = frame constraint
c  igc_bond  = bond constraint
c  igc_vgp   = vector-based constraint- in-plane
c  igc_vgd   = vector-based constraint- distance along axis
c  igc_vga   = vector-based constraint- along axis 
c  igc_vgl   = vector-based constraint- along axis, and distance
c  igc_slink = slinky/layer (slab inter-layer) 
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
c  Geometry constraint/local-coord (SLICS) types
      COMMON  /SLICTYPS/ igc_fixed, igc_free,
     $ igc_slic,  igt_slic1,igt_slic2,
     $ igc_frame,igc_bond,igc_vgp,igc_vgd,igc_vga,igc_vgl,igc_slink
c
c input declarations:
      CHARACTER*(*)  sliclbl
c local declarations:
      CHARACTER*6    slictyp
c
c >>>> EXECUTABLE CODE:
c
c
      slictyp = sliclbl(1:6)
      if( slictyp(1:4).eq.'init' .or. slictyp(1:4).eq.'INIT' )then
c       Simply initialize the tags
        islictyp = -999
        igc_fixed = 0
        igc_free  = 1
        igc_slic  = 2
        igc_frame = 3
        igc_bond  = 4
        igc_vgp   = 5
        igc_vgd   = 6
        igc_vga   = 7
        igc_vgl   = 8
        igc_slink = 9
        igc_dev   = 10
c
        igt_slic1 = 1
        igt_slic2 = 2
c
      elseif( slictyp.eq.'FIXED ' )then
        islictyp = igc_fixed
      elseif( slictyp.eq.'FREE  ' )then
        islictyp = igc_free
      elseif( slictyp.eq.'SLIC  ' )then
        islictyp = igc_slic
       elseif( slictyp.eq.'SLIC1 ' )then
         islictyp = igt_slic1
       elseif( slictyp.eq.'SLIC2 ' )then
         islictyp = igt_slic2
      elseif( slictyp.eq.'FRAME ' )then
        islictyp = igc_frame
      elseif( slictyp.eq.'BOND  ' )then
        islictyp = igc_bond
      elseif( slictyp.eq.'VGFIXP' )then
        islictyp = igc_vgp
      elseif( slictyp.eq.'VGFIXD' )then
        islictyp = igc_vgd
      elseif( slictyp.eq.'VGFIXA' )then
        islictyp = igc_vga
      elseif( slictyp.eq.'VGFIXL' )then
        islictyp = igc_vgl
      elseif( slictyp.eq.'SLINKY' )then
        islictyp = igc_slink
      elseif( slictyp.eq.'SLDEV ' )then
        islictyp = igc_dev
c
      else
        write(IWR,*) 'SLICTYP not extended to more than initialize'
        call STOPXERR( 'No such slictyp found' )
      endif
c
c    That's all Folks!
c
      RETURN
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLICTGET
c
c
      entry      SLICTGET( sliclbl, islictyp )
c
      if(     islictyp .eq. igc_fixed )then
        slictyp =  'FIX   '
      elseif( islictyp .eq. igc_free  )then
        slictyp =  'FREE  '
      elseif( islictyp .eq. igc_slic  )then
        slictyp =  'SLIC  '
       elseif( islictyp .eq. igt_slic1 )then
         slictyp =  'SL1   '
       elseif( islictyp .eq. igt_slic2 )then
         slictyp =  'SL2   '
      elseif( islictyp .eq. igc_frame )then
        slictyp =  'FRAM  '
      elseif( islictyp .eq. igc_bond  )then
        slictyp =  'BOND  '
      elseif( islictyp .eq. igc_vgp   )then
        slictyp =  'VGP   '
      elseif( islictyp .eq. igc_vgd   )then
        slictyp =  'VGD   '
      elseif( islictyp .eq. igc_vga   )then
        slictyp =  'VGA   '
      elseif( islictyp .eq. igc_vgl   )then
        slictyp =  'VGL   '
      elseif( islictyp .eq. igc_slink )then
        slictyp =  'LYR   '
      elseif( islictyp .eq. igc_dev   )then
        slictyp =  'DEV   '
c
      else
        call STOPXERR( 'Unknown SLIC typ - coding error' )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLICPSET
c
c
      subroutine SLICPSET( sliclbl, pslic,ipslic )
c---------------------------------------------------------------
c Purpose: set up flags for geometry update method
c
c Written: Peter A. Schultz, 30-October-2001, for v2.50 (dmd)
c
c Revision history:
c  none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      PARAMETER  ( zero = 0.d0, one=1.d0 )
      CHARACTER   sliclbl*(*)
c
      COMMON  / SLICPARS / sl_pars(9), isl_fank
c
      if(    sliclbl(1:4).eq.'INIT' )then
c       Initialize everything to default of zero
        do  i=1,9
          sl_pars(i) = zero
        enddo
        isl_fank = 2
c
c     Record desired parameter into 
      elseif( sliclbl(1:6).eq.'PAR1  ' )then
        sl_pars(1) = pslic
      elseif( sliclbl(1:6).eq.'PAR2  ' )then
        sl_pars(2) = pslic
      elseif( sliclbl(1:6).eq.'PAR3  ' )then
        sl_pars(3) = pslic
      elseif( sliclbl(1:6).eq.'PAR4  ' )then
        sl_pars(4) = pslic
c
      elseif( sliclbl(1:6).eq.'FANK0 ' )then
c       Leave sphere anchor force unchanged
        isl_fank = 0
      elseif( sliclbl(1:6).eq.'FANKF ' )then
c       Propagate full anchor force into anchor force
        isl_fank = 1
      elseif( sliclbl(1:6).eq.'FANKB ' )then
c       Propagate bond-projected force into anchor force
        isl_fank = 2
c
      else
        write(*,*) 'slicpset: sliclbl=',sliclbl
        call MTBUFF
        call STOPXERR( 'Unknown slicpset label' )
      endif

      RETURN
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLICPGET
c
      entry      SLICPGET( sliclbl, pslic,ipslic  )
c
c     Retrieve desired parameter into 
      if(     sliclbl(1:6).eq.'PAR1  ' )then
        pslic = sl_pars(1)
      elseif( sliclbl(1:6).eq.'PAR2  ' )then
        pslic = sl_pars(2)
      elseif( sliclbl(1:6).eq.'PAR3  ' )then
        pslic = sl_pars(3)
      elseif( sliclbl(1:6).eq.'PAR4  ' )then
        pslic = sl_pars(4)
c
      elseif( sliclbl(1:4).eq.'FANK'   )then
        ipslic = isl_fank
c
      else
        call STOPXERR( 'Bad slicpget argument' )
      endif
c
c    That's all Folks!
c
      RETURN
      END
c
c
c >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SLICSUM
c
c
      subroutine SLICSUM( IWR, natm,
     $ nslics,islics,islicats,vslics,    iatframe )
c---------------------------------------------------------------
c Purpose: summarize slic inputs, to output file
c Written: 31-July-2017, for v2.68
c Revisions: none
c---------------------------------------------------------------
c
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
c
      DIMENSION  islics(4,*),islicats(*),vslics(3,*)
c
      DIMENSION  iatframe(3)
c
      DATA  iprint / 2 /
c
c >>>> EXECUTABLE CODE:
c
      if( iatframe(1).gt.0 ) write(IWR,*) 'DEV/FRAME activated'
c
      if( nslics.eq.0 ) RETURN
c
c  Recap all unified SLIC descriptors
c
      if( iprint.gt.0 .and. nslics.ne.0 )
     $  write(IWR,*) 'SLIC recap: # of slics nslics=',nslics
c
      if( iprint.lt.2 ) RETURN
c
      do  islic=1,nslics
        islictyp = islics(1,islic)
        write(IWR,'(a,i2,a,i3)') 'SLICS #',islic,' typ=',islictyp
c
        if( islictyp.eq.1 .or. islictyp.eq.2 )then
c         SLIC project atom
          iatmproj = islics(2,islic)
c**** DEV should reverse CYL/SPH order to 1-fold/2-fold
          write(IWR,'(2x,a,i3)') '  CYL=1,SPH=2, type=',islictyp
          write(IWR,'(2x,a,i8)') '  SLIC projected atom: ',iatmproj
          write(IWR,'(2x,a,2i8)')
     $     '       anchors: ',islics(3,islic),islics(4,islic)
c
        elseif( islictyp.eq.3 )then
c         FRAME
          write(IWR,*) 'DEV/FRAME activated, not unified into SLICS'
c
        elseif( islictyp.eq.4 )then
c         BOND atoms
          write(IWR,'(2x,a,2i6)') 'BOND length fixed between atoms=',
     $                            islics(2,islic),islics(3,islic)
c
        elseif( islictyp.ge.5 .and. islictyp.le.8 )then
c         VGFIX atom
          islicv = islics(4,islic)
          write(IWR,'(2x,a,2i3,3f12.4)')'  VGFIX: typ, #atoms, vector=',
     $     islictyp, islics(2,islic), (vslics(i,islicv),i=1,3)
c
        elseif( islictyp.eq.9 )then
c         SLINKY/LAYERS atom
          islicv = islics(4,islic)
          write(IWR,'(2x,a,i3,3f12.4)') '  SLINKY: #atoms, vector=',
     $               islics(2,islic), (vslics(i,islicv),i=1,3)
c
        endif
c
      enddo
c
c    That's all Folks!
c
      RETURN
      END
c
c Customization of Fortran mode in Emacs. Must be in last 3000 characters of the file.
c Local Variables:
c fortran-continuation-string: "$"
c fortran-comment-line-start: "c"
c fortran-do-indent: 2
c fortran-if-indent: 2
c End
